=== use-supabase.tsx ===
"use client";

import { createBrowserClient } from "@supabase/ssr";
import { useState, useEffect } from "react";
import type { SupabaseClient } from "@supabase/supabase-js";

// Assume Database type is defined elsewhere or use 'any'
// import type { Database } from '@/types/supabase';
type Database = any; // Replace with your actual Database type if generated

/**
 * Custom hook for accessing the Supabase client instance.
 * 
 * This hook provides:
 * - Access to the Supabase client for database operations
 * - Automatic cookie handling for authentication
 * - Consistent client instance across the application
 * 
 * @returns {SupabaseClient} The Supabase client instance
 * @throws {Error} If the Supabase client cannot be initialized
 */
export function useSupabase() {
  // Initialize state to null. Client will be created after mount.
  const [supabase, setSupabase] = useState<SupabaseClient<Database> | null>(null);

  useEffect(() => {
    // Create the client only on the client side after initial render.
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

    // Robust check for environment variables.
    if (!supabaseUrl || supabaseUrl.trim() === '' || !supabaseAnonKey || supabaseAnonKey.trim() === '') {
      // Log error or handle appropriately. Maybe set an error state?
      console.error(
        "Supabase URL or Anon Key is missing or empty in useSupabase hook. Cannot create client."
      );
      // Optionally throw or set an error state here if needed.
      // For now, we just prevent client creation.
      return; // Don't attempt to create client if keys are missing
    }

    // Create and set the Supabase client instance.
    const client = createBrowserClient<Database>(supabaseUrl, supabaseAnonKey);
    setSupabase(client);

    // No cleanup needed for the client itself, Supabase handles connections.
    // If there were listeners setup here, we'd return a cleanup function.
  }, []); // Empty dependency array ensures this runs once on mount

  // Return the client state. Components using this hook must handle the initial null value.
  return { supabase };
}

// Optional: Define Database type based on Supabase schema
// You can generate this using: npx supabase gen types typescript --project-id <your-project-id> > types/supabase.ts
// Then import it here: import type { Database } from '@/types/supabase';
// If you don't have it, use generic SupabaseClient type or remove <Database> generic
// NOTE: The previous type definition was below the hook, moved it up for better organization.
// type Database = any; // Replace with your actual Database type if generated

// Removed the old Database type definition from here
=== use-mobile.tsx ===
"use client"

import * as React from "react"

const MOBILE_BREAKPOINT = 768

/**
 * Custom hook for detecting mobile device state.
 * 
 * This hook provides:
 * - Mobile device detection
 * - Responsive state management
 * - Window resize handling
 * 
 * @returns {boolean} Whether the current device is considered mobile
 */
export function useMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    if (typeof window === 'undefined') return

    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

=== use-auth.tsx ===
"use client"

import type React from "react"

import { useState, useEffect, createContext, useContext, useCallback } from "react"
import { useRouter } from "next/navigation"
import { useSupabase } from "@/hooks/use-supabase"
import type { Session, User, AuthError } from "@supabase/supabase-js"

/**
 * @typedef AuthContextType
 * @property {User | null} user The currently authenticated Supabase user, or null if not logged in.
 * @property {Session | null} session The current Supabase session, or null if not logged in.
 * @property {boolean} loading True while the authentication state is being determined (initial load), false otherwise.
 * @property {(email: string, password: string) => Promise<{ error: AuthError | Error | null }>} signIn Function to sign in a user with email and password. Returns an error object if sign-in fails.
 * @property {(email: string, password: string) => Promise<{ data: any | null; error: AuthError | Error | null }>} signUp Function to sign up a new user. Returns data and error objects. Requires email confirmation by default.
 * @property {() => Promise<{ error: AuthError | Error | null }>} signOut Function to sign out the current user. Returns an error object if sign-out fails.
 * @property {(email: string) => Promise<{ error: AuthError | Error | null }>} resetPassword Function to initiate the password reset process for a given email. Returns an error object if the request fails.
 */
interface AuthContextType {
  user: User | null
  session: Session | null
  loading: boolean
  signIn: (email: string, password: string) => Promise<{ error: AuthError | Error | null }>
  signUp: (email: string, password: string) => Promise<{ data: any | null; error: AuthError | Error | null }>
  signOut: () => Promise<{ error: AuthError | Error | null }>
  resetPassword: (email: string) => Promise<{ error: AuthError | Error | null }>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

const DEBUG_AUTH = process.env.NODE_ENV !== 'production'

const logAuth = (...args: any[]) => {
  if (DEBUG_AUTH) {
    console.log('[Auth Debug]:', ...args);
  }
};
const logAuthError = (...args: any[]) => {
  if (DEBUG_AUTH) {
    console.error('[Auth Error]:', ...args);
  }
};

/**
 * Provides authentication state and functions to its children components.
 * Manages user session, loading state, and interactions with Supabase auth.
 * @param {object} props - Component props.
 * @param {React.ReactNode} props.children - Child components to be wrapped by the provider.
 */
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const { supabase } = useSupabase()
  const router = useRouter()
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    logAuth("Auth useEffect triggered...");

    // --- Guard Clause ---
    // Only proceed if the Supabase client is initialized.
    if (!supabase) {
      logAuth("Supabase client not ready yet, waiting...");
      // Keep loading true until supabase client is available.
      // Note: If supabase NEVER becomes available (e.g., missing env vars caught in useSupabase),
      // loading might stay true indefinitely. Consider adding a timeout or error state if needed.
      setLoading(true); 
      return; 
    }
    // --- End Guard Clause ---

    logAuth("Supabase client is ready. Proceeding with auth checks.");
    setLoading(true); // Ensure loading is true while we check the session

    let initialSessionFetched = false; // Flag to track if initial fetch completed

    const getSession = async () => {
      logAuth("Attempting to get session...");
      try {
        // Supabase client is guaranteed to be non-null here
        const { data: { session: currentSession }, error } = await supabase.auth.getSession();

        if (error) {
          logAuthError("Error getting session in useEffect:", error);
        }
        logAuth("getSession result:", currentSession ? "Session found" : "No session");
        setSession(currentSession);
        setUser(currentSession?.user ?? null);
      } catch (error) {
        logAuthError("Unexpected error during getSession:", error);
        setSession(null); // Ensure clean state on error
        setUser(null);
      } finally {
        initialSessionFetched = true;
        // Only set loading false if the listener is also set (or failed to set)
        // This check prevents flicker if onAuthStateChange runs immediately after getSession
        if (authListener) { 
            logAuth("getSession finally block: setting loading false (listener ready).");
            setLoading(false);
        } else {
            logAuth("getSession finally block: listener not ready yet, keeping loading true.");
        }
      }
    };

    getSession(); // Call getSession now that supabase is confirmed

    logAuth("Setting up onAuthStateChange listener...");
    const { data: { subscription: authListener } } = supabase.auth.onAuthStateChange((event, newSession) => {
      logAuth("onAuthStateChange triggered:", event, newSession ? "Session found" : "No session");
      setSession(newSession);
      setUser(newSession?.user ?? null);
      // Set loading to false once the listener provides an update OR
      // if the initial getSession has already finished. This handles cases
      // where the listener fires very quickly or after the initial check.
      if (!loading || initialSessionFetched) {
          logAuth("onAuthStateChange: setting loading false.");
          setLoading(false);
      }
    });

    // Cleanup function
    return () => {
      logAuth("Cleaning up auth useEffect: Unsubscribing...");
      authListener?.unsubscribe();
    };

    // This effect depends only on the supabase client instance.
    // It runs once when supabase is null (returns early),
    // and again when supabase becomes non-null.
  }, [supabase]);

  /**
   * Signs in a user using email and password.
   * Relies on onAuthStateChange to update user/session state.
   */
  const signIn = useCallback(
    async (email: string, password: string): Promise<{ error: AuthError | Error | null }> => {
      // Add guard clause for supabase availability
      if (!supabase) {
        logAuthError("Sign in failed: Supabase client not available.");
        return { error: new Error("Authentication service not ready.") };
      }
      setLoading(true);
      let errorResult: AuthError | Error | null = null;
      try {
        const { error } = await supabase.auth.signInWithPassword({ email, password })
        errorResult = error
        if (errorResult) {
          logAuthError("Sign in error:", errorResult)
        } else {
          logAuth("Sign in successful (state update via listener)")
        }
      } catch (err) {
        logAuthError("Unexpected error during sign in API call:", err)
        setLoading(false)
        errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during sign in")
      }
      return { error: errorResult }
    },
    [supabase],
  )

  /**
   * Signs up a new user. Requires email confirmation.
   */
  const signUp = useCallback(
    async (email: string, password: string): Promise<{ data: any | null; error: AuthError | Error | null }> => {
      // Add guard clause for supabase availability
      if (!supabase) {
        logAuthError("Sign up failed: Supabase client not available.");
        return { data: null, error: new Error("Authentication service not ready.") };
      }
      setLoading(true);
      let errorResult: AuthError | Error | null = null;
      try {
        const emailRedirectTo = typeof window !== "undefined"
            ? `${window.location.origin}/auth/callback`
            : undefined

        const { data, error } = await supabase.auth.signUp({
          email,
          password,
          options: { emailRedirectTo },
        })
        errorResult = error
        if (errorResult) {
          logAuthError("Error during sign up:", errorResult)
        } else {
          logAuth("Sign up successful (pending confirmation)", data)
        }
        setLoading(false)
        return { data, error: errorResult }
      } catch (err) {
        logAuthError("Unexpected error during sign up:", err)
        setLoading(false)
        errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during sign up")
        return { data: null, error: errorResult }
      }
    },
    [supabase],
  )

  /**
   * Signs out the currently authenticated user.
   * Navigates the user to the login page upon successful sign out.
   */
  const signOut = useCallback(async (): Promise<{ error: AuthError | Error | null }> => {
    // Add guard clause for supabase availability
    if (!supabase) {
      logAuthError("Sign out failed: Supabase client not available.");
      // Still attempt navigation? Or return error? Let's return error for consistency.
      return { error: new Error("Authentication service not ready.") };
    }
    setLoading(true);
    let errorResult: AuthError | Error | null = null;
    try {
      const { error: signOutError } = await supabase.auth.signOut()
      errorResult = signOutError
      if (errorResult) {
        logAuthError("Error during sign out:", errorResult)
      } else {
        logAuth("Sign out successful - redirecting")
        router.push("/login")
      }
    } catch (err) {
      logAuthError("Unexpected error during sign out:", err)
      errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during sign out")
    }
    return { error: errorResult }
  }, [supabase, router])

  /**
   * Sends a password reset email to the user.
   */
  const resetPassword = useCallback(
    async (email: string): Promise<{ error: AuthError | Error | null }> => {
      // Add guard clause for supabase availability
      if (!supabase) {
        logAuthError("Password reset failed: Supabase client not available.");
        return { error: new Error("Authentication service not ready.") };
      }
      let errorResult: AuthError | Error | null = null;
      try {
        const redirectTo = typeof window !== 'undefined' ? `${window.location.origin}/auth/update-password` : undefined
        const { error } = await supabase.auth.resetPasswordForEmail(email, { redirectTo })
        errorResult = error
        if (errorResult) {
          logAuthError("Error requesting password reset:", errorResult)
        } else {
          logAuth("Password reset email sent successfully for:", email)
        }
      } catch (err) {
        logAuthError("Unexpected error during password reset:", err)
        errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during password reset")
      }
      return { error: errorResult }
    },
    [supabase],
  )

  const value = {
    user,
    session,
    loading,
    signIn,
    signUp,
    signOut,
    resetPassword,
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

/**
 * Custom hook for managing authentication state and operations.
 * 
 * This hook provides:
 * - User authentication state management
 * - Login and logout functionality
 * - User session management
 * - Error handling for auth operations
 * 
 * @returns {Object} Authentication functions and state
 * @returns {User | null} returns.user - The currently authenticated user
 * @returns {boolean} returns.loading - Whether auth operations are in progress
 * @returns {string | null} returns.error - Error message if auth operation fails
 * @returns {(email: string, password: string) => Promise<void>} returns.login - Function to log in a user
 * @returns {() => Promise<void>} returns.logout - Function to log out the current user
 * @returns {() => Promise<void>} returns.refreshSession - Function to refresh the user's session
 */
export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider")
  }
  return context
}


=== useDecks.ts ===
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getDecks } from '@/lib/actions/deckActions'; // Assuming this action exists now
import type { Database, Tables } from "@/types/database"; // Ensure correct path

type DbDeck = Tables<'decks'>; // Get the full DbDeck type

interface UseDecksReturn {
  decks: Pick<DbDeck, 'id' | 'name'>[]; // Return only id and name as fetched by getDecks
  isLoading: boolean;
  error: string | null;
  refetchDecks: () => Promise<void>;
}

/**
 * Custom hook for managing deck operations and state.
 * 
 * This hook provides:
 * - Deck creation, reading, updating, and deletion
 * - Deck state management
 * - Error handling for deck operations
 * - Loading state management
 * 
 * @returns {Object} Deck management functions and state
 * @returns {Deck[]} returns.decks - Array of user's decks
 * @returns {boolean} returns.loading - Whether deck operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {(title: string, description?: string) => Promise<void>} returns.createDeck - Function to create a new deck
 * @returns {(deckId: string, updates: Partial<Deck>) => Promise<void>} returns.updateDeck - Function to update a deck
 * @returns {(deckId: string) => Promise<void>} returns.deleteDeck - Function to delete a deck
 * @returns {() => Promise<void>} returns.refreshDecks - Function to refresh the decks list
 */
export function useDecks(): UseDecksReturn {
  const [decks, setDecks] = useState<Pick<DbDeck, 'id' | 'name'>[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchDecks = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await getDecks();
      if (result.error) {
        setError(result.error);
        setDecks([]); // Clear decks on error
      } else {
        // Ensure data is an array, default to empty array if null/undefined
        setDecks(result.data || []); 
      }
    } catch (err) {
      console.error("Unexpected error fetching decks:", err);
      setError('An unexpected error occurred while fetching decks.');
      setDecks([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch on mount
  useEffect(() => {
    fetchDecks();
  }, [fetchDecks]);

  return { decks, isLoading, error, refetchDecks: fetchDecks };
} 
=== useStudySetForm.ts ===
// hooks/useStudySetForm.ts
"use client";

import { useState, useEffect, useCallback, useMemo } from 'react';
import { useForm, UseFormReturn } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod'; // Zod is needed here
// Import the schema object and type
import { studyQueryCriteriaSchema, StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import { useTags } from '@/hooks/useTags';
import { useDecks } from '@/hooks/useDecks';
import type { Database, Tables } from "@/types/database";
type DbTag = Tables<'tags'>;
// Type for deck list item from useDecks
type DeckListItem = Pick<Tables<'decks'>, 'id' | 'name' | 'primary_language' | 'secondary_language' | 'is_bilingual' | 'updated_at'> & { card_count: number };
import { toast } from 'sonner';
import { format, isValid, parseISO } from "date-fns";
import { DateRange } from "react-day-picker";

// Define allowed operator types (constants)
const DateDaysOperators = ['newerThanDays', 'olderThanDays'] as const;
const DateSpecificOperators = ['onDate', 'betweenDates'] as const;
const NullableDateOperators = ['never'] as const;
const DueDateOperators = ['isDue'] as const;
const SrsLevelOperators = ['equals', 'lessThan', 'greaterThan'] as const;

// Define combined operator types
type CreatedUpdatedDateOp = typeof DateDaysOperators[number] | typeof DateSpecificOperators[number];
type LastReviewedDateOp = CreatedUpdatedDateOp | typeof NullableDateOperators[number];
type NextReviewDateOp = CreatedUpdatedDateOp | typeof NullableDateOperators[number] | typeof DueDateOperators[number];
type SrsLevelOp = typeof SrsLevelOperators[number];

// --- Define a Zod Schema specifically for the FORM data ---
const studySetFormSchema = z.object({
  name: z.string().trim().min(1, 'Study set name is required').max(100, 'Name too long'),
  description: z.string().trim().max(500, 'Description too long').optional().nullable(),
  selectedDeckId: z.string().uuid().or(z.literal('none')).optional().nullable(),
  includeTags: z.array(z.string().uuid()).optional().default([]),
  tagLogic: z.enum(['ANY', 'ALL']).default('ANY'),
  excludeTags: z.array(z.string().uuid()).optional().default([]),
  createdDateOperator: z.string().nullable().optional(),
  createdDateValueDays: z.number().int().positive().nullable().optional(),
  createdDateValueDate: z.date().nullable().optional(),
  createdDateValueRange: z.custom<DateRange>((val) => typeof val === 'object' && val !== null && ('from' in val || 'to' in val || (val as DateRange).from === undefined && (val as DateRange).to === undefined)).nullable().optional(),
  updatedDateOperator: z.string().nullable().optional(),
  updatedDateValueDays: z.number().int().positive().nullable().optional(),
  updatedDateValueDate: z.date().nullable().optional(),
  updatedDateValueRange: z.custom<DateRange>((val) => typeof val === 'object' && val !== null && ('from' in val || 'to' in val || (val as DateRange).from === undefined && (val as DateRange).to === undefined)).nullable().optional(),
  lastReviewedOperator: z.string().nullable().optional(),
  lastReviewedValueDays: z.number().int().positive().nullable().optional(),
  lastReviewedValueDate: z.date().nullable().optional(),
  lastReviewedValueRange: z.custom<DateRange>((val) => typeof val === 'object' && val !== null && ('from' in val || 'to' in val || (val as DateRange).from === undefined && (val as DateRange).to === undefined)).nullable().optional(),
  nextReviewDueOperator: z.string().nullable().optional(),
  nextReviewDueValueDays: z.number().int().positive().nullable().optional(),
  nextReviewDueValueDate: z.date().nullable().optional(),
  nextReviewDueValueRange: z.custom<DateRange>((val) => typeof val === 'object' && val !== null && ('from' in val || 'to' in val || (val as DateRange).from === undefined && (val as DateRange).to === undefined)).nullable().optional(),
  srsLevelOperator: z.string().nullable().optional(),
  srsLevelValue: z.number().int().gte(0).nullable().optional(),
  includeDifficult: z.boolean().nullable().optional(),
}).strict();

// Export Form Data type if needed elsewhere, otherwise keep internal
export type StudySetBuilderFormData = z.infer<typeof studySetFormSchema>;


// --- Helper to parse Date Criteria from DB schema to Form schema ---
const parseDateCriteriaForForm = (criteriaValue: StudyQueryCriteria['createdDate'] | undefined): { operator: string | null, days: number | null, date: Date | null, range: DateRange | null } => {
    const defaultValue = { operator: null, days: null, date: null, range: null };
    let operator: string | null = null; let days = null, date = null, range = null;
    const op = criteriaValue?.operator; const value = criteriaValue?.value;
    if (!op) return defaultValue; operator = op;
    try {
        if ((op === 'newerThanDays' || op === 'olderThanDays') && typeof value === 'number') { days = value; }
        else if (op === 'onDate' && typeof value === 'string') { const parsed = parseISO(value + 'T00:00:00Z'); if (isValid(parsed)) date = parsed; }
        else if (op === 'betweenDates' && Array.isArray(value)) {
            const fromString = value[0]; const toString = value[1]; let fromDate = undefined, toDate = undefined;
            if (fromString && typeof fromString === 'string') { const parsed = parseISO(fromString); if (isValid(parsed)) fromDate = parsed; }
            if (toString && typeof toString === 'string') { const parsed = parseISO(toString); if (isValid(parsed)) toDate = parsed; }
            if (fromDate !== undefined || toDate !== undefined) { range = { from: fromDate, to: toDate }; }
        }
    } catch (e) { console.error("Error parsing date criteria:", e); return defaultValue; }
    return { operator, days, date, range };
};

// Helper to parse initial SRS Level from DB schema to Form schema
const parseSrsLevelCriteriaForForm = (criteriaValue: StudyQueryCriteria['srsLevel'] | undefined): { operator: string | null, value: number | null } => {
    const op = criteriaValue?.operator; const value = criteriaValue?.value;
    if (op && typeof value === 'number') return { operator: op, value };
    return { operator: null, value: null };
};

// --- Custom Hook Props Interface ---
interface UseStudySetFormProps {
    initialData?: { id?: string; name: string; description?: string | null; criteria: StudyQueryCriteria; };
    onSave: (data: { name: string; description: string | null; criteria: StudyQueryCriteria }) => Promise<void>;
    isSaving?: boolean;
}

// --- FIX: Export the hook's return type ---
export interface UseStudySetFormReturn { // Use export keyword
    form: UseFormReturn<StudySetBuilderFormData>;
    isLoading: boolean;
    tagsError: string | null;
    decksError: string | null;
    allTags: DbTag[];
    decks: DeckListItem[];
    onSubmit: (e?: React.BaseSyntheticEvent) => Promise<void>;
    watchedOperators: {
        createdDateOperator: string | null | undefined;
        updatedDateOperator: string | null | undefined;
        lastReviewedOperator: string | null | undefined;
        nextReviewDueOperator: string | null | undefined;
        srsLevelOperator: string | null | undefined;
    };
    watchedFilterValues: {
        includeDifficult: boolean | null | undefined;
        includeTags: string[] | undefined;
        excludeTags: string[] | undefined;
    };
    allowedOperators: {
        createdUpdatedOps: readonly CreatedUpdatedDateOp[];
        lastReviewedOps: readonly LastReviewedDateOp[];
        nextReviewDueOps: readonly NextReviewDateOp[];
        srsLevelOps: readonly SrsLevelOp[];
    };
}
// -----------------------------------------

// --- Hook Implementation ---
export function useStudySetForm({ initialData, onSave, isSaving = false }: UseStudySetFormProps): UseStudySetFormReturn {
  const { allTags, isLoading: isLoadingTags, error: tagsError } = useTags();
  const { decks, isLoading: isLoadingDecks, error: decksError } = useDecks();

  // Parse initial data memoized
  const initialCreated = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.createdDate), [initialData]);
  const initialUpdated = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.updatedDate), [initialData]);
  const initialLastReviewed = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.lastReviewed), [initialData]);
  const initialNextReviewDue = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.nextReviewDue), [initialData]);
  const initialSrsLevel = useMemo(() => parseSrsLevelCriteriaForForm(initialData?.criteria?.srsLevel), [initialData]);
  const initialIncludeDifficult = useMemo(() => initialData?.criteria?.includeDifficult ?? false, [initialData]);

  // Setup form
  const form = useForm<StudySetBuilderFormData>({
    resolver: zodResolver(studySetFormSchema),
    defaultValues: {
      name: initialData?.name || '', description: initialData?.description ?? null,
      selectedDeckId: initialData?.criteria?.deckId ?? 'none',
      includeTags: initialData?.criteria?.includeTags || [], tagLogic: initialData?.criteria?.tagLogic || 'ANY', excludeTags: initialData?.criteria?.excludeTags || [],
      createdDateOperator: initialCreated.operator, createdDateValueDays: initialCreated.days, createdDateValueDate: initialCreated.date, createdDateValueRange: initialCreated.range,
      updatedDateOperator: initialUpdated.operator, updatedDateValueDays: initialUpdated.days, updatedDateValueDate: initialUpdated.date, updatedDateValueRange: initialUpdated.range,
      lastReviewedOperator: initialLastReviewed.operator, lastReviewedValueDays: initialLastReviewed.days, lastReviewedValueDate: initialLastReviewed.date, lastReviewedValueRange: initialLastReviewed.range,
      nextReviewDueOperator: initialNextReviewDue.operator, nextReviewDueValueDays: initialNextReviewDue.days, nextReviewDueValueDate: initialNextReviewDue.date, nextReviewDueValueRange: initialNextReviewDue.range,
      srsLevelOperator: initialSrsLevel.operator, srsLevelValue: initialSrsLevel.value,
      includeDifficult: initialIncludeDifficult,
    },
    mode: 'onChange',
  });

  // Watch relevant form values
  const watchedOperatorsArray = form.watch(['createdDateOperator', 'updatedDateOperator', 'lastReviewedOperator', 'nextReviewDueOperator', 'srsLevelOperator']);
  const watchedFilterValuesArray = form.watch(['includeDifficult', 'includeTags', 'excludeTags']);
  const [createdDateOperator, updatedDateOperator, lastReviewedOperator, nextReviewDueOperator, srsLevelOperator] = watchedOperatorsArray;
  const [includeDifficult, includeTags, excludeTags] = watchedFilterValuesArray;

  // --- onSubmit Handler (Maps Form Data -> DB Schema) ---
  // Memoize the mapping helper
  const mapDateFilterToCriteria = useCallback((
      operator: StudySetBuilderFormData['createdDateOperator'], days: StudySetBuilderFormData['createdDateValueDays'], date: StudySetBuilderFormData['createdDateValueDate'], range: StudySetBuilderFormData['createdDateValueRange']
  ): StudyQueryCriteria['createdDate'] | undefined => {
      // (Mapping logic remains the same as previous correct version)
      if (!operator || operator === 'any') return undefined;
      const schemaOperators: (CreatedUpdatedDateOp | LastReviewedDateOp | NextReviewDateOp)[] = [...DateDaysOperators, ...DateSpecificOperators, ...NullableDateOperators, ...DueDateOperators];
      if (!schemaOperators.includes(operator as any)) return undefined;
      const schemaOperator = operator as typeof schemaOperators[number];
      if ((schemaOperator === 'newerThanDays' || schemaOperator === 'olderThanDays') && typeof days === 'number' && days > 0) return { operator: schemaOperator, value: days };
      if (schemaOperator === 'onDate' && date && isValid(date)) return { operator: schemaOperator, value: format(date, 'yyyy-MM-dd') };
      if (schemaOperator === 'betweenDates' && range) {
          const fromISO = range.from ? range.from.toISOString() : null; const toISO = range.to ? range.to.toISOString() : null;
          if (fromISO !== null || toISO !== null) { const valueArray = (fromISO !== null && toISO !== null) && fromISO > toISO ? [toISO, fromISO] : [fromISO, toISO]; return { operator: 'betweenDates', value: valueArray as [string | null, string | null] }; }
          return undefined;
      }
      if (schemaOperator === 'never') return { operator: 'never' };
      if (schemaOperator === 'isDue') return { operator: 'isDue' };
      return undefined;
  }, []); // Empty dependency array for pure mapping logic

  // Memoize the RHF submit handler wrapper
  const handleFormSubmit = useCallback(form.handleSubmit(async (formData: StudySetBuilderFormData) => {
    const criteria: StudyQueryCriteria = {};
    // Map deckId, tags
    if (formData.selectedDeckId && formData.selectedDeckId !== 'none') criteria.deckId = formData.selectedDeckId;
    if (formData.includeTags && formData.includeTags.length > 0) { criteria.includeTags = formData.includeTags; criteria.tagLogic = formData.tagLogic ?? 'ANY'; } else { delete criteria.tagLogic; }
    if (formData.excludeTags && formData.excludeTags.length > 0) criteria.excludeTags = formData.excludeTags;
    // Map dates
    criteria.createdDate = mapDateFilterToCriteria(formData.createdDateOperator, formData.createdDateValueDays, formData.createdDateValueDate, formData.createdDateValueRange);
    criteria.updatedDate = mapDateFilterToCriteria(formData.updatedDateOperator, formData.updatedDateValueDays, formData.updatedDateValueDate, formData.updatedDateValueRange);
    criteria.lastReviewed = mapDateFilterToCriteria(formData.lastReviewedOperator, formData.lastReviewedValueDays, formData.lastReviewedValueDate, formData.lastReviewedValueRange);
    criteria.nextReviewDue = mapDateFilterToCriteria(formData.nextReviewDueOperator, formData.nextReviewDueValueDays, formData.nextReviewDueValueDate, formData.nextReviewDueValueRange);
    // Remove undefined
    for (const key of ['createdDate', 'updatedDate', 'lastReviewed', 'nextReviewDue', 'srsLevel', 'includeDifficult'] as (keyof StudyQueryCriteria)[]) { if (criteria[key] === undefined) { if (key in criteria) delete criteria[key]; } }
    // Map SRS
    if (formData.srsLevelOperator && formData.srsLevelOperator !== 'any' && (formData.srsLevelValue !== null && formData.srsLevelValue !== undefined && formData.srsLevelValue >= 0)) {
        const validOperators: SrsLevelOp[] = ['equals', 'lessThan', 'greaterThan'];
        if (validOperators.includes(formData.srsLevelOperator as any)) criteria.srsLevel = { operator: formData.srsLevelOperator as SrsLevelOp, value: formData.srsLevelValue };
    }
    // Map includeDifficult
    if (formData.includeDifficult === true) criteria.includeDifficult = true;

    console.log("Final Form Data (Raw):", formData);
    console.log("Generated Criteria for Save:", criteria);
    await onSave({ name: formData.name, description: formData.description ?? null, criteria }).catch(err => { toast.error("Save failed."); console.error("onSave error:", err); });
  }), [form, onSave, mapDateFilterToCriteria]); // Include mapDateFilterToCriteria in deps

  // Combine loading states
  const isLoading = isLoadingTags || isLoadingDecks || isSaving;

  // Return hook outputs
  return {
    form,
    isLoading,
    tagsError,
    decksError,
    allTags: allTags || [],
    decks: (decks || []) as DeckListItem[], // Cast to expected type
    onSubmit: handleFormSubmit, // Return the memoized RHF handleSubmit wrapper
    watchedOperators: { createdDateOperator, updatedDateOperator, lastReviewedOperator, nextReviewDueOperator, srsLevelOperator },
    watchedFilterValues: { includeDifficult, includeTags, excludeTags },
    allowedOperators: {
        createdUpdatedOps: [...DateDaysOperators, ...DateSpecificOperators],
        lastReviewedOps: [...DateDaysOperators, ...DateSpecificOperators, ...NullableDateOperators],
        nextReviewDueOps: [...DateDaysOperators, ...DateSpecificOperators, ...NullableDateOperators, ...DueDateOperators],
        srsLevelOps: [...SrsLevelOperators],
    }
  };
}
=== useTags.ts ===
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getTags } from '@/lib/actions/tagActions';
import type { Tables } from '@/types/database';

interface UseTagsReturn {
  allTags: Tables<'tags'>[];
  isLoading: boolean;
  error: string | null;
  refetchAllTags: () => Promise<void>;
}

/**
 * Custom hook for managing tag operations and state.
 * 
 * This hook provides:
 * - Tag creation, reading, updating, and deletion
 * - Tag state management
 * - Error handling for tag operations
 * - Loading state management
 * 
 * @returns {Object} Tag management functions and state
 * @returns {Tag[]} returns.tags - Array of user's tags
 * @returns {boolean} returns.loading - Whether tag operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {(name: string) => Promise<void>} returns.createTag - Function to create a new tag
 * @returns {(tagId: string, newName: string) => Promise<void>} returns.updateTag - Function to update a tag's name
 * @returns {(tagId: string) => Promise<void>} returns.deleteTag - Function to delete a tag
 * @returns {() => Promise<void>} returns.refreshTags - Function to refresh the tags list
 */
export function useTags(): UseTagsReturn {
  const [allTags, setAllTags] = useState<Tables<'tags'>[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTags = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await getTags();
      if (result.error) {
        setError(result.error);
        setAllTags([]); // Clear tags on error
      } else {
        setAllTags(result.data || []);
      }
    } catch (err) {
      console.error("Unexpected error fetching all tags:", err);
      setError('An unexpected error occurred while fetching tags.');
      setAllTags([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch on mount
  useEffect(() => {
    fetchTags();
  }, [fetchTags]);

  return { allTags, isLoading, error, refetchAllTags: fetchTags };
} 
=== use-tts.ts ===
"use client";

import { useState, useCallback, useRef, useEffect } from 'react';
import { useSettings } from '@/providers/settings-provider';
// --- Import the new action ---
import { generateTtsAction } from '@/lib/actions/ttsActions';

// Language code mapping for fallbacks
const LANGUAGE_CODES: Record<string, string> = {
  // ISO codes with dialects
  // English dialects
  en: "en-GB",  // Default to UK English
  "en-GB": "en-GB",
  "en-US": "en-US",
  
  // Dutch dialects
  nl: "nl-NL",  // Default to Netherlands Dutch
  "nl-BE": "nl-BE",
  "nl-NL": "nl-NL",
  
  // French dialects
  fr: "fr-FR",  // Default to France French
  "fr-BE": "fr-BE",
  "fr-FR": "fr-FR",
  "fr-CH": "fr-CH",
  
  // German dialects
  de: "de-DE",  // Default to Germany German
  "de-DE": "de-DE",
  "de-AT": "de-AT",
  "de-CH": "de-CH",
  
  // Spanish dialect
  es: "es-ES",  // Default to Spain Spanish
  "es-ES": "es-ES",
  
  // Italian dialects
  it: "it-IT",  // Default to Italy Italian
  "it-IT": "it-IT",
  "it-CH": "it-CH",
  
  // Full names (for backward compatibility)
  english: "en-GB",
  dutch: "nl-NL",
  french: "fr-FR",
  german: "de-DE",
  spanish: "es-ES",
  italian: "it-IT",
};

// --- Interfaces (Keep as is) ---
interface UseTTSProps {
    onAudioStart?: () => void;
    onAudioEnd?: () => void;
}

type TTSState = 'idle' | 'loading' | 'playing' | 'error';

interface UseTTSResult {
    ttsState: TTSState;
    speak: (text: string, languageCode: string) => Promise<void>;
    stop: () => void;
    currentLanguage: string | null;
}

// --- Helper function to log errors (Keep as is) ---
function logTTSError(message: string, error?: any) {
    console.error(`[TTS Hook Error]: ${message}`, error instanceof Error ? error.message : error || '');
    // Optionally send to an error tracking service
}

export function useTTS({ onAudioStart, onAudioEnd }: UseTTSProps): UseTTSResult {
    const [ttsState, setTtsState] = useState<TTSState>('idle');
    const { settings } = useSettings();
    const audioRef = useRef<HTMLAudioElement | null>(null);
    const [currentLanguage, setCurrentLanguage] = useState<string | null>(null);

    // --- Ensure Audio Element Exists (Keep as is) ---
    useEffect(() => {
        if (!audioRef.current) {
            audioRef.current = new Audio();
            audioRef.current.onplay = () => {
                setTtsState('playing');
                onAudioStart?.(); // Call callback if provided
            };
            audioRef.current.onended = () => {
                setTtsState('idle');
                onAudioEnd?.(); // Call callback if provided
            };
            audioRef.current.onerror = () => {
                // Access the error property from the audio element itself
                const error = audioRef.current?.error;
                logTTSError('Audio playback error', error?.message || 'Unknown audio error');
                setTtsState('error');
                onAudioEnd?.(); // Also call on end for errors
            };
        }
        // Cleanup function to pause and clear src on unmount
        return () => {
            if (audioRef.current) {
                 audioRef.current.pause();
                 audioRef.current.removeAttribute('src'); // Clear source
            }
        };
    }, [onAudioStart, onAudioEnd]); // Dependencies for callbacks

    // --- Stop Function (Keep as is) ---
    const stop = useCallback(() => {
        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.currentTime = 0; // Reset playback position
             audioRef.current.removeAttribute('src'); // Clear source to prevent re-play if src changes
            setTtsState('idle');
            onAudioEnd?.(); // Ensure end callback is called on explicit stop
        }
    }, [onAudioEnd]);

    // --- Speak Function (Simplified version based on old client implementation) ---
    const speak = useCallback(async (text: string, language: string) => {
        if (!text || !language) {
            logTTSError('Missing text or language code for TTS.');
            return;
        }
        
        // Use console.log instead of console.error to avoid Next.js error handling
        console.log(`[TTS Debug] Original language: "${language}"`);
        console.log(`[TTS Debug] Settings:`, settings);
        
        // Stop any currently playing audio before starting new request
        stop();

        try {
            setTtsState('loading');
            
            // Get basic language info - directly use the working client-side implementation logic
            const langToUse = language?.toLowerCase() || 'en';
            const baseLanguage = langToUse.split('-')[0];
            
            // DIRECTLY PORT THE WORKING VERSION
            // This is the exact language mapping logic from the working client implementation
            console.log(`[TTS Debug] Base language: "${baseLanguage}"`);
            
            // Create a copy of the EXACT implementation from the working version
            const mappedLanguage = settings?.languageDialects?.[baseLanguage as keyof typeof settings.languageDialects] || 
                                  LANGUAGE_CODES[langToUse] || 
                                  "en-GB";
                                  
            console.log(`[TTS Debug] Mapped language: "${mappedLanguage}"`);
            console.log(`[TTS Debug] Final mapping: ${language} â†’ ${mappedLanguage}`);
            
            setCurrentLanguage(mappedLanguage);

            // Call the server action with mapped language
            const { audioContent, error: ttsError } = await generateTtsAction(
                text,
                mappedLanguage // Use the mapped language
            );

            if (ttsError || !audioContent) {
                throw new Error(ttsError || 'TTS Action returned no audio content.');
            }

            // --- Play the audio --- 
            if (audioRef.current) {
                const audioSrc = `data:audio/mp3;base64,${audioContent}`;
                audioRef.current.src = audioSrc;
                await audioRef.current.play();
            } else {
                throw new Error("Audio element not available.");
            }

        } catch (error: any) {
            logTTSError('TTS Error (action call or playback)', error);
            if (audioRef.current) {
                audioRef.current.removeAttribute('src'); // Clear src on error
            }
            setTtsState('error');
            onAudioEnd?.(); // Ensure end callback fires on error
        }
    }, [settings, stop, onAudioEnd]);

    return { ttsState, speak, stop, currentLanguage };
} 
=== use-tts.tsx -remove ===
"use client"

import { useState, useCallback } from "react"
import { useSettings } from "@/providers/settings-provider"
import type { Settings } from "@/providers/settings-provider"

// Language code mapping for Google Cloud TTS
const LANGUAGE_CODES: Record<string, string> = {
  // ISO codes with dialects
  // English dialects
  en: "en-GB",  // Default to UK English
  "en-GB": "en-GB",
  "en-US": "en-US",
  
  // Dutch dialects
  nl: "nl-NL",  // Default to Netherlands Dutch
  "nl-BE": "nl-BE",
  "nl-NL": "nl-NL",
  
  // French dialects
  fr: "fr-FR",  // Default to France French
  "fr-BE": "fr-BE",
  "fr-FR": "fr-FR",
  "fr-CH": "fr-CH",
  
  // German dialects
  de: "de-DE",  // Default to Germany German
  "de-DE": "de-DE",
  "de-AT": "de-AT",
  "de-CH": "de-CH",
  
  // Spanish dialect
  es: "es-ES",  // Default to Spain Spanish
  "es-ES": "es-ES",
  
  // Italian dialects
  it: "it-IT",  // Default to Italy Italian
  "it-IT": "it-IT",
  "it-CH": "it-CH",
  
  // Full names (for backward compatibility)
  english: "en-GB",
  dutch: "nl-NL",
  french: "fr-FR",
  german: "de-DE",
  spanish: "es-ES",
  italian: "it-IT",
}

// Conditional logging helpers
const logTTS = (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
        console.log('[TTS Hook]:', ...args);
    }
};
const logTTSError = (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
        console.error('[TTS Hook Error]:', ...args);
    }
};

export function useTTS() {
  const [loading, setLoading] = useState(false)
  const [currentLanguage, setCurrentLanguage] = useState<string>("en")
  const { settings } = useSettings()

  // Speak text using Google Cloud TTS
  const speak = useCallback(async (text: string, language?: string): Promise<{ success: boolean; error: Error | null }> => {
    // Check if TTS is enabled in settings, return early if disabled
    if (!settings?.ttsEnabled) {
      logTTS('TTS is disabled in settings');
      return { success: false, error: new Error("TTS is disabled in settings") };
    }

    if (!text.trim()) {
       logTTS('Speak called with empty text.');
       return { success: true, error: null }; // Not an error, just nothing to do
    }

    let audio: HTMLAudioElement | null = null;
    let audioUrl: string | null = null;

    try {
      setLoading(true)
      const langToUse = language?.toLowerCase() || currentLanguage
      const baseLanguage = langToUse.split('-')[0] as keyof Settings['languageDialects']
      const mappedLanguage = settings?.languageDialects?.[baseLanguage] || 
                            LANGUAGE_CODES[langToUse] || 
                            "en-GB"
      logTTS('TTS Debug:', {
        providedLanguage: language,
        currentLanguage,
        baseLanguage,
        settingsDialects: settings?.languageDialects,
        selectedDialect: settings?.languageDialects?.[baseLanguage],
        fallbackDialect: LANGUAGE_CODES[langToUse],
        finalMappedLanguage: mappedLanguage
      })

      const response = await fetch('/api/tts', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          text,
          languageCode: mappedLanguage,
        }),
      })

      if (!response.ok) {
        const errorBody = await response.text(); // Attempt to get error details
        logTTSError(`Failed to generate speech. Status: ${response.status}`, errorBody);
        throw new Error(`Failed to generate speech. Status: ${response.status}`);
      }

      // --- Corrected Blob Handling ---
      const data = await response.json(); // 1. Parse the JSON response
      if (!data.audioContent) {
        logTTSError('TTS API response missing audioContent.');
        throw new Error('TTS API response missing audioContent.');
      }

      // 2. Decode Base64 to binary string
      const binaryString = window.atob(data.audioContent);
      // 3. Convert binary string to byte array
      const len = binaryString.length;
      const bytes = new Uint8Array(len);
      for (let i = 0; i < len; i++) {
          bytes[i] = binaryString.charCodeAt(i);
      }
      // 4. Create Blob with correct MIME type
      const audioBlob = new Blob([bytes], { type: 'audio/mpeg' });
      // --- End Corrected Blob Handling ---

      audioUrl = URL.createObjectURL(audioBlob) // 5. Create Object URL
      audio = new Audio(audioUrl)

      return new Promise((resolve) => {
         // Clean up the URL after the audio has played
         audio!.onended = () => {
           logTTS("Audio playback finished.");
           if (audioUrl) URL.revokeObjectURL(audioUrl);
           setLoading(false);
           resolve({ success: true, error: null });
         };
   
         // Handle errors during playback
         audio!.onerror = (event) => {
           const error = audio?.error || event;
           logTTSError('Audio playback error:', error);
           if (audioUrl) URL.revokeObjectURL(audioUrl);
           setLoading(false);
           resolve({ success: false, error: new Error(`Audio playback failed: ${error?.message || String(error)}`) });
         };
         
         // Start playback
         logTTS("Starting audio playback...");
         audio!.play().catch(playError => { // Catch potential immediate play errors
             logTTSError("Error initiating audio playback:", playError);
             if (audioUrl) URL.revokeObjectURL(audioUrl);
             setLoading(false);
             resolve({ success: false, error: playError instanceof Error ? playError : new Error("Failed to start audio playback") });
         });
      });

    } catch (error) {
      logTTSError('TTS Error (fetch or setup):', error);
      if (audioUrl) URL.revokeObjectURL(audioUrl); // Cleanup if URL was created before error
      setLoading(false);
      return { success: false, error: error instanceof Error ? error : new Error("An unexpected error occurred during TTS processing") };
    }
  }, [currentLanguage, settings, logTTS, logTTSError]) // Added loggers

  const setLanguage = useCallback((lang: string) => {
    logTTS('Setting TTS language to:', lang)
    setCurrentLanguage(lang.toLowerCase())
  }, [logTTS]) // Added logger

  return {
    speak, // Now returns Promise<{ success, error }>
    setLanguage,
    loading,
    // These are kept for compatibility with existing code
    voices: [],
    selectedVoice: null,
    setSelectedVoice: () => {},
  }
}


=== use-decks.tsx ===
// hooks/use-decks.tsx
"use client";

import { useState, useEffect, useCallback, useRef } from "react";
import { useSupabase } from "@/hooks/use-supabase"; // Ensure this is used if needed, otherwise remove
import { useAuth } from "@/hooks/use-auth";
// Import server actions for deck operations
import {
  getDecks as getDecksAction,
  getDeck as getDeckAction,
  createDeck as createDeckAction,
  updateDeck as updateDeckAction,
  deleteDeck as deleteDeckAction
} from "@/lib/actions/deckActions";
// Optional: If using local storage caching (currently commented out)
// import { getDecksFromLocalStorage, saveDecksToLocalStorage } from "@/lib/localStorageUtils";
// Import necessary types
import type { Database, Tables } from "@/types/database";
import { toast } from "sonner"; // For user feedback

// ActionResult interface for consistent return type from actions/wrappers
interface ActionResult<T> {
  data: T | null;
  error: string | null;
}

// --- Type Definitions Updated for Tags AND Stage Counts ---

// Base type for a deck with associated tags (from deckActions)
type DeckWithTags = Tables<'decks'> & { tags: Tables<'tags'>[] };

// Type returned by the getDeck action (includes cards AND tags)
export type DeckWithCardsAndTags = DeckWithTags & { cards: Tables<'cards'>[] };

// Types for the parameters expected by create/update actions/wrappers
export interface CreateDeckParams extends Pick<Tables<'decks'>, 'name' | 'primary_language' | 'secondary_language' | 'is_bilingual'> {}
export interface UpdateDeckParams extends Partial<Pick<Tables<'decks'>, 'name' | 'primary_language' | 'secondary_language' | 'is_bilingual'>> {}

// Type for the items stored in the local 'decks' state list
// This now matches the return type of the modified getDecksAction
type DeckListItem = {
    id: string;
    name: string;
    primary_language: string | null;
    secondary_language: string | null;
    is_bilingual: boolean | null;
    updated_at: string | null;
    new_count: number;
    learning_count: number;
    young_count: number;
    mature_count: number;
    // Note: Tags are NOT currently returned by the RPC function.
    // If needed, they would need to be added to the function or fetched separately.
    // tags: Tables<'tags'>[];
};
// -----------------------------------------

// Define the structure of the object returned by the useDecks hook
interface UseDecksReturn {
    decks: DeckListItem[]; // Use the updated DeckListItem type
    loading: boolean;
    getDeck: (id: string) => Promise<ActionResult<DeckWithCardsAndTags | null>>;
    createDeck: (params: CreateDeckParams) => Promise<ActionResult<Tables<'decks'>>>;
    updateDeck: (id: string, params: UpdateDeckParams) => Promise<ActionResult<Tables<'decks'>>>;
    deleteDeck: (id: string) => Promise<ActionResult<null>>;
    refetchDecks: () => Promise<void>;
}

// --- Conditional Logging ---
// Avoid logging spam in production builds
const logDecks = (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
        console.log('[Decks Hook]:', ...args);
    }
};
const logDecksError = (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
        console.error('[Decks Hook Error]:', ...args);
    }
};

/**
 * Custom hook for managing and interacting with deck data.
 * Provides functions to fetch, create, update, and delete decks using server actions,
 * while managing a local state for the list of decks suitable for display components.
 */
export function useDecks(): UseDecksReturn {
  // State for storing the list of decks - Use the updated DeckListItem type
  const [decks, setDecks] = useState<DeckListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const { user, loading: authLoading } = useAuth();
  const isFetchingList = useRef(false);

  // Function to fetch the list of decks from the server action
  const fetchDeckList = useCallback(async () => {
        // Don't fetch if user isn't loaded or doesn't exist
        if (authLoading || !user) {
           setDecks([]); // Clear decks if no user
           setLoading(false); // Stop loading if no user
           if (!authLoading) logDecks("No user, clearing deck list.");
           return;
        }
        // --- Prevent concurrent fetches --- 
        if (isFetchingList.current) { 
            logDecks("Fetch already in progress, skipping.");
            return;
        }
        // ---------------------------------
      logDecks("Fetching deck list via RPC..."); // Updated log message
      setLoading(true);
      isFetchingList.current = true;
      try {
          // Call the server action (which now calls the RPC)
          const result = await getDecksAction();
          if (result.error) {
              logDecksError("Error fetching deck list:", result.error);
              toast.error("Failed to load decks", { description: result.error });
              setDecks([]);
          } else {
              logDecks(`Fetched ${result.data?.length ?? 0} decks via RPC.`);
              // Data structure from action should match DeckListItem
              setDecks(result.data || []); // No cast needed if action type is correct
          }
      } catch (error) {
          logDecksError("Unexpected error fetching deck list:", error);
          toast.error("Failed to load decks", { description: "An unexpected error occurred." });
          setDecks([]);
      } finally {
        setLoading(false);
        isFetchingList.current = false;
      }
  }, [user, authLoading]);

  // Effect to fetch the deck list
  useEffect(() => {
      fetchDeckList();
  }, [fetchDeckList]);

  // --- Action Wrappers ---
  // These functions wrap the server actions, handle loading states (if needed specifically per action),
  // manage optimistic UI updates, and provide user feedback via toasts.

  /**
   * Creates a new deck by calling the server action.
   * Optimistically updates the local deck list state upon success.
   */
  const createDeck = useCallback(async (params: CreateDeckParams): Promise<ActionResult<Tables<'decks'>>> => {
      if (!user) return { data: null, error: "User not authenticated" };

      const toastId = toast.loading("Creating deck..."); 
      const result = await createDeckAction(params);

      if (!result.error && result.data) {
          toast.success(`Deck "${result.data.name}" created.`, { id: toastId });

          // --- Optimistic UI update needs the new counts (initially zero) ---
          const newDeckItem: DeckListItem = {
              id: result.data.id,
              name: result.data.name,
              primary_language: result.data.primary_language,
              secondary_language: result.data.secondary_language,
              is_bilingual: result.data.is_bilingual,
              updated_at: result.data.updated_at,
              new_count: 0, // Initialize counts to 0
              learning_count: 0,
              young_count: 0,
              mature_count: 0,
              // tags: [] // If tags were included, initialize here
          };
          setDecks((prev) => [...prev, newDeckItem].sort((a,b) => a.name.localeCompare(b.name)));
          // -------------------------------------------------------------------------

      } else if (result.error) {
          logDecksError("Create action failed:", result.error);
          toast.error("Failed to create deck", { id: toastId, description: result.error });
      }
      return result;
  }, [user]);

  /**
   * Fetches the full details of a single deck, including its cards and tags.
   */
  const getDeck = useCallback(async (id: string): Promise<ActionResult<DeckWithCardsAndTags | null>> => {
       if (!user) return { data: null, error: "User not authenticated" };
       if (!id) return { data: null, error: "Deck ID required" };

       // Optionally show loading state specifically for getDeck if needed elsewhere
       // const toastId = toast.loading("Loading deck details...");
       const result = await getDeckAction(id); // Call server action

        if (result.error) {
            // toast.error("Failed to load deck details", { id: toastId, description: result.error });
            toast.error("Failed to load deck details", { description: result.error });
       } else {
            // toast.dismiss(toastId);
       }
       // Return the raw result from the server action
       return result as ActionResult<DeckWithCardsAndTags | null>; // Cast if needed
  }, [user]); // Dependency: user state

  /**
   * Updates an existing deck's metadata by calling the server action.
   * IMPORTANT: Does NOT update the local 'decks' list state to prevent loops
   * when called from the Edit Deck page's auto-save.
   */
  const updateDeck = useCallback(async (id: string, params: UpdateDeckParams): Promise<ActionResult<Tables<'decks'>>> => {
       if (!user) return { data: null, error: "User not authenticated" };
       if (!id) return { data: null, error: "Deck ID required" };

       // Optionally show loading toast if needed for manual updates elsewhere
       // const toastId = toast.loading(`Updating deck...`);
       logDecks("Calling updateDeck action for ID:", id, "with params:", params);
       const result = await updateDeckAction(id, params); // Call server action

       // Handle TOAST notification based on result
       if (!result.error && result.data) {
            logDecks("Update action successful for ID:", id);
            // --- FIX: NO setDecks CALL HERE ---
            // The component initiating the update (e.g., Edit Page)
            // handles refreshing its own state. Updating the global list here
            // causes re-render loops in the Edit Page's auto-save scenario.
            // We only show the success toast.
            // ---------------------------------
            toast.success(`Deck "${result.data.name}" updated.`); // Keep toast notification
       } else if (result.error) {
            logDecksError("Update action failed for ID:", id, "Error:", result.error);
            toast.error("Failed to update deck", { description: result.error });
       }
       // Return the raw result from the server action
       return result;
  // Dependency: user state
  }, [user]);


  /**
   * Deletes a deck by calling the server action.
   * Optimistically updates the local 'decks' list state.
   */
  const deleteDeck = useCallback(async (id: string): Promise<ActionResult<null>> => {
      if (!user) return { data: null, error: "User not authenticated" };
      if (!id) return { data: null, error: "Deck ID required" };

      // Store original decks for potential revert on error
      const originalDecks = decks;
      // Optimistic UI: Remove immediately from local state
      setDecks((prev) => prev.filter(d => d.id !== id));
      const toastId = toast.loading("Deleting deck..."); // Show loading toast
      logDecks("Calling deleteDeck action for ID:", id);
      const result = await deleteDeckAction(id); // Call server action

       if (result.error) {
            // Action failed, update toast and revert local state
            toast.error("Failed to delete deck", { id: toastId, description: result.error });
            logDecksError("Delete action failed for ID:", id, "Error:", result.error);
            setDecks(originalDecks); // Revert list state
            return { data: null, error: result.error };
       } else {
            // Action successful, update toast
            logDecks("Delete action successful for ID:", id);
            toast.success("Deck deleted.", { id: toastId });
            return { data: null, error: null };
       }
  // Dependencies: user and the 'decks' state for reverting optimistic update
  }, [user, decks]);

  // refetchDecks function uses the updated fetchDeckList
  const refetchDecks = useCallback(async () => {
    logDecks("Explicit refetch triggered.");
    await fetchDeckList();
  }, [fetchDeckList]);

  // Return the hook's public API
  return {
    decks,
    loading,
    getDeck,
    createDeck,
    updateDeck,
    deleteDeck,
    refetchDecks,
  };
}
=== useStudySets.ts ===
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getUserStudySets } from '@/lib/actions/studySetActions'; // Adjust path if needed
import type { Database, Tables } from "@/types/database"; // Corrected path to the actual file

// Assuming DbStudySet is the type for rows in your 'study_sets' table
type DbStudySet = Tables<'study_sets'>;

interface UseStudySetsReturn {
  studySets: DbStudySet[];
  isLoading: boolean;
  error: string | null;
  refetchStudySets: () => Promise<void>;
}

/**
 * Custom hook for managing study sets (smart playlists).
 * 
 * This hook provides:
 * - Study set creation, reading, updating, and deletion
 * - Study set state management
 * - Error handling for study set operations
 * - Loading state management
 * 
 * @returns {Object} Study set management functions and state
 * @returns {StudySet[]} returns.studySets - Array of user's study sets
 * @returns {boolean} returns.loading - Whether study set operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {(name: string, queryCriteria: StudyQueryCriteria) => Promise<void>} returns.createStudySet - Function to create a new study set
 * @returns {(studySetId: string, updates: Partial<StudySet>) => Promise<void>} returns.updateStudySet - Function to update a study set
 * @returns {(studySetId: string) => Promise<void>} returns.deleteStudySet - Function to delete a study set
 * @returns {() => Promise<void>} returns.refreshStudySets - Function to refresh the study sets list
 */
export function useStudySets(): UseStudySetsReturn {
  const [studySets, setStudySets] = useState<DbStudySet[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchStudySets = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    console.log("[useStudySets] Fetching study sets...");
    try {
      const result = await getUserStudySets();
      if (result.error) {
        console.error("[useStudySets] Error fetching study sets:", result.error);
        setError(result.error);
        setStudySets([]); // Clear sets on error
      } else {
        console.log(`[useStudySets] Successfully fetched ${result.data?.length ?? 0} sets.`);
        setStudySets(result.data || []); // Ensure data is an array
      }
    } catch (err) {
      console.error("[useStudySets] Unexpected error during fetch:", err);
      setError('An unexpected error occurred while fetching study sets.');
      setStudySets([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch on mount
  useEffect(() => {
    fetchStudySets();
  }, [fetchStudySets]);

  return { studySets, isLoading, error, refetchStudySets: fetchStudySets };
} 
=== useStudySession.ts ===
// Fixed TypeScript errors - 2023-09-15
// hooks/useStudySession.ts
'use client';

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { resolveStudyQuery } from '@/lib/actions/studyQueryActions';
import { getCardsByIds } from '@/lib/actions/cardActions';
import { updateCardProgress } from '@/lib/actions/progressActions'; // Assuming this action expects { cardId, grade, updatedFields: Partial<Tables<'cards'>> }
import {
  calculateSm2State,
  Sm2UpdatePayload,
  ReviewGrade,
  Sm2InputCardState,
  calculateNextStandardLearnStep,
  calculateNextRelearningStep,
  createGraduationPayload,
  createRelearningGraduationPayload,
} from '@/lib/srs'; // Assuming these utilities are in srs.ts
import { useSettings, type Settings } from '@/providers/settings-provider'; // Import Settings type
import type { Database, Tables, TablesUpdate } from "@/types/database"; // Import TablesUpdate
import type { StudyInput, StudyMode } from '@/store/studySessionStore';
import type { ResolvedCardId, StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import {
  isAfter,
  parseISO,
  isValid,
  isToday,
  isPast,
  addDays,
  addMinutes,
  startOfDay
} from 'date-fns';
import { debounce } from "@/lib/utils";
import { toast } from 'sonner';
// import { useAuth } from '@/hooks/use-auth'; // Assuming auth is managed globally/elsewhere if not used directly here

// Define card type from database Tables
type StudyCard = Tables<'cards'>;

// Define LearningState locally as it's a limited set of strings
type LearningState = 'learning' | 'relearning' | null;

/**
 * Represents the relevant SRS state of a card needed for calculations in lib/srs.ts.
 * Derived from StudyCard.
 */
type CardSrsState = Pick<StudyCard, 'srs_level' | 'easiness_factor' | 'interval_days' | 'learning_state' | 'learning_step_index' | 'next_review_due'>;


/**
 * Represents the internal state of a card within the study session queue.
 * This state is specific to the *current session instance*.
 */
export type InternalCardState = {
  streak: number;             // For dedicated-learn tracking consecutive correct answers in *current session*
  learningStepIndex: number | null; // Current position in learning/relearning steps array for *current session*
  dueTime: Date;              // When card is next due *within the session context* (now for immediate, future for timed steps)
  failedAttemptsInLearn: number; // Track 'Again' responses in learn mode for initial EF
  hardAttemptsInLearn: number;   // Track 'Hard' responses in learn mode for initial EF
};

/**
 * Represents a card item in the study session queue.
 * Combines the database card data with session-specific internal state.
 */
export type SessionCard = {
  card: StudyCard; // Full card data from DB
  internalState: InternalCardState; // State specific to this session instance
};

/**
 * Represents the aggregated results/stats for the current study session.
 */
export type SessionResults = {
  totalAnswered: number; // Total grades given
  correctCount: number;  // Grade >= 3
  incorrectCount: number; // Grade 1
  hardCount: number; // Grade 2
  easedCount: number; // Grade 4
  graduatedCount: number; // Cards graduating from Initial Learn or Relearn this session
  relapsedCount: number; // Cards lapsing from Review to Relearn this session
  // elapsedTimeMs: number; // Optional: Add timer logic if needed
};


// Define the structure returned by the hook
interface UseStudySessionReturn {
    currentCard: StudyCard | null; // The card data currently displayed
    isInitializing: boolean; // Is the hook loading data/preparing session
    error: string | null; // Any error message
    studyMode: StudyMode | null; // The mode of the current session ('learn' or 'review')
    isComplete: boolean; // Is the session finished
    totalCardsInSession: number; // Total cards initially loaded into the mode queue
    currentCardNumber: number; // 1-based index of the currently displayed card within the mode queue
    initialSelectionCount: number; // Total cards matching initial query criteria before mode filtering
    isProcessingAnswer: boolean; // Is the app currently processing an answer (UI locked)
    isFlipped: boolean; // Is the current card flipped to show the answer
    onFlip: () => void; // Action to trigger card flip
    sessionResults: Pick<SessionResults, 'totalAnswered' | 'correctCount' | 'incorrectCount'>; // Publicly exposed results (simplified)
    answerCard: (grade: ReviewGrade) => Promise<void>; // Action to grade a card
    currentCardStatusDisplay: string | null; // String like "Streak: 2/3", "Due in 5m" for UI display
    // debugQueue?: SessionCard[]; // Optional debug export
}

interface UseStudySessionProps {
    initialInput: StudyInput | null;
    initialMode: StudyMode | null;
}

const PROGRESS_UPDATE_DEBOUNCE_MS = 1500;
const FLIP_DURATION_MS = 300;
const PROCESSING_DELAY_MS = FLIP_DURATION_MS + 50; // Delay processing slightly longer than flip

/**
 * Custom hook for managing study session state and logic.
 */
export function useStudySession({ 
    initialInput, 
    initialMode 
}: UseStudySessionProps): UseStudySessionReturn {
    const { settings, loading: isLoadingSettings } = useSettings(); // Access settings and loading state
    // Study mode and input are derived from props
    const studyInput = initialInput;
    const studyMode = initialMode;
    // Session is initialized when input, mode, and settings are available and settings are not loading
    const isInitialized = Boolean(initialInput && initialMode && settings && !isLoadingSettings);

    // --- State Variables ---
    const [sessionQueue, setSessionQueue] = useState<SessionCard[]>([]); // The queue of cards for this session
    // currentCardIndex tracks the index of the card *currently being displayed* within sessionQueue
    const [currentCardIndex, setCurrentCardIndex] = useState<number>(0);
    const [isFlipped, setIsFlipped] = useState<boolean>(false);
    const [isComplete, setIsComplete] = useState<boolean>(false);
    const [isLoading, setIsLoading] = useState<boolean>(true); // True during initial data fetch/queue prep
    const [isProcessingAnswer, setIsProcessingAnswer] = useState<boolean>(false); // True while processing an answer
    const [sessionResults, setSessionResults] = useState<SessionResults>({
      totalAnswered: 0, correctCount: 0, incorrectCount: 0, hardCount: 0, easedCount: 0, graduatedCount: 0, relapsedCount: 0
    });
    const [error, setError] = useState<string | null>(null);
    // State variable for the status display string (derived from internal state)
    const [currentCardStatusText, setCurrentCardStatusText] = useState<string | null>(null);

    // Total cards matching initial query criteria (set once during init)
    const [initialSelectionCount, setInitialSelectionCount] = useState<number>(-1);


    // Ref for timer to check for cards becoming due (timed steps)
    const dueCheckTimerRef = useRef<NodeJS.Timeout | null>(null);
    // Ref for settings to use in async functions and callbacks
    const settingsRef = useRef<Settings | null>(null);


    // Update settings ref when settings change
    useEffect(() => {
      settingsRef.current = settings;
    }, [settings]);


    // --- Debounced Save Progress Function ---
    // This function takes the *final state of the card object* after logic is applied
    // and the grade that triggered the update.
    const debouncedUpdateProgress = useCallback(
      debounce(async (updateData: { cardToSave: StudyCard, grade: ReviewGrade }) => {
        const { cardToSave, grade } = updateData;
        console.log(`[debouncedUpdateProgress] Saving card ${cardToSave?.id} with grade ${grade}`);

        if (!cardToSave || !cardToSave.id) {
            console.error("[debouncedUpdateProgress] Attempted to save invalid card data (missing card or id).");
            toast.error("Failed to save progress for a card due to invalid data.");
            return;
        }

        try {
          // Cast learning_state to the specific union type expected by the schema
          const learningState = cardToSave.learning_state as LearningState;
          
          // Explicitly define the fixed payload with non-nullable required fields
          const payload = {
               srs_level: cardToSave.srs_level ?? 0,
               easiness_factor: cardToSave.easiness_factor ?? settings?.defaultEasinessFactor ?? 2.5, 
               interval_days: cardToSave.interval_days ?? 0, 
               next_review_due: cardToSave.next_review_due && isValid(parseISO(cardToSave.next_review_due)) 
                 ? cardToSave.next_review_due 
                 : new Date().toISOString(), // Ensure valid date string
               learning_state: learningState, // Already cast to the correct type
               learning_step_index: cardToSave.learning_step_index ?? null,
               failed_attempts_in_learn: cardToSave.failed_attempts_in_learn ?? 0,
               hard_attempts_in_learn: cardToSave.hard_attempts_in_learn ?? 0,
               attempt_count: cardToSave.attempt_count ?? 0, 
               correct_count: cardToSave.correct_count ?? 0,
               incorrect_count: cardToSave.incorrect_count ?? 0,
           };

          // The action sets last_reviewed_at and last_review_grade based on its grade parameter
          const result = await updateCardProgress({
            cardId: cardToSave.id,
            grade: grade, 
            updatedFields: payload,
          });

          if (result.error) {
            console.error(`Error updating card ${cardToSave.id} progress:`, result.error);
             toast.error(`Failed to save progress for card: ${cardToSave.id}`);
          } else {
             console.log(`Successfully saved progress for card ${cardToSave.id}.`);
             // Optional: toast.success(`Progress saved for ${cardToSave.id}`);
          }
        } catch (error) {
          console.error(`Exception saving progress for card ${cardToSave?.id}:`, error);
           toast.error(`Exception saving progress for card: ${cardToSave?.id}`);
            }
        }, PROGRESS_UPDATE_DEBOUNCE_MS),
      [settingsRef] // Depend on the settings ref
    );

    // --- Find the next card to study based on due time ---
    // Iterates through the queue from the beginning to find the first card ready now.
    // Returns the index of the first item where dueTime <= now, or queue.length if none are due.
    // This function does NOT modify state and does NOT schedule timers.
    const findNextCardIndex = useCallback((queue: SessionCard[]): number => {
        if (!queue || queue.length === 0) return queue.length; // Return length to signal empty/no-due

        const now = new Date();
        // Find the index of the first card that is due now or in the past
        const nextIndex = queue.findIndex(item => item.internalState.dueTime <= now);

        // If no card is currently due, findIndex returns -1. Map -1 to queue.length for consistency.
        return nextIndex !== -1 ? nextIndex : queue.length;
    }, []); // No dependencies on state, pure function of input queue


    // --- Schedule a check for the next due card ---
    // Finds the soonest *future* due time in the current queue and schedules a timer.
    // Called after queue state updates.
    const scheduleNextDueCheck = useCallback(() => {
         // Clear any existing timer
         if (dueCheckTimerRef.current) {
             clearTimeout(dueCheckTimerRef.current);
             dueCheckTimerRef.current = null;
         }

         // If session is complete or queue is empty, no need to schedule
         if (isComplete || sessionQueue.length === 0) return;

         // Find the soonest *future* due time in the current queue
         const now = new Date();
         let soonestFutureDueTime: Date | null = null;

         // Iterate through the queue to find the earliest future due time
         // Assumes sessionQueue is sorted by dueTime
         for (const item of sessionQueue) {
             if (item.internalState.dueTime > now) {
                 soonestFutureDueTime = item.internalState.dueTime;
                 break; // Found the soonest future one since it's sorted
             }
         }

         // If found a future due time, schedule a timer
         if (soonestFutureDueTime) {
             const delay = soonestFutureDueTime.getTime() - now.getTime() + 100; // Add a small buffer

             dueCheckTimerRef.current = setTimeout(() => {
                  console.log("[useStudySession] Due check timer fired. Triggering queue re-evaluation.");
                  // Trigger re-evaluation by updating queue state (shallow copy to force render)
                  // This will cause the currentCard memo (which calls findNextCardIndex) to re-run.
                  setSessionQueue([...sessionQueue]);
             }, Math.max(delay, 100)); // Minimum 100ms delay
             console.log(`[useStudySession] Scheduled next due check in ${Math.max(delay, 100)}ms.`);
         } else {
             // No future cards are due in the queue. No timer needed.
             console.log("[useStudySession] No future cards to schedule check for.");
         }
     }, [isComplete, sessionQueue]); // Dependency on sessionQueue to re-schedule when queue changes


    // --- Initialize the session when dependencies are ready ---
    useEffect(() => {
      let isMounted = true; // Flag to prevent state updates on unmounted component

      async function initializeSession() {
        try {
          // Wait for initial parameters and settings to be loaded
          // Only initialize if hook is not already loading and dependencies are ready
          if (!isLoading && !isInitialized) {
               console.log("[useStudySession] Waiting for initialization dependencies (input, mode, settings)...");
               return; // Exit if not ready
          }
          // If already initialized and dependencies haven't changed, do nothing
           if (!isLoading && sessionQueue.length > 0 && initialSelectionCount > -1 && !isComplete) {
                console.log("[useStudySession] Session already initialized with existing queue.");
                // If the hook was unmounted and remounted, the timer might be gone. Re-schedule it.
                 scheduleNextDueCheck(); // Schedule check based on existing queue
                return;
            }


          console.log(`[useStudySession] Starting session initialization for Mode: ${studyMode}`);
          setIsLoading(true);
                setError(null);
                setIsComplete(false);
          setSessionQueue([]); // Clear previous session state
          setCurrentCardIndex(0); // Reset index
          setSessionResults({ totalAnswered: 0, correctCount: 0, incorrectCount: 0, hardCount: 0, easedCount: 0, graduatedCount: 0, relapsedCount: 0 });
          setIsFlipped(false);
          setInitialSelectionCount(-1); // Reset count for new init
          setCurrentCardStatusText(null); // Clear status display

           // Clear any old timers
           if (dueCheckTimerRef.current) {
             clearTimeout(dueCheckTimerRef.current);
             dueCheckTimerRef.current = null;
           }


          // 1. Get card IDs based on study input (resolveQuery handles StudySet/Deck/etc)
          let cardIds: string[] = [];
          let resolveResult;

          // Adapt resolveStudyQuery call based on the structure of StudyInput
          if (studyInput && 'studySetId' in studyInput && studyInput.studySetId) {
              console.log(`[useStudySession] Resolving Study Set: ${studyInput.studySetId}`);
              resolveResult = await resolveStudyQuery({ studySetId: studyInput.studySetId });
          } else if (studyInput && 'criteria' in studyInput && studyInput.criteria) {
               console.log(`[useStudySession] Resolving Study Criteria:`, studyInput.criteria);
               resolveResult = await resolveStudyQuery({ criteria: studyInput.criteria });
          } else if (studyInput && 'deckId' in studyInput && studyInput.deckId) {
               // For a specific deck, resolve ALL cards in the deck first by ID
               console.log(`[useStudySession] Resolving Deck ID: ${studyInput.deckId}`);
               resolveResult = await resolveStudyQuery({ 
                 criteria: { 
                   deckId: studyInput.deckId as string,
                   tagLogic: "ANY",
                   includeDifficult: true
                 } 
               });
          } else {
              console.error("[useStudySession] Invalid study input configuration:", studyInput);
              throw new Error('Invalid study input configuration');
          }


          if (!isMounted) return; // Check mount status after async op
                if (resolveResult.error || !resolveResult.data) {
            console.error("[useStudySession] Failed to resolve card IDs:", resolveResult.error);
            // If the query failed, set initial count to 0 to indicate nothing was found
            setInitialSelectionCount(0);
            throw new Error(resolveResult.error || 'Failed to resolve study query');
          }
          cardIds = resolveResult.data;
          console.log(`[useStudySession] Resolved ${cardIds.length} card IDs from query`);

          // Set total cards matching criteria (before mode filtering)
          setInitialSelectionCount(cardIds.length);

                if (cardIds.length === 0) {
            console.log("[useStudySession] No card IDs found matching criteria.");
                    if (isMounted) {
              setIsLoading(false);
                        setIsComplete(true);
              setCurrentCardStatusText('No cards found matching criteria.');
            }
            return; // Exit initialization
          }

          // 2. Fetch full card data for all resolved IDs
          const cardResult = await getCardsByIds(cardIds);
          if (!isMounted) return; // Check mount status
          if (cardResult.error || !cardResult.data) {
            console.error("[useStudySession] Failed to fetch cards:", cardResult.error);
             // If fetching failed, set initial count to the number of IDs found but couldn't fetch
             // setInitialSelectionCount(cardIds.length); // Keep the count of resolved IDs
            throw new Error(cardResult.error || 'Failed to fetch cards');
          }
          const fetchedCards: StudyCard[] = cardResult.data;
          console.log(`[useStudySession] Fetched ${fetchedCards.length} cards for session.`);

          // 3. CRITICAL: Filter fetched cards to create the *initial* queue based on Study Mode
          let initialQueueCards: StudyCard[] = [];
          const now = new Date();

          if (studyMode === 'learn') {
            // Learn mode queue: cards with srs_level=0 and not in relearning
            // These are the cards needing initial learning or reset learning
            initialQueueCards = fetchedCards.filter(card =>
                 card.srs_level === 0 && card.learning_state !== 'relearning'
            );
            console.log(`[useStudySession] Filtered ${initialQueueCards.length} cards for Learn mode queue.`);

          } else if (studyMode === 'review') {
            // Review mode queue: cards in review state OR relearning state that are currently DUE
            initialQueueCards = fetchedCards.filter(card => {
                 const isReviewOrRelearning = (card.srs_level >= 1 && card.learning_state === null) ||
                                              (card.srs_level === 0 && card.learning_state === 'relearning');

                 // A card is due if its next_review_due is null OR <= now()
                 // Review mode should ideally only get cards already scheduled (non-null next_review_due)
                 // If the query was for 'isDue', it might include NULLs, but filter them out for Review mode queue
                 const isScheduledAndDue = card.next_review_due && isValid(parseISO(card.next_review_due)) && parseISO(card.next_review_due) <= now;

                 // For Review mode queue, we only want cards that are *scheduled* and due (srs_level >= 1 or relearning)
                 return isReviewOrRelearning && isScheduledAndDue;
            });

            console.log(`[useStudySession] Filtered ${initialQueueCards.length} cards for Review mode queue (due).`);
          }


          // --- Handle empty queue after filtering ---
          if (initialQueueCards.length === 0) {
            console.log(`[useStudySession] No cards filtered into ${studyMode} queue.`);
                if (isMounted) {
              setIsLoading(false);
              setIsComplete(true);
              setCurrentCardStatusText(
                studyMode === 'learn'
                  ? (fetchedCards.length > 0 ? 'No new cards in selection' : 'No cards found matching criteria.')
                  : (fetchedCards.length > 0 ? 'No cards due for review in selection' : 'No cards found matching criteria.')
              );
            }
            return; // Exit initialization
          }

          // 4. Create session queue with internal state
          // sessionStartTimeRef.current = new Date(); // Start timer here if needed

          const newSessionQueue: SessionCard[] = initialQueueCards.map(card => {
            const internalState: InternalCardState = {
              // Initialize state relevant for the session based on card's *initial* DB state
              streak: 0, // Streak starts at 0 for the session
              learningStepIndex: card.learning_step_index, // Carry over step index from DB
              // failedAttemptsInLearn and hardAttemptsInLearn are tracked on the card object, not internal state
              // Set initial dueTime for session queue management
              // Review cards use their DB due date for initial sorting/finding
              // Learn cards start as immediately due (now())
              dueTime: studyMode === 'review' && card.next_review_due ? parseISO(card.next_review_due) : new Date(),
              failedAttemptsInLearn: card.failed_attempts_in_learn ?? 0,
              hardAttemptsInLearn: card.hard_attempts_in_learn ?? 0,
            };

            // IMPORTANT: For truly new cards (srs_level=0, learning_state=null) entering Learn mode,
            // explicitly set their state to 'learning' and step 0 *here* for the session queue item
            // This is the transition from 'new' to 'learning' state for the session/saving
            if (studyMode === 'learn' && card.srs_level === 0 && !card.learning_state) {
                 // Update card object itself (copy) for saving later
                 card = { ...card, learning_state: 'learning', learning_step_index: 0 };
                 // Update internal internalState as well
                 internalState.learningStepIndex = 0;
            }


            return { card: { ...card }, internalState }; // Clone card again to be safe
          });

          // 5. Sort the initial queue by due time (earliest first)
          const sortedQueue = [...newSessionQueue].sort((a, b) =>
            a.internalState.dueTime.getTime() - b.internalState.dueTime.getTime()
          );
                
                if (isMounted) {
            setSessionQueue(sortedQueue);
            // Find the first card that is due *now* from the sorted queue
            const initialNextCardIndex = findNextCardIndex(sortedQueue);

             // Set the current index to the first due card, or queue.length to signal 'waiting' state
             setCurrentCardIndex(initialNextCardIndex); // findNextCardIndex returns index or queue.length


            setIsLoading(false);
            // scheduleNextDueCheck() will be triggered by the queue state update effect
          }

        } catch (err) {
          console.error('[useStudySession] Error during initialization:', err);
                if (isMounted) {
            setError(err instanceof Error ? err.message : 'An unknown error occurred during setup.');
            setIsLoading(false);
            setIsComplete(true); // Mark as complete on error
             // setCurrentStatusText will show the error via the memo
          }
        }
      }

        // Effect runs when isInitialized becomes true (initialInput, initialMode, settings load)
        // Dependencies: Re-run when init parameters/settings are ready change
        // Include isLoadingSettings as a dependency because settings might load asynchronously
        initializeSession();

      // Cleanup function for the effect
      return () => {
        isMounted = false;
        // Clear any scheduled timer when component unmounts or dependencies change (triggering re-init)
        if (dueCheckTimerRef.current) {
          clearTimeout(dueCheckTimerRef.current);
          dueCheckTimerRef.current = null;
        }
      };
    }, [isInitialized, studyInput, studyMode, settings, isLoadingSettings]);


    // Effect to re-schedule the timer whenever the queue changes, if not complete
    useEffect(() => {
        // This effect handles scheduling the *next* timer if the queue state changes (after answer, init, etc.)
        if (!isComplete && sessionQueue.length > 0) {
             // scheduleNextDueCheck() will find the next future due time in the *new* queue and schedule the timer
             scheduleNextDueCheck();
        } else if (isComplete && dueCheckTimerRef.current) {
             // If session becomes complete, clear any pending timer
             clearTimeout(dueCheckTimerRef.current);
             dueCheckTimerRef.current = null;
        }
         // Cleanup timer on effect re-run or component unmount is handled in the initialization effect's cleanup

    }, [sessionQueue, isComplete, scheduleNextDueCheck]);


    // --- Get the currently displayed SessionCard item ---
    // This memo finds the card to display based on the currentCardIndex state
    const currentQueueItem = useMemo(() => {
      // If session is loading, complete, queue is empty, or index is out of bounds, no card item to display
      // currentCardIndex can be queue.length to signal the 'waiting' state
      if (isLoading || isComplete || !sessionQueue || sessionQueue.length === 0 || currentCardIndex < 0 || currentCardIndex > sessionQueue.length) {
          // console.log("[currentQueueItem] Returning null based on state or index bounds.", {isLoading, isComplete, queueLength: sessionQueue.length, currentCardIndex});
          return null;
      }

       // If currentCardIndex is queue.length, it means we are in the waiting state (no cards currently due)
       if (currentCardIndex === sessionQueue.length) {
           // console.log("[currentQueueItem] Returning null due to waiting state index.");
           return null;
       }

       // Return the item at the currentCardIndex state
       // The findNextCardIndex logic is now responsible for setting the currentCardIndex state correctly
       //console.log(`[currentQueueItem] Displaying card at index ${currentCardIndex}`);
      return sessionQueue[currentCardIndex];

    }, [isLoading, isComplete, sessionQueue, currentCardIndex]); // Depends on the state variables


    // The actual StudyCard object returned by the hook
    const currentCard = currentQueueItem ? currentQueueItem.card : null;


    // Calculate total cards in session (count after mode filtering during init)
    const totalCardsInSession = useMemo(() => {
        // Use the count after the mode-specific filtering set during initialization
        // If initialSelectionCount is -1 (init not finished or error), use queue length as fallback
        return initialSelectionCount > -1 ? initialSelectionCount : sessionQueue.length;
    }, [initialSelectionCount, sessionQueue.length]); // Depends on the count set after filtering

    // Calculate current card number (1-based index of the currently displayed card)
    const currentCardNumber = useMemo(() => {
        if (!currentQueueItem) {
            // If no current item, and session is complete but queue wasn't empty, show total count
            if (isComplete && totalCardsInSession > 0) return totalCardsInSession;
            return 0; // No card displayed, or session empty from start
        }
        // Find the 0-based index of the current item within the *full* session queue + 1
        // currentCardIndex state should already be the correct index
        return currentCardIndex + 1;
    }, [currentQueueItem, currentCardIndex, isComplete, totalCardsInSession]); // Depends on the current displayed item and its index


    // Derived status display (memoized)
    const currentCardStatusDisplay = useMemo(() => {
        if (isLoading) return 'Loading session...';
        if (error) return `Error: ${error}`;
        if (isComplete) return totalCardsInSession > 0 ? 'Session Complete!' : 'No cards to study.';
        if (!settings || isLoadingSettings) return 'Loading settings...'; // Wait for settings to display status

        // If queue is not empty, but no card is currently displayed (waiting for timed step)
        if (!currentQueueItem && sessionQueue.length > 0) {
            const now = new Date();
            // Find the soonest future due time from the *entire* queue (which is sorted)
            // The first item in the sorted queue that is > now() is the soonest future one
            let soonestFutureDueItem = sessionQueue.find(item => item.internalState.dueTime > now);

            if (soonestFutureDueItem) {
                 const diffMs = soonestFutureDueItem.internalState.dueTime.getTime() - now.getTime();
                 const diffSeconds = Math.ceil(diffMs / 1000);
                 if (diffSeconds <= 1) return `Next card due in ~1s`; // Round up to 1 sec if < 1 sec
                 if (diffSeconds < 60) return `Next card due in ${diffSeconds}s`;
                 const diffMinutes = Math.ceil(diffMs / (1000 * 60));
                 if (diffMinutes <= 1) return `Next card due in ~1m`; // Round up to 1 min if < 1 min
                 if (diffMinutes < 60) return `Next card due in ${diffMinutes}m`;
                 const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));
                 if (diffHours <= 24) return `Next card due in ${diffHours}h`;
                 // Format date like "MMM dd"
                 return setCurrentCardStatusText(`Next card due on ${soonestFutureDueItem.internalState.dueTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`);
            } else {
                 // This case means queue is not empty, but no card is due now or in future (shouldn't happen if logic is right)
                 return 'Waiting... (No future due times)';
            }
        }

        // If a currentQueueItem exists, display its specific status
        if (currentQueueItem) {
             const card = currentQueueItem.card;
             const internalState = currentQueueItem.internalState;

             if (card.srs_level === 0 && card.learning_state === 'learning') {
                 if (settings.studyAlgorithm === 'dedicated-learn') {
                      return `Streak: ${internalState.streak}/${settings.masteryThreshold}`;
                 } else { // Standard SM-2 Learn
                      const stepIndex = internalState.learningStepIndex || 0; // Use internal state's step index
                      const totalSteps = settings.initialLearningStepsMinutes?.length || 0;
                      return `Learn Step: ${stepIndex + 1}${totalSteps > 0 ? '/' + totalSteps : ''}`;
                 }
             } else if (card.srs_level === 0 && card.learning_state === 'relearning') {
                 const stepIndex = internalState.learningStepIndex || 0; // Use internal state's step index
                 const totalSteps = settings.relearningStepsMinutes?.length || 0;
                 return `Relearning: Step ${stepIndex + 1}${totalSteps > 0 ? '/' + totalSteps : ''}`;
             } else if (card.srs_level >= 1 && card.learning_state === null) {
                 // Standard Review
                 const interval = Math.round(card.interval_days || 0); // Round interval for display
                 let displayText = `Reviewing (Level ${card.srs_level}) â€¢ Interval: ${interval} day${interval === 1 ? '' : 's'}`;
                 // Add more specific due time if it's due today
                 const cardDueDate = card.next_review_due ? parseISO(card.next_review_due) : null;
                 if (cardDueDate && isValid(cardDueDate) && isToday(cardDueDate)) {
                     displayText = `Reviewing (Level ${card.srs_level}) â€¢ Due Today`;
                 } else if (cardDueDate && isValid(cardDueDate) && isPast(cardDueDate) && !isToday(cardDueDate)) {
                     displayText = `Reviewing (Level ${card.srs_level}) â€¢ Overdue`;
                 }
                 return displayText;
             } else if (card.srs_level === 0 && card.learning_state === null && studyMode === 'learn') {
                  // This is the initial 'new' state encountered in Learn mode if not filtered/mapped correctly in init
                  // Should transition to learning state in init
                  return 'New Card (Initializing...)'; // Should not remain in this state
             } else {
                 // Catch any unexpected state or cards not meant for this mode
                 return 'Studying... (Unknown State)';
             }
        }

        // Fallback status - should ideally be covered by isComplete/error/isLoading/waiting
        return null;

    }, [currentQueueItem, isLoading, error, isComplete, sessionQueue, totalCardsInSession, settings, isLoadingSettings, studyMode]);


    // Handle card flipping
    const onFlip = useCallback(() => {
      // Use currentQueueItemState (calculated by memo)
      if (!currentQueueItem || isProcessingAnswer || isComplete) return;
      setIsFlipped(prev => !prev);
    }, [currentQueueItem, isProcessingAnswer, isComplete]); // Depend on currentQueueItemState


    // Handle answering a card
    const answerCard = useCallback(async (grade: ReviewGrade) => {
      // Only allow answering if a card is currently displayed, not processing, and not complete
      // Use currentQueueItemState (calculated by memo)
      if (!currentQueueItem || isProcessingAnswer || isComplete || !settings) { // Depends on settings here directly
          console.log("[answerCard] Ignoring answer: processing, complete, no card, or settings missing.");
            return;
        }

      setIsProcessingAnswer(true); // Lock input
      setIsFlipped(true); // Auto-flip back to front/answer side before processing

      console.log(`[answerCard] Answering card ${currentQueueItem.card.id} (Mode: ${studyMode}, State: ${currentQueueItem.card.learning_state}/${currentQueueItem.card.srs_level}) with grade ${grade}`);

      // Use setTimeout to delay processing until flip animation completes (roughly)
      setTimeout(async () => {
          // Create copies of the current card and its internal state for updates
          // Use currentQueueItemState (calculated by memo)
          const updatedCard = { ...currentQueueItem.card };
          const currentInternalState = { ...currentQueueItem.internalState }; // Ensure all internalState fields are copied
          const nextQueue = [...sessionQueue]; // Copy the queue to modify

          // Find the index of the card we are CURRENTLY answering in the queue copy
          // Use currentQueueItemState (calculated by memo)
          const queueItemIndex = nextQueue.findIndex(item => item.card.id === updatedCard.id);
          if (queueItemIndex === -1) {
               console.error("[answerCard] Cannot find current card in queue copy. Aborting processing.", updatedCard.id);
               setIsProcessingAnswer(false);
               setIsFlipped(false);
               // Schedule next check in case other cards became due (based on potentially unchanged queue state)
               scheduleNextDueCheck(); // This depends on sessionQueue state, which hasn't changed yet
               return; // Should not happen in a functional app
          }

          // Remove the card from its *current* position in the queue copy.
          // It will be re-added later if it stays in the session queue.
          const [answeredQueueItem] = nextQueue.splice(queueItemIndex, 1); // Use splice to remove


          // --- Update Session Results & General Card Stats ---
          setSessionResults(prev => {
              const newResults = { ...prev, totalAnswered: prev.totalAnswered + 1 };
              // Update counts based on grade
              if (grade === 1) { newResults.incorrectCount++; } // Relapse count updated during state transition check below
              else if (grade === 2) newResults.hardCount++;
              else if (grade === 3) newResults.correctCount++;
              else if (grade === 4) newResults.easedCount++;
              // graduatedCount and relapsedCount are updated below during state transitions
              return newResults;
          });

          // Update general stats on the card object itself for saving
          updatedCard.attempt_count = (updatedCard.attempt_count || 0) + 1;
          if (grade >= 3) {
            updatedCard.correct_count = (updatedCard.correct_count || 0) + 1;
          } else if (grade === 1) {
            updatedCard.incorrect_count = (updatedCard.incorrect_count || 0) + 1;
          }

          // Update last reviewed timestamp and grade on the card object for saving
          updatedCard.last_reviewed_at = new Date().toISOString();
          updatedCard.last_review_grade = grade;

          // --- Determine NEXT State and Queue based on Current State and Algorithm ---
          let nextSrsPayload: Sm2UpdatePayload | null = null; // Payload calculated by SRS functions
          let shouldRemoveFromQueue = false; // Should this card be removed from the session queue permanently?
          let reAddToQueue = false; // Should this card be added back to the *end* or a specific position?
          let reinsertCard: SessionCard | null = null; // The item to potentially re-add to the queue
          let reinsertIndex: number | null = null; // Position for re-insertion if applicable

          // Use settingsRef.current for settings within the async function
          const currentSettings = settingsRef.current!; // settings is guaranteed here by the initial check


          // --- Handle the card based on its CURRENT state ---

          // Case 1: Card is currently in Initial Learning state (srs_level = 0, learning_state = 'learning')
          if (answeredQueueItem.card.srs_level === 0 && answeredQueueItem.card.learning_state === 'learning') {
               console.log(`[answerCard] Processing Initial Learning state (srs_level=0, learning_state=learning)`);

               // Update learning attempt counters on the card object (only increment in initial learning)
               if (grade === 1) updatedCard.failed_attempts_in_learn = (updatedCard.failed_attempts_in_learn || 0) + 1;
               if (grade === 2) updatedCard.hard_attempts_in_learn = (updatedCard.hard_attempts_in_learn || 0) + 1;
                // Update internal state counters (redundant but keeps internal state consistent)
               currentInternalState.failedAttemptsInLearn = updatedCard.failed_attempts_in_learn;
               currentInternalState.hardAttemptsInLearn = updatedCard.hard_attempts_in_learn;


               // --- Branch based on Learning Algorithm Setting ---
               if (currentSettings.enableDedicatedLearnMode) {
                    // --- Custom Learn Mode Logic (Streak) ---
                     console.log(`[answerCard] Using Dedicated Learn logic`);
                    let newStreak = currentInternalState.streak;

                    if (grade === 1) newStreak = 0; // Again: Reset streak
                    else if (grade === 2) newStreak = Math.max(0, newStreak); // Hard: Keep streak as is (do not increment, do not reset)
                    else if (grade === 3) newStreak++; // Good: Increment streak
                    else if (grade === 4) newStreak += 2; // Easy: Increment streak by 2

                    currentInternalState.streak = newStreak; // Update internal state streak

                    // Check for Graduation
                    if (newStreak >= currentSettings.masteryThreshold || grade === 4) { // Graduating (threshold or Easy)
                         console.log(`[answerCard] Card ${updatedCard.id} graduating from Dedicated Learn (Streak: ${newStreak}).`);
                        shouldRemoveFromQueue = true; // Remove from session queue permanently
                         setSessionResults(prev => ({ ...prev, graduatedCount: prev.graduatedCount + 1 })); // Count graduation

                         // Calculate initial SM-2 state upon graduation (srs_level=1)
                         nextSrsPayload = createGraduationPayload(
                             grade,
                             updatedCard.failed_attempts_in_learn, // Pass final counts from card object
                             updatedCard.hard_attempts_in_learn,
                             currentSettings
                         );
                         // Update card object fields for saving
                         updatedCard.srs_level = nextSrsPayload.srsLevel; // 1
                         updatedCard.learning_state = nextSrsPayload.learningState; // null
                         updatedCard.learning_step_index = nextSrsPayload.learningStepIndex; // null
                         updatedCard.easiness_factor = nextSrsPayload.easinessFactor;
                         updatedCard.interval_days = nextSrsPayload.intervalDays; // Integer days for first review
                         updatedCard.next_review_due = nextSrsPayload.nextReviewDue 
                            ? nextSrsPayload.nextReviewDue.toISOString() 
                            : new Date().toISOString();
                         // Reset learning counters in the card object upon graduation
                         updatedCard.failed_attempts_in_learn = 0;
                         updatedCard.hard_attempts_in_learn = 0;


                    } else { // Not Graduated - Re-queue in session
                         console.log(`[answerCard] Card ${updatedCard.id} continues in Dedicated Learn (Streak: ${newStreak}).`);
                        shouldRemoveFromQueue = false; // Stays in queue
                         reAddToQueue = true; // Mark to be re-added

                         // Determine re-queue position based on grade and setting
                         if (grade === 1 || grade === 2) { // Again or Hard: Re-insert after a gap
                              reinsertIndex = Math.min(queueItemIndex + currentSettings.customLearnRequeueGap, nextQueue.length);
                         } else { // Good or Easy (if Easy didn't graduate): Move to end of queue
                             reinsertIndex = nextQueue.length; // Add to the end
                         }

                         // internalState needs updating (streak, counters). dueTime remains now().
                         currentInternalState.dueTime = new Date(); // Keep it immediately due

                         // Create the item to re-add
                         reinsertCard = { card: updatedCard, internalState: currentInternalState };
                    }

               } else { // settings.enableDedicatedLearnMode === FALSE (Standard SM-2 Learn Steps)
                    console.log(`[answerCard] Using Standard SM-2 Learn logic`);
                    currentInternalState.learningStepIndex = answeredQueueItem.internalState.learningStepIndex ?? 0;

                    // Calculate next state using standard learning steps
                    const stepResult = calculateNextStandardLearnStep(currentInternalState.learningStepIndex, grade, currentSettings);

                    if (stepResult.nextStepIndex === 'graduated') { // Completed steps or Easy grade
                         console.log(`[answerCard] Card ${updatedCard.id} graduating from Standard Learn.`);
                        shouldRemoveFromQueue = true; // Remove from session queue permanently
                         setSessionResults(prev => ({ ...prev, graduatedCount: prev.graduatedCount + 1 })); // Count graduation

                         // Calculate initial SM-2 state upon graduation (srs_level=1)
                         nextSrsPayload = createGraduationPayload(
                             grade,
                             updatedCard.failed_attempts_in_learn, // Pass final counts
                             updatedCard.hard_attempts_in_learn,
                             currentSettings
                         );
                         // Update card object fields for saving
                         updatedCard.srs_level = nextSrsPayload.srsLevel;
                         updatedCard.learning_state = nextSrsPayload.learningState; // null
                         updatedCard.learning_step_index = nextSrsPayload.learningStepIndex; // null
                         updatedCard.easiness_factor = nextSrsPayload.easinessFactor;
                         updatedCard.interval_days = nextSrsPayload.intervalDays; // Integer days for first review
                         updatedCard.next_review_due = nextSrsPayload.nextReviewDue?.toISOString() || '';
                          // Reset learning counters in the card object upon graduation
                         updatedCard.failed_attempts_in_learn = 0;
                         updatedCard.hard_attempts_in_learn = 0;


                    } else { // Card continues in standard learning steps
                         console.log(`[answerCard] Card ${updatedCard.id} continues in Standard Learn step ${stepResult.nextStepIndex}.`);
                        shouldRemoveFromQueue = false; // Stays in queue
                         reAddToQueue = true; // Mark to be re-added (to be sorted by dueTime)
                         reinsertIndex = nextQueue.length; // Add to end initially, then sort

                         // Update internal state (next step index and due time)
                         currentInternalState.learningStepIndex = stepResult.nextStepIndex as number;
                         currentInternalState.dueTime = stepResult.nextDueTime; // Timed step due time

                         // Update card object fields for saving (state and next due time)
                         updatedCard.learning_state = 'learning'; // Explicitly set state
                         updatedCard.learning_step_index = currentInternalState.learningStepIndex;
                         updatedCard.next_review_due = currentInternalState.dueTime 
                             ? currentInternalState.dueTime.toISOString()
                             : new Date().toISOString();
                         // Failed/hard attempt counters are incremented above and saved on the card object

                         // Create the item to re-add
                         reinsertCard = { card: updatedCard, internalState: currentInternalState };
                    }
               }
          }

          // Case 2: Card is currently in Relearning state (srs_level = 0, learning_state = 'relearning')
          else if (answeredQueueItem.card.srs_level === 0 && answeredQueueItem.card.learning_state === 'relearning') {
               console.log(`[answerCard] Processing Relearning state (srs_level=0, learning_state=relearning)`);

               currentInternalState.learningStepIndex = answeredQueueItem.internalState.learningStepIndex ?? 0;

               // Calculate next state using relearning steps
               const stepResult = calculateNextRelearningStep(currentInternalState.learningStepIndex, grade, currentSettings);

               if (stepResult.nextStepIndex === 'graduatedFromRelearning') { // Completed relearning steps
                    console.log(`[answerCard] Card ${updatedCard.id} graduating from Relearning.`);
                    shouldRemoveFromQueue = true; // Remove from session queue (completed in this session)
                    setSessionResults(prev => ({ ...prev, graduatedCount: prev.graduatedCount + 1 })); // Count graduation from relearning

                    // Calculate payload for re-entering standard Review (srs_level=1)
                    nextSrsPayload = createRelearningGraduationPayload(
                        grade,
                        updatedCard.easiness_factor || currentSettings.defaultEasinessFactor, // Use card's current EF (penalized on initial lapse)
                        currentSettings
                    );
                     // Update card object fields for saving
                    updatedCard.srs_level = nextSrsPayload.srsLevel; // 1
                    updatedCard.learning_state = nextSrsPayload.learningState; // null
                    updatedCard.learning_step_index = nextSrsPayload.learningStepIndex; // null
                    updatedCard.easiness_factor = nextSrsPayload.easinessFactor; // Penalized EF
                    updatedCard.interval_days = nextSrsPayload.intervalDays; // Integer days for re-entry review
                    updatedCard.next_review_due = nextSrsPayload.nextReviewDue?.toISOString() || '';
                    // Failed/hard attempts counters from initial learning are NOT reset by relearning - keep their current value on updatedCard

               } else { // Card continues in relearning steps
                    console.log(`[answerCard] Card ${updatedCard.id} continues in Relearning step ${stepResult.nextStepIndex}.`);
                    shouldRemoveFromQueue = false; // Stays in queue
                    reAddToQueue = true; // Mark to be re-added (to be sorted by dueTime)
                    reinsertIndex = nextQueue.length; // Add to end initially, then sort

                    // Update internal state (next step index and due time)
                    currentInternalState.learningStepIndex = stepResult.nextStepIndex as number;
                    currentInternalState.dueTime = stepResult.nextDueTime; // Timed step due time

                    // Update card object fields for saving (state and next due time)
                    updatedCard.learning_state = 'relearning'; // Explicitly set state
                    updatedCard.learning_step_index = currentInternalState.learningStepIndex;
                    updatedCard.next_review_due = currentInternalState.dueTime 
                        ? currentInternalState.dueTime.toISOString()
                        : new Date().toISOString();
                    // EF and srs_level remain as they were when it entered relearning. Failed/hard attempts are not incremented here.

                    // Create the item to re-add
                    reinsertCard = { card: updatedCard, internalState: currentInternalState };
               }

          }

          // Case 3: Card is currently in Standard Review state (srs_level >= 1, learning_state === null)
          else if (answeredQueueItem.card.srs_level >= 1 && answeredQueueItem.card.learning_state === null) {
               console.log(`[answerCard] Processing Standard Review state (srs_level=${answeredQueueItem.card.srs_level})`);

               // Calculate next state using SM-2 algorithm (handles Review -> Review or Review -> Relearning)
               // Use card's current DB state fields for input to calculateSm2State
               const sm2Input: Sm2InputCardState = {
                    srsLevel: answeredQueueItem.card.srs_level,
                    easinessFactor: answeredQueueItem.card.easiness_factor || currentSettings.defaultEasinessFactor, // Use card's current EF
                    intervalDays: answeredQueueItem.card.interval_days || 0, // Use card's current interval (in days)
                    learningState: answeredQueueItem.card.learning_state as LearningState, // null
                    learningStepIndex: answeredQueueItem.card.learning_step_index, // null
                    nextReviewDue: answeredQueueItem.card.next_review_due // Pass existing due date
               };
               const sm2Result = calculateSm2State(sm2Input, grade, currentSettings);

               // Apply the calculated changes to the card object for saving
               updatedCard.srs_level = sm2Result.srsLevel;
               updatedCard.learning_state = sm2Result.learningState; // null or 'relearning'
               updatedCard.learning_step_index = sm2Result.learningStepIndex; // null or 0
               updatedCard.easiness_factor = sm2Result.easinessFactor;
               updatedCard.interval_days = sm2Result.intervalDays; // Integer or fractional days
               updatedCard.next_review_due = sm2Result.nextReviewDue 
                   ? sm2Result.nextReviewDue.toISOString() 
                   : new Date().toISOString();

               if (sm2Result.learningState === 'relearning') {
                    // Card lapsed from Review to Relearning
                    console.log(`[answerCard] Card ${updatedCard.id} lapsed to Relearning.`);
                    setSessionResults(prev => ({ ...prev, relapsedCount: prev.relapsedCount + 1 })); // Count relapse
                    shouldRemoveFromQueue = true; // Remove from *this* review session queue (it's due later/tomorrow)
                     // Failed/hard attempt counters from initial learning are NOT reset on lapse - keep their value on updatedCard

               } else { // Card successful in Review (Grade >= 2)
                    console.log(`[answerCard] Card ${updatedCard.id} successful in Review.`);
                    shouldRemoveFromQueue = true; // Remove from *this* review session queue
               }

          }
           // Case 4: Card is a truly new card (srs_level = 0, learning_state = null) - This case is handled during initialization
           // It transitions from 'new' to 'learning' in the map function during the initial useEffect
           // So, cards entering answerCard will always be in one of the first 3 cases (learning, relearning, review).


          // --- Manage the queue based on whether the card completed the session ---
          if (shouldRemoveFromQueue) {
               // Card was already spliced out above. nextQueue is correct.
               console.log(`[answerCard] Card ${updatedCard.id} removed from session queue permanently.`);
          } else if (reinsertIndex !== null) {
               // Card needs to be re-added to the queue copy at a specific position
                console.log(`[answerCard] Card ${updatedCard.id} re-adding to queue at index ${reinsertIndex}.`);
               nextQueue.splice(reinsertIndex!, 0, reinsertCard!); // Re-insert the updated item
          } else {
              // This case should ideally not happen if shouldRemoveFromQueue or reinsertIndex cover all possibilities
              // It means a card was spliced out but not re-added/completed.
              console.error("[answerCard] Logic error: Card neither removed nor marked for re-queueing. Re-adding to end as fallback.", updatedCard.id);
              // Create a new item to push
              nextQueue.push({ card: updatedCard, internalState: currentInternalState }); // Fallback - push the updated item
          }

          // --- Sort the queue ---
          // Sorting is always needed after answers because dueTimes change or items are re-inserted.
          nextQueue.sort((a, b) => a.internalState.dueTime.getTime() - b.internalState.dueTime.getTime());


          // --- Save Progress to database (debounced) ---
          // Pass the potentially updated card object and the grade
          // The debounced function constructs the payload for the action
          debouncedUpdateProgress({ cardToSave: updatedCard, grade: grade });


          // --- Update UI State (Delayed for animation) ---
          setTimeout(() => {
              const sessionIsComplete = nextQueue.length === 0;
              console.log(`[answerCard] Delayed state update. Queue length: ${nextQueue.length}, Complete: ${sessionIsComplete}`);

              setSessionQueue(nextQueue); // Update session queue state
              setIsComplete(sessionIsComplete); // Update completion status

              if (!sessionIsComplete) {
                   // Find the next card to show from the *updated and sorted* queue
                   const nextIndex = findNextCardIndex(nextQueue); // findNextCardIndex returns index or queue.length
                   console.log(`[answerCard] Next card index to display: ${nextIndex}`);

                   // Set currentCardIndex state. This will trigger the currentQueueItem memo.
                   // If nextIndex is queue.length, currentCard will become null (waiting state)
                   setCurrentCardIndex(nextIndex);

                   // scheduleNextDueCheck() will be triggered by the queue state update effect (dependency on sessionQueue)
             } else {
                   // Session is complete, index doesn't matter
                   setCurrentCardIndex(0);
                   console.log("[answerCard] Session is now complete.");
              }

              setIsFlipped(false); // Flip back
              setIsProcessingAnswer(false); // Unlock input

          }, PROCESSING_DELAY_MS); // Use the constant

      }, PROCESSING_DELAY_MS); // Use the constant for the outer timeout as well
    }, [
      currentQueueItem, // Depend on the current item being answered
      sessionQueue, // Depend on sessionQueue to create nextQueue copy and for sorting/finding next
      studyMode, // Depend on studyMode for logic branching
      isProcessingAnswer, isComplete, // Depend on state to prevent multiple calls
      settings, // Depend on settings for algorithm, thresholds, intervals, intervals/penalties for calc fns
      debouncedUpdateProgress, // Depend on the memoized function
      findNextCardIndex, // Depend on the memoized function
      scheduleNextDueCheck, // Depend on the memoized function
      // Dependencies from calculate/create payload functions are implicitly via 'settings'
    ]);

    // Helper to update card status display (memoized)
    // This memo *returns* the string, it does NOT set state.
     const cardStatusDisplayMemo = useMemo(() => {
       // Status display logic relies on currentQueueItem and settings
       if (isLoading) return 'Loading session...';
       if (error) return `Error: ${error}`;
       if (isComplete) return totalCardsInSession > 0 ? 'Session Complete!' : 'No cards to study.';
       if (!settings || isLoadingSettings) return 'Loading settings...'; // Wait for settings to display status

       // If queue is not empty, but currentQueueItem is null (waiting for timed step)
       if (!currentQueueItem && sessionQueue.length > 0) {
           const now = new Date();
           // Find the soonest future due time from the *entire* queue (which is sorted)
           // The first item in the sorted queue that is > now() is the soonest future one
           let soonestFutureDueItem = sessionQueue.find(item => item.internalState.dueTime > now);

           if (soonestFutureDueItem) {
                const diffMs = soonestFutureDueItem.internalState.dueTime.getTime() - now.getTime();
                const diffSeconds = Math.ceil(diffMs / 1000);
                if (diffSeconds <= 1) return `Next card due in ~1s`; // Round up to 1 sec if < 1 sec
                if (diffSeconds < 60) return `Next card due in ${diffSeconds}s`;
                const diffMinutes = Math.ceil(diffMs / (1000 * 60));
                if (diffMinutes <= 1) return `Next card due in ~1m`; // Round up to 1 min if < 1 min
                if (diffMinutes < 60) return `Next card due in ${diffMinutes}m`;
                const diffHours = Math.ceil(diffMs / (1000 * 60 * 60));
                if (diffHours <= 24) return `Next card due in ${diffHours}h`;
                // Format date like "MMM dd"
                return `Next card due on ${soonestFutureDueItem.internalState.dueTime.toLocaleDateString('en-US', { month: 'short', day: 'numeric' })}`;
           } else {
                // This case means queue is not empty, but no card is due now or in future (shouldn't happen if logic is right)
                return 'Waiting... (No future due times)';
           }
       }

       // If a currentQueueItem exists, display its specific status
       if (currentQueueItem) {
            const card = currentQueueItem.card;
            const internalState = currentQueueItem.internalState;

            if (card.srs_level === 0 && card.learning_state === 'learning') {
                if (settings.studyAlgorithm === 'dedicated-learn') {
                     return `Streak: ${internalState.streak}/${settings.masteryThreshold}`;
                } else { // Standard SM-2 Learn
                     const stepIndex = internalState.learningStepIndex || 0; // Use internal state's step index
                     const totalSteps = settings.initialLearningStepsMinutes?.length || 0;
                     return `Learn Step: ${stepIndex + 1}${totalSteps > 0 ? '/' + totalSteps : ''}`;
                }
            } else if (card.srs_level === 0 && card.learning_state === 'relearning') {
                const stepIndex = internalState.learningStepIndex || 0; // Use internal state's step index
                const totalSteps = settings.relearningStepsMinutes?.length || 0;
                return `Relearning: Step ${stepIndex + 1}${totalSteps > 0 ? '/' + totalSteps : ''}`;
            } else if (card.srs_level >= 1 && card.learning_state === null) {
                // Standard Review
                const interval = Math.round(card.interval_days || 0); // Round interval for display
                let displayText = `Reviewing (Level ${card.srs_level})`; // Base display
                if (interval > 0) displayText += ` â€¢ Interval: ${interval} day${interval === 1 ? '' : 's'}`; // Add interval if > 0

                // Add more specific due time if it's due today or past
                 const cardDueDate = card.next_review_due ? parseISO(card.next_review_due) : null;
                 if (cardDueDate && isValid(cardDueDate) && isToday(cardDueDate)) {
                     displayText = `Reviewing (Level ${card.srs_level}) â€¢ Due Today`;
                 } else if (cardDueDate && isValid(cardDueDate) && isPast(cardDueDate) && !isToday(cardDueDate)) {
                     displayText = `Reviewing (Level ${card.srs_level}) â€¢ Overdue`;
                 }
                 return displayText;
            } else if (card.srs_level === 0 && card.learning_state === null && studyMode === 'learn') {
                 // This is the initial 'new' state encountered in Learn mode if not filtered/mapped correctly in init
                 // Should transition to learning state in init
                 return 'New Card (Initializing...)'; // Should not remain in this state
            } else {
                 // Catch any unexpected state or cards not meant for this mode
                 return 'Studying... (Unknown State)';
            }
       }

       // Fallback status - should ideally be covered by isComplete/error/isLoading/waiting
            return null;


    }, [currentQueueItem, isLoading, error, isComplete, sessionQueue, totalCardsInSession, settings, isLoadingSettings, studyMode]); // Depends on currentQueueItem, global state, settings

    // Removed the useEffect that watched currentQueueItem for status update, the memo handles it

    // Clean up timer on component unmount
    useEffect(() => {
      return () => {
        if (dueCheckTimerRef.current) {
          clearTimeout(dueCheckTimerRef.current);
          dueCheckTimerRef.current = null;
        }
      };
    }, []); // Effect runs only on mount and unmount

    // Map our session results to the expected format for the return type (memoized)
    const mappedSessionResults = useMemo(() => ({
      totalAnswered: sessionResults.totalAnswered,
      correctCount: sessionResults.correctCount,
      incorrectCount: sessionResults.incorrectCount,
      // graduatedCount and relapsedCount are not exposed in the return type
      // graduatedCount: sessionResults.graduatedCount,
      // relapsedCount: sessionResults.relapsedCount,
    }), [sessionResults]);


    return {
      // Map to the expected return interface
      currentCard: currentCard, // Use the extracted StudyCard or null
      isInitializing: isLoading, // Renamed isLoading to isInitializing for consistency with return type
        error,
      studyMode: studyMode, // Return the study mode
        isComplete,
      totalCardsInSession: totalCardsInSession, // Use the calculated count
      currentCardNumber: currentCardNumber, // Use the calculated card number
      initialSelectionCount: initialSelectionCount, // Total cards from query
      isProcessingAnswer,
      isFlipped,
      onFlip, // Use the memoized flip handler
      sessionResults: mappedSessionResults, // Use the memoized results
      answerCard, // Use the memoized answer handler
      currentCardStatusDisplay: cardStatusDisplayMemo, // Use the memoized value directly instead of the state
      // debugQueue: sessionQueue, // Optional debug export
    };
} 
=== useCardTags.ts ===
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getCardTags } from '@/lib/actions/tagActions';
import type { Tables } from '@/types/database';

interface UseCardTagsReturn {
  cardTags: Tables<'tags'>[];
  isLoading: boolean;
  error: string | null;
  refetchCardTags: () => Promise<void>;
}

/**
 * Custom hook for managing card-tag relationships.
 * 
 * This hook provides:
 * - Tag assignment and removal for cards
 * - Card-tag relationship state management
 * - Error handling for tag operations
 * - Loading state management
 * 
 * @param {string} cardId - ID of the card to manage tags for
 * @returns {Object} Card-tag management functions and state
 * @returns {Tag[]} returns.cardTags - Array of tags assigned to the card
 * @returns {boolean} returns.loading - Whether tag operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {() => Promise<void>} returns.refreshCardTags - Function to refresh the card's tags
 */
export function useCardTags(cardId: string): UseCardTagsReturn {
  const [cardTags, setCardTags] = useState<Tables<'tags'>[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Function to fetch card tags that can be used in both useEffect and refetch
  const fetchCardTags = useCallback(async () => {
    // Only fetch if cardId is valid
    if (!cardId) {
      console.log(`[useCardTags] Skipping fetch for invalid cardId: ${cardId}`);
      setCardTags([]);
      setIsLoading(false);
      setError(null);
      return;
    }

    console.log(`[useCardTags] Fetching tags for card: ${cardId}`);
    setIsLoading(true);
    setError(null);
    try {
      const result = await getCardTags(cardId);
      if (result.error) {
        setError(result.error);
        setCardTags([]); // Clear tags on error
      } else {
        setCardTags(result.data || []);
      }
    } catch (err) {
      console.error(`Unexpected error fetching tags for card ${cardId}:`, err);
      setError('An unexpected error occurred while fetching card tags.');
      setCardTags([]);
    } finally {
      setIsLoading(false);
    }
  }, [cardId]);

  // Fetch on mount or when cardId changes
  useEffect(() => {
    console.log(`[useCardTags] useEffect triggered for cardId: ${cardId}`);
    fetchCardTags();
  }, [fetchCardTags, cardId]);

  return { cardTags, isLoading, error, refetchCardTags: fetchCardTags };
} 
