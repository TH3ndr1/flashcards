# Project Codebase Overview

.
./__tests__
./__tests__/deckService.test.tsx
./__tests__/settingsService.test.ts
./__tests__/studyQueryActions.test.ts
./__tests__/use-decks.test.tsx
./__tests__/use-supabase.test.tsx
./app
./app/api
./app/api/cards
./app/api/cards/route.ts
./app/api/decks
./app/api/decks/[deckId]
./app/api/decks/[deckId]/name
./app/api/decks/[deckId]/name/route.ts
./app/api/decks/route.ts
./app/api/extract-pdf
./app/api/extract-pdf/config.ts
./app/api/extract-pdf/fileUtils.ts
./app/api/extract-pdf/flashcardGeneratorService.ts
./app/api/extract-pdf/gcpClients.ts
./app/api/extract-pdf/route.ts
./app/api/extract-pdf/textExtractorService.ts
./app/api/extract-pdf/types.ts
./app/api/process-ai-step2
./app/api/process-ai-step2/route.ts
./app/api/tts
./app/api/tts/route.ts
./app/auth
./app/auth/callback
./app/auth/callback/route.ts
./app/decks
./app/decks/create-choice
./app/decks/create-choice/page.tsx
./app/decks/new
./app/decks/new/page.tsx
./app/edit
./app/edit/[deckId]
./app/edit/[deckId]/CardViewTabContent.tsx
./app/edit/[deckId]/DeckDangerZone.tsx
./app/edit/[deckId]/DeckMetadataEditor.tsx
./app/edit/[deckId]/TableViewTabContent.tsx
./app/edit/[deckId]/page.tsx
./app/edit/[deckId]/useEditDeck.ts
./app/globals.css
./app/layout-script.tsx
./app/layout.tsx
./app/login
./app/login/page.tsx
./app/page.tsx
./app/prepare
./app/prepare/ai-generate
./app/prepare/ai-generate/AiGenerateInputCard.tsx
./app/prepare/ai-generate/AiGenerateResultsCard.tsx
./app/prepare/ai-generate/AiGenerateSaveDeckCard.tsx
./app/prepare/ai-generate/page.tsx
./app/prepare/ai-generate/useAiGenerate.ts
./app/profile
./app/profile/page.tsx
./app/settings
./app/settings/page.tsx
./app/signup
./app/signup/page.tsx
./app/study
./app/study/select
./app/study/select/page.tsx
./app/study/session
./app/study/session/page.tsx
./app/study/sets
./app/study/sets/[studySetId]
./app/study/sets/[studySetId]/edit
./app/study/sets/[studySetId]/edit/page.tsx
./app/study/sets/new
./app/study/sets/new/page.tsx
./app/study/sets/page.tsx
./app/sw.js
./app/tags
./app/tags/page.tsx
./components
./components/ClientProviders.tsx
./components/DeckListClient.tsx
./components/camera-capture.tsx
./components/card-editor.tsx
./components/create-deck-dialog.tsx
./components/deck
./components/deck/DeckProgressBar.tsx
./components/deck/EditableCardTable.tsx
./components/deck-header.tsx
./components/deck-list.tsx
./components/deck-tag-editor.tsx
./components/file-upload.tsx
./components/layout
./components/layout/Header.tsx
./components/layout/ResponsiveLayout.tsx
./components/layout/Sidebar.tsx
./components/media-capture-tabs.tsx
./components/settings-button.tsx
./components/study
./components/study/StudyModeButtons.tsx
./components/study/StudySelectClient.tsx
./components/study/StudySetBuilder.tsx
./components/study/StudySetListClient.tsx
./components/study/StudySetSelector.tsx
./components/study-completion-screen.tsx
./components/study-flashcard-view.tsx
./components/study-progress.tsx
./components/study-session.tsx
./components/table-editor.tsx
./components/tags
./components/tags/TagManager.tsx
./components/tags/TagManagerClient.tsx
./components/tags-button.tsx
./components/theme-provider.tsx
./components/tts-toggle-button.tsx
./components/ui
./components/ui/accordion.tsx
./components/ui/alert-dialog.tsx
./components/ui/alert.tsx
./components/ui/aspect-ratio.tsx
./components/ui/avatar.tsx
./components/ui/badge.tsx
./components/ui/breadcrumb.tsx
./components/ui/button.tsx
./components/ui/calendar.tsx
./components/ui/card.tsx
./components/ui/carousel.tsx
./components/ui/chart.tsx
./components/ui/checkbox.tsx
./components/ui/collapsible.tsx
./components/ui/command.tsx
./components/ui/context-menu.tsx
./components/ui/dialog.tsx
./components/ui/drawer.tsx
./components/ui/dropdown-menu.tsx
./components/ui/form.tsx
./components/ui/hover-card.tsx
./components/ui/input-otp.tsx
./components/ui/input.tsx
./components/ui/label.tsx
./components/ui/menubar.tsx
./components/ui/navigation-menu.tsx
./components/ui/page-heading.tsx
./components/ui/pagination.tsx
./components/ui/popover.tsx
./components/ui/progress.tsx
./components/ui/radio-group.tsx
./components/ui/resizable.tsx
./components/ui/scroll-area.tsx
./components/ui/select.tsx
./components/ui/separator.tsx
./components/ui/sheet.tsx
./components/ui/sidebar.tsx
./components/ui/skeleton.tsx
./components/ui/slider.tsx
./components/ui/sonner.tsx
./components/ui/switch.tsx
./components/ui/table.tsx
./components/ui/tabs.tsx
./components/ui/textarea.tsx
./components/ui/toggle-group.tsx
./components/ui/toggle.tsx
./components/ui/tooltip.tsx
./components/user-nav.tsx
./components.json
./docker-compose.yml
./docs
./docs/setup
./docs/setup/setup-fonts.sh
./eslint.config.js
./git_push.sh
./hooks
./hooks/use-auth.tsx
./hooks/use-decks.tsx
./hooks/use-mobile.tsx
./hooks/use-supabase.tsx
./hooks/use-tts.ts
./hooks/useCardTags.ts
./hooks/useDecks.ts
./hooks/useStudySession.ts
./hooks/useStudySetForm.ts
./hooks/useStudySets.ts
./hooks/useTags.ts
./instrumentation.ts
./jest.config.js
./jest.setup.js
./lib
./lib/actions
./lib/actions/cardActions.ts
./lib/actions/deckActions.ts
./lib/actions/progressActions.ts
./lib/actions/settingsActions.ts
./lib/actions/storageActions.ts
./lib/actions/studyQueryActions.ts
./lib/actions/studySetActions.ts
./lib/actions/tagActions.ts
./lib/actions/ttsActions.ts
./lib/actions/types.ts
./lib/fonts.ts
./lib/localStorageUtils.ts
./lib/logger.ts
./lib/palettes.ts
./lib/schema
./lib/schema/card.schema.ts
./lib/schema/deckSchemas.ts
./lib/schema/study-query.schema.ts
./lib/schema/study-set.schema.ts
./lib/srs.ts
./lib/study
./lib/study/card-state-handlers.ts
./lib/study/session-queue-manager.ts
./lib/study-utils.ts
./lib/supabase
./lib/supabase/server.ts
./lib/utils.ts
./middleware.ts
./next-env.d.ts
./next.config.mjs
./package.json
./postcss.config.mjs
./providers
./providers/settings-provider.tsx
./schema.sql
./scripts
./scripts/export_codebase.sh
./store
./store/studySessionStore.ts
./supabase
./supabase/config.toml
./supabase/migrations
./supabase/migrations/20250426200000_add_ai_uploads_storage_policies.sql
./supabase/migrations/20250427092434_remote_schema.sql
./supabase/migrations/20250427092656_remote_schema.sql
./supabase/migrations/20250427171814_create_cards_with_difficulty_view.sql
./supabase/migrations/20250428000000_create_deck_srs_counts_function.sql
./supabase/migrations/20250428010000_add_show_deck_progress_setting.sql
./supabase/migrations/20250428020000_add_theme_preference_setting.sql
./supabase/migrations/20250430214258_update_resolve_study_query.sql
./supabase/migrations/20250501153215_update_resolve_study_query_difficult_logic_v3.sql.sql
./supabase/migrations/20250501154500_add_missing_study_fields.sql
./supabase/migrations/20250510000000_optimize_deck_listing_performance.sql
./supabase/migrations/20250510010000_optimize_rls_performance.sql
./supabase/migrations/20250510020000_add_complete_srs_counts_function.sql
./supabase/migrations/20250518095041_update_cards_with_srs_stage_v2.sql
./supabase/migrations/20250518100551_deprecate_get_deck_list_with_srs_counts_function.sql.sql
./supabase/migrations/20250518102853_refine_resolve_study_query_srs_filters_v8.sql.sql
./tailwind.config.ts
./test-gcp-apis.ts
./tsconfig.jest.json
./tsconfig.json
./types
./types/database.ts
./types/pdf-parse.d.ts
./types/study.ts
./vercel.json

52 directories, 202 files


## Directory: .

### File: .cursorindexingignore

```
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**

```

### File: .env.example

```
# Supabase Configuration
# Get these values from your Supabase project settings
NEXT_PUBLIC_SUPABASE_URL=
NEXT_PUBLIC_SUPABASE_ANON_KEY=

# Google Cloud Text-to-Speech API credentials
# Get these from your Google Cloud Console
GCP_PROJECT_ID=
GCP_SERVICE_ACCOUNT_EMAIL=
GCP_PRIVATE_KEY= 
```

### File: .gitignore

```
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage
/__tests__

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# IDE
.idea/
.vscode/
.spectory/
/.spectory

# OS generated files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

.cursorindexingignore

# Ignore SpecStory directory and its contents
.specstory/
# SpecStory explanation file
.specstory/.what-is-this.md

```

### File: components.json

```
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

### File: docker-compose.yml

```
version: '3'
services:
  tts:
    image: coqui/tts-cpu:latest
    ports:
      - "5002:5002"
    environment:
      - MODEL_NAME=tts_models/multilingual/multi-dataset/your_tts
      - USE_CUDA=false
    restart: unless-stopped 
```

### File: eslint.config.js

```
import nextPlugin from '@next/eslint-plugin-next';
import tsPlugin from '@typescript-eslint/eslint-plugin';
import tsParser from '@typescript-eslint/parser';
import reactHooksPlugin from 'eslint-plugin-react-hooks';
import globals from 'globals';

export default [
  // Base TypeScript configuration
  {
    files: ['**/*.{ts,tsx}'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 'latest',
        sourceType: 'module',
        ecmaFeatures: {
          jsx: true,
        },
      },
      globals: {
        ...globals.browser,
        ...globals.node,
        ...globals.es2021,
      },
    },
    plugins: {
      '@typescript-eslint': tsPlugin,
      '@next/next': nextPlugin,
      'react-hooks': reactHooksPlugin,
    },
    rules: {
      // TypeScript rules
      '@typescript-eslint/no-unused-vars': ['warn', {
        argsIgnorePattern: '^_',
        varsIgnorePattern: '^_',
      }],
      '@typescript-eslint/no-explicit-any': 'warn',
      
      // Next.js rules
      '@next/next/no-html-link-for-pages': 'warn',
      '@next/next/no-img-element': 'warn',
      
      // React Hooks rules
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
      
      // Common rules
      'no-console': ['warn', { allow: ['warn', 'error', 'info'] }],
    },
  },
  
  // JavaScript specific rules
  {
    files: ['**/*.{js,jsx,mjs,cjs}'],
    languageOptions: {
      ecmaVersion: 'latest',
      sourceType: 'module',
      globals: {
        ...globals.browser,
        ...globals.node,
        ...globals.es2021,
      },
    },
    plugins: {
      '@next/next': nextPlugin,
      'react-hooks': reactHooksPlugin,
    },
    rules: {
      // JavaScript specific rules here
      '@next/next/no-html-link-for-pages': 'warn',
      '@next/next/no-img-element': 'warn',
      
      // React Hooks rules
      'react-hooks/rules-of-hooks': 'error',
      'react-hooks/exhaustive-deps': 'warn',
    },
  },
  
  // Ignore files
  {
    ignores: [
      'node_modules/**',
      '.next/**',
      'dist/**',
      'build/**',
      'public/**',
      '*.config.js',
      '*.config.mjs',
    ],
  },
]; 
```

### File: git_push.sh

```
#!/bin/bash

# Check if a commit message was provided
if [ "$#" -ne 1 ]; then
  echo "Usage: $0 <commit message>"
  exit 1
fi

# Ensure Git user is configured
if ! git config user.name > /dev/null || ! git config user.email > /dev/null; then
  echo "Git user not configured. Please run:"
  echo "  git config --global user.name \"Your Name\""
  echo "  git config --global user.email \"you@example.com\""
  exit 1
fi

# Ensure GitHub CLI is authenticated
if ! gh auth status &> /dev/null; then
  echo "GitHub CLI is not authenticated. Attempting to authenticate..."
  gh auth login
  if [ $? -ne 0 ]; then
    echo "Authentication failed."
    exit 1
  fi
fi

# Stage all changes
git add .

# Commit with the provided message
git commit -m "$1"

# Push changes to the refactor branch on the origin remote
git push origin refactor
```

### File: instrumentation.ts

```
export async function register() {
  if (process.env.NEXT_RUNTIME === 'nodejs') {
    // Simply import the module to let it register itself
    await import('@vercel/speed-insights');
  }
} 
```

### File: jest.config.js

```
// jest.config.js
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'jest-environment-jsdom',
  transform: {
    '^.+\\.(ts|tsx)$': ['ts-jest', { tsconfig: '<rootDir>/tsconfig.jest.json' }],
  },
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/$1',
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js'],
};
```

### File: jest.setup.js

```
// jest.setup.js
const ReactDOM = require('react-dom/client');
require('@testing-library/jest-dom');

// Polyfill for crypto.randomUUID if it's not available
if (typeof crypto === 'undefined') {
  global.crypto = require('crypto');
}
if (!crypto.randomUUID) {
  const { v4: uuidv4 } = require('uuid');
  crypto.randomUUID = uuidv4;
}
const originalConsoleError = console.error;
console.error = (...args) => {
  const [firstArg] = args;
  if (
    typeof firstArg === 'string' &&
    firstArg.includes('The current testing environment is not configured to support act')
  ) {
    return;
  }
  originalConsoleError(...args);
};
```

### File: middleware.ts

```
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { NextResponse, type NextRequest } from 'next/server'
import { appLogger, statusLogger } from '@/lib/logger'

/**
 * Decodes a Supabase cookie value if it's in base64 format
 */
function decodeSupabaseCookie(cookieValue?: string): string | undefined {
  if (!cookieValue) return undefined;
  
  // Handle base64 encoded cookies from Supabase
  if (cookieValue.startsWith('base64-')) {
    try {
      // Remove 'base64-' prefix and decode
      const base64Value = cookieValue.substring(7);
      return Buffer.from(base64Value, 'base64').toString();
    } catch (error) {
      appLogger.error('Error decoding base64 cookie:', error);
      return cookieValue; // Return original as fallback
    }
  }
  
  return cookieValue;
}

/**
 * Supabase authentication middleware for Next.js.
 * 
 * This middleware is responsible for:
 * 1. Refreshing the user's session cookie if it has expired.
 * 2. Making the session available for server components and routes.
 * 
 * Using the standard @supabase/ssr approach.
 */
export async function middleware(request: NextRequest) {
  let response = NextResponse.next()
  
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  
  if (!supabaseUrl || !supabaseAnonKey) {
    appLogger.error('Missing Supabase environment variables in middleware')
    return response
  }
  
  // Create a Supabase client configured to use cookies
  const supabase = createServerClient(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get(name: string) {
        return request.cookies.get(name)?.value
      },
      set(name: string, value: string, options: CookieOptions) {
        // Update cookies on the request and response
        request.cookies.set({
          name,
          value,
          ...options,
        })
        response = NextResponse.next({
          request: {
            headers: request.headers,
          },
        })
        response.cookies.set({
          name,
          value,
          ...options,
        })
      },
      remove(name: string, options: CookieOptions) {
        // Remove cookies from request and response
        request.cookies.set({
          name,
          value: '',
          ...options,
        })
        response = NextResponse.next({
          request: {
            headers: request.headers,
          },
        })
        response.cookies.set({
          name,
          value: '',
          ...options,
        })
      },
    },
  })
  
  // Refresh session if expired
  await supabase.auth.getSession()
  
  return response
}

// Configure the middleware matcher to avoid running on static assets
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - public folder files
     */
    '/((?!_next/static|_next/image|favicon.ico|public|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
  ],
} 
```

### File: next-env.d.ts

```
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/app/api-reference/config/typescript for more information.

```

### File: next.config.mjs

```
let userConfig = undefined
try {
  userConfig = await import('./v0-user-next.config')
} catch (e) {
  // ignore error
}

/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  images: {
    unoptimized: true,
  },
  experimental: {
    webpackBuildWorker: true,
    parallelServerBuildTraces: true,
    parallelServerCompiles: true,
  },
  serverExternalPackages: ['pino', 'thread-stream'],
}

mergeConfig(nextConfig, userConfig)

function mergeConfig(nextConfig, userConfig) {
  if (!userConfig) {
    return
  }

  for (const key in userConfig) {
    if (
      typeof nextConfig[key] === 'object' &&
      !Array.isArray(nextConfig[key])
    ) {
      nextConfig[key] = {
        ...nextConfig[key],
        ...userConfig[key],
      }
    } else {
      nextConfig[key] = userConfig[key]
    }
  }
}

export default nextConfig

```

### File: package.json

```
{
  "name": "my-v0-project",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "test": "jest --verbose",
    "lint": "next lint",
    "export:codebase": "bash scripts/export_codebase.sh"
  },
  "dependencies": {
    "@google-cloud/documentai": "^9.1.0",
    "@google-cloud/storage": "^7.7.0",
    "@google-cloud/text-to-speech": "^6.0.1",
    "@google-cloud/vertexai": "^1.9.3",
    "@google-cloud/vision": "^5.1.0",
    "@hookform/resolvers": "^3.9.1",
    "@radix-ui/react-accordion": "^1.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.4",
    "@radix-ui/react-aspect-ratio": "^1.1.1",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-collapsible": "^1.1.2",
    "@radix-ui/react-context-menu": "^2.2.4",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-hover-card": "^1.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-menubar": "^1.1.4",
    "@radix-ui/react-navigation-menu": "^1.2.3",
    "@radix-ui/react-popover": "^1.1.4",
    "@radix-ui/react-progress": "^1.1.1",
    "@radix-ui/react-radio-group": "^1.2.2",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.2",
    "@radix-ui/react-toast": "^1.2.4",
    "@radix-ui/react-toggle": "^1.1.1",
    "@radix-ui/react-toggle-group": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.6",
    "@supabase/auth-helpers-nextjs": "^0.10.0",
    "@supabase/ssr": "^0.6.1",
    "@supabase/supabase-js": "latest",
    "@types/loglevel": "^1.6.3",
    "@types/uuid": "^10.0.0",
    "@vercel/otel": "^1.12.0",
    "@vercel/speed-insights": "^1.2.0",
    "autoprefixer": "^10.4.20",
    "canvas": "^3.1.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "1.0.4",
    "date-fns": "4.1.0",
    "embla-carousel-react": "8.5.1",
    "input-otp": "1.4.1",
    "lodash": "^4.17.21",
    "loglevel": "^1.9.2",
    "lucide-react": "^0.454.0",
    "next": "15.2.4",
    "next-themes": "^0.4.4",
    "pdf-lib": "^1.17.1",
    "pdfjs-dist": "^5.1.91",
    "pino": "^9.7.0",
    "react": "^19.1.0",
    "react-day-picker": "8.10.1",
    "react-dom": "^19.1.0",
    "react-hook-form": "^7.54.1",
    "react-resizable-panels": "^2.1.7",
    "recharts": "2.15.0",
    "sonner": "^1.7.4",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "uuid": "^11.1.0",
    "vaul": "^0.9.9",
    "zod": "^3.24.1",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@next/eslint-plugin-next": "^15.3.2",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react-hooks": "^8.0.1",
    "@types/jest": "^29.5.14",
    "@types/lodash": "^4.17.16",
    "@types/node": "^22",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "@typescript-eslint/eslint-plugin": "^8.32.1",
    "@typescript-eslint/parser": "^8.32.1",
    "dotenv": "^16.5.0",
    "eslint": "^9",
    "eslint-config-next": "15.3.2",
    "eslint-plugin-react-hooks": "^5.2.0",
    "globals": "^16.1.0",
    "jest": "^29.7.0",
    "jest-environment-jsdom": "^29.7.0",
    "postcss": "^8",
    "tailwindcss": "^3.4.17",
    "ts-jest": "^29.3.0",
    "ts-node": "^10.9.2",
    "tsx": "^4.19.3",
    "typescript": "^5"
  },
  "pnpm": {
    "onlyBuiltDependencies": [
      "canvas",
      "sharp"
    ]
  }
}
```

### File: postcss.config.mjs

```
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

```

### File: schema.sql

```


SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;


CREATE EXTENSION IF NOT EXISTS "pgsodium";






COMMENT ON SCHEMA "public" IS 'standard public schema';



CREATE EXTENSION IF NOT EXISTS "pg_graphql" WITH SCHEMA "graphql";






CREATE EXTENSION IF NOT EXISTS "pg_stat_statements" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgcrypto" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "pgjwt" WITH SCHEMA "extensions";






CREATE EXTENSION IF NOT EXISTS "supabase_vault" WITH SCHEMA "vault";






CREATE EXTENSION IF NOT EXISTS "uuid-ossp" WITH SCHEMA "extensions";






CREATE TYPE "public"."font_option" AS ENUM (
    'default',
    'opendyslexic',
    'atkinson'
);


ALTER TYPE "public"."font_option" OWNER TO "postgres";

SET default_tablespace = '';

SET default_table_access_method = "heap";


CREATE TABLE IF NOT EXISTS "public"."cards" (
    "id" "uuid" NOT NULL,
    "deck_id" "uuid" NOT NULL,
    "question" "text" NOT NULL,
    "answer" "text" NOT NULL,
    "correct_count" integer DEFAULT 0,
    "incorrect_count" integer DEFAULT 0,
    "last_studied" timestamp with time zone,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "attempt_count" integer DEFAULT 0,
    "difficulty_score" double precision DEFAULT 0
);


ALTER TABLE "public"."cards" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."decks" (
    "id" "uuid" NOT NULL,
    "user_id" "uuid" NOT NULL,
    "name" "text" NOT NULL,
    "language" "text" NOT NULL,
    "progress" "jsonb" DEFAULT '{"streak": 0, "correct": 0, "incorrect": 0, "lastStudied": null}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "is_bilingual" boolean DEFAULT false NOT NULL,
    "primary_language" "text" DEFAULT 'en'::"text" NOT NULL,
    "secondary_language" "text" DEFAULT 'en'::"text" NOT NULL
);


ALTER TABLE "public"."decks" OWNER TO "postgres";


CREATE TABLE IF NOT EXISTS "public"."settings" (
    "id" "uuid" DEFAULT "gen_random_uuid"() NOT NULL,
    "user_id" "uuid" NOT NULL,
    "app_language" "text" DEFAULT 'english'::"text" NOT NULL,
    "preferred_voices" "jsonb" DEFAULT '{"dutch": null, "french": null, "english": null}'::"jsonb" NOT NULL,
    "created_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "updated_at" timestamp with time zone DEFAULT "timezone"('utc'::"text", "now"()),
    "language_dialects" "jsonb" DEFAULT "jsonb_build_object"('en', 'en-GB', 'nl', 'nl-NL', 'fr', 'fr-FR', 'de', 'de-DE', 'es', 'es-ES', 'it', 'it-IT'),
    "tts_enabled" boolean DEFAULT true,
    "show_difficulty" boolean DEFAULT true,
    "mastery_threshold" integer DEFAULT 3,
    "card_font" character varying(20) DEFAULT 'default'::character varying
);


ALTER TABLE "public"."settings" OWNER TO "postgres";


COMMENT ON COLUMN "public"."settings"."tts_enabled" IS 'Whether text-to-speech is enabled for the user';



ALTER TABLE ONLY "public"."cards"
    ADD CONSTRAINT "cards_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."decks"
    ADD CONSTRAINT "decks_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."settings"
    ADD CONSTRAINT "settings_pkey" PRIMARY KEY ("id");



ALTER TABLE ONLY "public"."settings"
    ADD CONSTRAINT "unique_user_settings" UNIQUE ("user_id");



CREATE INDEX "idx_cards_deck_id" ON "public"."cards" USING "btree" ("deck_id");



CREATE INDEX "idx_decks_user_id" ON "public"."decks" USING "btree" ("user_id");



CREATE INDEX "idx_settings_user_id" ON "public"."settings" USING "btree" ("user_id");



ALTER TABLE ONLY "public"."cards"
    ADD CONSTRAINT "fk_deck" FOREIGN KEY ("deck_id") REFERENCES "public"."decks"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."decks"
    ADD CONSTRAINT "fk_user" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



ALTER TABLE ONLY "public"."settings"
    ADD CONSTRAINT "settings_user_id_fkey" FOREIGN KEY ("user_id") REFERENCES "auth"."users"("id") ON DELETE CASCADE;



CREATE POLICY "Users can only access cards in their decks" ON "public"."cards" USING ((EXISTS ( SELECT 1
   FROM "public"."decks"
  WHERE (("decks"."id" = "cards"."deck_id") AND ("decks"."user_id" = "auth"."uid"())))));



CREATE POLICY "Users can only access their own decks" ON "public"."decks" USING (("auth"."uid"() = "user_id"));



CREATE POLICY "Users can only access their own settings" ON "public"."settings" USING (("auth"."uid"() = "user_id"));



ALTER TABLE "public"."cards" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."decks" ENABLE ROW LEVEL SECURITY;


ALTER TABLE "public"."settings" ENABLE ROW LEVEL SECURITY;




ALTER PUBLICATION "supabase_realtime" OWNER TO "postgres";


ALTER PUBLICATION "supabase_realtime" ADD TABLE ONLY "public"."cards";



GRANT USAGE ON SCHEMA "public" TO "postgres";
GRANT USAGE ON SCHEMA "public" TO "anon";
GRANT USAGE ON SCHEMA "public" TO "authenticated";
GRANT USAGE ON SCHEMA "public" TO "service_role";



































































































































































































GRANT ALL ON TABLE "public"."cards" TO "anon";
GRANT ALL ON TABLE "public"."cards" TO "authenticated";
GRANT ALL ON TABLE "public"."cards" TO "service_role";



GRANT ALL ON TABLE "public"."decks" TO "anon";
GRANT ALL ON TABLE "public"."decks" TO "authenticated";
GRANT ALL ON TABLE "public"."decks" TO "service_role";



GRANT ALL ON TABLE "public"."settings" TO "anon";
GRANT ALL ON TABLE "public"."settings" TO "authenticated";
GRANT ALL ON TABLE "public"."settings" TO "service_role";



ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON SEQUENCES  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON FUNCTIONS  TO "service_role";






ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "postgres";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "anon";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "authenticated";
ALTER DEFAULT PRIVILEGES FOR ROLE "postgres" IN SCHEMA "public" GRANT ALL ON TABLES  TO "service_role";






























RESET ALL;

```

### File: tailwind.config.ts

```
import type { Config } from "tailwindcss";
// --- 1. Import defaultTheme for fallbacks ---
const { fontFamily } = require("tailwindcss/defaultTheme");
// ---

const config = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}', // Check if src exists, otherwise remove or adjust
                         // If using app router primarily, './app/**/...' is most important
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      fontFamily: {
        // --- 2. Update font definitions ---
        sans: ["var(--font-sans)", ...fontFamily.sans], // Use variable + default fallbacks
        opendyslexic: ["var(--font-open-dyslexic)", ...fontFamily.sans], // Use variable + default fallbacks
        atkinson: ["var(--font-atkinson)", ...fontFamily.sans],       // Use variable + default fallbacks
        // --- End of font updates ---
      },
      colors: {
        // Okabe-Ito colors REMOVED as gradients are used now
        // 'okabe-new': '#B51963',
        // 'okabe-learning': '#D55E00',
        // 'okabe-young': '#56B4E9',
        // 'okabe-mature': '#009E73',
        // Existing colors
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
} satisfies Config;

export default config;
```

### File: test-gcp-apis.ts

```
// test-gcp-apis.ts
import dotenv from 'dotenv';
import { ImageAnnotatorClient } from '@google-cloud/vision';
import { VertexAI } from '@google-cloud/vertexai';
import { appLogger } from '@/lib/logger';

// Load environment variables from .env.local (or .env)
// Make sure you have run: pnpm add -D dotenv @types/dotenv (or npm/yarn equivalent)
dotenv.config({ path: '.env.local' });

// --- Configuration ---
const projectId = process.env.GCP_PROJECT_ID;
const clientEmail = process.env.GCP_SERVICE_ACCOUNT_EMAIL;
// Read the private key and replace escaped newlines with actual newlines
const privateKey = process.env.GCP_PRIVATE_KEY?.replace(/\\n/g, '\n');
const location = 'europe-west4'; // Or your preferred Vertex AI region for Gemini models
const testImageUrl = 'https://storage.googleapis.com/cloud-samples-data/vision/ocr/sign.jpg'; // Public image for OCR
const testPrompt = 'Explain Spaced Repetition System (SRS) simply, in one sentence.';
const geminiModel = 'gemini-2.0-flash-lite-001'; // Use a fast and recent model

// --- Validation & Credential Setup ---
if (!projectId || !clientEmail || !privateKey) {
  appLogger.error(
    '\n❌ Error: Missing required Google Cloud credentials in environment variables.'
  );
  appLogger.error(
    '   Ensure GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, and GCP_PRIVATE_KEY are set correctly in your .env.local file.'
  );
  process.exit(1); // Exit script if credentials are missing
}

// Credentials object structure expected by google-auth-library (used internally)
const credentials = {
  client_email: clientEmail,
  private_key: privateKey,
};

// --- Test Execution ---
async function runTests() {
  appLogger.info('--- Testing Google Cloud APIs ---');
  let visionSuccess = false;
  let vertexSuccess = false;
  
  // Test 1: Cloud Vision AI OCR
  appLogger.info('\n1. Testing Cloud Vision AI (OCR)...');
  try {
    // Vision client accepts credentials directly
    const visionClient = new ImageAnnotatorClient({ credentials, projectId });
    appLogger.info('   Vision Client Initialized.');
    const [result] = await visionClient.textDetection(testImageUrl);
    const detections = result.textAnnotations;
    if (detections && detections.length > 0 && detections[0]?.description) {
      appLogger.info('✅ Vision API Success! Detected Text (excerpt):');
      appLogger.info(`   "${detections[0].description.substring(0, 100)}..."`);
      visionSuccess = true;
    } else {
      appLogger.error('❌ Vision API Error: No text detected or unexpected response format.');
      appLogger.error('   Full Response:', JSON.stringify(result, null, 2));
    }
  } catch (error) {
    appLogger.error('❌ Vision API Error: Request failed.');
    if (error instanceof Error) {
        appLogger.error(`   Message: ${error.message}`);
        if ('code' in error) appLogger.error(`   Code: ${(error as any).code}`); // Log common error codes
        if ('details' in error) appLogger.error(`   Details: ${(error as any).details}`);
    } else {
        appLogger.error(error);
    }
  }

  // Test 2: Vertex AI Gemini Text Generation
  appLogger.info('\n2. Testing Vertex AI (Gemini)...');
  try {
    // Initialize VertexAI client passing credentials via googleAuthOptions
    const vertexAI = new VertexAI({
        project: projectId,
        location: location,
        googleAuthOptions: { // Correct way to pass credentials
            credentials
        }
    });
    appLogger.info('   Vertex AI Client Initialized.');

    // Select Gemini model
    const generativeModel = vertexAI.getGenerativeModel({ model: geminiModel });
    appLogger.info(`   Attempting to generate content with model: ${geminiModel}`);

    // Generate content
    const result = await generativeModel.generateContent(testPrompt);
    const response = result.response;

    // Process response safely
    const candidate = response?.candidates?.[0];
    if (candidate) {
        if (candidate.content?.parts?.[0]?.text) {
             const text = candidate.content.parts[0].text;
             appLogger.info('✅ Vertex AI Success! Generated Text:');
             appLogger.info(`   "${text.trim()}"`);
             vertexSuccess = true;
        } else if (candidate.finishReason && candidate.finishReason !== 'STOP') {
             appLogger.warn(`⚠️ Vertex AI Warning: Generation finished with reason: ${candidate.finishReason}`);
             if(candidate.safetyRatings) appLogger.warn('   Safety Ratings:', JSON.stringify(candidate.safetyRatings, null, 2));
        }
        else {
             appLogger.error('❌ Vertex AI Error: No text part found in the candidate.');
             appLogger.error('   Full Candidate:', JSON.stringify(candidate, null, 2));
        }
    } else {
        appLogger.error('❌ Vertex AI Error: No candidates returned in the response.');
        appLogger.error('   Full Response:', JSON.stringify(response, null, 2));
    }

  } catch (error) {
    appLogger.error('❌ Vertex AI Error: Request failed.');
     if (error instanceof Error) {
        appLogger.error(`   Message: ${error.message}`);
        if ('code' in error) appLogger.error(`   Code: ${(error as any).code}`);
        if ('details' in error) appLogger.error(`   Details: ${(error as any).details}`);
    } else {
        appLogger.error(error);
    }
  }

  // --- Summary ---
  appLogger.info('\n--- Test Summary ---');
  appLogger.info(`Cloud Vision API: ${visionSuccess ? '✅ PASSED' : '❌ FAILED'}`);
  appLogger.info(`Vertex AI Gemini API: ${vertexSuccess ? '✅ PASSED' : '❌ FAILED'}`);
  appLogger.info('--------------------');

  if (!visionSuccess || !vertexSuccess) {
    appLogger.error('\nOne or more API tests failed. Check credentials in .env.local, ensure APIs are enabled in GCP, and verify IAM roles for the service account.');
    process.exit(1);
  } else {
     appLogger.info('\nAll API tests passed successfully!');
  }
}

// Run the tests
runTests();
```

### File: tsconfig.jest.json

```
{
  "extends": "./tsconfig.json",
  "compilerOptions": {
    "jsx": "react-jsx"
  }
}
```

### File: tsconfig.json

```
{
  "compilerOptions": {
    // --- Your Existing Options (Unchanged) ---
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "target": "ES6", // Consider updating to ES2017 or newer if compatible
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./*"
      ]
    }
    // --- End Existing Options ---
  },
  // --- ADD THIS BLOCK for ts-node configuration ---
  "ts-node": {
    "esm": true, // Enable ESM support for ts-node execution
    "experimentalSpecifierResolution": "node", // Helps with module resolution
    "compilerOptions": {
      // Specify options specifically for ts-node's compilation if needed
      // Often helps to target CommonJS for direct Node execution,
      // even if the main project targets esnext for the bundler.
      "module": "CommonJS"
    }
  },
  // --- End ADD ---
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts"
    // Ensure your test script is included if not covered by **/*.ts
    // "test-gcp-apis.ts" // Usually not needed if covered by wildcard
  ],
  "exclude": [
    "node_modules"
  ]
}
```

### File: vercel.json

```
{
  "functions": {
    "app/api/extract-pdf/route.ts": {
      "memory": 1024,
      "maxDuration": 60
    }
  }
} 
```

## Directory: __tests__

### File: __tests__/deckService.test.tsx

```
import { fetchDecks, getDeckService, createDeckService, updateDeckService, deleteDeckService } from '@/lib/deckService';
import type { Deck, FlashCard } from '@/types/deck';
import type { SupabaseClient, PostgrestError } from '@supabase/supabase-js';

// --- Mock Data (using camelCase as defined in types/deck.ts) ---
const mockDeck1: Deck = {
  id: 'deck1',
  name: 'Test Deck 1',
  language: 'en-US',
  isBilingual: false,
  questionLanguage: 'en-US',
  answerLanguage: 'en-US',
  cards: [],
  progress: { correct: 0, total: 0 }
};
const mockCard1: FlashCard = {
  id: 'card1',
  question: 'Q1',
  answer: 'A1',
  correctCount: 0,
  incorrectCount: 0,
  lastStudied: null,
  attemptCount: 0,
  difficultyScore: 0
};
const mockCard2: FlashCard = {
  id: 'card2',
  question: 'Q2',
  answer: 'A2',
  correctCount: 1,
  incorrectCount: 0,
  lastStudied: new Date(),
  attemptCount: 1,
  difficultyScore: 0.1
};
const mockDeckWithCards: Deck = { ...mockDeck1, cards: [mockCard1, mockCard2] };

// --- Define CreateDeckParams inline based on expected usage ---
interface CreateDeckParamsTest {
  name: string;
  isBilingual: boolean;
  questionLanguage: string;
  answerLanguage: string;
}

describe('deckService', () => {
  // --- Mock Supabase Client Setup ---
  let mockSupabase: SupabaseClient;
  let mockFrom: jest.Mock;
  let mockSelect: jest.Mock;
  let mockEq: jest.Mock;
  let mockOrder: jest.Mock;
  let mockSingle: jest.Mock;
  let mockInsert: jest.Mock;
  let mockUpdate: jest.Mock;
  let mockDelete: jest.Mock;
  let mockUpsert: jest.Mock;
  let mockReturns: jest.Mock; // Added mock for .returns()
  let mockIn: jest.Mock; // Added mock for .in()

  beforeEach(() => {
    // Reset mocks before each test
    mockReturns = jest.fn(); // Mock for .returns()
    mockSingle = jest.fn(() => ({ returns: mockReturns })); // .single() returns object with .returns()
    mockOrder = jest.fn(() => ({ returns: mockReturns })); // .order() returns object with .returns()
    mockIn = jest.fn(); // Placeholder for .in()

    // mockEq needs to return itself AND other chain terminators/modifiers
    const eqReturnObject: any = { 
      order: mockOrder, 
      single: mockSingle, 
      eq: jest.fn(), // Placeholder for self-reference
      in: mockIn, // Add mock for .in()
      // .returns() needed if eq is the last call
      returns: mockReturns 
    };
    mockEq = jest.fn(() => eqReturnObject);
    eqReturnObject.eq = mockEq; // Make eq return itself for chaining
    // Make .in() return an object allowing termination with .eq or .returns()
    // (Adjust if .in() needs to chain with other methods)
    mockIn.mockImplementation(() => ({ eq: mockEq, returns: mockReturns })); 

    // Mock .select() to return object with .eq and potentially .single/.returns
    mockSelect = jest.fn(() => ({ eq: mockEq, single: mockSingle, returns: mockReturns }));
    // Mock insert/upsert to return object with .select
    mockInsert = jest.fn(() => ({ select: mockSelect }));
    mockUpsert = jest.fn(() => ({ select: mockSelect })); // Assuming upsert returns select() like insert()
    // Mock update/delete to return object with .eq (and potentially other filters like .in)
    mockUpdate = jest.fn(() => ({ eq: mockEq })); // update -> eq
    mockDelete = jest.fn(() => ({ eq: mockEq, in: mockIn })); // delete -> eq or delete -> in
    // Mock .from() to return object with all possible first methods
    mockFrom = jest.fn(() => ({ 
      select: mockSelect, 
      insert: mockInsert, 
      update: mockUpdate, 
      delete: mockDelete, 
      upsert: mockUpsert 
    }));

    // Assign the mock implementation
    mockSupabase = { from: mockFrom } as any; 
  });

  // --- fetchDecks Tests ---
  describe('fetchDecks', () => {
    const userId = 'user1';
    it('should fetch and return decks for a user', async () => {
      // Arrange: Mock the chain ending with .returns()
      const mockRawDecks = [{ /* ... raw deck data ... */ }]; // Simulate raw DB result
      mockReturns.mockResolvedValueOnce({ data: mockRawDecks, error: null });

      // Act
      const result = await fetchDecks(mockSupabase, userId);

      // Assert
      expect(mockFrom).toHaveBeenCalledWith('decks');
      expect(mockSelect).toHaveBeenCalled(); 
      expect(mockEq).toHaveBeenCalledWith('user_id', userId);
      expect(mockOrder).toHaveBeenCalledWith('created_at', { ascending: false });
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeDefined(); // Check data exists
      expect(result.error).toBeNull();
    });

    it('should return an error if Supabase fetch fails', async () => {
      // Arrange
      const dbError = { message: 'Database fetch failed', details: '', hint: '', code: 'DB_ERROR' } as PostgrestError;
      mockReturns.mockResolvedValueOnce({ data: null, error: dbError });

      // Act
      const result = await fetchDecks(mockSupabase, userId);

      // Assert
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeNull();
      expect(result.error).toBe(dbError);
    });
  });

  // --- getDeckService Tests ---
  describe('getDeckService', () => {
    const deckId = 'deck1';
    const userId = 'user1';
    const mockRawDeck = { /* ... raw deck data ... */ }; // Simulate DB structure

    it('should fetch a single deck and its associated cards', async () => {
      // Arrange: Mock the chain eq -> eq -> single -> returns
      mockReturns.mockResolvedValueOnce({ data: mockRawDeck, error: null }); 

      // Act
      const result = await getDeckService(mockSupabase, userId, deckId); // Add userId

      // Assert
      expect(mockFrom).toHaveBeenCalledWith('decks');
      expect(mockSelect).toHaveBeenCalled(); // Check exact select if needed
      expect(mockEq).toHaveBeenCalledWith('id', deckId);
      expect(mockEq).toHaveBeenCalledWith('user_id', userId); // Check second eq call
      expect(mockSingle).toHaveBeenCalledTimes(1);
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeDefined(); // Check transformed data exists
      expect(result.error).toBeNull();
    });

    it('should return null data if the deck is not found', async () => {
      // Arrange: Mock deck fetch returning PGRST116 error
      const notFoundError = { message: 'Not Found', details: '', hint: '', code: 'PGRST116' } as PostgrestError;
      mockReturns.mockResolvedValueOnce({ data: null, error: notFoundError });

      // Act
      const result = await getDeckService(mockSupabase, userId, 'nonexistent-deck'); // Add userId

      // Assert
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeNull();
      expect(result.error).toBeNull(); // Service transforms PGRST116
    });

    it('should return an error if fetching the deck fails (non-PGRST116)', async () => {
      // Arrange: Mock deck fetch returning a different error
      const dbError = { message: 'Deck fetch error', details: '', hint: '', code: 'DB_ERROR' } as PostgrestError;
      mockReturns.mockResolvedValueOnce({ data: null, error: dbError });

      // Act
      const result = await getDeckService(mockSupabase, userId, deckId); // Add userId

      // Assert
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeNull();
      expect(result.error).toBe(dbError);
    });
  });

  // --- createDeckService Tests ---
  describe('createDeckService', () => {
    const userId = 'user1';
    const deckParams: CreateDeckParamsTest = {
      name: 'New Test Deck',
      isBilingual: false,
      questionLanguage: 'en-US',
      answerLanguage: 'en-US',
    };
    const expectedInsertData = { /* ... */ user_id: userId }; // Data passed to insert (snake_case)
    const mockRawCreatedDeck = {
      id: 'new-id',
      name: deckParams.name,
      user_id: userId, // Not in Deck type, but likely in raw data
      language: deckParams.questionLanguage,
      is_bilingual: deckParams.isBilingual,
      primary_language: deckParams.questionLanguage,
      secondary_language: deckParams.answerLanguage,
      progress: { correct: 0, total: 0 },
      // created_at handled by DB
    }; 
    const mockTransformedCreatedDeck: Deck = { /* ... */ id: 'new-id' }; // Transformed data

    it('should insert a new deck and return the transformed deck', async () => {
      // Arrange: Mock insert -> select -> single -> returns
      mockReturns.mockResolvedValueOnce({ data: mockRawCreatedDeck, error: null });

      // Act
      const result = await createDeckService(mockSupabase, userId, deckParams);

      // Assert
      expect(mockFrom).toHaveBeenCalledWith('decks');
      expect(mockInsert).toHaveBeenCalledWith([expect.objectContaining({ user_id: userId })]); 
      expect(mockSelect).toHaveBeenCalled(); 
      expect(mockSingle).toHaveBeenCalledTimes(1);
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeDefined();
      expect(result.error).toBeNull();
    });

    it('should return an error if Supabase insert fails', async () => {
      // Arrange: Mock insert failing
      const dbError = { message: 'Insert failed', details: '', hint: '', code: 'DB_ERROR' } as PostgrestError;
      mockReturns.mockResolvedValueOnce({ data: null, error: dbError });

      // Act
      const result = await createDeckService(mockSupabase, userId, deckParams);

      // Assert
      expect(mockReturns).toHaveBeenCalledTimes(1);
      expect(result.data).toBeNull();
      expect(result.error).toBe(dbError);
    });
  });

  // --- updateDeckService Tests ---
  describe('updateDeckService', () => {
    const deckId = 'deck1';
    const userId = 'user1';
    const baseDeck: Deck = {
      id: deckId,
      name: 'Original Name',
      language: 'en-US',
      isBilingual: false,
      questionLanguage: 'en-US',
      answerLanguage: 'nl-NL',
      cards: [
        { ...mockCard1 }, // Use copies of base mocks
        { ...mockCard2 },
      ],
      progress: { correct: 0, total: 0 }
    }; 

    it('should update deck metadata successfully', async () => {
      const updates: Deck = { ...baseDeck, name: 'Updated Name' };
      const expectedDbUpdate = { name: 'Updated Name' /* ... other snake_case fields ... */ };
      const mockExistingCardIds = [{ id: 'card1' }, { id: 'card2' }];
      
      // Arrange Mocks:
      // 1. Deck update succeeds (update -> eq -> eq)
      mockEq.mockResolvedValueOnce({ error: null }); // Second eq call resolves
      // 2. Fetch existing card IDs succeeds (select -> eq -> returns)
      mockReturns.mockResolvedValueOnce({ data: mockExistingCardIds, error: null }); 
      
      // Act
      const result = await updateDeckService(mockSupabase, userId, updates); // Add userId

      // Assert
      expect(mockFrom).toHaveBeenCalledWith('decks'); 
      expect(mockUpdate).toHaveBeenCalledWith(expect.objectContaining({ name: updates.name }));
      expect(mockEq).toHaveBeenCalledWith('id', deckId);
      expect(mockEq).toHaveBeenCalledWith('user_id', userId);
      expect(mockFrom).toHaveBeenCalledWith('cards'); 
      expect(mockSelect).toHaveBeenCalledWith('id');
      expect(mockEq).toHaveBeenCalledWith('deck_id', deckId);
      expect(mockReturns).toHaveBeenCalledTimes(1); 
      expect(mockUpsert).not.toHaveBeenCalled();
      expect(mockDelete).not.toHaveBeenCalled();
      expect(result.error).toBeNull();
    });

    it('should update deck and handle complex card changes successfully', async () => {
      const cardToUpdate: FlashCard = { ...mockCard1, question: 'Q1 Updated' };
      const cardToDeleteId = mockCard2.id;
      const cardToAdd: Omit<FlashCard, 'id'> = { question: 'Q3', answer: 'A3', correctCount: 0, incorrectCount: 0, lastStudied: null, attemptCount: 0, difficultyScore: 0 };
      
      const updates: Deck = {
        ...baseDeck,
        name: 'Updated Complex Name',
        cards: [
          cardToUpdate,
          cardToAdd as FlashCard, // Cast okay here for test setup
        ]
      };

      const expectedDeckDbUpdate = { name: updates.name };
      const expectedCardsToUpsert = [ /* ... snake_case card data ... */ ];
      const expectedCardIdsToDelete = [cardToDeleteId];
      const mockExistingCardIds = [{ id: mockCard1.id }, { id: mockCard2.id }];

      // Arrange Mocks:
      // 1. Deck update succeeds (update -> eq -> eq)
      mockEq.mockResolvedValueOnce({ error: null }); 
      // 2. Fetch existing card IDs succeeds (select -> eq -> returns)
      mockReturns.mockResolvedValueOnce({ data: mockExistingCardIds, error: null }); 
      // 3. Card upsert succeeds (upsert returns resolved promise directly, maybe check service code?)
      mockUpsert.mockResolvedValueOnce({ error: null }); // Assuming upsert resolves directly
      // 4. Card delete succeeds (delete -> eq -> in)
      mockEq.mockResolvedValueOnce({ error: null }); // For the .in().eq() part

      // Act
      const result = await updateDeckService(mockSupabase, userId, updates); // Add userId

      // Assert
      // Deck Update
      expect(mockUpdate).toHaveBeenCalledWith(expect.objectContaining({ name: updates.name }));
      expect(mockEq).toHaveBeenCalledWith('id', deckId);
      expect(mockEq).toHaveBeenCalledWith('user_id', userId);
      // Fetch Existing Cards
      expect(mockSelect).toHaveBeenCalledWith('id');
      expect(mockEq).toHaveBeenCalledWith('deck_id', deckId);
      expect(mockReturns).toHaveBeenCalledTimes(1); 
      // Card Upsert
      expect(mockUpsert).toHaveBeenCalledWith(expect.arrayContaining([expect.objectContaining({ id: cardToUpdate.id })]), { onConflict: 'id' });
      // Card Delete
      expect(mockDelete).toHaveBeenCalledTimes(1);
      expect(mockIn).toHaveBeenCalledWith('id', expectedCardIdsToDelete);
      expect(mockEq).toHaveBeenCalledWith('deck_id', deckId); // Check the eq after in
      // Final Result
      expect(result.error).toBeNull();
    });

    it('should return error if deck update fails', async () => {
        const updates: Deck = { ...baseDeck, name: 'Fail Update' };
        const dbError = { message: 'Deck update failed', details: '', hint: '', code: 'DB_ERROR' } as PostgrestError;
        // Mock the second .eq call to fail
        mockEq.mockImplementationOnce(() => ({ // First eq() returns object... 
            eq: jest.fn().mockResolvedValueOnce({ error: dbError }) // ...whose eq() call fails
        })); 

        const result = await updateDeckService(mockSupabase, userId, updates); // Add userId

        expect(mockUpdate).toHaveBeenCalledTimes(1);
        expect(mockEq).toHaveBeenCalledWith('id', deckId); // First eq call
        expect(mockEq).toHaveBeenCalledWith('user_id', userId); // Second eq call
        expect(result.error).toBe(dbError);
        expect(mockSelect).not.toHaveBeenCalledWith('id'); 
        expect(mockUpsert).not.toHaveBeenCalled();
        expect(mockDelete).not.toHaveBeenCalled();
    });

    // Add more error tests for fetch, upsert, delete failures...

  });

  // --- deleteDeckService Tests ---
  describe('deleteDeckService', () => {
    const deckId = 'deck1';
    const userId = 'user1';

    it('should delete associated cards and then the deck successfully', async () => {
      // Arrange: Mock card delete success (delete -> eq)
      mockEq.mockResolvedValueOnce({ error: null }); 
      // Arrange: Mock deck delete success (delete -> eq -> eq)
      mockEq.mockResolvedValueOnce({ error: null }); 

      // Act
      const result = await deleteDeckService(mockSupabase, userId, deckId); // Add userId

      // Assert
      // Card delete checks
      expect(mockFrom).toHaveBeenCalledWith('cards');
      expect(mockDelete).toHaveBeenCalledTimes(1);
      expect(mockEq).toHaveBeenCalledWith('deck_id', deckId);
      // Deck delete checks
      expect(mockFrom).toHaveBeenCalledWith('decks');
      expect(mockDelete).toHaveBeenCalledTimes(2); 
      expect(mockEq).toHaveBeenCalledWith('id', deckId);
      expect(mockEq).toHaveBeenCalledWith('user_id', userId);
      expect(result.error).toBeNull();
    });

    it('should return an error if deleting associated cards fails', async () => {
      // Arrange: Mock card delete failure (delete -> eq)
      const dbError = { message: 'Card delete failed', details: '', hint: '', code: 'DB_ERROR' } as PostgrestError;
      mockEq.mockResolvedValueOnce({ error: dbError }); 

      // Act
      const result = await deleteDeckService(mockSupabase, userId, deckId); // Add userId

      // Assert
      expect(mockFrom).toHaveBeenCalledWith('cards');
      expect(mockDelete).toHaveBeenCalledTimes(1);
      expect(mockEq).toHaveBeenCalledWith('deck_id', deckId);
      expect(mockFrom).not.toHaveBeenCalledWith('decks');
      expect(result.error).toBe(dbError);
    });

    it('should return an error if deleting the deck fails (after card delete succeeds)', async () => {
      // Arrange: Mock card delete success (delete -> eq)
      mockEq.mockResolvedValueOnce({ error: null }); 
      // Arrange: Mock deck delete failure (delete -> eq -> eq)
      const dbError = { message: 'Deck delete failed', details: '', hint: '', code: 'DB_ERROR' } as PostgrestError;
      // Mock the eq chain for deck deletion to fail on the second eq
      mockEq.mockImplementationOnce(() => ({ // First eq() returns object... 
          eq: jest.fn().mockResolvedValueOnce({ error: dbError }) // ...whose eq() call fails
      })); 

      // Act
      const result = await deleteDeckService(mockSupabase, userId, deckId); // Add userId

      // Assert
      // Card delete checks
      expect(mockFrom).toHaveBeenCalledWith('cards');
      expect(mockDelete).toHaveBeenCalledTimes(1); 
      expect(mockEq).toHaveBeenCalledWith('deck_id', deckId); // From card delete
      // Deck delete checks
      expect(mockFrom).toHaveBeenCalledWith('decks');
      expect(mockDelete).toHaveBeenCalledTimes(2); 
      expect(mockEq).toHaveBeenCalledWith('id', deckId); // First eq for deck delete
      expect(mockEq).toHaveBeenCalledWith('user_id', userId); // Second eq for deck delete
      expect(result.error).toBe(dbError);
    });
  });

});
```

### File: __tests__/settingsService.test.ts

```
// __tests__/settingsService.test.ts

import type { SupabaseClient } from '@supabase/supabase-js';
import { getUserSettings, updateUserSettings } from '@/lib/actions/settingsActions';
import type { Settings } from '@/providers/settings-provider';

describe('settingsService', () => {
  let mockSupabase: Partial<SupabaseClient>;

  beforeEach(() => {
    // Create a minimal mock for the Supabase client.
    mockSupabase = {
      from: jest.fn().mockReturnThis(),
    };
  });

  describe('getUserSettings', () => {
    it('should return transformed settings if data is found', async () => {
      const mockData = {
        appLanguage: 'en',
        cardFont: 'default' as const,
        showDifficulty: true,
        masteryThreshold: 3,
        ttsEnabled: true,
        srs_algorithm: 'sm2' as const,
        languageDialects: {
          en: 'en-US',
          nl: 'nl-NL',
          fr: 'fr-FR',
          de: 'de-DE',
          es: 'es-ES',
          it: 'it-IT'
        }
      };

      (mockSupabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        maybeSingle: jest.fn().mockResolvedValue({ data: mockData, error: null }),
      });

      const result = await getUserSettings();

      expect(result).toEqual(mockData);
    });

    it('should return null if no settings are found', async () => {
      (mockSupabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        maybeSingle: jest.fn().mockResolvedValue({ data: null, error: null }),
      });

      const result = await getUserSettings();
      expect(result).toBeNull();
    });

    it('should throw an error if the database query fails', async () => {
      (mockSupabase.from as jest.Mock).mockReturnValue({
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        maybeSingle: jest.fn().mockRejectedValue(new Error('Error occurred')),
      });

      await expect(getUserSettings()).rejects.toThrow('Error occurred');
    });
  });

  describe('updateUserSettings', () => {
    const inputSettings: Partial<Settings> = {
      appLanguage: 'en',
      cardFont: 'default' as const,
      showDifficulty: true,
      masteryThreshold: 3,
      ttsEnabled: true,
      srs_algorithm: 'sm2' as const,
      languageDialects: {
        en: 'en-US',
        nl: 'nl-NL',
        fr: 'fr-FR',
        de: 'de-DE',
        es: 'es-ES',
        it: 'it-IT'
      }
    };

    it('should update settings successfully', async () => {
      (mockSupabase.from as jest.Mock).mockReturnValue({
        upsert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        maybeSingle: jest.fn().mockResolvedValue({ data: inputSettings, error: null }),
      });

      const result = await updateUserSettings({ updates: inputSettings });
      
      expect(result).toEqual(inputSettings);
    });

    it('should throw an error if the update fails', async () => {
      (mockSupabase.from as jest.Mock).mockReturnValue({
        upsert: jest.fn().mockReturnThis(),
        select: jest.fn().mockReturnThis(),
        eq: jest.fn().mockReturnThis(),
        maybeSingle: jest.fn().mockRejectedValue(new Error('Update failed')),
      });

      await expect(updateUserSettings({ updates: inputSettings }))
        .rejects.toThrow('Update failed');
    });
  });
});
```

### File: __tests__/studyQueryActions.test.ts

```
import { createClient } from '@supabase/supabase-js';
import { Database } from '@/types/database';

// Mock Supabase client
jest.mock('@supabase/supabase-js', () => ({
  createClient: jest.fn()
}));

describe('studyQueryActions', () => {
  const mockSupabase = {
    rpc: jest.fn()
  };

  beforeEach(() => {
    // Reset all mocks before each test
    jest.clearAllMocks();
    (createClient as jest.Mock).mockReturnValue(mockSupabase);
  });

  describe('resolve_study_query RPC', () => {
    const TEST_USER_ID = '12345678-1234-1234-1234-123456789012';
    const TEST_DECK_ID = '98765432-9876-9876-9876-987654321098';
    const TEST_TAG_IDS = [
      'aaaaaaaa-aaaa-aaaa-aaaa-aaaaaaaaaaaa',
      'bbbbbbbb-bbbb-bbbb-bbbb-bbbbbbbbbbbb'
    ];

    // Helper to simulate RPC response
    const mockRpcResponse = (cards: Array<{ card_id: string; priority: number }>) => {
      mockSupabase.rpc.mockResolvedValueOnce({ data: cards, error: null });
    };

    it('should fetch all cards when no filters are applied', async () => {
      // Arrange
      const criteria = {
        limit: 10,
        includeNew: true,
        includeReview: true,
        includeLearning: true
      };
      
      mockRpcResponse([
        { card_id: 'card1', priority: 1 },
        { card_id: 'card2', priority: 2 },
        { card_id: 'card3', priority: 3 }
      ]);

      // Act
      const { data, error } = await mockSupabase.rpc('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });

      // Assert
      expect(error).toBeNull();
      expect(data).toHaveLength(3);
      expect(mockSupabase.rpc).toHaveBeenCalledWith('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });
    });

    it('should filter only new cards', async () => {
      // Arrange
      const criteria = {
        limit: 10,
        includeNew: true,
        includeReview: false,
        includeLearning: false
      };
      
      mockRpcResponse([
        { card_id: 'new1', priority: 1 },
        { card_id: 'new2', priority: 1 }
      ]);

      // Act
      const { data, error } = await mockSupabase.rpc('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });

      // Assert
      expect(error).toBeNull();
      expect(data).toHaveLength(2);
      expect(data?.every(card => card.priority === 1)).toBe(true);
    });

    it('should filter by deck ID', async () => {
      // Arrange
      const criteria = {
        deckId: TEST_DECK_ID,
        limit: 10,
        includeNew: true,
        includeReview: true,
        includeLearning: true
      };
      
      mockRpcResponse([
        { card_id: 'deck1', priority: 1 },
        { card_id: 'deck2', priority: 2 }
      ]);

      // Act
      const { data, error } = await mockSupabase.rpc('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });

      // Assert
      expect(error).toBeNull();
      expect(mockSupabase.rpc).toHaveBeenCalledWith('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: expect.objectContaining({ deckId: TEST_DECK_ID })
      });
    });

    it('should filter by tags', async () => {
      // Arrange
      const criteria = {
        tagIds: TEST_TAG_IDS,
        limit: 10,
        includeNew: true,
        includeReview: true,
        includeLearning: true
      };
      
      mockRpcResponse([
        { card_id: 'tagged1', priority: 1 },
        { card_id: 'tagged2', priority: 2 }
      ]);

      // Act
      const { data, error } = await mockSupabase.rpc('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });

      // Assert
      expect(error).toBeNull();
      expect(mockSupabase.rpc).toHaveBeenCalledWith('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: expect.objectContaining({ tagIds: TEST_TAG_IDS })
      });
    });

    it('should handle complex filtering (deck + tags + learning only)', async () => {
      // Arrange
      const criteria = {
        deckId: TEST_DECK_ID,
        tagIds: TEST_TAG_IDS,
        limit: 10,
        includeNew: false,
        includeReview: false,
        includeLearning: true
      };
      
      mockRpcResponse([
        { card_id: 'learning1', priority: 2 },
        { card_id: 'learning2', priority: 2 }
      ]);

      // Act
      const { data, error } = await mockSupabase.rpc('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });

      // Assert
      expect(error).toBeNull();
      expect(data?.every(card => card.priority === 2)).toBe(true);
      expect(mockSupabase.rpc).toHaveBeenCalledWith('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: expect.objectContaining({
          deckId: TEST_DECK_ID,
          tagIds: TEST_TAG_IDS,
          includeLearning: true
        })
      });
    });

    it('should handle RPC errors gracefully', async () => {
      // Arrange
      const criteria = { limit: 10 };
      mockSupabase.rpc.mockResolvedValueOnce({
        data: null,
        error: { message: 'Test error', code: 'TEST_ERROR' }
      });

      // Act
      const { data, error } = await mockSupabase.rpc('resolve_study_query', {
        p_user_id: TEST_USER_ID,
        p_criteria: criteria
      });

      // Assert
      expect(data).toBeNull();
      expect(error).toEqual(expect.objectContaining({
        message: 'Test error',
        code: 'TEST_ERROR'
      }));
    });
  });
}); 
```

### File: __tests__/use-decks.test.tsx

```
// __tests__/use-decks.test.tsx

// Place mocks at the very top before any other imports:
jest.mock('@/hooks/use-auth', () => ({
    useAuth: jest.fn(),
  }));
  jest.mock('@/hooks/use-supabase', () => ({
    useSupabase: jest.fn(),
  }));
  // Updated mock: useSettings now always returns an object with settings and setSettings
  jest.mock('@/providers/settings-provider', () => ({
    useSettings: jest.fn(),
  }));
  jest.mock('@/lib/deckService', () => ({
    fetchDecks: jest.fn(),
    createDeckService: jest.fn(),
    getDeckService: jest.fn(),
    updateDeckService: jest.fn(),
    deleteDeckService: jest.fn(),
  }));
  jest.mock('@/lib/localStorageUtils', () => ({
    getDecksFromLocalStorage: jest.fn(),
    saveDecksToLocalStorage: jest.fn(),
  }));
  
  // Optional: Suppress warnings about act in concurrent mode
  const originalConsoleError = console.error;
  console.error = (...args) => {
    if (typeof args[0] === 'string' && args[0].includes('The current testing environment is not configured to support act')) {
      return;
    }
    originalConsoleError(...args);
  };
  
  // Now import modules that rely on the above mocks:
  import React from 'react';
  import { createRoot } from 'react-dom/client';
  import { act } from 'react';
  import { useDecks } from '@/hooks/use-decks';
  import { useAuth } from '@/hooks/use-auth';
  import { useSupabase } from '@/hooks/use-supabase';
  import { fetchDecks } from '@/lib/deckService';
  import { getDecksFromLocalStorage } from '@/lib/localStorageUtils';
  
  // Instead of using renderHook from @testing-library/react-hooks,
  // we create a test component that uses the hook and renders its output.
  function TestComponent() {
    const { decks, loading } = useDecks();
    return (
      <div>
        {loading ? (
          <span data-testid="loading">Loading</span>
        ) : (
          decks.map((deck) => (
            <div key={deck.id} data-testid="deck">
              {deck.name}
            </div>
          ))
        )}
      </div>
    );
  }
  
  // Create a container for our tests
  let container: HTMLDivElement | null = null;
  let root: ReturnType<typeof createRoot>;
  
  beforeEach(() => {
    container = document.createElement('div');
    document.body.appendChild(container);
    root = createRoot(container);
  });
  
  afterEach(() => {
    if (root) {
      root.unmount();
    }
    if (container) {
      container.remove();
      container = null;
    }
  });
  
  describe('useDecks (using createRoot)', () => {
    beforeEach(() => {
      jest.resetAllMocks();
    });
  
    it('loads decks from Supabase and updates localStorage', async () => {
      // Arrange: Setup mocks for auth and supabase
      const mockUser = { id: 'user1' };
      (useAuth as jest.Mock).mockReturnValue({ user: mockUser });
      const mockSupabase = {
        // Create a simple mock for Supabase chainable calls if needed
      };
      (useSupabase as jest.Mock).mockReturnValue({ supabase: mockSupabase });
      const fakeDecks = [{ id: 'deck1', name: 'Test Deck', cards: [] }];
      (fetchDecks as jest.Mock).mockResolvedValue(fakeDecks);
      (getDecksFromLocalStorage as jest.Mock).mockReturnValue([]);
  
      // Act: Render the test component using createRoot
      await act(async () => {
        root.render(<TestComponent />);
      });
  
      // Assert: Check that the rendered output contains our deck name
      expect(container?.textContent).toContain('Test Deck');
    });
  });
```

### File: __tests__/use-supabase.test.tsx

```
// __tests__/use-supabase.test.tsx

// Set environment variables required by useSupabase before any imports occur
process.env.NEXT_PUBLIC_SUPABASE_URL = "https://example.supabase.co";
process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY = "dummy-key";

// Place mocks at the very top before any other imports:
jest.mock('@/hooks/use-auth', () => ({
  useAuth: jest.fn(),
}));
jest.mock('@/hooks/use-settings', () => ({
  __esModule: true,
  useSettings: () => ({
    settings: {},
    setSettings: () => {},
  }),
}));
jest.mock('@/lib/deckService', () => ({
  fetchDecks: jest.fn(),
  createDeckService: jest.fn(),
  getDeckService: jest.fn(),
  updateDeckService: jest.fn(),
  deleteDeckService: jest.fn(),
}));
jest.mock('@/lib/localStorageUtils', () => ({
  getDecksFromLocalStorage: jest.fn(),
  saveDecksToLocalStorage: jest.fn(),
}));
jest.mock('@supabase/ssr', () => ({
  createBrowserClient: jest.fn(),
}));

// IMPORTANT: Do NOT mock use-supabase so that we test the real hook
import React, { useEffect } from 'react';
import { createRoot } from 'react-dom/client';
import { act } from 'react';
import { useSupabase } from '@/hooks/use-supabase';

// A test component that uses useSupabase and calls onUpdate when values change
function TestSupabaseComponent({ onUpdate }: { onUpdate: (initialized: boolean, client: any) => void }) {
  const { supabase, initialized } = useSupabase();

  useEffect(() => {
    onUpdate(initialized, supabase);
  }, [initialized, supabase, onUpdate]);

  return <div data-testid="initialized">{initialized ? 'true' : 'false'}</div>;
}

describe('useSupabase hook', () => {
  let container: HTMLDivElement;
  let root: ReturnType<typeof createRoot>;
  let hookState: { initialized: boolean; client: any } | null = null;

  beforeEach(() => {
    container = document.createElement('div');
    document.body.appendChild(container);
    root = createRoot(container);
    hookState = null;
  });

  afterEach(() => {
    // Wrap unmount in act to flush updates
    act(() => {
      root.unmount();
    });
    container.remove();
  });

  it('should return a supabase client and eventually set initialized to true', async () => {
    // Arrange: Setup the useAuth mock so that useSupabase gets a user
    const { useAuth } = require('@/hooks/use-auth');
    useAuth.mockReturnValue({ user: { id: 'user1' } });

    // Act: Render our test component using createRoot
    await act(async () => {
      root.render(
        <TestSupabaseComponent
          onUpdate={(initialized, client) => {
            hookState = { initialized, client };
          }}
        />
      );
    });

    // Wait a bit for the hook's useEffect to run
    await act(async () => {
      await new Promise((resolve) => setTimeout(resolve, 20));
    });

    // Assert: Verify that the hookState has been set, a supabase client is defined, and initialized is true.
    expect(hookState).not.toBeNull();
    expect(hookState?.client).toBeDefined();
    expect(hookState?.initialized).toBe(true);
  });
});
```

## Directory: app

### File: app/globals.css

```
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Import custom fonts */
@font-face {
  font-family: 'OpenDyslexic';
  src: url('/fonts/OpenDyslexic-Regular.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Atkinson Hyperlegible';
  src: url('/fonts/AtkinsonHyperlegible-Regular.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

/* Font classes */
.font-opendyslexic {
  font-family: 'OpenDyslexic', sans-serif;
}

.font-atkinson {
  font-family: 'Atkinson Hyperlegible', sans-serif;
}

.font-sans {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}

/* Ensure fonts are loaded before use */
.fonts-loaded .font-opendyslexic,
.fonts-loaded .font-atkinson {
  opacity: 1;
  transition: opacity 0.1s ease-in;
}

.fonts-loading .font-opendyslexic,
.fonts-loading .font-atkinson {
  opacity: 0;
}

/* Debug styles to force font application */
[style*="OpenDyslexic"] {
  font-family: OpenDyslexic, -apple-system, BlinkMacSystemFont, system-ui, sans-serif !important;
}

[style*="Atkinson"] {
  font-family: "Atkinson Hyperlegible", -apple-system, BlinkMacSystemFont, system-ui, sans-serif !important;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 22%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* CSS class to apply specific border color to flashcards */
.flashcard-border {
  /* Override --border locally for light mode */
  --border: 210 40% 70%;
}

.dark .flashcard-border {
  /* Override --border locally for dark mode */
  --border: 210 30% 35%;
}

.flip-card {
  perspective: 1000px;
}

.flip-card-inner {
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.flip-card-front,
.flip-card-back {
  backface-visibility: hidden;
}

.flip-card-back {
  transform: rotateY(180deg);
}

.flip-card.flipped .flip-card-inner {
  transform: rotateY(180deg);
}

.card-is-changing .flip-card-content {
  opacity: 0;
  transition: opacity 0.01s;
}

.flip-card-content {
  opacity: 1;
  transition: opacity 0.01s;
}


```

### File: app/layout-script.tsx

```
"use client"

import { useEffect } from "react"
import { appLogger, statusLogger } from '@/lib/logger'

export default function LayoutScript() {
  useEffect(() => {
    // Only register service worker in production and when in a browser context
    // that supports service workers
    if (typeof window !== "undefined" && "serviceWorker" in navigator) {
      // Check if we're in a development/preview environment
      const isPreviewEnvironment =
        window.location.hostname.includes("vusercontent.net") ||
        window.location.hostname.includes("vercel.app") ||
        window.location.hostname === "localhost" ||
        window.location.hostname === "127.0.0.1"

      if (isPreviewEnvironment) {
        appLogger.info("Service Worker registration skipped in preview/development environment")
        return
      }

      // Only register in production environments
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("/sw.js")
          .then((registration) => {
            appLogger.info("Service Worker registered with scope:", registration.scope)
          })
          .catch((error) => {
            appLogger.error("Service Worker registration failed:", error)
            // Continue app execution even if service worker fails
          })
      })
    }
  }, [])

  return null
}


```

### File: app/layout.tsx

```
import { Atkinson_Hyperlegible } from "next/font/google";
import type React from "react";
import type { Metadata } from "next";
import { Inter as FontSans } from "next/font/google";
// --- 1. Import custom font objects and cn utility ---
import { openDyslexicFont, atkinsonFont } from '@/lib/fonts';
import { cn } from '@/lib/utils';
// --- End of imports ---
import "./globals.css";
import { ClientProviders } from "@/components/ClientProviders";
import { ResponsiveLayout } from '@/components/layout/ResponsiveLayout';
import LayoutScript from "./layout-script";
import { SpeedInsights } from "@vercel/speed-insights/next";

export const metadata: Metadata = {
  title: "StudyCards - Interactive Flashcard App",
  description: "Study effectively with interactive question-and-answer cards",
  icons: {
    icon: [
      { url: '/favicon-96x96.png', sizes: '96x96', type: 'image/png' },
      { url: '/favicon.svg', type: 'image/svg+xml' },
      { url: '/favicon.ico' },
    ],
    apple: '/apple-touch-icon.png'
  },
  manifest: '/manifest.json'
};

// --- 2. Configure Inter to use a CSS variable ---
const fontSans = FontSans({
  subsets: ["latin"],
  variable: "--font-sans", // Define the CSS variable name
});
// --- End of font configuration ---

/**
 * Root layout component for the application.
 * 
 * This component sets up the fundamental structure of the application, including:
 * - HTML document structure and metadata
 * - Global styles and fonts
 * - Client-side providers for authentication, theme, and settings
 * 
 * @component
 * @returns {JSX.Element} The root layout with all necessary providers and global styles
 */
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta name="theme-color" content="#ffffff" />
        <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
      </head>
      {/* --- 3. Apply all font variables using cn --- */}
      <body
        className={cn(
          "min-h-screen bg-background font-sans antialiased", // Base styles + default font utility
          fontSans.variable,           // Apply --font-sans variable
          openDyslexicFont.variable,   // Apply --font-open-dyslexic variable
          atkinsonFont.variable        // Apply --font-atkinson variable
        )}
      >
      {/* --- End of body className changes --- */}
        <ClientProviders>
          <ResponsiveLayout>
            <div className="relative flex min-h-screen flex-col">
              <div className="flex-1">
                <div className="pb-8">
                  {children}
                </div>
              </div>
            </div>
          </ResponsiveLayout>
        </ClientProviders>
        <LayoutScript />
        <SpeedInsights />
      </body>
    </html>
  )
}
```

### File: app/page.tsx

```
import { DeckListClient } from "@/components/DeckListClient";
import { getDecksWithSrsCounts } from "@/lib/actions/deckActions";
import { redirect } from "next/navigation";
import { createServerClient } from "@/lib/supabase/server";
import { cookies } from "next/headers";
import { appLogger, statusLogger } from '@/lib/logger';

/**
 * Home page component.
 * 
 * This is a Server Component that pre-fetches deck data with all SRS counts
 * server-side before rendering the page. This eliminates client-side requests
 * and provides a faster initial load experience.
 * 
 * The page is protected and requires authentication. If the user is not
 * authenticated, they are redirected to the login page.
 * 
 * @returns {Promise<JSX.Element>} The Home page with pre-fetched data
 */
export default async function Home() {
  // Check authentication server-side
  const cookieStore = cookies();
  const supabase = createServerClient();
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  // Redirect to login if not authenticated
  if (!session) {
    redirect("/login");
  }
  
  // Fetch all deck data with SRS counts in a single database call
  const { data: decksWithCounts, error: fetchError } = await getDecksWithSrsCounts();
  
  // Log any fetch errors but still render the page (client will handle empty state)
  if (fetchError) {
    appLogger.error("Error fetching decks with counts:", fetchError);
  }
  
  return (
    <div className="grid gap-4">
      <DeckListClient initialData={decksWithCounts || []} />
    </div>
  );
}


```

### File: app/sw.js

```
// This is a service worker file for PWA functionality

// Use a versioned cache name
const CACHE_NAME = "studycards-v1"

// List of assets to cache
const ASSETS_TO_CACHE = ["/", "/index.html", "/manifest.json", "/icon-192x192.png", "/icon-512x512.png"]

// Install event handler
self.addEventListener("install", (event) => {
  // Skip waiting to activate the new service worker immediately
  self.skipWaiting()

  event.waitUntil(
    caches
      .open(CACHE_NAME)
      .then((cache) => {
        console.log("Opened cache")
        return cache.addAll(ASSETS_TO_CACHE)
      })
      .catch((error) => {
        console.error("Failed to cache assets:", error)
      }),
  )
})

// Activate event handler
self.addEventListener("activate", (event) => {
  // Clean up old caches
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log("Deleting old cache:", cacheName)
            return caches.delete(cacheName)
          }
        }),
      )
    }),
  )

  // Ensure the service worker takes control immediately
  return self.clients.claim()
})

// Fetch event handler with improved error handling
self.addEventListener("fetch", (event) => {
  // Only cache GET requests
  if (event.request.method !== "GET") return

  // Skip caching for certain URLs
  if (
    event.request.url.includes("/api/") ||
    event.request.url.includes("chrome-extension://") ||
    event.request.url.includes("extension://")
  ) {
    return
  }

  event.respondWith(
    caches.match(event.request).then((response) => {
      // Return cached response if found
      if (response) {
        return response
      }

      // Otherwise fetch from network
      return fetch(event.request)
        .then((fetchResponse) => {
          // Don't cache non-successful responses
          if (!fetchResponse || fetchResponse.status !== 200 || fetchResponse.type !== "basic") {
            return fetchResponse
          }

          // Cache important assets for offline use
          const responseToCache = fetchResponse.clone()

          caches
            .open(CACHE_NAME)
            .then((cache) => {
              cache.put(event.request, responseToCache)
            })
            .catch((error) => {
              console.error("Failed to cache response:", error)
            })

          return fetchResponse
        })
        .catch((error) => {
          console.error("Fetch failed:", error)

          // Return a fallback for offline experience
          if (event.request.url.includes(".html") || event.request.mode === "navigate") {
            return caches.match("/")
          }

          // For other resources, just let the error happen
          throw error
        })
    }),
  )
})


```

## Directory: app/api

## Directory: app/api/cards

### File: app/api/cards/route.ts

```
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'
import type { Tables } from "@/types/database";
import { appLogger, statusLogger } from '@/lib/logger';
type DbCard = Tables<'cards'>;

export const dynamic = 'force-dynamic'

// Expects card IDs in the request body
export async function POST(request: Request) {
  appLogger.info(`[API /api/cards] POST request received`);

  let cardIds: string[] = [];
  try {
    const body = await request.json();
    if (!Array.isArray(body.cardIds) || body.cardIds.length === 0) {
        throw new Error("cardIds array is required in the request body.");
    }
    cardIds = body.cardIds;
    appLogger.info(`[API /api/cards] Requesting details for ${cardIds.length} cards.`);
  } catch (e) {
    appLogger.error("[API /api/cards] Invalid request body:", e);
    return NextResponse.json({ error: 'Invalid request body. Expecting { "cardIds": [...] }' }, { status: 400 })
  }

  const cookieStore = cookies()
  const supabase = createRouteHandlerClient({ cookies: () => cookieStore })

  const { data: { session }, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !session) {
    appLogger.error('[API /api/cards] Auth error or no session', sessionError);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    appLogger.info(`[API /api/cards] Fetching cards for user: ${session.user.id}`);
    const { data: dbCards, error: fetchError } = await supabase
      .from('cards')
      .select(`*`) // Select all needed card fields
      .in('id', cardIds)
      // RLS policy should handle user access via deck relationship
      
    appLogger.info("[API /api/cards] Supabase fetch result:", { count: dbCards?.length, fetchError });

    if (fetchError) {
      appLogger.error("[API /api/cards] Supabase fetch error:", fetchError);
      throw fetchError;
    }

    if (!dbCards) {
      // This shouldn't happen if fetchError is null, but good practice
      return NextResponse.json({ cards: [] }) 
    }
    
    // Return the raw DbCard data - mapping will happen on client if needed, 
    // or adjust DbCard type to match FlashCard needs exactly
    return NextResponse.json({ cards: dbCards })

  } catch (error) {
     const errorMessage = error instanceof Error ? error.message : String(error);
     appLogger.error('[API /api/cards] Caught error:', errorMessage, error);
     return NextResponse.json({ error: 'Failed to fetch card details', details: errorMessage }, { status: 500 })
  }
} 
```

## Directory: app/api/decks

### File: app/api/decks/route.ts

```
// app/api/decks/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createActionClient } from '@/lib/supabase/server';
import type { ApiFlashcard } from '../extract-pdf/types';
import type { Database, Tables, Json } from '@/types/database';
// --- Import the NEW batch action ---
import { createCardsBatch, type CreateCardInput } from '@/lib/actions/cardActions'; // Adjust path if needed
import { appLogger, statusLogger } from '@/lib/logger';

// Define the expected request body structure (remains the same)
interface CreateDeckRequestBody {
    name: string;
    questionLanguage: string;
    answerLanguage: string;
    isBilingual: boolean;
    flashcards: ApiFlashcard[]; // Expect the full ApiFlashcard structure
}

export async function POST(request: NextRequest) {
    appLogger.info("[API POST /api/decks] Received request to create deck.");
    const supabase = createActionClient(); // Used for deck creation only now

    try {
        // 1. Get User Session (No change)
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            appLogger.error("[API POST /api/decks] Authentication error:", authError);
            return NextResponse.json({ success: false, message: 'Authentication required' }, { status: 401 });
        }
        appLogger.info(`[API POST /api/decks] User authenticated: ${user.id}`);

        // 2. Parse Request Body (No change)
        let body: CreateDeckRequestBody;
        try {
             body = await request.json();
        } catch (jsonError: any) {
             appLogger.error("[API POST /api/decks] Error parsing JSON body:", jsonError);
             return NextResponse.json({ success: false, message: `Invalid JSON format in request body: ${jsonError.message}` }, { status: 400 });
        }

        const { name, questionLanguage, answerLanguage, isBilingual, flashcards } = body;

        // 3. Validate Input (No change)
        if (!name || !questionLanguage || !answerLanguage || flashcards === undefined || flashcards === null) {
            return NextResponse.json({ success: false, message: 'Missing required fields: name, questionLanguage, answerLanguage, flashcards (array, can be empty)' }, { status: 400 });
        }
        if (!Array.isArray(flashcards)) {
             return NextResponse.json({ success: false, message: 'Field "flashcards" must be an array.' }, { status: 400 });
        }
        appLogger.info(`[API POST /api/decks] Input validation passed. Creating deck "${name}" with ${flashcards.length} potential cards.`);

        // 4. Insert Deck into Supabase (No change)
        const deckToInsert: Database['public']['Tables']['decks']['Insert'] = {
                user_id: user.id,
                name: name.trim(),
                primary_language: questionLanguage,
                secondary_language: answerLanguage,
                is_bilingual: isBilingual,
        };

        const { data: deckData, error: deckError } = await supabase
            .from('decks')
            .insert(deckToInsert)
            .select()
            .single();

        if (deckError || !deckData) {
            appLogger.error("[API POST /api/decks] Error inserting deck:", deckError);
             if (deckError?.message.includes('duplicate key value violates unique constraint')) {
                 return NextResponse.json({ success: false, message: 'A deck with this name already exists.' }, { status: 409 });
             }
            return NextResponse.json({ success: false, message: `Failed to create deck: ${deckError?.message || 'Unknown DB error'}` }, { status: 500 });
        }

        const newDeckId = deckData.id;
        appLogger.info(`[API POST /api/decks] Deck metadata created successfully with ID: ${newDeckId}`);

        let insertedCardsCount = 0;
        let cardCreationError: string | null = null;

        // 5. Prepare and Insert Cards using Batch Action
        if (flashcards.length > 0) {
            appLogger.info(`[API POST /api/decks] Preparing ${flashcards.length} cards for batch action into deck ${newDeckId}...`);

            // --- Prepare data for the batch action ---
            // Map ApiFlashcard[] to CreateCardInput[] expected by the action
            const cardDataForAction: CreateCardInput[] = flashcards.map(card => ({
                question: card.question,
                answer: card.answer,
                question_part_of_speech: card.questionPartOfSpeech, // Pass through classification fields
                question_gender: card.questionGender,
                answer_part_of_speech: card.answerPartOfSpeech,
                answer_gender: card.answerGender,
            }));

            // --- Call the batch action ---
            const batchResult = await createCardsBatch(newDeckId, cardDataForAction);

            if (batchResult.error || batchResult.data === null) {
                // --- Handle error from batch action ---
                cardCreationError = batchResult.error || 'Unknown error during batch card creation.';
                appLogger.error(`[API POST /api/decks] Error calling createCardsBatch for deck ${newDeckId}:`, cardCreationError);

                // Attempt rollback
                try {
                     await supabase.from('decks').delete().eq('id', newDeckId);
                     appLogger.info(`[API POST /api/decks] Rolled back deck creation (ID: ${newDeckId}) due to card batch error.`);
                } catch (rollbackError: any) {
                    appLogger.error(`[API POST /api/decks] CRITICAL: Failed to rollback deck ${newDeckId} after card batch failure:`, rollbackError);
                    cardCreationError += ' Rollback also failed.'; // Append rollback failure info
                }
                return NextResponse.json({ success: false, message: `Failed to insert cards, deck creation rolled back: ${cardCreationError}` }, { status: 500 });

            } else {
                // --- Success from batch action ---
                insertedCardsCount = batchResult.data.insertedCount;
                appLogger.info(`[API POST /api/decks] createCardsBatch action succeeded. Inserted Count: ${insertedCardsCount}`);
                if (insertedCardsCount < flashcards.length) {
                     appLogger.warn(`[API POST /api/decks] Note: ${flashcards.length - insertedCardsCount} card(s) were skipped during batch validation within the action.`);
                }
            }
        } else {
            appLogger.info(`[API POST /api/decks] No cards provided in request, only created deck metadata for ID: ${newDeckId}.`);
        }


        // 7. Return Success Response
        // Construct message based on outcome
        let message = `Deck "${name}" created successfully`;
        if (flashcards.length > 0) {
            if (insertedCardsCount > 0) {
                message += ` with ${insertedCardsCount} valid card(s)${insertedCardsCount < flashcards.length ? ` (${flashcards.length - insertedCardsCount} skipped)` : ''}.`;
            } else {
                 message += ', but no valid cards were inserted after validation.';
            }
        } else {
            message += '.'; // Just created deck metadata
        }

        return NextResponse.json({
            success: true,
            message: message,
            deckId: newDeckId,
            deck: deckData as Tables<'decks'>
        }, { status: 201 });

    } catch (error: any) {
        appLogger.error("[API POST /api/decks] Unhandled error in POST handler:", error);
        // Keep generic error handlers
        if (error instanceof SyntaxError) {
             return NextResponse.json({ success: false, message: 'Invalid JSON in request body' }, { status: 400 });
        }
        return NextResponse.json({ success: false, message: `Internal server error: ${error.message}` }, { status: 500 });
    }
}
```

## Directory: app/api/decks/[deckId]

## Directory: app/api/decks/[deckId]/name

### File: app/api/decks/[deckId]/name/route.ts

```
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'
import { appLogger, statusLogger } from '@/lib/logger'

export const dynamic = 'force-dynamic' // Ensure dynamic execution

export async function GET(
  request: Request,
  { params }: { params: { deckId: string } }
) {
  const { deckId } = params
  appLogger.info(`[API /api/decks/name] GET request for deckId: ${deckId}`);

  if (!deckId) {
    appLogger.error("[API /api/decks/name] Missing deckId param.");
    return NextResponse.json({ error: 'Missing deckId' }, { status: 400 })
  }

  const cookieStore = cookies()
  const supabase = createRouteHandlerClient({ cookies: () => cookieStore })

  // Check user session
  const { data: { session }, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !session) {
    appLogger.error('[API /api/decks/name] Auth error or no session', sessionError);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    appLogger.info(`[API /api/decks/name] Querying decks table for id: ${deckId} and user_id: ${session.user.id}`);
    const { data, error } = await supabase
      .from('decks')
      .select('name') // Select the correct column
      .eq('id', deckId)
      .eq('user_id', session.user.id)
      .single()

    appLogger.info("[API /api/decks/name] Supabase query result:", { data, error });

    if (error) {
      appLogger.error("[API /api/decks/name] Supabase query error:", error);
      // Handle specific errors like not found vs other DB errors
      if (error.code === 'PGRST116') { // PostgREST code for "Relation does not exist" or similar (check actual code if needed)
         return NextResponse.json({ error: 'Deck not found' }, { status: 404 })
      }
      throw error; // Re-throw other errors
    }

    if (!data) {
      return NextResponse.json({ error: 'Deck not found' }, { status: 404 })
    }

    appLogger.info("[API /api/decks/name] Successfully fetched name:", data.name);
    // Return just the name
    return NextResponse.json({ name: data.name })

  } catch (error) {
     const errorMessage = error instanceof Error ? error.message : String(error);
     appLogger.error('[API /api/decks/name] Caught error:', errorMessage, error);
     return NextResponse.json({ error: 'Failed to fetch deck name', details: errorMessage }, { status: 500 })
  }
} 
```

## Directory: app/api/extract-pdf

### File: app/api/extract-pdf/config.ts

```
// app/api/extract-pdf/config.ts
/**
 * Configuration module for the PDF/Image extraction and flashcard generation API.
 * Reads environment variables and defines constants.
 */

import { appLogger, statusLogger } from '@/lib/logger';

function getEnvVariable(key: string, optional: boolean = false): string | undefined {
    const value = process.env[key];
    if (!value && !optional) {
        appLogger.error(`[Config] Missing required environment variable: ${key}`);
        // In a real app, you might throw an error here or have a stricter startup check
        // For now, we log the error and allow the app to potentially fail later if the value is used.
    }
    return value;
}

// --- GCP Credentials ---
export const GCP_PROJECT_ID = getEnvVariable('GCP_PROJECT_ID');
export const GCP_SERVICE_ACCOUNT_EMAIL = getEnvVariable('GCP_SERVICE_ACCOUNT_EMAIL');
// Ensure newlines are correctly interpreted if present
export const GCP_PRIVATE_KEY = getEnvVariable('GCP_PRIVATE_KEY')?.replace(/\\n/g, '\n');

export const credentials = {
    client_email: GCP_SERVICE_ACCOUNT_EMAIL,
    private_key: GCP_PRIVATE_KEY,
};

// --- Document AI Configuration ---
export const DOCAI_LOCATION = getEnvVariable('DOCAI_LOCATION') || 'eu'; // Default to 'eu' if not set
export const DOCAI_PROCESSOR_ID = getEnvVariable('DOCAI_PROCESSOR_ID');
export const DOCAI_API_ENDPOINT = `${DOCAI_LOCATION}-documentai.googleapis.com`;

// --- Vertex AI Configuration ---
export const VERTEX_LOCATION = getEnvVariable('VERTEX_LOCATION') || 'us-central1'; // Default if not set
export const VERTEX_MODEL_NAME = getEnvVariable('VERTEX_MODEL_NAME') || 'gemini-2.0-flash-lite-001'; // Default model

// --- Processing Limits ---
export const PAGE_LIMIT = 30;
export const DOCAI_OCR_PAGE_LIMIT = 15; // Limit for default OCR mode
export const MAX_TEXT_CHARS_FOR_GEMINI = 50000;

// --- Validation Function ---
export function validateConfiguration(): boolean {
    const requiredVars = [
        GCP_PROJECT_ID,
        GCP_SERVICE_ACCOUNT_EMAIL,
        GCP_PRIVATE_KEY,
        DOCAI_LOCATION,
        DOCAI_PROCESSOR_ID,
        VERTEX_LOCATION,
        VERTEX_MODEL_NAME,
    ];

    const missingVars = requiredVars.filter(v => !v);

    if (missingVars.length > 0) {
        appLogger.error(`[Config Validation] FAILED: Missing required configuration. Check environment variables.`);
        // Logging which specific vars are missing was done by getEnvVariable
        return false;
    }

    appLogger.info(`[Config Validation] SUCCESS: All required configurations seem to be present.`);
    return true;
}

// Log configuration on module load for debugging purposes
appLogger.info(`[Config Loaded] API Configuration:
  - GCP Project ID: ${GCP_PROJECT_ID ? 'Configured' : 'MISSING!'}
  - GCP Service Account: ${GCP_SERVICE_ACCOUNT_EMAIL ? 'Configured' : 'MISSING!'}
  - GCP Private Key: ${GCP_PRIVATE_KEY ? 'Configured' : 'MISSING!'}
  - Doc AI Location: ${DOCAI_LOCATION}
  - Doc AI Processor ID: ${DOCAI_PROCESSOR_ID ? 'Configured' : 'MISSING!'}
  - Doc AI Endpoint: ${DOCAI_API_ENDPOINT}
  - Vertex AI Location: ${VERTEX_LOCATION}
  - Vertex AI Model: ${VERTEX_MODEL_NAME}
  - Page Limit: ${PAGE_LIMIT}
  - Doc AI OCR Page Limit: ${DOCAI_OCR_PAGE_LIMIT}
  - Max Gemini Chars: ${MAX_TEXT_CHARS_FOR_GEMINI}
`);

// Initial validation check during server startup/module load
// Note: This won't stop the server cold in Vercel, but logs the issue early.
// The POST handler should perform a runtime check as well.
validateConfiguration();
```

### File: app/api/extract-pdf/fileUtils.ts

```
// app/api/extract-pdf/fileUtils.ts
/**
 * Utilities for handling file types related to the extraction API.
 */

export type SupportedFileType = 'pdf' | 'image';

export const SUPPORTED_EXTENSIONS: Record<string, SupportedFileType> = {
  'jpg': 'image',
  'jpeg': 'image',
  'png': 'image',
  'gif': 'image', // Note: Animated GIFs might not extract well
  'bmp': 'image',
  'webp': 'image',
  'pdf': 'pdf',
};

/**
 * Determines the supported file type based on the filename extension.
 * @param filename The full filename (e.g., 'document.pdf', 'photo.jpg').
 * @returns The supported file type ('pdf' or 'image') or null if unsupported.
 */
export function getSupportedFileType(filename: string): SupportedFileType | null {
  if (!filename) {
      return null;
  }
  const extension = filename.split('.').pop()?.toLowerCase() || '';
  return SUPPORTED_EXTENSIONS[extension] || null;
}

/**
 * Maps file extensions to their common MIME types.
 * Used for providing hints to APIs.
 * @param filename The full filename.
 * @returns The common MIME type string or a default if unknown.
 */
export function getMimeTypeFromFilename(filename: string): string {
    const extension = filename.split('.').pop()?.toLowerCase() || '';
    switch (extension) {
        case 'pdf': return 'application/pdf';
        case 'jpg':
        case 'jpeg': return 'image/jpeg';
        case 'png': return 'image/png';
        case 'gif': return 'image/gif';
        case 'bmp': return 'image/bmp';
        case 'webp': return 'image/webp';
        default: return 'application/octet-stream'; // Default binary type
    }
}
```

### File: app/api/extract-pdf/flashcardGeneratorService.ts

```
// app/api/extract-pdf/flashcardGeneratorService.ts
/**
 * Service responsible for generating flashcards from text using Google Vertex AI (Gemini).
 * Handles structured output configuration and parsing, now in a multi-step process:
 * 1. generateInitialFlashcards: Detects mode/languages, generates basic Q/A.
 * 2. classifyTranslationFlashcards: Classifies grammar for translation flashcards.
 * 3. regenerateAsKnowledgeFlashcards: Re-generates flashcards forcing knowledge mode.
 */
import {
    VertexAI,
    HarmCategory,
    HarmBlockThreshold,
    Schema,
    SchemaType,
    GenerationConfig,
    SafetySetting
} from '@google-cloud/vertexai';
import { vertexAI } from './gcpClients';
import { VERTEX_MODEL_NAME, MAX_TEXT_CHARS_FOR_GEMINI } from './config';
import {
    ApiFlashcard, // Assuming ApiFlashcard type needs update elsewhere
    GenerationApiError
} from './types'; // Ensure types.ts is updated if necessary
import { appLogger, statusLogger } from '@/lib/logger';

// --- Internal Types (remain largely the same, but used differently) ---

// --- Basic Flashcard Structure (Output of Phase 1 & Knowledge Regen) ---
interface GeminiFlashcardInputBasic {
    question: string;
    answer: string;
}

// --- Phase 1 Output --- (Basic Generation + Mode/Lang)
export interface InitialGenerationResult {
    mode: 'translation' | 'knowledge';
    detectedQuestionLanguage: string;
    detectedAnswerLanguage: string;
    basicFlashcards: GeminiFlashcardInputBasic[];
}

// --- Phase 2 Input/Output (Classification) ---
export interface GeminiFlashcardClassification {
    questionPartOfSpeech: string;
    questionGender: string;
    answerPartOfSpeech: string;
    answerGender: string;
}
// Phase 2 function will return GeminiFlashcardClassification[]
interface GeminiStructuredOutputPhase2 {
    classifiedFlashcards: GeminiFlashcardClassification[];
}

// --- Vertex AI Schema Definitions (remain the same) ---

// Schema for Phase 1 and Knowledge Regeneration (Basic Q/A + Mode/Lang)
const flashcardSchemaBasic: Schema = {
    type: SchemaType.OBJECT,
    properties: {
      mode: { type: SchemaType.STRING, enum: ['translation', 'knowledge'], description: "The mode determined: 'translation' for word lists, 'knowledge' for prose." },
      detectedQuestionLanguage: { type: SchemaType.STRING, description: "The primary language detected for questions/source words (e.g., 'English', 'French')." },
      detectedAnswerLanguage: { type: SchemaType.STRING, description: "The secondary/target language detected for answers/translations (e.g., 'Dutch', 'Spanish'). Same as question language for 'knowledge' mode." },
      flashcards: {
        type: SchemaType.ARRAY, description: "An array of generated flashcard objects.",
        items: {
          type: SchemaType.OBJECT,
          properties: {
            question: { type: SchemaType.STRING, description: "The question or source word/phrase." },
            answer: { type: SchemaType.STRING, description: "The answer or target word/phrase/translation." },
          },
          required: ['question', 'answer']
        }
      }
    },
    required: ['mode', 'detectedQuestionLanguage', 'detectedAnswerLanguage', 'flashcards']
};

// Schema for Phase 2 (Classification Only)
const flashcardSchemaClassification: Schema = {
    type: SchemaType.OBJECT,
    description: "Output schema for grammatical classification of flashcards.",
    properties: {
        classifiedFlashcards: {
            type: SchemaType.ARRAY,
            description: "An array of classification objects, corresponding exactly to the input flashcard array.",
            items: {
                type: SchemaType.OBJECT,
                properties: {
                    questionPartOfSpeech: { type: SchemaType.STRING, description: "Part of Speech for the question word (e.g., 'Noun', 'Verb', 'N/A')." },
                    questionGender: { type: SchemaType.STRING, description: "Grammatical gender for the question word (e.g., 'Male', 'Female', 'N/A')." },
                    answerPartOfSpeech: { type: SchemaType.STRING, description: "Part of Speech for the answer word (e.g., 'Noun', 'Verb', 'N/A')." },
                    answerGender: { type: SchemaType.STRING, description: "Grammatical gender for the answer word (e.g., 'Male', 'Female', 'N/A')." }
                },
                required: ['questionPartOfSpeech', 'questionGender', 'answerPartOfSpeech', 'answerGender']
            }
        }
    },
    required: ['classifiedFlashcards']
};


// --- Configs (remain the same) ---
const safetySettings: SafetySetting[] = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];

// Generation Configs for different steps
const generationConfigBasic: GenerationConfig = {
    responseMimeType: 'application/json',
    responseSchema: flashcardSchemaBasic, // Use Basic schema
};

const generationConfigClassification: GenerationConfig = {
    responseMimeType: 'application/json',
    responseSchema: flashcardSchemaClassification, // Use Classification schema
};

// --- Mapped Output Type for FINAL result sent to client hook (includes classification) ---
// This type represents the final combined flashcard structure.
export interface MappedFlashcardCore {
    question: string;
    answer: string;
    questionLanguage: string;
    answerLanguage: string;
    isBilingual: boolean;
    questionPartOfSpeech: string;
    questionGender: string;
    answerPartOfSpeech: string;
    answerGender: string;
    // --- Add source and fileType for consistency with ApiFlashcard? Needed downstream? ---
    // source?: string; 
    // fileType?: string;
}

// --- Helper Functions (parseJsonResponse, callVertexAI - modified slightly) ---
function parseJsonResponse(jsonString: string, filename: string, stepName: string): any {
    try {
        return JSON.parse(jsonString);
    } catch (parseError: any) {
        appLogger.error(`[Generator Service] Error parsing JSON string in ${stepName} for ${filename}:`, parseError.message);
        appLogger.error(`[Generator Service] Received text content (${stepName}):`, jsonString);
        throw new GenerationApiError(`Failed to parse ${stepName} JSON response for ${filename}: ${parseError.message}`);
    }
}

// Updated to accept any expected output type based on the config/schema used
async function callVertexAI<T>(
    prompt: string,
    generationConfig: GenerationConfig,
    filename: string,
    stepName: string // e.g., 'Phase 1', 'Classification', 'Knowledge Regen'
): Promise<T> { 
    if (!vertexAI) {
        throw new GenerationApiError("Vertex AI client is not initialized.");
    }

    appLogger.info(`[Generator Service] ${stepName}: Sending prompt for ${filename} to ${VERTEX_MODEL_NAME}. Prompt length: ${prompt.length}`);

    const model = vertexAI.getGenerativeModel({
        model: VERTEX_MODEL_NAME,
        safetySettings: safetySettings,
        generationConfig: generationConfig,
    });

    const requestPayload = {
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
    };

    const result = await model.generateContent(requestPayload);
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content || !response.candidates[0].content.parts || response.candidates[0].content.parts.length === 0) {
        const finishReason = response?.candidates?.[0]?.finishReason;
        const safetyRatings = response?.candidates?.[0]?.safetyRatings;
        appLogger.error(`[Generator Service] ${stepName}: Invalid response structure or safety block for ${filename}. Reason: ${finishReason}`, safetyRatings);
        throw new GenerationApiError(`${stepName}: Invalid or empty response structure from AI for ${filename}. Finish Reason: ${finishReason}`);
    }

    const responsePart = response.candidates[0].content.parts[0];

    if (typeof responsePart === 'object' && responsePart !== null && 'text' in responsePart && typeof responsePart.text === 'string') {
        appLogger.info(`[Generator Service] ${stepName}: Found 'text' property for ${filename}. Parsing.`);
        return parseJsonResponse(responsePart.text, filename, stepName);
    } else {
         appLogger.warn(`[Generator Service] ${stepName}: Response part for ${filename} might be a direct JSON object (lacks 'text' property). Assuming direct object.`);
         if (typeof responsePart === 'object' && responsePart !== null) {
             return responsePart as T; // Assume it matches the expected structure T
         } else {
             appLogger.error(`[Generator Service] ${stepName}: Unexpected response part format for ${filename}. Expected object, got: ${typeof responsePart}. Content:`, String(responsePart));
             throw new GenerationApiError(`${stepName}: Unexpected response format from AI for ${filename}.`);
         }
     }
}


/**
 * STEP 1: Generates initial flashcards, detects mode and languages from text.
 * Does NOT perform grammatical classification.
 * @param text The extracted text content.
 * @param filename The original filename (for context in logging/errors).
 * @returns A promise resolving to the initial generation result.
 */
export async function generateInitialFlashcards(
    text: string,
    filename: string
): Promise<InitialGenerationResult> { // Return specific type for Step 1
    if (!vertexAI) {
        throw new GenerationApiError("Vertex AI client is not initialized. Check configuration.");
    }
    if (!text || text.trim().length < 10) {
        appLogger.warn(`[Generator Service - Step 1] Input text for ${filename} is too short or empty. Skipping generation.`);
        // Return a default structure indicating failure or empty state
        return { mode: 'knowledge', detectedQuestionLanguage: 'N/A', detectedAnswerLanguage: 'N/A', basicFlashcards: [] };
    }

    appLogger.info(`[Generator Service - Step 1] Starting initial generation for: ${filename}`);

    const truncatedText = text.length > MAX_TEXT_CHARS_FOR_GEMINI
        ? text.slice(0, MAX_TEXT_CHARS_FOR_GEMINI) + `\n\n...(text truncated at ${MAX_TEXT_CHARS_FOR_GEMINI} characters for brevity)`
        : text;

    // --- Use Phase 1 Prompt (unchanged logic, just generating basic Q/A) ---
    const promptPhase1 = `
**Goal:** Analyze the provided text, determine the mode ('translation' or 'knowledge'), detect languages, generate basic question/answer flashcards, and prepare the output as structured JSON.

**Instructions:**

1.  **Analyze Content:** Read the text provided below under "Document Text". You are a teacher who is creating flashcards for his students.
2.  **Determine Mode & Languages:**
    *   Identify if the text is primarily a 'translation' list (pairs of words/phrases in different languages) or 'knowledge' text (prose, factual information in a single primary language). Assign 'translation' or 'knowledge' to the \`mode\` field.
    *   Detect the primary language used for the questions or source words. Assign this language name (e.g., 'English', 'German') to the \`detectedQuestionLanguage\` field.
    *   Detect the secondary/target language used for answers or translations. Assign this language name (e.g., 'Spanish', 'French') to the \`detectedAnswerLanguage\` field.
        *   If \`mode\` is 'translation', \`detectedAnswerLanguage\` should typically be different from \`detectedQuestionLanguage\`.
        *   If \`mode\` is 'knowledge', \`detectedAnswerLanguage\` must be the *same* as \`detectedQuestionLanguage\`.
3.  **Generate Basic Flashcards:** Create an array of flashcard objects for the \`flashcards\` field based on the determined mode:
    *   **If Mode is 'translation':**
        *   Create one flashcard object for each distinct word/phrase pair found in the text.
        *   Use the source language word/phrase for the \`question\` field.
        *   Use the target language word/phrase for the \`answer\` field.
    *   **If Mode is 'knowledge':**
        *   Generate multiple high-quality flashcards
        *   Aim for at least 2-3 per main topic or distinct paragraph.
        *   Create as many fashcards as needed in order for the reader to test whether he truly understands the text.
        *   Create a \`question\` that tests understanding or recall of a key concept from the text. Avoid trivial questions.
        *   Provide a concise (ideally under 100 words) and accurate \`answer\` derived directly from the text.
        *   Both \`question\` and \`answer\` must be in the \`detectedQuestionLanguage\`.
4.  **Format Output:** Structure your *entire response* as a single JSON object containing the \`mode\`, \`detectedQuestionLanguage\`, \`detectedAnswerLanguage\`, and \`flashcards\` fields. Each object within the \`flashcards\` array must contain only \`question\` and \`answer\` fields. Adhere strictly to this structure.

**Example \`flashcards\` array content for 'translation' mode:**
\`[ { "question": "la table", "answer": "the table" }, { "question": "le livre", "answer": "the book" }, { "question": "aller", "answer": "to go" } ]\`

**Example \`flashcards\` array content for 'knowledge' mode:**
\`[ { "question": "What is the primary function of the mitochondria?", "answer": "The primary function of mitochondria is to generate most of the cell's supply of adenosine triphosphate (ATP), used as a source of chemical energy." } ]\`

**Important Constraints:**
*   Your final output must be *only* the JSON object. Do not include any introductory text, explanations, or markdown formatting around the JSON.
*   Accurately determine the \`mode\` and languages based *only* on the provided text.
*   Ensure language consistency as described in step 2.
*   Strictly adhere to the output format. The \`flashcards\` array must only contain objects with \`question\` and \`answer\`.

**Document Text:**

"""
${truncatedText}
"""
`;

    // Type alias for clarity
    type Step1OutputType = { mode: 'translation' | 'knowledge', detectedQuestionLanguage: string, detectedAnswerLanguage: string, flashcards: GeminiFlashcardInputBasic[] };

    try {
        const step1Result = await callVertexAI<Step1OutputType>(promptPhase1, generationConfigBasic, filename, 'Step 1 - Initial Generation');

        // --- Validate Step 1 Response --- 
        if (!step1Result || typeof step1Result !== 'object' ||
            !step1Result.mode || typeof step1Result.mode !== 'string' || !['translation', 'knowledge'].includes(step1Result.mode) ||
            !step1Result.detectedQuestionLanguage || typeof step1Result.detectedQuestionLanguage !== 'string' ||
            !step1Result.detectedAnswerLanguage || typeof step1Result.detectedAnswerLanguage !== 'string' ||
            !Array.isArray(step1Result.flashcards))
        {
            appLogger.error(`[Generator Service - Step 1] JSON for ${filename} does NOT match required base schema fields/types. Received:`, JSON.stringify(step1Result, null, 2));
            throw new GenerationApiError(`Step 1 AI response JSON base structure mismatch for ${filename}. Received: ${JSON.stringify(step1Result)}`);
        }

        for (const card of step1Result.flashcards) {
             if (typeof card !== 'object' || card === null ||
                 typeof card.question !== 'string' ||
                 typeof card.answer !== 'string')
             {
                 appLogger.error(`[Generator Service - Step 1] Invalid flashcard structure within the array for ${filename}. Received card:`, JSON.stringify(card, null, 2));
                 throw new GenerationApiError(`Step 1 AI response flashcard structure mismatch for ${filename}.`);
             }
         }

        appLogger.info(`[Generator Service - Step 1] successful for ${filename}. Mode: ${step1Result.mode}, QLang: ${step1Result.detectedQuestionLanguage}, ALang: ${step1Result.detectedAnswerLanguage}, Cards: ${step1Result.flashcards.length}`);

        // Return the structured result
        return {
            mode: step1Result.mode,
            detectedQuestionLanguage: step1Result.detectedQuestionLanguage,
            detectedAnswerLanguage: step1Result.detectedAnswerLanguage,
            basicFlashcards: step1Result.flashcards
        };

    } catch (error: any) {
        appLogger.error(`[Generator Service - Step 1] Error during initial generation for ${filename}:`, error.message);
        if (error.stack) appLogger.error(error.stack);
        if (error instanceof GenerationApiError) throw error;
        throw new GenerationApiError(`Unexpected error during Step 1 generation for ${filename}: ${error.message}`);
    }
}

/**
 * STEP 2 (Optional): Classifies grammatical properties for translation flashcards.
 * @param basicFlashcards Array of Q/A pairs from Step 1.
 * @param filename Original filename for logging.
 * @returns A promise resolving to an array of classification objects.
 */
export async function classifyTranslationFlashcards(
    basicFlashcards: GeminiFlashcardInputBasic[],
    filename: string
): Promise<GeminiFlashcardClassification[]> { 
    if (basicFlashcards.length === 0) {
        appLogger.info(`[Generator Service - Step 2 Classify] No flashcards provided for classification for ${filename}.`);
        return [];
    }

    appLogger.info(`[Generator Service - Step 2 Classify] Starting classification for ${basicFlashcards.length} cards from ${filename}.`);

    // Prepare input for Phase 2 prompt (same as before)
    const inputJsonForPhase2 = JSON.stringify(basicFlashcards, null, 2);
    // Use Phase 2 Prompt (same as before)
    const promptPhase2 = `
**Goal:** Perform grammatical classification (Part of Speech and Gender) for the provided list of translation flashcards.

**Input:** You are given a JSON array of flashcard objects, each containing a "question" (source word/phrase) and an "answer" (target word/phrase).

**Instructions:**

1.  **Analyze Each Flashcard:** For *each* object in the input array below:
    *   **a. Classify Question Word:** Identify the primary vocabulary word in the \`question\` field. Determine its Part of Speech (PoS) and Gender (if applicable).
    *   **b. Classify Answer Word:** Identify the primary vocabulary word in the \`answer\` field. Determine its Part of Speech (PoS) and Gender (if applicable).
2.  **Use Allowed Values:**
    *   **Part of Speech:** Use *only* one of: 'Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other', 'N/A'.
    *   **Gender:** Use *only* one of: 'Male', 'Female', 'Neuter', 'N/A'. Use 'N/A' if gender is linguistically irrelevant for the word/language (e.g., English nouns, verbs, adjectives) or cannot be reliably determined.
3.  **Format Output:** Structure your *entire response* as a single JSON object containing exactly one key: \`classifiedFlashcards\`. The value of this key must be an array of classification objects.
    *   This output array must have the *exact same number of elements* as the input flashcard array.
    *   Each object in the \`classifiedFlashcards\` array must correspond positionally to the object in the input array.
    *   Each classification object must contain the fields: \`questionPartOfSpeech\`, \`questionGender\`, \`answerPartOfSpeech\`, and \`answerGender\`, using the allowed values from step 2.

**Example Input Flashcards JSON:**
\`[ { "question": "la table", "answer": "the table" }, { "question": "bon", "answer": "good" }, { "question": "aller", "answer": "to go" } ]\`

**Example Corresponding Output JSON:**
\`{ "classifiedFlashcards": [ { "questionPartOfSpeech": "Noun", "questionGender": "Female", "answerPartOfSpeech": "Noun", "answerGender": "N/A" }, { "questionPartOfSpeech": "Adjective", "questionGender": "Male", "answerPartOfSpeech": "Adjective", "answerGender": "N/A" }, { "questionPartOfSpeech": "Verb", "questionGender": "N/A", "answerPartOfSpeech": "Verb", "answerGender": "N/A" } ] }\`

**Important Constraints:**
*   Your final output must be *only* the JSON object containing the \`classifiedFlashcards\` array. Do not include any introductory text, explanations, or markdown formatting.
*   The output array length *must* match the input array length.
*   Strictly adhere to the classification value lists provided.

**Input Flashcards JSON:**

"""json
${inputJsonForPhase2}
"""
`;

    try {
        // Type alias for clarity
        type Step2OutputType = { classifiedFlashcards: GeminiFlashcardClassification[] };
        const step2Result = await callVertexAI<Step2OutputType>(promptPhase2, generationConfigClassification, filename, 'Step 2 - Classification');

        // --- Log Raw Result --- 
        appLogger.info(`[Generator Service - Step 2 Classify] Raw Result for ${filename}:`, JSON.stringify(step2Result, null, 2));

        // --- Validate Classification Response --- 
        if (!step2Result || typeof step2Result !== 'object' || !Array.isArray(step2Result.classifiedFlashcards)) {
            appLogger.error(`[Generator Service - Step 2 Classify] JSON for ${filename} does NOT match required schema. Expected { classifiedFlashcards: [...] }. Received:`, JSON.stringify(step2Result, null, 2));
            throw new GenerationApiError(`Step 2 Classification AI response JSON structure mismatch for ${filename}.`);
        }

        // Log warning on count mismatch, but still return the data we got
        if (step2Result.classifiedFlashcards.length !== basicFlashcards.length) {
            appLogger.warn(`[Generator Service - Step 2 Classify] Classification count mismatch for ${filename}. Expected ${basicFlashcards.length}, Received ${step2Result.classifiedFlashcards.length}. Proceeding with available data.`);
        }

        // Validate individual classification objects (optional but good practice)
        for (const classification of step2Result.classifiedFlashcards) {
             if (typeof classification !== 'object' || classification === null ||
                 typeof classification.questionPartOfSpeech !== 'string' ||
                 typeof classification.questionGender !== 'string' ||
                 typeof classification.answerPartOfSpeech !== 'string' ||
                 typeof classification.answerGender !== 'string')
             {
                 appLogger.error(`[Generator Service - Step 2 Classify] Invalid classification structure for ${filename}. Received:`, JSON.stringify(classification, null, 2));
                 // Decide whether to throw or just skip/default this specific item
                 throw new GenerationApiError(`Step 2 Classification AI response contains invalid classification object structure for ${filename}.`);
             }
         }

        appLogger.info(`[Generator Service - Step 2 Classify] successful for ${filename}. Classified ${step2Result.classifiedFlashcards.length} cards.`);
        return step2Result.classifiedFlashcards;

    } catch (error: any) {
        appLogger.error(`[Generator Service - Step 2 Classify] Error during classification for ${filename}. Returning empty array. Error:`, error.message);
        if (error.stack) appLogger.error(error.stack);
        // Return empty array on error, let downstream handle merging defaults
        return [];
    }
}

/**
 * STEP 2 (Alternative): Regenerates flashcards forcing knowledge mode.
 * @param text The original extracted text content.
 * @param filename The original filename (for context in logging/errors).
 * @returns A promise resolving to basic Q/A flashcards and detected languages.
 */
export async function regenerateAsKnowledgeFlashcards(
    text: string,
    filename: string
): Promise<{ detectedQuestionLanguage: string; detectedAnswerLanguage: string; basicFlashcards: GeminiFlashcardInputBasic[] }> { // Return similar structure to step 1, but mode is fixed
    if (!vertexAI) {
        throw new GenerationApiError("Vertex AI client is not initialized. Check configuration.");
    }
    if (!text || text.trim().length < 10) {
        appLogger.warn(`[Generator Service - Step 2 Knowledge Regen] Input text for ${filename} is too short or empty. Skipping generation.`);
        return { detectedQuestionLanguage: 'N/A', detectedAnswerLanguage: 'N/A', basicFlashcards: [] };
    }

    appLogger.info(`[Generator Service - Step 2 Knowledge Regen] Starting knowledge regeneration for: ${filename}`);

    const truncatedText = text.length > MAX_TEXT_CHARS_FOR_GEMINI
        ? text.slice(0, MAX_TEXT_CHARS_FOR_GEMINI) + `\n\n...(text truncated at ${MAX_TEXT_CHARS_FOR_GEMINI} characters for brevity)`
        : text;

    // --- Adapt the Phase 1 prompt for KNOWLEDGE mode generation ONLY ---
    // Define the prompt variable
    const promptKnowledge = `\n**Goal:** Analyze the provided text, determine its primary language, generate high-quality knowledge-based question/answer flashcards, and prepare the output as structured JSON in 'knowledge' mode.\n\n**Instructions:**\n\n1.  **Analyze Content:** Read the text provided below under \"Document Text\". You are a teacher creating flashcards for students based *only* on this text.\n2.  **Determine Language:**\n    *   Potentially the document contains multiple languages. Detect the  primary language used in the text content. Assign this language name (e.g., 'English', 'German') to *both* the \`detectedQuestionLanguage\` and \`detectedAnswerLanguage\` fields.\n3.  **Generate Knowledge Flashcards:** Create an array of flashcard objects for the \`flashcards\` field based on the text content:\n    *   Generate multiple high-quality flashcards.\n    *   Aim for at least 3-5 per main topic or distinct paragraph, or more if it is needed to capture the knowledge of a student for this paragraph.\n    *   Create as many flashcards as needed for a reader to test their understanding of the text.\n    *   Create a \`question\` that tests understanding or recall of a key concept, fact, or relationship explicitly described in the Document Text. Avoid trivial questions or questions about the generation process/metadata.\n    *   Provide a concise (ideally under 100 words) and accurate \`answer\` derived **directly and only from the Document Text**.\n    *   Both \`question\` and \`answer\` must be in the \`detectedQuestionLanguage\`.\n4.  **Set Mode:** The \`mode\` field in your output MUST be set to \"knowledge\".\n5.  **Format Output:** Structure your *entire response* as a single JSON object containing the \`mode\` (fixed as \"knowledge\"), \`detectedQuestionLanguage\`, \`detectedAnswerLanguage\` (same as question language), and \`flashcards\` fields. Each object within the \`flashcards\` array must contain only \`question\` and \`answer\` fields. Adhere strictly to this structure.\n\n**Example Output JSON (Knowledge Mode):**\n\`{ \"mode\": \"knowledge\", \"detectedQuestionLanguage\": \"English\", \"detectedAnswerLanguage\": \"English\", \"flashcards\": [ { \"question\": \"What is the primary function of the mitochondria?\", \"answer\": \"The primary function of mitochondria is to generate most of the cell's supply of adenosine triphosphate (ATP), used as a source of chemical energy.\" }, { \"question\": \"Where does the Krebs cycle occur?\", \"answer\": \"The Krebs cycle occurs in the mitochondrial matrix.\" } ] }\`\n\n**Important Constraints:**\n*   Your final output must be *only* the JSON object. Do not include any introductory text, explanations, or markdown formatting around the JSON.\n*   The \`mode\` MUST be \"knowledge\".\n*   \`detectedAnswerLanguage\` MUST be identical to \`detectedQuestionLanguage\`.\n*   Flashcards must test understanding of the **provided Document Text content ONLY**.\n\n**Document Text:**\n\n\"\"\"\n${truncatedText}\n\"\"\"\n`;

    // Type alias for clarity (same structure as Step 1 output)
    // Define the type alias
    type KnowledgeRegenOutputType = { mode: 'knowledge', detectedQuestionLanguage: string, detectedAnswerLanguage: string, flashcards: GeminiFlashcardInputBasic[] };

    try {
        // --- Reduce logging verbosity for Step 2 prompt ---\
        // appLogger.info(`[Generator Service - Step 2 Knowledge Regen] Full prompt for ${filename}:`);\
        // appLogger.info("--- PROMPT START ---");\
        // appLogger.info(promptKnowledge); // <-- Don't log the full prompt
        appLogger.info(`[Generator Service - Step 2 Knowledge Regen] Preparing prompt for ${filename}. Text length being included: ${truncatedText.length}`);
        // ----------------------------------------------------\n\n        // Pass the correct prompt variable to callVertexAI\n        const knowledgeResult = await callVertexAI<KnowledgeRegenOutputType>(promptKnowledge, generationConfigBasic, filename, 'Step 2 - Knowledge Regen');\n\n        // --- Validate Knowledge Regen Response ---
        appLogger.info("--- PROMPT END ---");
        appLogger.info(`[Generator Service - Step 2 Knowledge Regen] Preparing prompt for ${filename}. Text length being included: ${truncatedText.length}`);
        // ----------------------------------------------------\n\n        // Pass the correct prompt variable to callVertexAI\n        const knowledgeResult = await callVertexAI<KnowledgeRegenOutputType>(promptKnowledge, generationConfigBasic, filename, 'Step 2 - Knowledge Regen');\n\n        // --- Validate Knowledge Regen Response ---

        // Add log to inspect the full prompt being sent (Corrected Syntax)
        appLogger.info(`[Generator Service - Step 2 Knowledge Regen] Full prompt for ${filename}:`);
        appLogger.info("--- PROMPT START ---");
        appLogger.info(promptKnowledge);
        appLogger.info("--- PROMPT END ---");
        // Pass the correct prompt variable to callVertexAI
        const knowledgeResult = await callVertexAI<KnowledgeRegenOutputType>(promptKnowledge, generationConfigBasic, filename, 'Step 2 - Knowledge Regen');

        // --- Validate Knowledge Regen Response ---
        if (!knowledgeResult || typeof knowledgeResult !== 'object' ||
            knowledgeResult.mode !== 'knowledge' || // Mode MUST be knowledge
            !knowledgeResult.detectedQuestionLanguage || typeof knowledgeResult.detectedQuestionLanguage !== 'string' ||
            !knowledgeResult.detectedAnswerLanguage || typeof knowledgeResult.detectedAnswerLanguage !== 'string' ||
            knowledgeResult.detectedQuestionLanguage !== knowledgeResult.detectedAnswerLanguage || // Languages MUST match
            !Array.isArray(knowledgeResult.flashcards))
        {
            appLogger.error(`[Generator Service - Step 2 Knowledge Regen] JSON for ${filename} does NOT match required knowledge schema. Received:`, JSON.stringify(knowledgeResult, null, 2));
            throw new GenerationApiError(`Step 2 Knowledge Regen AI response JSON structure/content mismatch for ${filename}. Received: ${JSON.stringify(knowledgeResult)}`);
        }

        // Validate individual flashcards (same as step 1)
        for (const card of knowledgeResult.flashcards) {
             if (typeof card !== 'object' || card === null ||
                 typeof card.question !== 'string' ||
                 typeof card.answer !== 'string')
             {
                 appLogger.error(`[Generator Service - Step 2 Knowledge Regen] Invalid flashcard structure for ${filename}. Received card:`, JSON.stringify(card, null, 2));
                 throw new GenerationApiError(`Step 2 Knowledge Regen AI response flashcard structure mismatch for ${filename}.`);
             }
         }

        appLogger.info(`[Generator Service - Step 2 Knowledge Regen] successful for ${filename}. QLang: ${knowledgeResult.detectedQuestionLanguage}, Cards: ${knowledgeResult.flashcards.length}`);

        // Return the relevant parts
        return {
            detectedQuestionLanguage: knowledgeResult.detectedQuestionLanguage,
            detectedAnswerLanguage: knowledgeResult.detectedAnswerLanguage, // Will be same as QLang
            basicFlashcards: knowledgeResult.flashcards
        };

    } catch (error: any) {
        appLogger.error(`[Generator Service - Step 2 Knowledge Regen] Error during knowledge regeneration for ${filename}:`, error.message);
        if (error.stack) appLogger.error(error.stack);
        if (error instanceof GenerationApiError) throw error;
        throw new GenerationApiError(`Unexpected error during Step 2 Knowledge Regen for ${filename}: ${error.message}`);
    }
}

// Removed the old monolithic generateFlashcards function
```

### File: app/api/extract-pdf/gcpClients.ts

```
// app/api/extract-pdf/gcpClients.ts
/**
 * Initializes and exports configured GCP service clients.
 */
import { VertexAI } from '@google-cloud/vertexai';
import { ImageAnnotatorClient } from '@google-cloud/vision';
import { DocumentProcessorServiceClient } from '@google-cloud/documentai';
import { appLogger, statusLogger } from '@/lib/logger';

import * as config from './config';

// Ensure configuration is valid before attempting to create clients
if (!config.validateConfiguration()) {
    // Log a critical error, but avoid throwing here to prevent breaking module resolution
    // during potential build phases. The API route handler will perform the runtime check.
    appLogger.error("[GCP Clients] CRITICAL: Cannot initialize clients due to missing configuration.");
}

// Document AI client
const docAIClientOptions = {
    credentials: config.credentials,
    projectId: config.GCP_PROJECT_ID,
    apiEndpoint: config.DOCAI_API_ENDPOINT,
};
// Conditionally create clients only if config is likely valid
export const docAIClient = (config.GCP_PROJECT_ID && config.GCP_SERVICE_ACCOUNT_EMAIL && config.GCP_PRIVATE_KEY && config.DOCAI_PROCESSOR_ID)
    ? new DocumentProcessorServiceClient(docAIClientOptions)
    : null;

// Vision AI client
export const visionClient = (config.GCP_PROJECT_ID && config.GCP_SERVICE_ACCOUNT_EMAIL && config.GCP_PRIVATE_KEY)
    ? new ImageAnnotatorClient({
          credentials: config.credentials,
          projectId: config.GCP_PROJECT_ID
      })
    : null;

// Vertex AI client
export const vertexAI = (config.GCP_PROJECT_ID && config.GCP_SERVICE_ACCOUNT_EMAIL && config.GCP_PRIVATE_KEY)
    ? new VertexAI({
          project: config.GCP_PROJECT_ID!, // Use non-null assertion after validation check
          location: config.VERTEX_LOCATION,
          googleAuthOptions: { credentials: config.credentials }
      })
    : null;

// Log client initialization status
if (!docAIClient || !visionClient || !vertexAI) {
    appLogger.warn("[GCP Clients] One or more GCP clients could not be initialized due to missing configuration. API functionality will be limited.");
} else {
    appLogger.info("[GCP Clients] Document AI, Vision AI, and Vertex AI clients initialized.");
}
```

### File: app/api/extract-pdf/route.ts

```
// app/api/extract-pdf/route.ts
/**
 * API Route Handler for extracting text from PDF/Image files
 * and generating INITIAL flashcards using AI.
 * Orchestrates calls to text extraction and initial flashcard generation services.
 */
import { NextRequest, NextResponse } from 'next/server';
import { getFileFromStorage } from '@/lib/actions/storageActions';
import { validateConfiguration, GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, GCP_PRIVATE_KEY, PAGE_LIMIT } from './config';
import { getSupportedFileType, SupportedFileType } from './fileUtils';
import { extractText } from './textExtractorService';
// --- Import INITIAL generator function and its return type --- 
import { generateInitialFlashcards, InitialGenerationResult } from './flashcardGeneratorService'; 
// --- ApiFlashcard is no longer the direct output here --- 
import { /* ApiFlashcard, */ SkippedFile, PageLimitExceededError, ExtractionApiError, GenerationApiError } from './types'; 
import { appLogger, statusLogger } from '@/lib/logger';

// --- Runtime Configuration (Vercel specific) ---
export const config = {
  runtime: 'nodejs',
  regions: ['iad1'],
  maxDuration: 90,
  api: {
    bodyParser: {
      sizeLimit: '26mb'
    }
  }
};

// --- API Handlers ---

// GET Handler (No changes needed)
export async function GET(request: NextRequest) {
  if (!validateConfiguration()) {
    return NextResponse.json({
        message: 'API is potentially misconfigured. Check server logs.',
        status: 'error',
        timestamp: new Date().toISOString()
    }, { status: 500 });
  }
  return NextResponse.json({
    message: 'Flashcard generation API is active. Use POST method to process files.',
    status: 'ok',
    timestamp: new Date().toISOString(),
  });
}

// OPTIONS Handler (No changes needed)
export async function OPTIONS(request: NextRequest) {
  const origin = request.headers.get('origin') || '*';
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400',
    },
  });
}


// POST Handler
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  appLogger.info(`[API Route POST] Request received at ${new Date(startTime).toISOString()}`);

  // Runtime Credential/Config Check (No changes needed)
  if (!GCP_PROJECT_ID || !GCP_SERVICE_ACCOUNT_EMAIL || !GCP_PRIVATE_KEY) {
      appLogger.error('[API Route POST] CRITICAL: Missing required GCP credentials. Aborting.');
      return NextResponse.json({
          success: false, message: 'Server configuration error: Missing necessary credentials.', code: 'MISSING_CREDENTIALS'
      }, { status: 500 });
  }
   if (!validateConfiguration()) {
       appLogger.error('[API Route POST] CRITICAL: Core configuration validation failed. Aborting.');
       return NextResponse.json({
           success: false, message: 'Server configuration error: Invalid or missing configuration.', code: 'INVALID_CONFIG'
      }, { status: 500 });
    }

  // Initialization
  let skippedFiles: SkippedFile[] = [];
  // --- Store initial results per file --- 
  let allInitialResults: InitialGenerationResult[] = [];
  let allResultsInfo: { filename: string; type: SupportedFileType; pages: number; characters: number; initialFlashcardsGenerated: number }[] = [];
  let totalPagesProcessed = 0;
  let combinedTextPreview = "";
  // --- Add array to store full extracted text per file ---
  let allExtractedTexts: { filename: string; extractedText: string }[] = [];

  try {
    const contentType = request.headers.get('content-type') || '';

    // File Processing Logic (No changes needed in setup)
    interface FileSource {
        filename: string;
        getBuffer: () => Promise<ArrayBuffer>;
        fileTypeHint?: string;
    }
    let fileSources: FileSource[] = [];

    // 1. Determine File Sources (No changes needed here)
    if (contentType.includes('application/json')) {
      const jsonData = await request.json();
      const fileReferences = jsonData.files as { filename: string, filePath: string }[];
      if (!fileReferences || !Array.isArray(fileReferences) || fileReferences.length === 0) {
            return NextResponse.json({ success: false, message: 'Invalid or empty file list provided in JSON request', code: 'INVALID_INPUT' }, { status: 400 });
        }
        appLogger.info(`[API Route POST] Processing ${fileReferences.length} files from storage paths via JSON payload.`);
        fileSources = fileReferences.map(ref => ({
            filename: ref.filename,
            getBuffer: async () => {
                appLogger.info(`[API Route POST] Fetching buffer for ${ref.filename} from storage path ${ref.filePath}`);
                const buffer = await getFileFromStorage(ref.filePath);
                if (!buffer || buffer.byteLength === 0) throw new Error(`File not found or empty in storage at path: ${ref.filePath}`);
                return buffer;
            }
        }));
    } else if (contentType.includes('multipart/form-data')) {
        appLogger.info('[API Route POST] Handling multipart/form-data request.');
        const formData = await request.formData();
        const files = formData.getAll('file') as File[];
        if (!files || files.length === 0) {
            return NextResponse.json({ success: false, message: 'No files provided in form-data', code: 'NO_FILES' }, { status: 400 });
        }
        appLogger.info(`[API Route POST] Received ${files.length} file(s) from FormData.`);
        fileSources = files.map((file, i) => ({
            filename: file.name || `Unnamed File ${i+1}`,
            getBuffer: async () => {
                if (!file.name || file.size === 0 || typeof file.arrayBuffer !== 'function') throw new Error('Invalid file data (missing name, zero size, or methods)');
                return file.arrayBuffer();
            },
            fileTypeHint: file.type
        }));
    } else {
        appLogger.warn(`[API Route POST] Received request with unsupported content type: ${contentType}`);
        return NextResponse.json({ success: false, message: `Unsupported content type: ${contentType}. Please use application/json or multipart/form-data.`, code: 'UNSUPPORTED_CONTENT_TYPE'}, { status: 415 });
    }

    // 2. Process Each File Source Sequentially
    for (const source of fileSources) {
        const fileStartTime = Date.now();
        appLogger.info(`[API Route POST] Processing file: ${source.filename}`);
        let fileBuffer: ArrayBuffer | null = null;
        let fileType: SupportedFileType | null = null;

        try {
            // Steps a, b, c, d (No changes needed here)
            fileType = getSupportedFileType(source.filename);
            if (!fileType) throw new Error('Unsupported file type');
            fileBuffer = await source.getBuffer();
            appLogger.info(`[API Route POST] Attempting text extraction for ${source.filename} (Type: ${fileType})`);
            const extractionResult = await extractText(fileBuffer, source.filename, fileType);
            // --- Log the raw extracted text immediately ---
            appLogger.info(`[API Route POST] Raw server-extracted text for ${source.filename} (first 500 chars):\n`, extractionResult.text.substring(0, 500));
            // -------------------------------------------
            appLogger.info(`[API Route POST] Text extraction successful for ${source.filename}. Characters: ${extractionResult.info.metadata.characters}, Pages: ${extractionResult.info.pages}`);
            totalPagesProcessed += extractionResult.info.pages;
            combinedTextPreview += `--- Content from ${source.filename} ---\n${extractionResult.text.slice(0, 200)}...\n\n`;

            // --- Store the FULL extracted text ---
            allExtractedTexts.push({ filename: source.filename, extractedText: extractionResult.text });

            // --- Step e: Initial Flashcard Generation --- 
            let initialResult: InitialGenerationResult | null = null; // Variable to hold result for this file
            if (extractionResult.text && extractionResult.text.trim().length > 0) {
                appLogger.info(`[API Route POST] Attempting initial flashcard generation for ${source.filename}`);

                // --- Call the INITIAL generation service --- 
                initialResult = await generateInitialFlashcards(extractionResult.text, source.filename);
                // -------------------------------------------

                // Add source filename to the result for grouping later if needed (though client might handle this)
                // initialResult.source = source.filename;
                
                allInitialResults.push(initialResult);
                appLogger.info(`[API Route POST] Initial generation complete for ${source.filename}. Mode: ${initialResult.mode}, Cards: ${initialResult.basicFlashcards.length}`);
            } else {
                 appLogger.info(`[API Route POST] Skipping flashcard generation for ${source.filename} due to empty extracted text.`);
            }
            allResultsInfo.push({
                filename: source.filename,
                type: fileType!,
                pages: extractionResult.info.pages,
                characters: extractionResult.info.metadata.characters,
                initialFlashcardsGenerated: initialResult?.basicFlashcards.length || 0, // Count from initial result
            });
            appLogger.info(`[API Route POST] Successfully processed ${source.filename}. Time: ${Date.now() - fileStartTime}ms`);

        } catch (error: any) {
            appLogger.error(`[API Route POST] Error processing file ${source.filename}: ${error.message}`);
            let reason = error.message || 'Unknown processing error';
            let pages: number | undefined = undefined;
            let errorCode: string | undefined = undefined;

            if (error instanceof PageLimitExceededError) {
                reason = error.message;
                pages = error.pageCount;
                errorCode = 'PAGE_LIMIT_EXCEEDED';
            } else if (error instanceof ExtractionApiError || error instanceof GenerationApiError) {
                reason = `${error.name}: ${error.message.substring(0, 200)}${error.message.length > 200 ? '...' : ''}`;
                 if (error instanceof GenerationApiError && error.reason) {
                     reason += ` (Reason: ${error.reason})`;
                 }
            } else if (reason.includes('Invalid file data')) {
                 reason = 'Invalid file data provided';
            } else if (reason === 'Unsupported file type') {
                // Keep reason as is
            } else if (reason.includes('storage')) {
                 reason = `Storage access error: ${reason.substring(0,150)}...`;
            } else {
                 reason = `Processing error: ${reason.substring(0,150)}...`;
            }

            skippedFiles.push({ filename: source.filename, pages: pages, reason: reason, code: errorCode });
            continue;
        }
    }

    // Final Response Aggregation (No changes needed here)
    const endTime = Date.now();
    const duration = endTime - startTime;
    const processedCount = allResultsInfo.length;
    const skippedCount = skippedFiles.length;
    const totalInitialCards = allInitialResults.reduce((sum, res) => sum + res.basicFlashcards.length, 0);
    appLogger.info(`[API Route POST] Initial processing finished. Duration: ${duration}ms. Processed: ${processedCount}, Skipped: ${skippedCount}, Total Initial Flashcards: ${totalInitialCards}`);

    if (processedCount === 0) {
        let message = 'No files could be processed successfully.';
        let status = 400;
        let code = 'PROCESSING_FAILED'; // Default code

        // --- Check if the first skipped file has our specific error code --- 
        if (skippedCount === 1 && skippedFiles[0].code === 'PAGE_LIMIT_EXCEEDED') { 
            // Use the specific reason from the skipped file as the primary message
            message = skippedFiles[0].reason; 
            // Set the specific code for the client to handle
            code = skippedFiles[0].code; // Use the code from the skipped file object
            appLogger.info(`[API Route POST] Setting error code to ${code} for page limit exceeded error`);
        } else if (skippedCount > 0) {
            message = `Processed 0 files successfully. ${skippedCount} file(s) were skipped. See 'skippedFiles' for details.`;
            // Ensure code remains PROCESSING_FAILED if it wasn't a page limit error
            code = 'PROCESSING_FAILED'; 
        }
        // --------------------------------------------------------------------

        // --- Log the final code and message being sent ---
        appLogger.info(`[API Route POST] Returning error response. Code: ${code}, Message: ${message}`);
        appLogger.info(`[API Route POST] skippedFiles: ${JSON.stringify(skippedFiles)}`);
        // --------------------------------------------------

        return NextResponse.json({
            success: false, message, code, skippedFiles,
            // Ensure these fields are present even in error cases for consistent structure
            initialResults: [],
            extractedTexts: [],
            fileInfo: { pages: 0, files: 0, metadata: { sources: [] } },
        }, { status });
    }

    const finalFileInfo = {
        pages: totalPagesProcessed, files: processedCount, metadata: { sources: allResultsInfo }
    };

    // --- Return the INITIAL results --- 
    // The client will now receive mode, languages, and basicFlashcards per source.
    return NextResponse.json({
      success: true,
        message: `Successfully processed ${processedCount} file(s) and generated ${totalInitialCards} initial flashcards. ${skippedCount} file(s) skipped.`,
        extractedTextPreview: combinedTextPreview.length > 1000 ? combinedTextPreview.slice(0, 1000) + "..." : combinedTextPreview,
        fileInfo: finalFileInfo,
        initialResults: allInitialResults, // Array of results, one per processed file
        // --- Include the full extracted texts in the response ---
        extractedTexts: allExtractedTexts,
        skippedFiles: skippedCount > 0 ? skippedFiles : undefined,
        processingTimeMs: duration
    });

  } catch (error: any) {
    // Global Error Handler (No changes needed)
    const endTime = Date.now();
    const duration = endTime - startTime;
    appLogger.error(`[API Route POST] UNHANDLED ERROR after ${duration}ms:`, error);
    let message = 'An unexpected server error occurred.';
    let code = 'INTERNAL_SERVER_ERROR';
    if (error instanceof SyntaxError && error.message.includes('JSON')) {
        message = 'Invalid JSON received in request body.';
        code = 'INVALID_JSON_INPUT';
    } else if (error.message) {
        message = `Unhandled server error: ${error.message}`;
    }
    return NextResponse.json({
        success: false, message: message, code: code, processingTimeMs: duration,
        skippedFiles: skippedFiles.length > 0 ? skippedFiles : undefined,
    }, { status: 500 });
  }
}
```

### File: app/api/extract-pdf/textExtractorService.ts

```
// app/api/extract-pdf/textExtractorService.ts
/**
 * Service responsible for extracting text from PDF and Image files
 * using appropriate GCP services or libraries.
 */
import { PDFDocument } from 'pdf-lib';
import { docAIClient, visionClient } from './gcpClients';
// --- FIX: Import PAGE_LIMIT and add DOCAI_OCR_PAGE_LIMIT ---
import { PAGE_LIMIT, DOCAI_OCR_PAGE_LIMIT, DOCAI_PROCESSOR_ID, GCP_PROJECT_ID, DOCAI_LOCATION } from './config'; // Assume DOCAI_OCR_PAGE_LIMIT=15 is added
import { SupportedFileType, getMimeTypeFromFilename } from './fileUtils';
import { ExtractionResult, PageLimitExceededError, ExtractionApiError } from './types';
import { appLogger, statusLogger } from '@/lib/logger';

/**
 * Performs a pre-check on a PDF buffer to count pages.
 * Throws PageLimitExceededError if the absolute limit is surpassed.
 * @param fileBuffer The ArrayBuffer of the PDF file.
 * @param filename The name of the file (for error reporting).
 * @returns The page count if within the limit.
 */
async function checkPdfPageCount(fileBuffer: ArrayBuffer, filename: string): Promise<number> {
    appLogger.info(`[Text Extractor] Performing pdf-lib page count check for: ${filename}`);
    try {
        const pdfDoc = await PDFDocument.load(fileBuffer, { ignoreEncryption: true });
        const pageCount = pdfDoc.getPageCount();

        // --- Throw only if > absolute PAGE_LIMIT (e.g., 30) ---
        if (pageCount > PAGE_LIMIT) {
            appLogger.warn(`[Text Extractor] PDF "${filename}" has ${pageCount} pages, exceeding the absolute ${PAGE_LIMIT}-page limit.`);
            throw new PageLimitExceededError(
                `Exceeds absolute ${PAGE_LIMIT}-page limit (${pageCount} pages)`, // Updated message
                filename,
                pageCount,
                PAGE_LIMIT
            );
        }

        appLogger.info(`[Text Extractor] pdf-lib check complete for ${filename}: ${pageCount} pages (within absolute limit).`);
        return pageCount;
    } catch (error: any) {
        if (error instanceof PageLimitExceededError) {
            throw error; // Re-throw specific error
        }
        appLogger.error(`[Text Extractor] pdf-lib processing error for ${filename}:`, error.message);
        if (error.message.includes('Invalid PDF structure') || error.message.includes('not a PDF')) {
            throw new ExtractionApiError(`Invalid or corrupted PDF file (${filename}).`);
        }
        throw new ExtractionApiError(`Failed to process PDF metadata with pdf-lib: ${error.message}`);
    }
}

// extractTextFromImageVisionAI (No changes needed here)
async function extractTextFromImageVisionAI(fileBuffer: ArrayBuffer, filename: string): Promise<ExtractionResult> {
    if (!visionClient) {
        throw new ExtractionApiError("Vision AI client is not initialized. Check configuration.");
    }
    const buffer = Buffer.from(fileBuffer);
    appLogger.info(`[Text Extractor] Starting Vision AI extraction for IMAGE: ${filename}...`);
    try {
        const [result] = await visionClient.documentTextDetection({
            image: { content: buffer.toString('base64') }
        });
        const extractedText = result.fullTextAnnotation?.text || '';
        if (!extractedText && result.error?.message) {
             appLogger.warn(`[Text Extractor] Vision AI returned error for IMAGE ${filename}: ${result.error.message}`);
             throw new ExtractionApiError(`Vision AI error: ${result.error.message}`);
        }
         if (!extractedText) {
            appLogger.warn(`[Text Extractor] Vision AI returned no text detections for IMAGE ${filename}`);
            return {
                 text: "",
                 info: { pages: 0, metadata: { source: 'Vision AI', characters: 0, note: 'No text detected.' } }
             };
        }

        const detectedLanguageCodes = new Set<string>();
        if (result.fullTextAnnotation?.pages) {
            for (const page of result.fullTextAnnotation.pages) {
                if (page.property?.detectedLanguages) {
                    for (const lang of page.property.detectedLanguages) {
                        if (lang.languageCode) detectedLanguageCodes.add(lang.languageCode);
                    }
                }
            }
        }
        if (detectedLanguageCodes.size === 0 && result.textAnnotations && result.textAnnotations.length > 0) {
            for (const annotation of result.textAnnotations) {
                if (annotation.locale) detectedLanguageCodes.add(annotation.locale);
            }
        }

        appLogger.info(`[Text Extractor] Vision AI detected language codes for ${filename}:`, Array.from(detectedLanguageCodes));
        const characterCount = extractedText.length;
        const pageCount = result.fullTextAnnotation?.pages?.length || 1;
        appLogger.info(`[Text Extractor] Vision AI extraction complete for IMAGE ${filename}, extracted ${characterCount} characters from ${pageCount} page(s).`);

        return {
            text: extractedText,
            info: {
                pages: pageCount,
                metadata: {
                    source: 'Vision AI',
                    characters: characterCount,
                    detectedLanguages: Array.from(detectedLanguageCodes)
                }
            }
        };
    } catch (error: any) {
        appLogger.error(`[Text Extractor] Vision AI extraction error for IMAGE ${filename}:`, error.message);
        throw new ExtractionApiError(`Vision AI failed for ${filename}: ${error.message}`);
    }
}


// extractTextFromPdfDocAI (MODIFIED to handle imageless mode)
async function extractTextFromPdfDocAI(fileBuffer: ArrayBuffer, filename: string, initialPageCount: number): Promise<ExtractionResult> {
    if (!docAIClient) {
        throw new ExtractionApiError("Document AI client is not initialized. Check configuration.");
    }
     if (!GCP_PROJECT_ID || !DOCAI_LOCATION || !DOCAI_PROCESSOR_ID) {
         throw new ExtractionApiError("Document AI configuration (Project ID, Location, Processor ID) is incomplete.");
     }
     // --- Use the imported constant --- 
     if (typeof DOCAI_OCR_PAGE_LIMIT === 'undefined') { // Check if it was actually imported
        appLogger.warn('[Text Extractor] DOCAI_OCR_PAGE_LIMIT not defined in config, defaulting to 15.');
     }
     const ocrLimit = DOCAI_OCR_PAGE_LIMIT ?? 15; // Use imported constant or default
     // --------------------------------------

    appLogger.info(`[Text Extractor] Starting Document AI extraction for PDF: ${filename} (${initialPageCount} pages)`);
    const processorName = `projects/${GCP_PROJECT_ID}/locations/${DOCAI_LOCATION}/processors/${DOCAI_PROCESSOR_ID}`;
    const buffer = Buffer.from(fileBuffer);

    // --- Determine Process Options based on page count --- 
    let processOptions = {};
    let mode = 'Standard OCR';
    if (initialPageCount > ocrLimit && initialPageCount <= PAGE_LIMIT) {
        mode = 'Imageless (Native PDF Parsing)';
        processOptions = {
             ocrConfig: { enableNativePdfParsing: true }
        };
        appLogger.info(`[Text Extractor] Using Imageless mode for ${filename} (${initialPageCount} pages > ${ocrLimit})`);
    } else {
        appLogger.info(`[Text Extractor] Using Standard OCR mode for ${filename} (${initialPageCount} pages <= ${ocrLimit})`);
        // No specific options needed for standard, or explicitly set:
        // processOptions = { ocrConfig: { enableNativePdfParsing: false } }; 
    }
    // ----------------------------------------------------

    const request = {
        name: processorName,
        rawDocument: {
            content: buffer.toString('base64'),
            mimeType: 'application/pdf',
        },
        processOptions: processOptions, // Add the determined options
    };

    try {
        appLogger.info(`[Text Extractor] Sending Document AI request (${mode} mode) to processor: ${processorName}`);
        const [result] = await docAIClient.processDocument(request);
        appLogger.info(`[Text Extractor] Document AI request completed successfully (${mode} mode)`);

        const { document } = result;

        if (!document || !document.text) {
            // Handle cases where no text is returned (remains the same)
            appLogger.warn(`[Text Extractor] Document AI returned no text for PDF ${filename} (${mode} mode). Response status: ${result.document?.error?.message || 'N/A'}`);
             return {
                 text: "",
                 info: { pages: initialPageCount, metadata: { source: `Document AI (${mode})`, characters: 0, note: 'No text detected.' } }
             };
        }

        // Language detection (remains the same)
        const detectedLanguageCodes = new Set<string>();
        if (document.pages && document.pages.length > 0) {
            for (const page of document.pages) {
                if (page.detectedLanguages && page.detectedLanguages.length > 0) {
                    for (const lang of page.detectedLanguages) {
                        if (lang.languageCode) detectedLanguageCodes.add(lang.languageCode);
                    }
                }
            }
        }

        appLogger.info(`[Text Extractor] Document AI detected language codes for ${filename}:`, Array.from(detectedLanguageCodes));
        const extractedText = document.text;
        const characterCount = extractedText.length;
        const pageCount = document.pages?.length || initialPageCount;
        appLogger.info(`[Text Extractor] Document AI extraction complete for PDF ${filename} (${mode} mode), extracted ${characterCount} characters from ${pageCount} pages.`);

        return {
            text: extractedText,
            info: {
                pages: pageCount,
                metadata: {
                    source: `Document AI (${mode})`, // Include mode in metadata
                    characters: characterCount,
                    detectedLanguages: Array.from(detectedLanguageCodes)
                }
            }
        };
    } catch (error: any) {
        // Error handling (remains largely the same)
        appLogger.error(`[Text Extractor] Document AI extraction error (${mode} mode) for PDF ${filename}:`, JSON.stringify(error, null, 2));

         // --- ADD Specific Check for Google API Page Limit Error ---
         // Google API uses code 3 (INVALID_ARGUMENT) for various issues,
         // but specifically includes PAGE_LIMIT_EXCEEDED details for this case.
         if (error.code === 3 && (error.details?.includes('limit: 15 got 16') || error.details?.includes('page limit'))) {
             // Attempt to extract the actual page count from the error details if possible
             const match = error.details?.match(/got (\d+)/);
             const reportedPageCount = match ? parseInt(match[1], 10) : initialPageCount;
             appLogger.warn(`[Text Extractor] Detected Document AI page limit error for ${filename}. Reported pages: ${reportedPageCount}, Limit: 15 (for standard OCR)`);
             // Throw OUR custom error type, using the configured OCR limit
             throw new PageLimitExceededError(
                 `Exceeds Document AI OCR page limit (${ocrLimit} pages)`,
                 filename,
                 reportedPageCount,
                 ocrLimit
             );
         }
         // ------------------------------------------------------

         if (error.message.includes('Deadline Exceeded') || error.code === 4) {
             throw new ExtractionApiError(`Document AI request timed out for ${filename} (${mode} mode).`);
         }
         // --- INVALID_ARGUMENT might now indicate a non-digital PDF in imageless mode ---
         if (error.code === 3) { // Keep this generic check AFTER the specific page limit check
            let detail = `Document AI: Invalid argument. Ensure ${filename} is a valid PDF.`;
            if (mode === 'Imageless (Native PDF Parsing)') {
                detail += ` Or, the PDF might not be suitable for imageless mode (e.g., scanned).`;
            }
             throw new ExtractionApiError(detail);
         }
         // ------------------------------------------------------------------------------
         if (error.message.includes('PERMISSION_DENIED') || error.details?.includes('permission')) {
             throw new ExtractionApiError(`Document AI: Permission denied. Check service account roles.`);
         }
         if (error.message.includes('NOT_FOUND')) {
             throw new ExtractionApiError(`Document AI: Processor not found. Verify Processor ID/Location.`);
         }
        throw new ExtractionApiError(`Document AI failed for ${filename} (${mode} mode): ${error.message}`);
    }
}


// extractText (main service function - no changes needed here)
export async function extractText(
    fileBuffer: ArrayBuffer,
    filename: string,
    fileType: SupportedFileType
): Promise<ExtractionResult> {
    if (fileType === 'pdf') {
        const pageCount = await checkPdfPageCount(fileBuffer, filename); // Now only throws if > PAGE_LIMIT
        // Pass pageCount to DocAI function to determine mode
        return await extractTextFromPdfDocAI(fileBuffer, filename, pageCount);
    } else if (fileType === 'image') {
        return await extractTextFromImageVisionAI(fileBuffer, filename);
    } else {
        appLogger.error(`[Text Extractor] Called with unsupported file type for filename: ${filename}`);
        throw new ExtractionApiError(`Unsupported file type provided to extraction service for ${filename}.`);
    }
}
```

### File: app/api/extract-pdf/types.ts

```
// app/api/extract-pdf/types.ts
/**
 * TypeScript interfaces specific to the data flow within the extract-pdf API feature.
 */

import { SupportedFileType } from './fileUtils';

// SkippedFile interface (no change)
export interface SkippedFile {
  filename: string;
  pages?: number;
  reason: string;
  code?: string;
}

// ExtractionResult interface (no change)
export interface ExtractionResult {
  text: string;
  info: {
    pages: number;
    metadata: {
      source: string;
      characters: number;
      detectedLanguages?: string[];
      note?: string;
    }
  }
}

// --- UPDATED: GeminiFlashcardInput to include classification ---
// This reflects the structure EXPECTED FROM Gemini now
export interface GeminiFlashcardInput {
    question: string;
    answer: string;
    questionPartOfSpeech: string;
    questionGender: string;
    answerPartOfSpeech: string;
    answerGender: string;
}

// --- UPDATED: ApiFlashcard interface to include classification ---
// This reflects the structure RETURNED BY the /api/extract-pdf route
export interface ApiFlashcard {
  question: string;
  answer: string;
  questionLanguage?: string; // Language detected for the whole batch
  answerLanguage?: string;   // Language detected for the whole batch
  isBilingual?: boolean;     // Mode determined for the whole batch
  // --- NEW Classification Fields ---
  questionPartOfSpeech: string; // Classification specific to this card
  questionGender: string;       // Classification specific to this card
  answerPartOfSpeech: string;   // Classification specific to this card
  answerGender: string;         // Classification specific to this card
  // --- End of NEW Fields ---
  source?: string;           // Added by route.ts (filename)
  fileType?: SupportedFileType; // Added by route.ts
}

// --- UPDATED: GeminiStructuredOutput to expect richer flashcards ---
// This reflects the overall JSON structure EXPECTED FROM Gemini now
export interface GeminiStructuredOutput {
    mode: 'translation' | 'knowledge';
    detectedQuestionLanguage: string;
    detectedAnswerLanguage: string;
    flashcards: GeminiFlashcardInput[]; // Should now contain the classification fields
}

// PageLimitExceededError class (no change needed based on previous code)
export class PageLimitExceededError extends Error {
    public filename: string;
    public pageCount: number;
    public limit: number;

    constructor(message: string, filename: string, pageCount: number, limit: number) {
        super(message);
        this.name = 'PageLimitExceededError';
        this.filename = filename;
        this.pageCount = pageCount;
        this.limit = limit;
    }
}

// ExtractionApiError class (no change)
export class ExtractionApiError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'ExtractionApiError';
    }
}

// GenerationApiError class (no change)
export class GenerationApiError extends Error {
    public reason?: string;
    constructor(message: string, reason?: string) {
        super(message);
        this.name = 'GenerationApiError';
        this.reason = reason;
    }
}
```

## Directory: app/api/process-ai-step2

### File: app/api/process-ai-step2/route.ts

```
/**
 * API Route Handler for processing the second step of AI generation:
 * - Classifying grammar for translation flashcards.
 * - Regenerating flashcards forcing knowledge mode.
 */
import { NextRequest, NextResponse } from 'next/server';
import { validateConfiguration, GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, GCP_PRIVATE_KEY } from '../extract-pdf/config'; // Reuse config validation
import {
    classifyTranslationFlashcards,
    regenerateAsKnowledgeFlashcards,
    InitialGenerationResult // Needed for the return type of knowledge regen
} from '../extract-pdf/flashcardGeneratorService';
import { GenerationApiError } from '../extract-pdf/types';
import { appLogger, statusLogger } from '@/lib/logger';

// --- Request Body Types --- 
interface ClassifyPayload {
    action: 'classify';
    filename: string;
    basicFlashcards: { question: string; answer: string }[];
}

interface ForceKnowledgePayload {
    action: 'force_knowledge';
    filename: string;
    originalText: string; // Client needs to send the original text back
}

type RequestPayload = ClassifyPayload | ForceKnowledgePayload;

// --- Runtime Configuration (same as extract-pdf) ---
export const config = {
  runtime: 'nodejs',
  regions: ['iad1'], // Adjust if needed
  maxDuration: 90, // Adjust if needed, knowledge regen might take time
};

// --- API Handler --- 

export async function POST(request: NextRequest) {
    const startTime = Date.now();
    appLogger.info(`[API Route Step2 POST] Request received at ${new Date(startTime).toISOString()}`);

    // --- Runtime Credential/Config Check --- 
    if (!GCP_PROJECT_ID || !GCP_SERVICE_ACCOUNT_EMAIL || !GCP_PRIVATE_KEY) {
        appLogger.error('[API Route Step2 POST] CRITICAL: Missing required GCP credentials. Aborting.');
        return NextResponse.json({ success: false, message: 'Server configuration error: Missing necessary credentials.', code: 'MISSING_CREDENTIALS' }, { status: 500 });
    }
    if (!validateConfiguration()) {
        appLogger.error('[API Route Step2 POST] CRITICAL: Core configuration validation failed. Aborting.');
        return NextResponse.json({ success: false, message: 'Server configuration error: Invalid or missing configuration.', code: 'INVALID_CONFIG' }, { status: 500 });
    }

    try {
        // --- Parse and Validate Payload --- 
        let payload: RequestPayload;
        try {
            payload = await request.json();
        } catch (e) {
            return NextResponse.json({ success: false, message: 'Invalid JSON payload.', code: 'INVALID_JSON' }, { status: 400 });
        }

        if (!payload.action || !payload.filename) {
            return NextResponse.json({ success: false, message: 'Missing required fields: action, filename.', code: 'INVALID_PAYLOAD' }, { status: 400 });
        }

        appLogger.info(`[API Route Step2 POST] Processing action: ${payload.action} for file: ${payload.filename}`);

        // --- Execute Action --- 
        if (payload.action === 'classify') {
            if (!Array.isArray(payload.basicFlashcards)) {
                return NextResponse.json({ success: false, message: 'Missing or invalid basicFlashcards for classify action.', code: 'INVALID_PAYLOAD' }, { status: 400 });
            }
            
            appLogger.info(`[API Route Step2 POST] Calling classifyTranslationFlashcards for ${payload.basicFlashcards.length} cards.`);
            const classifications = await classifyTranslationFlashcards(payload.basicFlashcards, payload.filename);
            const duration = Date.now() - startTime;
            appLogger.info(`[API Route Step2 POST] Classification finished for ${payload.filename}. Duration: ${duration}ms. Results: ${classifications.length}`);
            
            return NextResponse.json({
                success: true,
                action: 'classify',
                data: classifications, // Array of classification objects
                processingTimeMs: duration
            });

        } else if (payload.action === 'force_knowledge') {
            if (typeof payload.originalText !== 'string') {
                return NextResponse.json({ success: false, message: 'Missing or invalid originalText for force_knowledge action.', code: 'INVALID_PAYLOAD' }, { status: 400 });
            }

            appLogger.info(`[API Route Step2 POST] Calling regenerateAsKnowledgeFlashcards.`);
            const knowledgeResult = await regenerateAsKnowledgeFlashcards(payload.originalText, payload.filename);
            const duration = Date.now() - startTime;
            appLogger.info(`[API Route Step2 POST] Knowledge regeneration finished for ${payload.filename}. Duration: ${duration}ms. Cards: ${knowledgeResult.basicFlashcards.length}`);

            // Return structure should match client expectation for merging
            return NextResponse.json({
                success: true,
                action: 'force_knowledge',
                data: { // Send back structure similar to InitialGenerationResult but without mode
                    detectedQuestionLanguage: knowledgeResult.detectedQuestionLanguage,
                    detectedAnswerLanguage: knowledgeResult.detectedAnswerLanguage,
                    basicFlashcards: knowledgeResult.basicFlashcards
                },
                processingTimeMs: duration
            });
        } else {
            // Use a type assertion to tell TypeScript that we know 'action' exists
            const actionValue = (payload as { action?: string }).action || 'unknown';
            return NextResponse.json({ success: false, message: `Invalid action specified: ${actionValue}. Must be 'classify' or 'force_knowledge'.`, code: 'INVALID_ACTION' }, { status: 400 });
        }

    } catch (error: any) {
        const endTime = Date.now();
        const duration = endTime - startTime;
        appLogger.error(`[API Route Step2 POST] UNHANDLED ERROR after ${duration}ms:`, error);
        
        let message = 'An unexpected server error occurred during Step 2 processing.';
        let code = 'INTERNAL_SERVER_ERROR';
        if (error instanceof GenerationApiError) {
            message = `AI Generation Error (Step 2): ${error.message}`;
            code = 'GENERATION_ERROR';
        } else if (error.message) {
            message = `Unhandled server error (Step 2): ${error.message}`;
        }

        return NextResponse.json({
            success: false, 
            message: message, 
            code: code, 
            processingTimeMs: duration
        }, { status: 500 });
    }
} 
```

## Directory: app/api/tts

### File: app/api/tts/route.ts

```
import { NextResponse } from 'next/server';
import { TextToSpeechClient } from '@google-cloud/text-to-speech';
import { google } from '@google-cloud/text-to-speech/build/protos/protos';
import { appLogger, statusLogger } from '@/lib/logger';

// Remove client initialization outside the handler
// const ttsClient = new TextToSpeechClient();

/**
 * API Route Handler for POST requests to generate Text-to-Speech audio.
 * Expects a JSON body with:
 * {
 *   text: string,
 *   languageCode: string,
 *   ssmlGender?: 'SSML_VOICE_GENDER_UNSPECIFIED' | 'MALE' | 'FEMALE' | 'NEUTRAL',
 *   voiceName?: string | null
 * }
 */
export async function POST(request: Request) {
    let text: string;
    let languageCode: string;
    let ssmlGender: google.cloud.texttospeech.v1.SsmlVoiceGender;
    let voiceName: string | null | undefined;

    try {
        const body = await request.json();
        text = body.text;
        languageCode = body.languageCode;
        ssmlGender = body.ssmlGender || google.cloud.texttospeech.v1.SsmlVoiceGender.NEUTRAL;
        voiceName = body.voiceName;

        if (!text || !languageCode) {
            appLogger.warn("[API /tts] Missing text or languageCode in request body.");
            return NextResponse.json({ error: "Missing required parameters: text and languageCode" }, { status: 400 });
        }
        if (body.ssmlGender && !(body.ssmlGender in google.cloud.texttospeech.v1.SsmlVoiceGender)) {
             appLogger.warn(`[API /tts] Invalid ssmlGender provided: ${body.ssmlGender}`);
             return NextResponse.json({ error: `Invalid ssmlGender value. Valid options are: ${Object.keys(google.cloud.texttospeech.v1.SsmlVoiceGender).join(', ')}` }, { status: 400 });
        }
    } catch (error) {
        appLogger.error("[API /tts] Failed to parse request body:", error);
        return NextResponse.json({ error: "Invalid request body. Expected JSON." }, { status: 400 });
    }

    appLogger.info(`[API /tts] Request received (using explicit GCP_... creds): lang=${languageCode}, gender=${ssmlGender}, voice=${voiceName ?? 'default'}, text="${text.substring(0, 50)}..."`);

    // Check for the specific credentials provided by the gcpvercel.com integration
    if (!process.env.GCP_PROJECT_ID || !process.env.GCP_SERVICE_ACCOUNT_EMAIL || !process.env.GCP_PRIVATE_KEY) {
         appLogger.error("[API /tts] Required GCP credentials (GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, GCP_PRIVATE_KEY) are not set in Vercel environment variables.");
         return NextResponse.json({ error: "Server configuration error." }, { status: 500 });
    }
    
    try {
        // Explicitly configure the client with credentials from environment variables
        const credentials = {
            client_email: process.env.GCP_SERVICE_ACCOUNT_EMAIL,
            private_key: process.env.GCP_PRIVATE_KEY.replace(/\\n/g, '\n'), // Ensure newlines are correct
        };
        const projectId = process.env.GCP_PROJECT_ID;

        // Initialize client inside the handler with explicit credentials
        const ttsClient = new TextToSpeechClient({ credentials, projectId });

        const ttsRequest: google.cloud.texttospeech.v1.ISynthesizeSpeechRequest = {
            input: { text: text },
            voice: {
                languageCode: languageCode,
                ssmlGender: ssmlGender,
                ...(voiceName && { name: voiceName })
            },
            audioConfig: { audioEncoding: 'MP3' },
        };

        const [response] = await ttsClient.synthesizeSpeech(ttsRequest);

        if (response.audioContent instanceof Uint8Array) {
            const audioBase64 = Buffer.from(response.audioContent).toString('base64');
            appLogger.info(`[API /tts] Successfully generated TTS audio (using explicit creds) for lang: ${languageCode}`);
            return NextResponse.json({ audioContent: audioBase64 }, { status: 200 });
        } else {
             appLogger.error("[API /tts] TTS response did not contain valid audio content.", response);
            return NextResponse.json({ error: "TTS generation failed: Invalid audio content received." }, { status: 500 });
        }
    } catch (error: any) {
        appLogger.error('[API /tts] Google TTS API Error (using explicit creds):', error);
        const errorMessage = error.details || error.message || 'Unknown API error';
        return NextResponse.json({ error: `TTS generation failed: ${errorMessage}` }, { status: 500 });
    }
} 
```

## Directory: app/auth

## Directory: app/auth/callback

### File: app/auth/callback/route.ts

```
import { NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase/server'
import { appLogger, statusLogger } from '@/lib/logger'

/**
 * Handles the GET request for the authentication callback.
 * This route is hit when the user clicks the email confirmation link sent by Supabase.
 * It exchanges the provided code for a user session.
 * 
 * @param {Request} request The incoming request object.
 * @returns {Promise<NextResponse>} A response object, typically a redirect.
 */
export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  // The `next` parameter might be used if you want to redirect to a specific page after login
  // const next = searchParams.get('next') ?? '/'

  if (code) {
    const supabase = createServerClient()
    try {
      const { error, data } = await supabase.auth.exchangeCodeForSession(code)
      
      if (!error && data.session) {
        // Email confirmed, session created successfully.
        // Redirect to the main application page or a specified 'next' page.
        appLogger.info('Auth callback successful, redirecting to /');
        return NextResponse.redirect(`${origin}/`) // Redirect to home page
      } else {
        // Handle errors during code exchange
        appLogger.error('Auth callback error during code exchange:', error?.message);

        // Check for common errors indicating the link was already used, expired, or invalid
        const isInvalidGrantError = error?.message?.toLowerCase().includes('invalid grant') || 
                                  error?.message?.toLowerCase().includes('invalid or expired') ||
                                  error?.message?.toLowerCase().includes('already confirmed');

        if (isInvalidGrantError) {
          // Redirect to login with a message indicating the issue (already confirmed, expired link, etc.)
          return NextResponse.redirect(`${origin}/login?message=email_already_confirmed_or_link_invalid`);
        } else {
           // Redirect to login page with a generic error for other issues
          return NextResponse.redirect(`${origin}/login?error=confirmation_failed`);
        }
      }
    } catch (e) {
      // Catch unexpected errors during the process
      appLogger.error('Auth callback unexpected error:', e);
      return NextResponse.redirect(`${origin}/login?error=confirmation_failed`);
    }
  }

  // If no code is present in the URL, redirect to login with an error
  appLogger.warn('Auth callback called without a code.');
  return NextResponse.redirect(`${origin}/login?error=missing_confirmation_code`);
} 
```

## Directory: app/decks

## Directory: app/decks/create-choice

### File: app/decks/create-choice/page.tsx

```
// app/decks/create-choice/page.tsx
"use client";

import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { ArrowLeft, FilePlus, BotMessageSquare, PencilLine } from 'lucide-react'; // Added PencilLine
import { useRouter } from 'next/navigation';

export default function CreateChoicePage() {
    const router = useRouter();

    return (
        <div className="container mx-auto max-w-lg px-4 py-8">
            <Button variant="outline" size="sm" onClick={() => router.back()} className="mb-6">
                 <ArrowLeft className="mr-2 h-4 w-4" />
                 Back
            </Button>

            <h1 className="text-2xl font-bold mb-6 text-center">How would you like to create a deck?</h1>

            <div className="grid grid-cols-1 gap-6">
                {/* Option 1: Manual Creation */}
                <Link href="/decks/new" legacyBehavior>
                    <a className="block hover:no-underline">
                        <Card className="hover:border-primary hover:shadow-md transition-all cursor-pointer">
                            <CardHeader className="flex flex-row items-center gap-4 pb-2">
                                <PencilLine className="h-8 w-8 text-primary" />
                                <div>
                                    <CardTitle>Create Manually</CardTitle>
                                    <CardDescription>Enter deck details and add cards yourself.</CardDescription>
                                </div>
                            </CardHeader>
                        </Card>
                    </a>
                </Link>

                {/* Option 2: AI from File/Image */}
                <Link href="/prepare/ai-generate" legacyBehavior>
                     <a className="block hover:no-underline">
                        <Card className="hover:border-primary hover:shadow-md transition-all cursor-pointer">
                             <CardHeader className="flex flex-row items-center gap-4 pb-2">
                                <BotMessageSquare className="h-8 w-8 text-primary" /> {/* Using Bot icon */}
                                <div>
                                    <CardTitle>Generate from File / Image (AI)</CardTitle>
                                    <CardDescription>Upload documents or photos to automatically create flashcards.</CardDescription>
                                </div>
                             </CardHeader>
                         </Card>
                     </a>
                </Link>

                {/* Add more options here in the future */}
                {/* Example:
                <Card className="opacity-50 cursor-not-allowed">
                    <CardHeader className="flex flex-row items-center gap-4 pb-2">
                        <LinkIcon className="h-8 w-8 text-muted-foreground" />
                        <div>
                            <CardTitle>Create from URL (Coming Soon)</CardTitle>
                            <CardDescription>Paste a web link to generate cards.</CardDescription>
                        </div>
                    </CardHeader>
                </Card>
                */}
            </div>
        </div>
    );
}
```

## Directory: app/decks/new

### File: app/decks/new/page.tsx

```
// app/decks/new/page.tsx
"use client";

import type React from "react"; // Import React type if needed for specific typings
import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useSettings } from "@/providers/settings-provider"; // To get default language
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { toast } from "sonner";
import { ArrowLeft, Loader2 as IconLoader } from "lucide-react"; // For loading state
import { appLogger, statusLogger } from '@/lib/logger';

/**
 * Page component for manually creating a new deck's metadata.
 * Collects name, language(s), and bilingual status, then calls the API
 * to create the deck shell before redirecting to the edit page.
 */
export default function NewDeckPage() {
    const router = useRouter();
    const { settings } = useSettings();

    // State for form inputs
    const [name, setName] = useState("");
    const [isBilingual, setIsBilingual] = useState(false);
    const [primaryLanguage, setPrimaryLanguage] = useState(""); // Renamed for clarity
    const [secondaryLanguage, setSecondaryLanguage] = useState(""); // Renamed for clarity
    const [loading, setLoading] = useState(false);

    // Set default languages based on user settings when component mounts
    useEffect(() => {
        if (settings?.appLanguage) {
            appLogger.info("[NewDeckPage] Setting default language from settings:", settings.appLanguage);
            setPrimaryLanguage(settings.appLanguage);
            setSecondaryLanguage(settings.appLanguage); // Default secondary to same as primary
        } else {
            // Fallback if settings not loaded or no language set
             appLogger.info("[NewDeckPage] No default language in settings, using 'en'.");
             setPrimaryLanguage("en");
             setSecondaryLanguage("en");
        }
    }, [settings]); // Re-run if settings change

    // Handler for language change when NOT bilingual
    const handleSingleLanguageChange = (value: string) => {
        setPrimaryLanguage(value);
        setSecondaryLanguage(value); // Keep them synced
    };

    // Form submission handler
    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault(); // Prevent default form submission

        // Basic Validation
        if (!name.trim()) {
            toast.error("Deck name is required.");
            return;
        }
        if (!primaryLanguage) {
            toast.error("Primary language is required.");
            return;
        }
        if (isBilingual && !secondaryLanguage) {
             toast.error("Secondary language is required for bilingual decks.");
             return;
        }

        setLoading(true); // Indicate loading state
        const toastId = toast.loading("Creating deck...");

        // Prepare the payload for the API
        const payload = {
            name: name.trim(),
            questionLanguage: primaryLanguage, // Map state to API expected field name
            answerLanguage: isBilingual ? secondaryLanguage : primaryLanguage, // Use primary if not bilingual
            isBilingual: isBilingual,
            flashcards: [] // Send empty array for manual creation
        };

        appLogger.info("[NewDeckPage] Sending payload to POST /api/decks:", payload);

        try {
            const response = await fetch('/api/decks', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            const result = await response.json();

            if (!response.ok) {
                // Handle API errors (like validation errors, auth errors, db errors)
                throw new Error(result.message || `HTTP error! status: ${response.status}`);
            }

            // Success!
            toast.success(`Deck "${payload.name}" created! Redirecting...`, { id: toastId });
            appLogger.info("[NewDeckPage] Deck created successfully, API response:", result);

            // Redirect to the edit page for the new deck
            if (result.deckId) {
                router.push(`/edit/${result.deckId}`);
            } else {
                 // Should not happen if API returns correctly, but handle defensively
                 throw new Error("API succeeded but did not return a deck ID.");
            }

        } catch (error: any) {
            appLogger.error("[NewDeckPage] Error creating deck:", error);
            toast.error("Failed to create deck", {
                id: toastId,
                description: error.message || "An unexpected error occurred.",
            });
            setLoading(false); // Stop loading on error
        }
        // No finally block needed for setLoading(false) because we navigate away on success
    };

    return (
        <div className="container mx-auto max-w-2xl px-4 py-8">
             <Button variant="outline" size="sm" onClick={() => router.back()} className="mb-4">
                 <ArrowLeft className="mr-2 h-4 w-4" />
                 Back
            </Button>

            <Card>
                <form onSubmit={handleSubmit}>
                    <CardHeader>
                        <CardTitle>Create New Deck</CardTitle>
                        <CardDescription>Enter the basic details for your new deck. You can add cards on the next screen.</CardDescription>
                    </CardHeader>
                    <CardContent className="grid gap-6">
                        {/* Deck Name */}
                        <div className="grid gap-2">
                            <Label htmlFor="name">Deck Name</Label>
                            <Input
                                id="name"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                placeholder="e.g., French Vocabulary Chapter 1"
                                required
                                disabled={loading}
                            />
                        </div>

                        {/* Bilingual Switch */}
                        <div className="flex items-center space-x-2 rounded-lg border p-4">
                             <Switch
                                id="bilingual"
                                checked={isBilingual}
                                onCheckedChange={setIsBilingual}
                                disabled={loading}
                            />
                            <div className="flex-1">
                                <Label htmlFor="bilingual" className="font-medium">
                                    Bilingual Deck
                                </Label>
                                <p className="text-xs text-muted-foreground">
                                    Use different languages for questions (front) and answers (back).
                                </p>
                            </div>
                        </div>

                        {/* Language Selects */}
                        {isBilingual ? (
                            <div className="grid sm:grid-cols-2 gap-4">
                                <div className="grid gap-2">
                                    <Label htmlFor="primaryLanguage">Question Language (Front)</Label>
                                    <Select value={primaryLanguage} onValueChange={setPrimaryLanguage} required disabled={loading}>
                                        <SelectTrigger id="primaryLanguage">
                                            <SelectValue placeholder="Select language..." />
                                        </SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="en">English</SelectItem>
                                            <SelectItem value="nl">Dutch</SelectItem>
                                            <SelectItem value="fr">French</SelectItem>
                                            <SelectItem value="de">German</SelectItem>
                                            <SelectItem value="es">Spanish</SelectItem>
                                            <SelectItem value="it">Italian</SelectItem>
                                            {/* Add more languages as needed */}
                                        </SelectContent>
                                    </Select>
                                </div>
                                <div className="grid gap-2">
                                    <Label htmlFor="secondaryLanguage">Answer Language (Back)</Label>
                                    <Select value={secondaryLanguage} onValueChange={setSecondaryLanguage} required disabled={loading}>
                                        <SelectTrigger id="secondaryLanguage">
                                            <SelectValue placeholder="Select language..." />
                                        </SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="en">English</SelectItem>
                                            <SelectItem value="nl">Dutch</SelectItem>
                                            <SelectItem value="fr">French</SelectItem>
                                            <SelectItem value="de">German</SelectItem>
                                            <SelectItem value="es">Spanish</SelectItem>
                                            <SelectItem value="it">Italian</SelectItem>
                                            {/* Add more languages as needed */}
                                        </SelectContent>
                                    </Select>
                                </div>
                            </div>
                        ) : (
                            <div className="grid gap-2">
                                <Label htmlFor="language">Deck Language</Label>
                                <Select value={primaryLanguage} onValueChange={handleSingleLanguageChange} required disabled={loading}>
                                    <SelectTrigger id="language">
                                        <SelectValue placeholder="Select language..." />
                                    </SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="en">English</SelectItem>
                                        <SelectItem value="nl">Dutch</SelectItem>
                                        <SelectItem value="fr">French</SelectItem>
                                        <SelectItem value="de">German</SelectItem>
                                        <SelectItem value="es">Spanish</SelectItem>
                                        <SelectItem value="it">Italian</SelectItem>
                                        {/* Add more languages as needed */}
                                    </SelectContent>
                                </Select>
                            </div>
                        )}
                    </CardContent>
                    <CardFooter>
                        <Button type="submit" disabled={loading} className="w-full">
                            {loading ? <IconLoader className="mr-2 h-4 w-4 animate-spin" /> : null}
                            {loading ? "Creating..." : "Create Deck & Add Cards"}
                        </Button>
                    </CardFooter>
                </form>
            </Card>
        </div>
    );
}
```

## Directory: app/edit

## Directory: app/edit/[deckId]

### File: app/edit/[deckId]/CardViewTabContent.tsx

```
// app/edit/[deckId]/CardViewTabContent.tsx
"use client";

import { memo } from 'react';
import { CardEditor } from "@/components/card-editor";
import { Button } from "@/components/ui/button";
import { Card as UICard, CardContent } from "@/components/ui/card"; // Alias Card component
import { Plus } from "lucide-react";
import type { Tables } from "@/types/database";

// --- Add Constants ---
const POS_OPTIONS: ReadonlyArray<string> = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other', 'N/A'];
const GENDER_OPTIONS = [
    { value: 'Male', label: 'Male'},
    { value: 'Female', label: 'Female'},
    { value: 'Default', label: 'Neutral / Other'}
]; // Use 'Default' as the key for N/A/Neutral
const GENDER_KEYS: ReadonlyArray<string> = ['Male', 'Female', 'Default'] as const; // Keys matching GENDER_OPTIONS values
const GENDERED_POS: ReadonlyArray<string> = ['Noun', 'Adjective', 'Pronoun'] as const; // PoS types where gender selection is relevant
// ---------------------

type DbCard = Tables<'cards'>;
// --- Define input types matching useEditDeck handlers ---
type CreateCardInput = Pick<DbCard, 'question' | 'answer' | 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>;
type UpdateCardInput = Partial<CreateCardInput>;
// -------------------------------------------------------

interface CardViewTabContentProps {
    cards: Array<Partial<DbCard>>; // Can include new placeholders
    // --- Update callback signatures to match useEditDeck handlers ---
    onCreateCard: (data: CreateCardInput) => Promise<string | null>;
    onUpdateCard: (cardId: string, data: UpdateCardInput) => void;
    // -----------------------------------------------------------
    onDeleteCard: (cardId: string) => void;
    onAddNewCardClick: () => void; // Trigger adding a new placeholder
}

export const CardViewTabContent = memo(({
    cards,
    onCreateCard,
    onUpdateCard,
    onDeleteCard,
    onAddNewCardClick
}: CardViewTabContentProps) => {

    return (
        <div className="mt-6">
            {cards.length === 0 ? (
                <UICard>
                    <CardContent className="flex flex-col items-center justify-center p-6 h-40">
                        <p className="text-muted-foreground text-center mb-4">No cards in this deck yet</p>
                        <Button onClick={onAddNewCardClick}>
                            <Plus className="mr-2 h-4 w-4" />
                            Add Your First Card
                        </Button>
                    </CardContent>
                </UICard>
            ) : (
                <div className="space-y-4">
                    {cards.map((cardData, index) => (
                        <CardEditor
                            // Use temporary ID for new cards or real ID for existing
                            key={cardData.id || `new-${index}`}
                            card={cardData}
                            // --- Pass down the action handlers directly --- They now have the correct signature
                            onUpdate={onUpdateCard}
                            onDelete={onDeleteCard}
                            onCreate={!cardData.id || cardData.id.startsWith('new-') ? onCreateCard : undefined} // Pass onCreate if it's a placeholder
                            // -------------------------------------------
                        />
                    ))}
                </div>
            )}

            {/* Always show Add Card button at the bottom if needed */}
            {cards.length >= 0 && ( // Show even if empty to allow first add
                <div className="flex justify-center mt-6">
                    <Button onClick={onAddNewCardClick}>
                        <Plus className="mr-2 h-4 w-4" />
                        Add Card
                    </Button>
                </div>
            )}
        </div>
    );
});

CardViewTabContent.displayName = 'CardViewTabContent';
```

### File: app/edit/[deckId]/DeckDangerZone.tsx

```
// app/edit/[deckId]/DeckDangerZone.tsx
"use client";

import { memo } from 'react';
import { Button } from "@/components/ui/button";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
    AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Trash2, Loader2 as IconLoader } from "lucide-react";

interface DeckDangerZoneProps {
    deckName: string;
    onDelete: () => Promise<void>; // The confirmed delete action
    isDeleting: boolean; // Loading state for delete button
}

export const DeckDangerZone = memo(({
    deckName,
    onDelete,
    isDeleting
}: DeckDangerZoneProps) => {

    return (
        <div className="mt-8 pt-6 border-t border-dashed border-destructive/50">
            <h3 className="text-lg font-semibold text-destructive mb-2">Danger Zone</h3>
            <p className="text-sm text-muted-foreground mb-4">Deleting this deck and all its cards cannot be undone.</p>
            <AlertDialog>
                <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isDeleting}>
                        {isDeleting ? <IconLoader className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                         Delete Deck
                    </Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        {/* Use template literal for dynamic title */}
                        <AlertDialogTitle>Delete "{deckName}"?</AlertDialogTitle>
                        <AlertDialogDescription>This action cannot be undone. This will permanently delete the deck and all associated cards.</AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
                        {/* Call the onDelete prop when confirmed */}
                        <AlertDialogAction onClick={onDelete} disabled={isDeleting} className="bg-destructive hover:bg-destructive/90">
                            {isDeleting ? <IconLoader className="h-4 w-4 animate-spin mr-2" /> : null} Delete
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>
        </div>
    );
});

DeckDangerZone.displayName = 'DeckDangerZone';
```

### File: app/edit/[deckId]/DeckMetadataEditor.tsx

```
// app/edit/[deckId]/DeckMetadataEditor.tsx
"use client";

import { memo } from 'react';
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import type { Tables, Json } from "@/types/database"; // Make sure Json is imported if needed, though not directly used here

type DbDeck = Tables<'decks'>;

interface DeckMetadataEditorProps {
    name: string;
    // Allow null from the parent state
    primaryLanguage: string | null;
    secondaryLanguage: string | null;
    isBilingual: boolean;
    // The callback expects Partial<Pick<...>> which implies undefined for optional fields
    onChange: (updates: Partial<Pick<DbDeck, 'name' | 'primary_language' | 'secondary_language' | 'is_bilingual'>>) => void;
    isSaving?: boolean;
}

export const DeckMetadataEditor = memo(({
    name,
    primaryLanguage,
    secondaryLanguage,
    isBilingual,
    onChange,
    isSaving
}: DeckMetadataEditorProps) => {

    const handleBilingualChange = (checked: boolean) => {
        // --- FIX: Convert null to undefined when updating ---
        const secondaryUpdate = !checked
            ? { secondary_language: primaryLanguage ?? undefined } // Convert null to undefined
            : {}; // No change to secondary if turning bilingual ON

        onChange({
            is_bilingual: checked,
            ...secondaryUpdate
        });
    };

    const handlePrimaryLangChange = (value: string) => {
        // --- FIX: Convert null to undefined when updating ---
        const secondaryUpdate = !isBilingual
            ? { secondary_language: value ?? undefined } // Update secondary if not bilingual (value won't be null here, but good practice)
            : {};

        onChange({
            primary_language: value ?? undefined, // Ensure primary is also undefined if needed, although Select usually gives string
            ...secondaryUpdate
        });
    };

     const handleSecondaryLangChange = (value: string) => {
         // Secondary change only matters if bilingual is on
         if (isBilingual) {
            onChange({
                secondary_language: value ?? undefined // Convert null to undefined if Select somehow returns it
            });
         }
    };


    return (
        <div className="space-y-6">
            {/* Deck Name Input */}
            <div>
                <Label htmlFor="deckNameInput">Deck Name</Label>
                <Input
                    id="deckNameInput"
                    value={name}
                    onChange={(e) => onChange({ name: e.target.value })}
                    className="mt-1"
                    placeholder="Enter deck name"
                    disabled={isSaving}
                />
                 {isSaving && <p className="text-sm text-muted-foreground mt-1">Saving...</p>}
            </div>

            {/* Language Settings Section */}
            <div className="p-4 border rounded-lg space-y-4">
                <div className="flex items-center justify-between">
                    <div>
                        <h3 className="font-medium">Bilingual Mode</h3>
                        <p className="text-sm text-muted-foreground">
                            Enable different languages for front and back
                        </p>
                    </div>
                    <Switch
                        checked={isBilingual}
                        onCheckedChange={handleBilingualChange}
                        disabled={isSaving}
                    />
                </div>

                {isBilingual ? (
                    <div className="grid gap-4 sm:grid-cols-2 pt-4 border-t">
                        <div>
                            <Label htmlFor="primaryLanguage">Front/Primary Language</Label>
                            <Select
                                value={primaryLanguage ?? undefined} // Pass undefined to Select if null
                                onValueChange={handlePrimaryLangChange}
                                disabled={isSaving}
                            >
                                <SelectTrigger id="primaryLanguage"><SelectValue placeholder="Select language" /></SelectTrigger>
                                <SelectContent> <SelectItem value="en">English</SelectItem> <SelectItem value="nl">Dutch</SelectItem> <SelectItem value="fr">French</SelectItem> <SelectItem value="de">German</SelectItem> <SelectItem value="es">Spanish</SelectItem> <SelectItem value="it">Italian</SelectItem> </SelectContent>
                            </Select>
                        </div>
                        <div>
                            <Label htmlFor="secondaryLanguage">Back/Secondary Language</Label>
                            <Select
                                value={secondaryLanguage ?? undefined} // Pass undefined to Select if null
                                onValueChange={handleSecondaryLangChange} // Use dedicated handler
                                disabled={isSaving}
                            >
                                <SelectTrigger id="secondaryLanguage"><SelectValue placeholder="Select language" /></SelectTrigger>
                                <SelectContent> <SelectItem value="en">English</SelectItem> <SelectItem value="nl">Dutch</SelectItem> <SelectItem value="fr">French</SelectItem> <SelectItem value="de">German</SelectItem> <SelectItem value="es">Spanish</SelectItem> <SelectItem value="it">Italian</SelectItem> </SelectContent>
                            </Select>
                        </div>
                    </div>
                ) : (
                    <div className="pt-4 border-t">
                        <Label htmlFor="language">Language</Label>
                        <Select
                            value={primaryLanguage ?? undefined} // Pass undefined to Select if null
                            onValueChange={handlePrimaryLangChange} // This handler updates both if not bilingual
                            disabled={isSaving}
                        >
                            <SelectTrigger id="language"><SelectValue placeholder="Select language" /></SelectTrigger>
                            <SelectContent> <SelectItem value="en">English</SelectItem> <SelectItem value="nl">Dutch</SelectItem> <SelectItem value="fr">French</SelectItem> <SelectItem value="de">German</SelectItem> <SelectItem value="es">Spanish</SelectItem> <SelectItem value="it">Italian</SelectItem> </SelectContent>
                        </Select>
                    </div>
                )}
            </div>
        </div>
    );
});

DeckMetadataEditor.displayName = 'DeckMetadataEditor';
```

### File: app/edit/[deckId]/TableViewTabContent.tsx

```
// app/edit/[deckId]/TableViewTabContent.tsx
"use client";

import { memo } from 'react';
import { EditableCardTable } from "@/components/deck/EditableCardTable"; // Assuming this component exists and works
import { Button } from "@/components/ui/button";
import { Card as UICard, CardContent } from "@/components/ui/card"; // Alias Card component
import { Plus } from "lucide-react";
import type { Tables } from "@/types/database";

type DbCard = Tables<'cards'>;

interface TableViewTabContentProps {
    // Expects only cards with actual IDs for the table view
    cards: Array<DbCard>;
    deckId: string;
    // Callback when the table signals an update (e.g., after inline edit save)
    onCardUpdated: (updatedCard: DbCard) => void; // Or maybe just refetch? Depends on EditableCardTable
    // Trigger adding a new placeholder/row (might need separate handling than card view)
    onAddNewCardClick: () => void;
}

export const TableViewTabContent = memo(({
    cards,
    deckId,
    onCardUpdated,
    onAddNewCardClick
}: TableViewTabContentProps) => {

    return (
        <div className="mt-6">
            {cards.length > 0 ? (
                <EditableCardTable
                    initialCards={cards}
                    deckId={deckId}
                    onCardUpdated={onCardUpdated} // Pass handler down
                     // Consider if EditableCardTable needs other props like delete handlers
                />
            ) : (
                <UICard>
                    <CardContent className="flex flex-col items-center justify-center p-6 h-40">
                        <p className="text-muted-foreground text-center mb-4">No cards to display in table view.</p>
                        {/* Optionally show Add button here too */}
                    </CardContent>
                </UICard>
            )}
            {/* Add Button Below Table */}
            <div className="flex justify-center mt-6">
                <Button onClick={onAddNewCardClick}>
                    <Plus className="mr-2 h-4 w-4" />
                    Add Card
                </Button>
            </div>
        </div>
    );
});

TableViewTabContent.displayName = 'TableViewTabContent';
```

### File: app/edit/[deckId]/page.tsx

```
// app/edit/[deckId]/page.tsx
"use client";

import { useState } from "react";
import { useParams, useRouter } from "next/navigation"; // Keep useRouter if needed for back button etc.
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ArrowLeft, Loader2 as IconLoader } from "lucide-react";
// Import the new hook and components
import { useEditDeck } from "./useEditDeck";
import { DeckMetadataEditor } from "./DeckMetadataEditor";
import { CardViewTabContent } from "./CardViewTabContent";
import { TableViewTabContent } from "./TableViewTabContent";
import { DeckDangerZone } from "./DeckDangerZone";
import { DeckTagEditor } from '@/components/deck-tag-editor';
import type { Tables } from "@/types/database"; // Keep type import
import { appLogger, statusLogger } from '@/lib/logger';

type DbCard = Tables<'cards'>;

/**
 * Refactored Edit Deck Page Component.
 *
 * Orchestrates the editing process using the `useEditDeck` hook and specialized
 * sub-components for metadata, card view, table view, and deletion.
 */
export default function EditDeckPage() {
    const params = useParams<{ deckId: string }>();
    const deckId = params?.deckId;
    const router = useRouter();

    // Use the custom hook to manage state and actions
    const {
        deck,
        deckTags,
        loading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        // loadDeckData, // Can be called directly if needed (e.g., manual refresh button)
        handleDeckMetadataChange,
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleAddTagToDeck,
        handleRemoveTagFromDeck,
        handleDeleteDeckConfirm,
    } = useEditDeck(deckId);

    const [activeTab, setActiveTab] = useState("cards");

    // --- Loading State ---
    if (loading) {
        return (
            <div className="flex justify-center items-center h-screen">
                <IconLoader className="h-12 w-12 animate-spin text-primary" />
            </div>
        );
    }

    // --- Error State ---
    if (error) {
        return (
            <div className="container mx-auto px-4 py-8">
                <div className="flex flex-col items-center justify-center">
                    <h2 className="text-xl font-semibold text-red-500 mb-4">Error Loading Deck</h2>
                    <p className="text-muted-foreground mb-6">{error}</p>
                    <Button onClick={() => router.push("/")}>Return to Home</Button>
                </div>
            </div>
        );
    }

    // --- Deck Not Found State ---
    if (!deck) {
        // This case covers both initial load failure where deck is null
        // and the case where getDeck returns null data (deck truly not found)
        return (
            <div className="container mx-auto px-4 py-8">
                <div className="flex flex-col items-center justify-center">
                    <h2 className="text-xl font-semibold mb-4">Deck Not Found</h2>
                    <p className="text-muted-foreground mb-6">The deck you're looking for doesn't exist or couldn't be loaded.</p>
                    <Button onClick={() => router.push("/")}>Return to Home</Button>
                </div>
            </div>
        );
    }

    // --- Main Render ---
    return (
        <div className="container mx-auto py-6 md:py-8 px-4">
            {/* Header */}
            <div className="flex items-center justify-between mb-6">
                <h1 className="text-2xl font-bold truncate pr-4" title={deck.name}>Edit Deck: {deck.name}</h1>
                <Button variant="outline" onClick={() => router.back()}>
                    <ArrowLeft className="mr-2 h-4 w-4" />
                    Back
                </Button>
            </div>

            {/* Deck Metadata Editor */}
            <div className="mb-6 space-y-6">
                <DeckMetadataEditor
                    name={deck.name}
                    primaryLanguage={deck.primary_language}
                    secondaryLanguage={deck.secondary_language}
                    isBilingual={deck.is_bilingual}
                    onChange={handleDeckMetadataChange}
                    isSaving={isSavingMetadata}
                />
                <DeckTagEditor 
                    deckId={deck.id}
                    currentTags={deckTags} 
                    onAddTag={handleAddTagToDeck}
                    onRemoveTag={handleRemoveTagFromDeck}
                />
            </div>

            {/* Card Tabs */}
            <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="cards">Card View</TabsTrigger>
                    <TabsTrigger value="table">Table View</TabsTrigger>
                </TabsList>

                <TabsContent value="cards">
                    <CardViewTabContent
                        cards={deck.cards}
                        onCreateCard={handleCreateCard}
                        onUpdateCard={handleUpdateCard}
                        onDeleteCard={handleDeleteCard}
                        onAddNewCardClick={handleAddCardOptimistic}
                    />
                </TabsContent>

                <TabsContent value="table">
                     <TableViewTabContent
                         // Filter out placeholder cards before passing to table
                         cards={deck.cards.filter(c => c.id && !c.id.startsWith('new-')) as DbCard[]}
                         deckId={deck.id}
                         // Decide how table updates should reflect - refetch or update local state?
                         // Option 1: Assume table handles its own saving and parent just needs to know
                         onCardUpdated={(updatedCard) => {
                              appLogger.info("Card updated via table:", updatedCard.id);
                              // Option: Update local state directly (if needed)
                              // setDeck(prev => ...)
                              // Option: Or trigger a full refetch
                              // loadDeckData(deck.id);
                         }}
                         onAddNewCardClick={handleAddCardOptimistic}
                     />
                 </TabsContent>
            </Tabs>

            {/* Danger Zone */}
            <DeckDangerZone
                deckName={deck.name}
                onDelete={handleDeleteDeckConfirm}
                isDeleting={isDeletingDeck}
            />

        </div>
    );
}
```

### File: app/edit/[deckId]/useEditDeck.ts

```
// app/edit/[deckId]/useEditDeck.ts
"use client";

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
// Assuming useDecks provides getDeck, updateDeck, deleteDeck and their loading state
import { useDecks } from "@/hooks/use-decks";
// Assuming card actions exist and follow ActionResult pattern
import { createCard as createCardAction, updateCard as updateCardAction, deleteCard as deleteCardAction } from "@/lib/actions/cardActions";
// Import your DB types generated by Supabase
import type { Tables, Json } from "@/types/database";
// Assuming useDecks defines this type for its updateDeck action payload
import type { UpdateDeckParams } from "@/hooks/use-decks";
// For user feedback
import { toast } from "sonner";
// For debouncing saves
import { debounce } from "@/lib/utils";
// --- Import NEW Deck Tag actions --- 
import { addTagToDeck, removeTagFromDeck } from '@/lib/actions/tagActions';
// --- Update state type to include tags --- 
// Use the DeckWithCardsAndTags type which includes the tags array
// Assuming useDecks.getDeck returns this structure now
import type { DeckWithCardsAndTags } from "@/hooks/use-decks"; // Import the combined type
import { appLogger, statusLogger } from '@/lib/logger';

// Type aliases for better readability
type DbDeck = Tables<'decks'>;
type DbCard = Tables<'cards'>;
type DbTag = Tables<'tags'>; // Added Tag type alias

// Define the input type for creating a card (matches server action expectation)
// Add the new classification fields here
type CreateCardInput = Pick<DbCard, 'question' | 'answer' | 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>;

// Define the input type for updating a card (matches server action expectation)
// All fields are optional
type UpdateCardInput = Partial<CreateCardInput>;

// Define the state type managed by this hook
// Base it on the imported type but explicitly allow partial cards in the state
export type DeckEditState = (Omit<DeckWithCardsAndTags, 'cards'> & { cards: Array<Partial<DbCard>> }) | null;

// Debounce time for auto-saving metadata (in milliseconds)
const DECK_UPDATE_DEBOUNCE_MS = 1500;

// Interface for storing previous/initial metadata state for comparison logic
interface MetadataState {
    name?: string | null;
    primary_language?: string | null;
    secondary_language?: string | null;
    is_bilingual?: boolean | null;
}

/**
 * Custom hook to manage the state and logic for editing a deck.
 *
 * @param deckId The ID of the deck to edit (from route params), or undefined if creating/invalid.
 * @returns An object containing the deck state, loading/error status, and action handlers.
 */
export function useEditDeck(deckId: string | undefined) {
    const router = useRouter();
    // Get deck-related actions and loading state from the dedicated useDecks hook
    const { getDeck, updateDeck, deleteDeck, loading: useDecksLoading } = useDecks();

    // --- State Definitions ---
    const [deck, setDeck] = useState<DeckEditState>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isSavingMetadata, setIsSavingMetadata] = useState(false);
    const [isDeletingDeck, setIsDeletingDeck] = useState(false);

    // --- Refs for Internal Logic ---
    const isMountedRef = useRef(false); // Track initial load completion
    // Ref to store the last *successfully saved* or initially loaded metadata state
    const previousSavedMetadataRef = useRef<MetadataState>({});


    // --- Data Fetching Logic ---
    const loadDeckData = useCallback(async (id: string) => {
        appLogger.info(`[useEditDeck] Loading deck data for ID: ${id}`);
        setLoading(true); setError(null);
        isMountedRef.current = false; // Reset load flag
        previousSavedMetadataRef.current = {}; // Reset saved state ref
        try {
            const result = await getDeck(id);
            if (result.error) throw new Error(result.error);
            if (result.data) {
                // Store in the state with cards explicitly as Partial<DbCard>[]
                const fetchedDeckForState: DeckEditState = {
                    ...result.data,
                    cards: (result.data.cards || []) as Array<Partial<DbCard>> // Cast to partial for state
                };
                appLogger.info("[useEditDeck] Fetched Deck Data for State:", fetchedDeckForState);
                setDeck(fetchedDeckForState); 
                // Null check before accessing properties
                if (fetchedDeckForState) { 
                    previousSavedMetadataRef.current = {
                        name: fetchedDeckForState.name,
                        primary_language: fetchedDeckForState.primary_language,
                        secondary_language: fetchedDeckForState.secondary_language,
                        is_bilingual: fetchedDeckForState.is_bilingual,
                    };
                    isMountedRef.current = true;
                    appLogger.info("[useEditDeck] Initial deck loaded. Metadata ref set.", previousSavedMetadataRef.current);
                } else {
                     isMountedRef.current = false;
                     appLogger.warn("[useEditDeck] Fetched deck data was unexpectedly null after check.");
                }
            } else {
                // Deck not found case
                setDeck(null); // Ensure deck state is null
                setError("Deck not found or access denied."); // Set error message
                isMountedRef.current = false; 
                appLogger.info("[useEditDeck] Deck not found or access denied, setting state to null.");
            }
        } catch (err: any) {
             appLogger.error("[useEditDeck] Error loading deck:", err);
              setError(err.message || "Failed to load deck.");
              setDeck(null);
              isMountedRef.current = false;
        } finally {
            setLoading(false);
        }
    }, [getDeck]);

    // Initial load effect
    useEffect(() => {
        isMountedRef.current = false; // Reset on ID change
        previousSavedMetadataRef.current = {};
        if (deckId && !useDecksLoading) {
            loadDeckData(deckId);
        } else if (!deckId) {
            setError("No Deck ID provided."); setLoading(false);
        } else if (useDecksLoading) {
            appLogger.info("[useEditDeck] Waiting for useDecks hook to finish loading...");
            setLoading(true);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [deckId, useDecksLoading]);


    // --- Deck Metadata Updates ---

    // Debounced function responsible for calling the actual update action
    const debouncedSaveMetadata = useCallback(
        debounce(async (deckIdToSave: string, payloadToSave: UpdateDeckParams) => {
            if (!isMountedRef.current) {
                appLogger.warn("[useEditDeck] Debounced save skipped: Initial load not complete.");
                return;
            }

            appLogger.info("[useEditDeck] Debounced Save Metadata EXECUTION for ID:", deckIdToSave, "Payload:", payloadToSave);
            setIsSavingMetadata(true);
            try {
                const result = await updateDeck(deckIdToSave, payloadToSave);

                if (result.error) {
                    toast.error("Deck settings auto-save failed", { description: result.error });
                } else {
                    appLogger.info("[useEditDeck] Deck settings auto-saved successfully to DB.");
                    // Update the ref ONLY after successful save
                    if (result.data) {
                         previousSavedMetadataRef.current = {
                            name: result.data.name,
                            primary_language: result.data.primary_language,
                            secondary_language: result.data.secondary_language,
                            is_bilingual: result.data.is_bilingual,
                         };
                         appLogger.info("[useEditDeck] Updated previousSavedMetadataRef after successful save.");
                    }
                     // *** NO setDeck() call here ***
                }
            } catch (error: any) {
                appLogger.error("[useEditDeck] Error during debouncedSaveMetadata execution:", error);
                toast.error("Deck settings auto-save failed", { description: error.message || "Unknown error" });
            } finally {
                setIsSavingMetadata(false);
            }
        }, DECK_UPDATE_DEBOUNCE_MS),
        [updateDeck] // Stable dependency
    );

    // Handler called by the DeckMetadataEditor component when user input changes
    const handleDeckMetadataChange = useCallback((updates: Partial<DbDeck>) => {
        appLogger.info('[DEBUG] handleDeckMetadataChange called with updates:', updates);
        // --- Use DeckEditState type for callback param and return --- 
        setDeck((prevDeckState: DeckEditState): DeckEditState => {
            if (!prevDeckState) return null;
            // Ensure cards remain Array<Partial<DbCard>>
            return { ...prevDeckState, ...updates }; 
        });
        // --- Trigger debounce after state update --- 
        if (isMountedRef.current && deck?.id && previousSavedMetadataRef.current) {
            const currentMetadataPayload: MetadataState = {
               name: updates.name ?? deck.name,
               primary_language: updates.primary_language ?? deck.primary_language,
               secondary_language: updates.secondary_language ?? deck.secondary_language,
               is_bilingual: updates.is_bilingual ?? deck.is_bilingual,
            };

            let changed = false;
            if (currentMetadataPayload.name !== previousSavedMetadataRef.current.name) changed = true;
            if (currentMetadataPayload.primary_language !== previousSavedMetadataRef.current.primary_language) changed = true;
            if (currentMetadataPayload.secondary_language !== previousSavedMetadataRef.current.secondary_language) changed = true;
            if (currentMetadataPayload.is_bilingual !== previousSavedMetadataRef.current.is_bilingual) changed = true;

            if (changed) {
                appLogger.info("[DEBUG] Change detected from initial/last save. Queuing debounced metadata save.");
                const payloadToSave: UpdateDeckParams = {
                    name: currentMetadataPayload.name ?? undefined,
                    primary_language: currentMetadataPayload.primary_language ?? undefined,
                    secondary_language: currentMetadataPayload.secondary_language ?? undefined,
                    is_bilingual: currentMetadataPayload.is_bilingual ?? undefined,
                };
                debouncedSaveMetadata(deck.id, payloadToSave);
            } else {
                appLogger.info("[DEBUG] No change detected from initial/last save. Save trigger skipped.");
            }
        }
        // -------------------------------------------
    }, [debouncedSaveMetadata, deck]); // Added deck dependency for check


    // --- Card Actions ---
    const handleAddCardOptimistic = useCallback(() => {
         if (!deck) return;
         // Generate a unique temporary ID for the placeholder
         const tempId = `new-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
         const newCardPlaceholder: Partial<DbCard> = {
             id: tempId, // Use unique temp ID
             question: "",
             answer: "",
             question_part_of_speech: null, // Initialize new fields
             question_gender: null,
             answer_part_of_speech: null,
             answer_gender: null,
             deck_id: deck.id,
             user_id: deck.user_id,
             // Default SRS fields
             srs_level: 0,
             easiness_factor: 2.5,
             interval_days: 0,
             stability: 0,
             difficulty: 0,
             last_review_grade: null,
             last_reviewed_at: null,
             next_review_due: null,
             correct_count: 0,
             incorrect_count: 0,
             attempt_count: 0
         };
         // --- Use DeckEditState type --- 
         setDeck((prev: DeckEditState): DeckEditState => {
             if (!prev) return null;
             const updatedCards: Array<Partial<DbCard>> = [...prev.cards, newCardPlaceholder];
             return { ...prev, cards: updatedCards };
         });
         appLogger.info("[useEditDeck] Added optimistic card placeholder:", newCardPlaceholder.id);
    }, [deck]);

    const handleCreateCard = useCallback(async (cardData: CreateCardInput): Promise<string | null> => {
        // deckId is stable from the hook's parameter
        if (!deckId) { 
            toast.error("Cannot create card: Deck ID missing."); 
            appLogger.error("[useEditDeck] handleCreateCard: deckId is undefined.");
            return null; 
        }

        // Find the temporary ID for optimistic update.
        // This part still needs access to the current cards list.
        // We can get it from the functional update form of setDeck.
        let tempId: string | undefined;

        setDeck((prevDeckState) => {
            if (prevDeckState) {
                const tempCard = prevDeckState.cards.find(c => c.id?.startsWith('new-'));
                tempId = tempCard?.id;
            }
            return prevDeckState; // No change here, just reading
        });

        const toastId = toast.loading("Saving new card...");
        try {
            const result = await createCardAction(deckId, cardData); // Use stable deckId from hook params
            if (result.error || !result.data) throw result.error || new Error("Failed to create card.");

            const savedCard = result.data;
            toast.success(`New card created!`, { id: toastId });

            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const updatedCards = prev.cards.map(c => 
                    (tempId && c.id === tempId) ? savedCard : c // Replace placeholder if tempId was found
                );
                // If placeholder wasn't found or wasn't replaced, add the saved card
                // This can happen if tempId was not identified correctly or if the create was triggered independently
                if (!updatedCards.some(c => c.id === savedCard.id)) {
                   appLogger.warn("[useEditDeck] Optimistic placeholder not replaced or found, adding saved card directly to list:", savedCard.id);
                   updatedCards.push(savedCard);
                }
                return { ...prev, cards: updatedCards.filter(c => !(tempId && c.id === tempId && c.id !== savedCard.id)) }; // Ensure only one instance
            });
            return savedCard.id;

        } catch (error: any) {
            toast.error("Failed to save new card", { id: toastId, description: error.message || "Unknown error." });
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const filteredCards: Array<Partial<DbCard>> = tempId 
                    ? prev.cards.filter((c: Partial<DbCard>) => c.id !== tempId)
                    : prev.cards.filter((c: Partial<DbCard>) => !c.id?.startsWith('new-')); // Fallback: remove all placeholders
                return { ...prev, cards: filteredCards };
            });
            return null;
        }
    }, [deckId, createCardAction]); // Dependencies: stable deckId and server action

    // updateCardCore should already be stable if its dependencies are just server actions
    const updateCardCore = useCallback(async (cardId: string, cardData: UpdateCardInput) => {
        const toastId = toast.loading("Updating card...");
        
        // For optimistic revert, we need the state of the specific card *before* this update.
        // It's complex to manage perfectly without a snapshot if setDeck is called multiple times.
        // The current optimistic update applies locally first.
        let originalCardState: Partial<DbCard> | undefined;

        setDeck((prev: DeckEditState): DeckEditState => {
            if (!prev) return null;
            originalCardState = prev.cards.find(c => c.id === cardId);
            const updatedCards = prev.cards.map(c => 
                c.id === cardId ? { ...c, ...cardData } : c
            );
            return { ...prev, cards: updatedCards };
        });

        try {
            const result = await updateCardAction(cardId, cardData);
            if (result.error || !result.data) throw result.error || new Error("Failed to update card.");

            const savedCard = result.data;
            toast.success("Card updated!", { id: toastId });

            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const confirmedCards = prev.cards.map(c => 
                    c.id === cardId ? savedCard : c
                );
                return { ...prev, cards: confirmedCards };
            });

        } catch (error: any) {
            toast.error("Failed to update card", { id: toastId, description: error.message || "Unknown error." });
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                // Revert to the specific card's original state if captured, else full originalCards might be too broad
                const revertedCards = prev.cards.map(c => 
                    (c.id === cardId && originalCardState) ? originalCardState : c
                );
                // If originalCardState wasn't captured or something went wrong, this might not fully revert.
                // A more robust revert might involve storing the full 'originalCards' array before any optimistic change for this action.
                appLogger.info("[useEditDeck] Attempting to revert card update due to error. Card ID:", cardId);
                return { ...prev, cards: revertedCards }; 
            });
        }
    }, [updateCardAction]); // Dependency: stable server action

    // This is the stable callback passed down to CardEditor for existing card updates
    const handleUpdateCard = useCallback((cardId: string, cardData: UpdateCardInput) => {
        if (cardId.startsWith('new-')) {
            appLogger.warn(`[useEditDeck] handleUpdateCard called for placeholder ID: ${cardId}. This should be handled by CardEditor's onCreate.`);
            // It's possible the CardEditor's internal save logic for new cards might call onUpdate if not careful.
            // If cardData contains enough info, we could redirect to handleCreateCard.
            // For now, let's assume CardEditor correctly distinguishes create vs update.
            return;
        }
        appLogger.info(`[useEditDeck] Stable handleUpdateCard forwarding to updateCardCore for ID: ${cardId}`);
        updateCardCore(cardId, cardData);
    }, [updateCardCore]); // Now only depends on the stable updateCardCore

    const handleDeleteCard = useCallback(async (cardId: string) => {
        // deckId is stable from hook params
        if (!deckId) {
             appLogger.error("[useEditDeck] handleDeleteCard: deckId is undefined, cannot proceed.");
             return; // Should not happen if deck is loaded
        }
        
        let originalCards: Array<Partial<DbCard>> = [];
        setDeck((prev: DeckEditState): DeckEditState => {
            if (!prev) return null;
            originalCards = [...prev.cards]; // Shallow copy for potential revert
            const updatedCards = prev.cards.filter(c => c.id !== cardId);
            return { ...prev, cards: updatedCards };
        });

        const toastId = toast.loading("Deleting card...");
        try {
            // For non-placeholder cards, call the server action
            if (!cardId.startsWith('new-')) {
                const result = await deleteCardAction(cardId);
                if (result.error) throw result.error;
            }
            // If it was a placeholder (starts with 'new-'), it's already removed from local state.
            toast.success("Card deleted!", { id: toastId });
            // State already updated optimistically.
        } catch (error: any) {
            toast.error("Failed to delete card", { id: toastId, description: error.message || "Unknown error." });
            setDeck((prev: DeckEditState): DeckEditState => {
                 if (!prev) return null;
                 // Revert to the copied originalCards array
                 return { ...prev, cards: originalCards }; 
            });
        }
    }, [deckId, deleteCardAction]); // Dependencies: stable deckId and server action


    // --- Deck Deletion ---
    const handleDeleteDeckConfirm = useCallback(async (): Promise<void> => {
        if (!deck || !deck.id) { toast.error("Cannot delete deck: data missing."); return; }
        setIsDeletingDeck(true);
        const deckName = deck.name;
        try {
            const result = await deleteDeck(deck.id);
            if (result.error) throw new Error(result.error);
            toast.success(`Deck "${deckName}" deleted successfully!`);
            router.push('/');
        } catch (error: any) {
            toast.error(`Failed to delete deck "${deckName}"`, { description: error.message || "Unknown error." });
            setIsDeletingDeck(false);
        }
    }, [deck, deleteDeck, router]);

    // --- NEW: Deck Tag Handlers ---
    const handleAddTagToDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot add tag: Deck not loaded.");
            return;
        }
        appLogger.info(`[useEditDeck] Adding tag ${tagId} to deck ${deck.id}`);
        const toastId = toast.loading("Adding tag...");
        try {
            const result = await addTagToDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag added to deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            appLogger.error("[useEditDeck] Error adding tag to deck:", error);
            toast.error("Failed to add tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData

    const handleRemoveTagFromDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot remove tag: Deck not loaded.");
            return;
        }
        appLogger.info(`[useEditDeck] Removing tag ${tagId} from deck ${deck.id}`);
        const toastId = toast.loading("Removing tag...");
        try {
            const result = await removeTagFromDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag removed from deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            appLogger.error("[useEditDeck] Error removing tag from deck:", error);
            toast.error("Failed to remove tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData
    // --------------------------------

    // --- Return Values ---
    return {
        deck,
        // Extract tags from deck state, provide empty array if deck is null
        deckTags: deck?.tags ?? [], 
        loading: loading || useDecksLoading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        loadDeckData,
        handleDeckMetadataChange, // Expose the handler that triggers the save
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleAddTagToDeck, // Expose new handler
        handleRemoveTagFromDeck, // Expose new handler
        handleDeleteDeckConfirm,
    };
}
```

## Directory: app/login

### File: app/login/page.tsx

```
"use client"

import type React from "react"

import { useState, useEffect, Suspense } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useAuth } from "@/hooks/use-auth"
import { toast } from "sonner"
import type { AuthError } from '@supabase/supabase-js'
import { appLogger, statusLogger } from '@/lib/logger'
import { Loader2 as IconLoader } from 'lucide-react'

/**
 * Login Page component.
 *
 * This component serves as the entry point for the login route.
 * It wraps the main `LoginContent` component within a React Suspense
 * boundary to handle client-side rendering dependencies like `useSearchParams`.
 *
 * @returns {JSX.Element} The Login Page UI with a Suspense boundary.
 */
export default function LoginPage() {
  // The main export wraps LoginContent in Suspense
  return (
    <Suspense fallback={<div className="flex items-center justify-center min-h-screen">Loading Page...</div>}>
      <LoginContent />
    </Suspense>
  )
}

/**
 * Renders the actual login form and handles user interactions.
 *
 * This client component manages the state for email and password inputs,
 * handles form submission, interacts with the `useAuth` hook for signing in,
 * displays loading states and error messages using toasts, and handles
 * redirection based on authentication status or feedback query parameters
 * (e.g., from email confirmation links).
 *
 * @returns {JSX.Element} The Login form UI or a loading spinner.
 */
// --- Define the inner component containing the client logic ---
function LoginContent() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [isSubmitting, setIsSubmitting] = useState(false)
  const { signIn, user, loading: authLoading } = useAuth()
  const router = useRouter()
  const searchParams = useSearchParams()

  useEffect(() => {
    const message = searchParams.get('message')
    const error = searchParams.get('error')

    if (message === 'email_already_confirmed_or_link_invalid') {
      toast("Your email may already be confirmed, or the link was invalid/expired. Please try logging in.")
    } else if (error === 'confirmation_failed') {
      toast.error("Email Confirmation Failed", {
        description: "Could not confirm your email. Please try the link again or sign up if needed."
      })
    } else if (error === 'missing_confirmation_code') {
      toast.error("Invalid Link", {
        description: "The confirmation link is missing necessary information. Please use the link from your email."
      })
    }

    if (message || error) {
      router.replace('/login', { scroll: false })
    }
  }, [searchParams, router])

  useEffect(() => {
    if (!authLoading && user) {
      const callbackUrl = searchParams.get('callbackUrl');
      // Check if callbackUrl exists and is a non-empty string
      if (callbackUrl && typeof callbackUrl === 'string' && callbackUrl.trim() !== '') {
        appLogger.info(`Login successful, redirecting to callbackUrl: ${callbackUrl}`);
        // Decode the URL in case it contains encoded characters
        router.push(decodeURIComponent(callbackUrl)); 
      } else {
        appLogger.info("Login successful, redirecting to default '/'");
        router.push("/"); // Default redirect to homepage
      }
    }
  }, [user, authLoading, router, searchParams]); // Added searchParams dependency

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSubmitting(true)

    if (!email || !password) {
      toast.error("Missing Information", {
        description: "Please enter both email and password."
      })
      setIsSubmitting(false)
      return
    }

    try {
      const { error } = await signIn(email, password)

      if (error) {
        appLogger.error("Sign in error:", error)
        if (error && typeof error === 'object' && 'message' in error) {
          toast.error(String(error.message) || "Invalid login credentials.")
        } else {
          toast.error("An unexpected error occurred during sign in.")
        }
      } else {
        toast.success("Sign in successful! Redirecting...")
        // Let the useEffect handle redirection
        // router.push("/") 
      }
    } catch (error) {
      appLogger.error("Login submit error:", error)
      toast.error("Login Failed", {
        description: "An unexpected error occurred. Please try again later."
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  if (authLoading || user) {
    return (
        <div className="flex items-center justify-center min-h-screen bg-background">
          <IconLoader className="h-12 w-12 animate-spin text-primary" />
        </div>
      )
  }

  // The actual JSX for the login form
  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl text-center">StudyCards</CardTitle>
          <CardDescription className="text-center">Enter your email and password to sign in</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="m@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={isSubmitting}
              />
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="password">Password</Label>
                <Link href="/auth/forgot-password" className="text-sm text-primary hover:underline">
                  Forgot password?
                </Link>
              </div>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isSubmitting}
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={isSubmitting}>
              {isSubmitting ? "Signing in..." : "Sign in"}
            </Button>
          </CardFooter>
        </form>
        <CardFooter className="flex flex-col items-center justify-center space-y-2">
          <div className="text-sm text-muted-foreground">
            Don't have an account?{" "}
            <Link href="/signup" className="text-primary hover:underline">
              Sign up
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  )
}
// --- End of LoginContent component ---



```

## Directory: app/prepare

## Directory: app/prepare/ai-generate

### File: app/prepare/ai-generate/AiGenerateInputCard.tsx

```
// app/prepare/ai-generate/AiGenerateInputCard.tsx
"use client";

import React from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Loader2, BotMessageSquare, FileText } from 'lucide-react';
import { MediaCaptureTabs } from '@/components/media-capture-tabs';

// Constants defined here or imported from a central constants file
const SUPPORTED_FILE_TYPES = "PDF, JPG, JPEG, PNG, GIF, BMP, WEBP, HEIC, HEIF";
const SUPPORTED_EXTENSIONS = [".pdf", ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".heic", ".heif"];
const MAX_FILE_SIZE = 25; // 25MB
const MAX_IMAGES = 10; // Example limit

interface AiGenerateInputCardProps {
    files: File[];
    isLoading: boolean;
    error: string | null;
    onFilesSelected: (selectedFiles: File[]) => void;
    onSubmit: (e: React.FormEvent) => Promise<void>; // Make onSubmit async if needed
    onClearAll: () => void;
    // Add props for any other display elements needed, e.g., results exist to show clear button
    hasResults: boolean;
}

export function AiGenerateInputCard({
    files,
    isLoading,
    error,
    onFilesSelected,
    onSubmit,
    onClearAll,
    hasResults
}: AiGenerateInputCardProps) {
    return (
        <Card className="sticky top-4"> {/* Make input card sticky */}
            <CardHeader className="px-4 sm:px-6 py-4">
                <CardTitle className="flex items-center gap-2"><FileText className="h-5 w-5" /> 1. Upload Source</CardTitle>
                <CardDescription> Upload PDF/Image files or use camera. </CardDescription>
            </CardHeader>
            <CardContent className="px-4 sm:px-6 pb-4">
                {/* Pass onSubmit directly to the form */}
                <form onSubmit={onSubmit}>
                    <div className="mb-4">
                        <MediaCaptureTabs
                            onFilesSelected={onFilesSelected} // Pass down the handler
                            supportedFileTypes={SUPPORTED_FILE_TYPES}
                            supportedExtensions={SUPPORTED_EXTENSIONS}
                            maxFileSize={MAX_FILE_SIZE}
                            maxImages={MAX_IMAGES}
                            // Pass current files ONLY if MediaCaptureTabs needs to display them
                            // initialFiles={files}
                        />
                        {/* Display error specific to input/validation */}
                        {error && <p className="text-sm text-red-500 mt-2">{error}</p>}
                    </div>
                    <div className="flex flex-col sm:flex-row gap-2">
                        <Button type="submit" disabled={isLoading || !files || files.length === 0} className="flex-1">
                            {isLoading ? <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...</> : <><BotMessageSquare className="mr-2 h-4 w-4" /> Generate Flashcards</>}
                        </Button>
                        {/* Show Clear button if files selected OR results exist */}
                        {(files.length > 0 || hasResults) && !isLoading && (
                            <Button type="button" variant="outline" onClick={onClearAll}> Clear All </Button>
                        )}
                    </div>
                </form>
            </CardContent>
        </Card>
    );
}
```

### File: app/prepare/ai-generate/AiGenerateResultsCard.tsx

```
// app/prepare/ai-generate/AiGenerateResultsCard.tsx
"use client";

import React from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Download, Eye, Languages, Repeat, Tag, Loader2, AlertTriangle, HelpCircle, Sparkles, BookOpen } from 'lucide-react'; // Updated Icons
import type { ApiFlashcard } from '@/app/api/extract-pdf/types';
// Import the basic type as well
import type { BasicFlashcardData } from './useAiGenerate';

// Use a union type for the flashcards prop
type FlashcardData = ApiFlashcard | BasicFlashcardData;

interface AiGenerateResultsCardProps {
    flashcards: FlashcardData[]; // Use the union type
    extractedTextPreview: string | null;
    processingSummary: string | null;
    deckName: string;
    savedDeckId: string | null;
    needsModeConfirmationSource: string | null; // New prop
    isProcessingStep2: boolean; // New prop
    onSaveJson: () => void;
    onSwapSource: (source: string) => void;
    onConfirmTranslation: () => void; // New prop
    onForceKnowledge: () => void; // New prop
}

// Helper to group cards (needs to handle union type)
const getFlashcardsBySource = (cards: FlashcardData[]) => {
    const grouped: Record<string, FlashcardData[]> = {};
    cards.forEach(card => {
        const source = card.source || 'Unknown Source';
        if (!grouped[source]) grouped[source] = [];
        grouped[source].push(card);
    });
    return grouped;
};

export function AiGenerateResultsCard({
    flashcards,
    extractedTextPreview,
    processingSummary,
    deckName,
    savedDeckId,
    needsModeConfirmationSource,
    isProcessingStep2,
    onSaveJson,
    onSwapSource,
    onConfirmTranslation,
    onForceKnowledge
}: AiGenerateResultsCardProps) {
    const hasFlashcards = flashcards.length > 0;
    // Disable JSON download if confirmation is needed
    const showJsonDownload = hasFlashcards && !savedDeckId && !needsModeConfirmationSource;

    // Helper to display classification info (check for existence of properties)
    const renderClassification = (
        card: FlashcardData,
        prefix: string = "",
        fieldPrefix: 'question' | 'answer'
    ) => {
        // Check if the card is ApiFlashcard type before accessing classification fields
        const pos = (card as ApiFlashcard)?. [`${fieldPrefix}PartOfSpeech`];
        const gender = (card as ApiFlashcard)?. [`${fieldPrefix}Gender`];

        const posText = (pos && pos !== 'N/A') ? pos : null;
        const genderText = (gender && gender !== 'N/A') ? gender : null;

        if (!posText && !genderText) {
            return null; // Don't render anything if both are N/A or undefined
        }

        return (
            <span className="flex items-center gap-1 text-xs text-muted-foreground ml-1">
                {prefix && <span className="font-medium">{prefix}:</span>}
                {posText && <Badge variant="outline" className="px-1.5 py-0 text-xs">{posText}</Badge>}
                {genderText && <Badge variant="outline" className="px-1.5 py-0 text-xs">{genderText}</Badge>}
            </span>
        );
    };

    // Confirmation UI Component
    const renderConfirmationPrompt = (source: string) => {
        return (
            <div className="border-l-4 border-blue-500 dark:border-blue-400 bg-blue-50 dark:bg-blue-900/20 p-4 rounded-md mb-4">
                <div className="flex items-center mb-2">
                    <HelpCircle className="h-5 w-5 text-blue-600 dark:text-blue-400 mr-2" />
                    <h4 className="font-semibold text-blue-800 dark:text-blue-200">We detected this as a 'Translation' list. How would you like to proceed?</h4>
                </div>
                <p className="text-sm text-blue-700 dark:text-blue-300 mb-3">
                    Mode Confirmation for '{source}'
                </p>
                <div className="flex flex-col sm:flex-row gap-2">
                    <Button 
                        onClick={onConfirmTranslation}
                        disabled={isProcessingStep2}
                        size="sm"
                        variant="default"
                        className="bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 dark:text-white w-full"
                    >
                        {isProcessingStep2 ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Sparkles className="mr-2 h-4 w-4"/>}
                        Add Grammar Details
                    </Button>
                    <Button 
                        onClick={onForceKnowledge}
                        disabled={isProcessingStep2}
                        size="sm"
                        variant="outline"
                        className="dark:text-gray-300 dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:text-white w-full"
                    >
                        {isProcessingStep2 ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <BookOpen className="mr-2 h-4 w-4"/>}
                        Change to Knowledge Mode
                    </Button>
                </div>
            </div>
        );
    };

    return (
        <Card className="min-h-[300px] flex flex-col">
            <CardHeader className="px-4 sm:px-6 py-4">
                 <CardTitle className="flex items-center gap-2"><Eye className="h-5 w-5" /> 2. Review Results</CardTitle>
                 <CardDescription className="mt-1 !mb-0">
                    Review generated flashcards and processing summary.
                 </CardDescription>
                 {/* Processing Summary Display */}
                 {processingSummary && (
                    <div className="text-xs space-y-1 mt-3 border-t pt-3">
                        <p className="font-medium mb-1 text-foreground">Processing Summary:</p>
                        {processingSummary.split('\n').map((line, index) => (
                        <p key={index} className="flex items-start">
                            <span className={`flex-shrink-0 w-4 ${line.includes('Skipped') ? 'text-orange-500' : 'text-green-500'}`}>{line.includes('Skipped') ? '⚠️' : '✓'}</span>
                            <span className={`ml-1 whitespace-pre-wrap ${line.includes('Skipped') ? 'text-muted-foreground' : 'text-foreground'}`}>{line.replace(/^- /, '')}</span>
                        </p>
                        ))}
                    </div>
                 )}
            </CardHeader>
            <CardContent className="flex-grow overflow-auto px-4 sm:px-6 pb-4">
                {!hasFlashcards && !extractedTextPreview && !processingSummary ? (
                    // Placeholder
                    <div className="text-center py-6 text-muted-foreground flex flex-col items-center justify-center h-full">
                        <p>Results will appear here after processing.</p>
                    </div>
                ) : hasFlashcards ? (
                    // Grouped Flashcard Display
                    <div className="space-y-6 pr-2">
                        {/* Render Confirmation Prompt if needed */}
                        {needsModeConfirmationSource && renderConfirmationPrompt(needsModeConfirmationSource)}

                        {Object.entries(getFlashcardsBySource(flashcards)).map(([source, cards]) => {
                            const firstCard = cards[0]; // Use first card for group info
                            // Check if properties exist before accessing for languages
                            const docLangs = {
                                qName: (firstCard as ApiFlashcard)?.questionLanguage,
                                aName: (firstCard as ApiFlashcard)?.answerLanguage,
                                b: (firstCard as ApiFlashcard)?.isBilingual
                             };
                            const showALang = docLangs.aName && docLangs.qName !== docLangs.aName;
                            return (
                            <div key={source}>
                                <div className="flex flex-wrap items-center justify-between gap-2 mb-3 pb-2 border-b">
                                    <h3 className="text-sm font-semibold truncate" title={source}>Source: {source}</h3>
                                    <div className="flex items-center gap-1 flex-wrap">
                                        {firstCard?.fileType && <Badge variant="outline" className="text-xs">{firstCard.fileType}</Badge>}
                                        {docLangs.qName && <Badge variant="secondary" className="text-xs capitalize"><Languages className="inline h-3 w-3 mr-1"/>Q: {docLangs.qName}</Badge>}
                                        {showALang && <Badge variant="secondary" className="text-xs capitalize"><Languages className="inline h-3 w-3 mr-1"/>A: {docLangs.aName}</Badge>}
                                        <Badge variant="outline" className="text-xs">{cards.length} cards</Badge>
                                    </div>
                                </div>
                                <div className="mb-3 -mt-2 flex justify-end">
                                    {/* Disable swap button if confirmation needed */}
                                    <Button variant="outline" size="sm" onClick={() => onSwapSource(source)} disabled={!!needsModeConfirmationSource}>
                                        <Repeat className="h-4 w-4 mr-2"/>
                                        Swap Q/A for this Source
                                    </Button>
                                </div>
                                <div className="space-y-3">
                                    {cards.map((card, index) => (
                                        <div key={`${source}-${index}-${card.question?.substring(0, 5)}`} className="border rounded-md p-3 text-sm bg-background shadow-sm">
                                            {/* Question and optional classification */}
                                            <div className="flex flex-wrap items-center gap-x-2 mb-1">
                                                <p className="font-medium break-words">{card.question}</p>
                                                {renderClassification(card, "", 'question')}
                                            </div>
                                            {/* Answer and optional classification */}
                                            <div className="flex flex-wrap items-center gap-x-2">
                                                <p className="text-muted-foreground whitespace-pre-line break-words">{card.answer}</p>
                                                {renderClassification(card, "", 'answer')}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            );
                        })}
                    </div>
                ) : extractedTextPreview ? (
                     // Text Preview Display
                    <div>
                        <h3 className="text-sm font-medium mb-2">Extracted Text Preview:</h3>
                        <div className="bg-muted p-3 rounded-md max-h-[40vh] overflow-y-auto text-xs border">
                            <pre className="whitespace-pre-wrap font-mono">{extractedTextPreview.substring(0, 1000)}{extractedTextPreview.length > 1000 && '...'}</pre>
                        </div>
                    </div>
                ) : (
                     // Fallback
                     <div className="text-center py-6 text-muted-foreground flex flex-col items-center justify-center h-full">
                         <p>Processing complete. Check summary above.</p>
                     </div>
                )}
            </CardContent>
             {/* Optional Footer for JSON Download */}
             {showJsonDownload && (
                <CardFooter className="border-t px-4 sm:px-6 py-3 mt-auto">
                    <Button variant="secondary" size="sm" className="w-full" onClick={onSaveJson}>
                        <Download className="mr-2 h-4 w-4" />
                        Download Flashcards as JSON
                    </Button>
                </CardFooter>
             )}
        </Card>
    );
}
```

### File: app/prepare/ai-generate/AiGenerateSaveDeckCard.tsx

```
// app/prepare/ai-generate/AiGenerateSaveDeckCard.tsx
"use client";

import React from 'react'; // Import React for ChangeEvent type
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Loader2, FilePlus, CheckCircle, ArrowRight } from 'lucide-react';
// Import both types
import type { ApiFlashcard } from '@/app/api/extract-pdf/types';
import type { BasicFlashcardData } from './useAiGenerate';

// Define the union type locally or import if defined elsewhere
type FlashcardData = ApiFlashcard | BasicFlashcardData;

interface AiGenerateSaveDeckCardProps {
    flashcards: FlashcardData[]; // Use the union type
    deckName: string;
    isSavingDeck: boolean;
    savedDeckId: string | null;
    onDeckNameChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onSaveDeck: () => Promise<void>;
}

export function AiGenerateSaveDeckCard({
    flashcards,
    deckName,
    isSavingDeck,
    savedDeckId,
    onDeckNameChange,
    onSaveDeck
}: AiGenerateSaveDeckCardProps) {

    // Don't render this card if there are no flashcards to save
    if (flashcards.length === 0) {
        return null;
    }

    return (
        <Card className="mt-6">
            <CardHeader>
                <CardTitle className="flex items-center gap-2">
                    {savedDeckId ? <CheckCircle className="h-5 w-5 text-green-600" /> : <FilePlus className="h-5 w-5" />}
                    {savedDeckId ? "Deck Created" : "3. Save as New Deck"}
                </CardTitle>
                <CardDescription>
                    {savedDeckId ? "Your new deck is ready!" : "Save these flashcards as a new deck in your collection."}
                </CardDescription>
            </CardHeader>
            <CardContent>
                {savedDeckId ? (
                    // Success Message & Link
                    <div className="flex items-center justify-between p-4 bg-green-50 dark:bg-green-900/30 rounded-md border border-green-200 dark:border-green-800">
                        <p className="text-sm font-medium text-green-800 dark:text-green-200">
                            Deck "{deckName}" created! {/* Show name used for saving */}
                        </p>
                        <Button variant="default" size="sm" asChild>
                            <Link href={`/edit/${savedDeckId}`}>
                                View Deck <ArrowRight className="ml-2 h-4 w-4" />
                            </Link>
                        </Button>
                    </div>
                ) : (
                    // Input and Save Button
                    <div className="flex flex-col sm:flex-row gap-3 items-end">
                        <div className="flex-1 w-full sm:w-auto">
                            <Label htmlFor="deckNameInput" className="mb-1 block text-sm font-medium">Deck Name</Label>
                            <Input
                                id="deckNameInput" // Use unique ID if needed elsewhere
                                value={deckName}
                                onChange={onDeckNameChange} // Pass handler down
                                placeholder="Enter deck name (e.g., Biology Ch. 5)"
                                disabled={isSavingDeck}
                                required
                                aria-required="true"
                            />
                        </div>
                        <Button
                            disabled={isSavingDeck || !deckName.trim()}
                            onClick={onSaveDeck} // Pass handler down
                            className="w-full sm:w-auto"
                        >
                            {isSavingDeck ? <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Saving...</> : "Save Deck"}
                        </Button>
                    </div>
                )}
            </CardContent>
        </Card>
    );
}
```

### File: app/prepare/ai-generate/page.tsx

```
// app/prepare/ai-generate/page.tsx
'use client';

import React from 'react'; // Import React if using JSX type React.FormEvent
// Import the hook and new components
import { useAiGenerate } from './useAiGenerate';
import { AiGenerateInputCard } from './AiGenerateInputCard';
import { AiGenerateResultsCard } from './AiGenerateResultsCard';
import { AiGenerateSaveDeckCard } from './AiGenerateSaveDeckCard';

/**
 * Main page component for the AI Flashcard Generator.
 * Orchestrates the UI by using the useAiGenerate hook and rendering
 * specialized child components for input, results, and saving.
 */
export default function AiGeneratePage() {
    // Get all state and handlers from the custom hook
    const {
        files,
        isLoading,
        isProcessingStep2,
        error,
        displayFlashcards,
        extractedTextPreview,
        processingSummary,
        deckName,
        isSavingDeck,
        savedDeckId,
        needsModeConfirmationSource,
        handleFilesSelected,
        handleSubmit, // This is now the async function to call
        handleConfirmTranslation,
        handleForceKnowledge,
        handleSaveDeck,
        handleClearAll,
        handleSaveFlashcards, // For JSON download
        handleDeckNameChange,
        handleSwapSourceCards,
    } = useAiGenerate();

    // --- FIX: Create an async wrapper for the form onSubmit ---
    const handleFormSubmit = async (e: React.FormEvent) => {
        e.preventDefault(); // Prevent default form submission
        await handleSubmit(); // Call the async handler from the hook
    };
    // -------------------------------------------------------

    return (
        <div className="container mx-auto px-3 sm:px-4 py-4 sm:py-8">
            <h1 className="text-2xl sm:text-3xl font-bold mb-4 sm:mb-6">AI Flashcard Generator</h1>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-6">

                {/* Input Column */}
                <div>
                    <AiGenerateInputCard
                        files={files}
                        isLoading={isLoading}
                        error={error}
                        onFilesSelected={handleFilesSelected}
                        onSubmit={handleFormSubmit} // Use the async wrapper here
                        onClearAll={handleClearAll}
                        hasResults={displayFlashcards.length > 0 || !!extractedTextPreview || !!processingSummary}
                    />
                </div>

                {/* Results & Save Column */}
                <div className="space-y-6">
                    <AiGenerateResultsCard
                        flashcards={displayFlashcards}
                        extractedTextPreview={extractedTextPreview}
                        processingSummary={processingSummary}
                        deckName={deckName}
                        savedDeckId={savedDeckId}
                        needsModeConfirmationSource={needsModeConfirmationSource}
                        isProcessingStep2={isProcessingStep2}
                        onSaveJson={handleSaveFlashcards}
                        onSwapSource={handleSwapSourceCards}
                        onConfirmTranslation={handleConfirmTranslation}
                        onForceKnowledge={handleForceKnowledge}
                    />

                    <AiGenerateSaveDeckCard
                        flashcards={displayFlashcards}
                        deckName={deckName}
                        isSavingDeck={isSavingDeck}
                        savedDeckId={savedDeckId}
                        onDeckNameChange={handleDeckNameChange}
                        onSaveDeck={handleSaveDeck}
                    />
                </div>

            </div>
        </div> // End container
    );
}
```

### File: app/prepare/ai-generate/useAiGenerate.ts

```
// app/prepare/ai-generate/useAiGenerate.ts
"use client";

import { useState, useCallback, useRef, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { useSupabase } from '@/hooks/use-supabase'; // For storage uploads
import { useAuth } from '@/hooks/use-auth'; // For user ID
import { v4 as uuidv4 } from 'uuid';
// Ensure ApiFlashcard is imported and reflects the latest structure with classification fields
import type { ApiFlashcard } from '@/app/api/extract-pdf/types';
import { swapCardFields } from '@/lib/utils';
// Import specific types needed
import type { InitialGenerationResult, GeminiFlashcardClassification } from '@/app/api/extract-pdf/flashcardGeneratorService';
// --- Import SupportedFileType --- 
import type { SupportedFileType } from '@/app/api/extract-pdf/fileUtils'; 
import { appLogger, statusLogger } from '@/lib/logger';

// Use consistent type alias within this file
type FinalFlashcardData = ApiFlashcard; // Represents the final card with classification
// Export this type so other modules can import it
export type BasicFlashcardData = { question: string; answer: string; source?: string; fileType?: SupportedFileType; }; // Basic card structure
type ClassificationData = GeminiFlashcardClassification;

// Constants (remain unchanged)
const SUPPORTED_EXTENSIONS = [".pdf", ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp"];
const MAX_FILE_SIZE = 25; // 25MB
const DIRECT_UPLOAD_LIMIT = 4; // 4MB
const COMBINED_SIZE_LIMIT = 4; // 4MB
const UPLOAD_BUCKET = 'ai-uploads';

// Language Name -> Code Mapping (remain unchanged)
const languageNameToCodeMap: Record<string, string> = {
    'english': 'en', 'dutch': 'nl', 'french': 'fr',
    'german': 'de',
    'spanish': 'es', 'italian': 'it', 'portuguese': 'pt',
    // Add more as needed
};
const getLanguageCode = (name: string | undefined): string => {
    if (!name) return 'en'; // Default to English if undefined
    const code = languageNameToCodeMap[name.toLowerCase().trim()];
    return code || 'en'; // Default to English if mapping not found
};

// Helper function (remain unchanged)

export function useAiGenerate() {
    // --- State ---
    const [files, setFiles] = useState<File[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [isProcessingStep2, setIsProcessingStep2] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [basicFlashcardsBySource, setBasicFlashcardsBySource] = useState<Record<string, BasicFlashcardData[]>>({});
    const [initialModeBySource, setInitialModeBySource] = useState<Record<string, 'translation' | 'knowledge'>>({});
    const [finalFlashcards, setFinalFlashcards] = useState<FinalFlashcardData[]>([]);
    const [serverExtractedTextMap, setServerExtractedTextMap] = useState<Record<string, string>>({});
    const [needsModeConfirmationSource, setNeedsModeConfirmationSource] = useState<string | null>(null);
    const [extractedTextPreview, setExtractedTextPreview] = useState<string | null>(null);
    const [processingSummary, setProcessingSummary] = useState<string | null>(null);
    const [deckName, setDeckName] = useState<string>("");
    const [isSavingDeck, setIsSavingDeck] = useState(false);
    const [savedDeckId, setSavedDeckId] = useState<string | null>(null);
    const [detectedLanguageNames, setDetectedLanguageNames] = useState<{ qName: string | undefined, aName: string | undefined, b: boolean }>({ qName: undefined, aName: undefined, b: false });

    // --- Hooks and Refs ---
    const { supabase } = useSupabase();
    const { user } = useAuth();
    const router = useRouter();
    const progressTimerRef = useRef<NodeJS.Timeout | null>(null);
    const currentFileIndexRef = useRef<number>(0);

    // --- Memoized Derived State --- 
    const allBasicFlashcards = useMemo(() => Object.values(basicFlashcardsBySource).flat(), [basicFlashcardsBySource]);
    const displayFlashcards: (BasicFlashcardData | FinalFlashcardData)[] = useMemo(() => {
        return needsModeConfirmationSource ? allBasicFlashcards : finalFlashcards;
    }, [needsModeConfirmationSource, allBasicFlashcards, finalFlashcards]);

    // --- Internal Helper Functions ---

    // startProgressIndicator (remain unchanged)
    const startProgressIndicator = (toastId: string, fileNames: string[]) => {
        const totalFiles = fileNames.length;
        const averageTimePerFile = Math.max(1500, Math.min(5000, 90000 / (totalFiles + 1)));
        if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        toast.loading(`Processing file 1/${totalFiles}: ${fileNames[0]}`, { id: toastId });
        currentFileIndexRef.current = 0;
        progressTimerRef.current = setInterval(() => {
            currentFileIndexRef.current++;
            if (currentFileIndexRef.current >= totalFiles) {
                if (progressTimerRef.current) clearInterval(progressTimerRef.current);
                progressTimerRef.current = null;
                toast.loading(`Finalizing processing of ${totalFiles} files...`, { id: toastId });
                return;
            }
            const currentFile = fileNames[currentFileIndexRef.current];
            toast.loading(`Processing file ${currentFileIndexRef.current + 1}/${totalFiles}: ${currentFile}`, { id: toastId });
        }, averageTimePerFile);
    };

    // Reset state function
    const resetGenerationState = useCallback(() => {
        setError(null);
        setBasicFlashcardsBySource({});
        setInitialModeBySource({});
        setFinalFlashcards([]);
        setServerExtractedTextMap({});
        setNeedsModeConfirmationSource(null);
        setExtractedTextPreview(null);
        setProcessingSummary(null);
        setDeckName("");
        setSavedDeckId(null);
        setDetectedLanguageNames({ qName: undefined, aName: undefined, b: false });
        setIsProcessingStep2(false);
        setIsSavingDeck(false);
    }, []);

    // --- ADDED BACK: handleFilesSelected ---
    const handleFilesSelected = useCallback((selectedFiles: File[]) => {
        appLogger.info(`[useAiGenerate] handleFilesSelected: ${selectedFiles.length} files`);
        setFiles(Array.isArray(selectedFiles) ? [...selectedFiles] : []);
        // Reset relevant state when new files are selected
        resetGenerationState();
    }, [resetGenerationState]);
    // -------------------------------------

    // --- UPDATED: handleApiResponse for Step 1 ---
    const handleStep1ApiResponse = (data: any, totalFilesSubmitted: number) => {
        // --- ADD LOG to see the received code ---
        appLogger.info(`[useAiGenerate] handleStep1ApiResponse received data.code: ${data?.code}`);
        // ---------------------------------------
        
        // --- Explicitly handle PAGE_LIMIT_EXCEEDED error from API --- 
        if (data?.success === false && data?.code === 'PAGE_LIMIT_EXCEEDED') {
            appLogger.warn(`[useAiGenerate] Handling PAGE_LIMIT_EXCEEDED error: ${data.message}`);
            setError(data.message); // Set the specific error message for display
            const skippedInfo = data.skippedFiles && data.skippedFiles[0] ? `- ${data.skippedFiles[0].filename}: Skipped (${data.skippedFiles[0].reason})` : "File skipped due to page limit.";
            setProcessingSummary(skippedInfo);
            toast.error("Processing Failed", { description: data.message });
            appLogger.info("[useAiGenerate] Page limit error handled, returning from handleStep1ApiResponse.");
            return; // Stop further processing in this handler
        }
        // --- ELSE: Check for other errors or invalid structure ---
        else if (!data?.success || !Array.isArray(data.initialResults)) {
            // Throw error for other unsuccessful responses or invalid structure
            throw new Error(data?.message || "Invalid response structure from initial generation API.");
        }
        // ----------------------------------------------------------
        
        // --- Capture Server-Extracted Text --- 
        const extractedTextsFromServer: { filename: string; extractedText: string }[] = data.extractedTexts || [];
        const newServerExtractedTextMap: Record<string, string> = {};
        extractedTextsFromServer.forEach(item => {
            newServerExtractedTextMap[item.filename] = item.extractedText;
        });
        setServerExtractedTextMap(newServerExtractedTextMap); // Store server text
        // ------------------------------------

        const initialResults: InitialGenerationResult[] = data.initialResults;
        const skippedFiles: Array<{ filename: string; reason: string }> = data?.skippedFiles || [];
        const successfullyProcessedCount = data?.fileInfo?.files || 0;
        
        const newBasicFlashcardsBySource: Record<string, BasicFlashcardData[]> = {};
        const newInitialModeBySource: Record<string, 'translation' | 'knowledge'> = {};
        let firstTranslationSource: string | null = null; // Track first source needing confirmation
        let firstCard: BasicFlashcardData | null = null; // Track first card overall for naming
        let firstCardLangs: { qName: string | undefined, aName: string | undefined } = { qName: undefined, aName: undefined };

        initialResults.forEach((result, index) => {
            // Find the source filename - assumes initialResults matches files processed order
            const sourceFilename = data.fileInfo?.metadata?.sources?.[index]?.filename || `Unknown Source ${index + 1}`;
            const sourceFileType = data.fileInfo?.metadata?.sources?.[index]?.type as SupportedFileType | undefined || undefined;

            const processedCards = result.basicFlashcards.map(card => ({ 
                ...card, // question, answer
                source: sourceFilename, // Add source
                fileType: sourceFileType // Add file type
            }));
            
            newBasicFlashcardsBySource[sourceFilename] = processedCards;
            newInitialModeBySource[sourceFilename] = result.mode;

            if (!firstCard && processedCards.length > 0) {
                firstCard = processedCards[0];
                firstCardLangs = { qName: result.detectedQuestionLanguage || undefined, aName: result.detectedAnswerLanguage || undefined };
            }

            if (result.mode === 'translation' && processedCards.length > 0 && !firstTranslationSource) {
                firstTranslationSource = sourceFilename;
            }
        });

        setBasicFlashcardsBySource(newBasicFlashcardsBySource);
        setInitialModeBySource(newInitialModeBySource);
        const initialFinalCards: FinalFlashcardData[] = Object.values(newBasicFlashcardsBySource).flat().map(bc => ({
            question: bc.question,
            answer: bc.answer,
            questionLanguage: getLanguageCode(firstCardLangs.qName),
            answerLanguage: getLanguageCode(firstCardLangs.aName),
            isBilingual: !!firstCardLangs.qName && !!firstCardLangs.aName && firstCardLangs.qName !== firstCardLangs.aName,
            questionPartOfSpeech: 'N/A',
            questionGender: 'N/A',
            answerPartOfSpeech: 'N/A',
            answerGender: 'N/A',
            source: bc.source,
            fileType: bc.fileType
        }));
        setFinalFlashcards(initialFinalCards);
        setExtractedTextPreview(data?.extractedTextPreview || null);

        // --- Handle Mode Confirmation ---
        setNeedsModeConfirmationSource(firstTranslationSource);
        if (firstTranslationSource) {
            appLogger.info(`[useAiGenerate] Mode confirmation needed for source: ${firstTranslationSource}`);
            toast.info("Mode Confirmation Needed", { description: "Please confirm or change the detected mode for one or more files." });
        } else {
             appLogger.info("[useAiGenerate] No mode confirmation needed.");
        }
        // -------------------------------

        // Update summary and languages based on the FIRST card found
        let summaryLines: string[] = [];
        Object.entries(newBasicFlashcardsBySource).forEach(([filename, cards]) => {
            summaryLines.push(`- ${filename}: ${cards.length} card${cards.length !== 1 ? 's' : ''} generated (Mode: ${newInitialModeBySource[filename]})`);
        });
        skippedFiles.forEach(skipped => summaryLines.push(`- ${skipped.filename}: Skipped (${skipped.reason})`));
        setProcessingSummary(summaryLines.length > 0 ? summaryLines.join('\n') : "Processing complete.");

        if (firstCard) {
            const qLangName = firstCardLangs.qName;
            const aLangName = firstCardLangs.aName;
            const isBilingual = !!qLangName && !!aLangName && qLangName !== aLangName;
            setDetectedLanguageNames({ qName: qLangName, aName: aLangName, b: isBilingual });
            const basicFirstCard = firstCard as BasicFlashcardData;
            const suggestedName = basicFirstCard.source
                ? basicFirstCard.source.substring(0, basicFirstCard.source.lastIndexOf('.')) || basicFirstCard.source
                : "Generated Deck";
            setDeckName(suggestedName);
        } else {
            setDetectedLanguageNames({ qName: undefined, aName: undefined, b: false });
            setDeckName("Generated Deck");
        }

        // Toast logic 
        const totalGenerated = Object.values(newBasicFlashcardsBySource).reduce((sum, cards) => sum + cards.length, 0);
        if (totalGenerated > 0) {
            toast.success(`Generated ${totalGenerated} initial flashcards!`, {
                description: skippedFiles.length > 0 ? `(${skippedFiles.length} file(s) skipped)` : `Processed ${successfullyProcessedCount} file(s).`,
            });
        } else if (successfullyProcessedCount > 0 && skippedFiles.length === 0) {
            toast.info(`No flashcards generated from ${successfullyProcessedCount} file(s).`, { description: "Check file content." });
        } else if (skippedFiles.length > 0) {
            toast.warning(`No flashcards generated. ${skippedFiles.length} file(s) skipped.`, { description: "Check summary." });
        } else {
            toast.error("Processing failed.", { description: "No files processed." });
        }
    };

    // --- UPDATED: handleSubmit --- 
    const handleSubmit = useCallback(async () => {
        // Set loading true IMMEDIATELY
        setIsLoading(true);
        
        appLogger.info("[useAiGenerate] handleSubmit triggered for Step 1");
        const currentFiles = files;
        if (!currentFiles || currentFiles.length === 0) {
            setError('Please select file(s)');
            setIsLoading(false); // Reset loading if no files
            return;
        }
        if (!supabase || !user) {
            setError('Auth or DB connection error.');
            setIsLoading(false); // Reset loading on auth error
            return;
        }

        // Now reset other state, isLoading is already true
        resetGenerationState();

        const loadingToastId = `loading-${Date.now()}`;
        currentFileIndexRef.current = 0;
        if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        const safetyTimeout = setTimeout(() => { /* ... */ }, 90000);
        toast.loading(`Preparing ${currentFiles.length} file(s)...`, { id: loadingToastId });

        try {
            // --- File Validation ---
            let totalSizeMB = 0;
            let isAnyFileLarge = false;
            for (const file of currentFiles) {
                const fileSizeMB = file.size / (1024 * 1024);
                totalSizeMB += fileSizeMB;
                const fileExtension = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();

                if (!SUPPORTED_EXTENSIONS.includes(fileExtension)) {
                    throw new Error(`Unsupported file type: ${file.name}`);
                }
                if (fileSizeMB > MAX_FILE_SIZE) {
                    throw new Error(`File too large: ${file.name} (${fileSizeMB.toFixed(2)}MB > ${MAX_FILE_SIZE}MB)`);
                }
                if (fileSizeMB > DIRECT_UPLOAD_LIMIT) {
                    isAnyFileLarge = true;
                }
            }
            if (isAnyFileLarge) {
                appLogger.info(`[useAiGenerate] Validation passed. isAnyFileLarge: ${isAnyFileLarge}, totalSizeMB: ${totalSizeMB.toFixed(2)}`);
            }


            // --- Determine Upload Strategy & Prepare API Payload ---
            let apiPayload: FormData | string; // Can be FormData or JSON string
            let fetchOptions: RequestInit = { method: 'POST', credentials: 'same-origin' }; // Default method

            if (isAnyFileLarge || totalSizeMB > COMBINED_SIZE_LIMIT) {
                // Storage Upload Flow (Restored Logic)
                toast.loading(`Uploading to storage...`, { id: loadingToastId });
                let currentUploadIndex = 0;
                const uploadPromises = currentFiles.map(async (file, index) => {
                    // Ensure user object and id exist before using them
                    if (!user?.id) throw new Error("User not authenticated for storage upload."); 
                    const storagePath = `${user.id}/${uuidv4()}${file.name.slice(file.name.lastIndexOf('.'))}`; // Preserve original extension
                    try {
                        currentUploadIndex = index + 1;
                        toast.loading(`Uploading ${currentUploadIndex}/${currentFiles.length}: ${file.name}`, { id: loadingToastId });
                        // Ensure supabase client exists
                        if (!supabase) throw new Error("Supabase client not available for storage upload."); 
                        const { data: uploadData, error: uploadError } = await supabase.storage.from(UPLOAD_BUCKET).upload(storagePath, file, { upsert: false });
                        if (uploadError) throw new Error(`Storage upload failed for ${file.name}: ${uploadError.message}`);
                        // Check if uploadData and path exist
                        if (!uploadData?.path) throw new Error(`Storage upload succeeded for ${file.name} but returned no path.`); 
                        toast.success(`Uploaded: ${file.name}`, { id: `upload-${file.name}-${index}` });
                        return { filename: file.name, filePath: uploadData.path };
                    } catch (err: any) {
                        appLogger.error(`Upload Error ${file.name}:`, err);
                        toast.error(`Failed to upload: ${file.name}`, { id: `upload-${file.name}-${index}`, description: err.message });
                        return null;
                    }
                });
                const uploadResults = await Promise.all(uploadPromises);
                const successfulUploads = uploadResults.filter(
                    (result): result is { filename: string; filePath: string } => result !== null
                );
                if (successfulUploads.length === 0) throw new Error('All storage uploads failed.');
                if (successfulUploads.length < currentFiles.length) toast.warning(`${currentFiles.length - successfulUploads.length} file(s) failed to upload. Continuing with successful ones.`);
                
                // Prepare JSON payload with file paths
                apiPayload = JSON.stringify({ files: successfulUploads }); 
                fetchOptions.headers = { 'Content-Type': 'application/json' };
                appLogger.info("[useAiGenerate] Using Storage Upload Flow. Payload:", apiPayload);

            } else {
                // Direct Upload Flow (Unchanged)
                const formData = new FormData();
                currentFiles.forEach(file => formData.append('file', file));
                apiPayload = formData;
                // No specific Content-Type header needed for FormData; browser sets it
                appLogger.info("[useAiGenerate] Using Direct Upload Flow.");
            }
            // Assign body AFTER the if/else
            fetchOptions.body = apiPayload; 
            // ---------------------------------------------------------

            // --- API Call to Step 1 endpoint --- 
            const filesToProcess = currentFiles.map(f => f.name);
            startProgressIndicator(loadingToastId, filesToProcess); // Update toast for processing phase
            appLogger.info("[useAiGenerate] Calling POST /api/extract-pdf (Step 1)");
            const response = await fetch('/api/extract-pdf', fetchOptions);
            // ---------------------------------

            // --- Handle API Response (Step 1) --- 
            if (!response) throw new Error("No response from initial generation server.");
            let data;
            try { data = await response.json(); }
            catch (jsonError) { throw new Error(`Server returned invalid response (${response.status}).`); }
            finally { clearTimeout(safetyTimeout); toast.dismiss(loadingToastId); }
            
            // Use the dedicated handler for Step 1 results
            handleStep1ApiResponse(data, currentFiles.length); 
            // ------------------------------------

        } catch (err: any) {
            appLogger.info("[useAiGenerate] Caught error in handleSubmit try block.");
            appLogger.error('[useAiGenerate] Error during file processing (Step 1):', err);
            clearTimeout(safetyTimeout); toast.dismiss(loadingToastId);
            // --- Only set generic error if a specific one wasn't already set (Corrected Syntax) --- 
            if (!error) {
                setError(err.message || 'An error occurred during initial processing.');
            }
            // -----------------------------------------------------------------------------------
            toast.error('Initial Processing Error', { description: err.message || 'An unknown error occurred.' });
            // Remove this - we want to keep the error state to display it
            // resetGenerationState(); \n        } finally {\n            setIsLoading(false); // Step 1 loading finished\n            if (progressTimerRef.current) clearInterval(progressTimerRef.current);\n        }
        } finally {
            appLogger.info("[useAiGenerate] Entering handleSubmit finally block.");
            setIsLoading(false); // Step 1 loading finished
            if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        }
    }, [files, supabase, user, resetGenerationState, handleStep1ApiResponse, startProgressIndicator]);


    // --- NEW: handleConfirmTranslation (Step 2 - Classify) --- 
    const handleConfirmTranslation = useCallback(async () => {
        if (!needsModeConfirmationSource) return;
        const sourceFilename = needsModeConfirmationSource;
        const basicCards = basicFlashcardsBySource[sourceFilename];
        if (!basicCards || basicCards.length === 0) {
            toast.error("Cannot classify: No basic flashcards found for this source.");
            setNeedsModeConfirmationSource(null); // Clear flag even on error
            return;
        }

        setIsProcessingStep2(true);
        const toastId = toast.loading(`Classifying ${basicCards.length} flashcards for ${sourceFilename}...`);

        try {
            const payload = {
                action: 'classify',
                filename: sourceFilename,
                basicFlashcards: basicCards.map(({ question, answer }) => ({ question, answer })) // Send only Q/A
            };

            appLogger.info(`[useAiGenerate] Calling POST /api/process-ai-step2 (Action: classify) for ${sourceFilename}`);
            const response = await fetch('/api/process-ai-step2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            if (!response) throw new Error("No response from classification server.");
            const result = await response.json();
            if (!result.success) throw new Error(result.message || "Classification API returned an error.");

            const classifications: ClassificationData[] = result.data;

            // Merge classifications with basic cards
            setFinalFlashcards(prevFinal => {
                return prevFinal.map(card => {
                    if (card.source === sourceFilename) {
                        // Find corresponding basic card index (less efficient, consider map if needed)
                        const basicIndex = basicCards.findIndex(bc => bc.question === card.question && bc.answer === card.answer);
                        const classification = (basicIndex !== -1 && basicIndex < classifications.length) ? classifications[basicIndex] : null;
                        return {
                            ...card,
                            questionPartOfSpeech: classification?.questionPartOfSpeech?.trim() || 'N/A',
                            questionGender: classification?.questionGender?.trim() || 'N/A',
                            answerPartOfSpeech: classification?.answerPartOfSpeech?.trim() || 'N/A',
                            answerGender: classification?.answerGender?.trim() || 'N/A',
                        };
                    }
                    return card;
                });
            });

            toast.success(`Classification complete for ${sourceFilename}!`, { id: toastId });
            setNeedsModeConfirmationSource(null); // Clear confirmation flag

        } catch (error: any) {
            appLogger.error('[useAiGenerate] Error during classification (Step 2):', error);
            toast.error(`Classification Failed for ${sourceFilename}`, { 
                id: toastId, 
                description: error.message || 'An unknown error occurred.'
            });
             // Optionally revert finalFlashcards back to basic? Or leave as is?
             // For now, leave as basic, user might retry.
        } finally {
            setIsProcessingStep2(false);
        }
    }, [needsModeConfirmationSource, basicFlashcardsBySource]);


    // --- NEW: handleForceKnowledge (Step 2 - Regenerate) --- 
    const handleForceKnowledge = useCallback(async () => {
        if (!needsModeConfirmationSource) return;
        const sourceFilename = needsModeConfirmationSource;
        // Retrieve text from the map holding SERVER-extracted text
        const serverExtractedText = serverExtractedTextMap[sourceFilename];
        // Explicitly type currentFileType
        const currentFileType: SupportedFileType | undefined = basicFlashcardsBySource[sourceFilename]?.[0]?.fileType;
        if (!serverExtractedText) { // Check the correct variable
            toast.error(`Cannot regenerate: Server-extracted text for ${sourceFilename} not found.`);
            setNeedsModeConfirmationSource(null); // Clear flag
            return;
        }

        setIsProcessingStep2(true);
        const toastId = toast.loading(`Regenerating flashcards in Knowledge Mode for ${sourceFilename}...`);

        try {
            const payload = {
                action: 'force_knowledge',
                filename: sourceFilename,
                originalText: serverExtractedText // Send the correct text
            };

            appLogger.info(`[useAiGenerate] Calling POST /api/process-ai-step2 (Action: force_knowledge) for ${sourceFilename}`);
            const response = await fetch('/api/process-ai-step2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            if (!response) throw new Error("No response from knowledge regeneration server.");
            const result = await response.json();
            if (!result.success || !result.data) throw new Error(result.message || "Knowledge regeneration API returned an error or invalid data.");

            const regeneratedData = result.data as { detectedQuestionLanguage: string; detectedAnswerLanguage: string; basicFlashcards: BasicFlashcardData[] };
            const regeneratedCards: FinalFlashcardData[] = regeneratedData.basicFlashcards.map(card => ({
                ...card,
                questionLanguage: regeneratedData.detectedQuestionLanguage,
                answerLanguage: regeneratedData.detectedAnswerLanguage,
                isBilingual: false, // Knowledge mode is never bilingual
                questionPartOfSpeech: 'N/A',
                questionGender: 'N/A',
                answerPartOfSpeech: 'N/A',
                answerGender: 'N/A',
                source: sourceFilename, // Re-add source
                fileType: currentFileType // Assign the potentially undefined SupportedFileType
            }));

            // Update the final flashcards state, replacing cards from this source
            setFinalFlashcards(prevFinal => {
                const otherSourceCards = prevFinal.filter(card => card.source !== sourceFilename);
                return [...otherSourceCards, ...regeneratedCards];
            });
            
            // Update detected languages if this is the first source processed
            if (Object.keys(basicFlashcardsBySource).length === 1) { // Or check if it was the source used for initial detection
                setDetectedLanguageNames({ qName: regeneratedData.detectedQuestionLanguage, aName: regeneratedData.detectedAnswerLanguage, b: false });
            }

            // Update the summary for this source
            setProcessingSummary(prev => {
                 if (!prev) return `Regenerated ${regeneratedCards.length} cards for ${sourceFilename} (Knowledge Mode).`;
                 const lines = prev.split('\n');
                 const existingIndex = lines.findIndex(line => line.includes(sourceFilename));
                 const newLine = `- ${sourceFilename}: ${regeneratedCards.length} card${regeneratedCards.length !== 1 ? 's' : ''} generated (Knowledge Mode - Regenerated)`;
                 if (existingIndex !== -1) {
                     lines[existingIndex] = newLine;
                     return lines.join('\n');
                 } else {
                     return prev + '\n' + newLine;
                 }
            });

            toast.success(`Regeneration complete for ${sourceFilename}!`, { id: toastId });
            setNeedsModeConfirmationSource(null); // Clear confirmation flag

        } catch (error: any) {
            appLogger.error('[useAiGenerate] Error during knowledge regeneration (Step 2):', error);
            toast.error(`Regeneration Failed for ${sourceFilename}`, { 
                id: toastId, 
                description: error.message || 'An unknown error occurred.'
            });
        } finally {
            setIsProcessingStep2(false);
        }
    }, [needsModeConfirmationSource, serverExtractedTextMap, basicFlashcardsBySource]);

    // --- handleSaveDeck (Cleaned up error handling comments) --- 
    const handleSaveDeck = useCallback(async () => {
        const cardsToSave = finalFlashcards; 
        if (!cardsToSave || cardsToSave.length === 0) { 
            toast.error("No flashcards to save."); 
            return; 
        }
        if (needsModeConfirmationSource) {
             toast.error("Please resolve the mode confirmation before saving.");
             return;
        }
        if (!deckName.trim()) {
            toast.error("Please enter a deck name.");
            return;
        }

        setIsSavingDeck(true);
        const toastId = toast.loading("Saving deck...");

        try {
            const firstCard = cardsToSave[0]; 
            const qLangCode = getLanguageCode(firstCard?.questionLanguage);
            const aLangCode = getLanguageCode(firstCard?.answerLanguage);
            const isBilingualFlag = !!firstCard?.isBilingual;
            const payload = { name: deckName.trim(), questionLanguage: qLangCode, answerLanguage: aLangCode, isBilingual: isBilingualFlag, flashcards: cardsToSave };

            const response = await fetch('/api/decks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            
            // --- Cleaned up response handling --- 
            let result;
            const contentType = response.headers.get("content-type"); 
            if (contentType && contentType.includes("application/json")) {
                 result = await response.json(); 
            } else {
                 const textResponse = await response.text();
                 throw new Error(`Server returned non-JSON response (${response.status}): ${textResponse.substring(0,150)}...`);
            }
             
            if (!response.ok || !result.success) { 
                 throw new Error(result.message || `Failed to save deck (Status: ${response.status})`); 
            }
            // ----------------------------------

            setSavedDeckId(result.deckId); 
            toast.success(result.message || `Deck "${deckName.trim()}" saved!`, { id: toastId, action: { label: "View Deck", onClick: () => router.push(`/edit/${result.deckId}`) } }); 

        } catch (error: any) {
            appLogger.error("[useAiGenerate] Error saving deck:", error);
            toast.error("Failed to save deck", { id: toastId, description: error.message || "An unknown error occurred." });
            setSavedDeckId(null); 
        } finally {
            setIsSavingDeck(false);
        }
    }, [deckName, finalFlashcards, router, needsModeConfirmationSource]); 


    // handleClearAll (Needs to reset new state)
    const handleClearAll = useCallback(() => {
        setFiles([]);
        setIsLoading(false);
        resetGenerationState(); // Use the reset helper
        if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        currentFileIndexRef.current = 0;
        toast.info("Inputs and results cleared.");
    }, [resetGenerationState]);


    // handleSaveFlashcards (JSON download - Should download FINAL cards)
    const handleSaveFlashcards = useCallback(() => {
        const cardsToDownload = finalFlashcards;
        if (cardsToDownload.length === 0) {
            toast.error("No flashcards to download.");
            return;
        }
        // ... rest of download logic remains the same ...
        const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(
            JSON.stringify(cardsToDownload, null, 2)
        )}`;
        const link = document.createElement("a");
        link.href = jsonString;
        link.download = `${deckName || 'flashcards'}.json`;
        link.click();
        toast.success("Final flashcard data downloaded as JSON.");
    }, [finalFlashcards, deckName]);


    // handleDeckNameChange (remain unchanged)
    const handleDeckNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        setDeckName(e.target.value);
    }, []);


    // handleSwapSourceCards (updated)
    const handleSwapSourceCards = useCallback((sourceToSwap: string) => {
        appLogger.info(`[useAiGenerate] Swapping Q/A for source: ${sourceToSwap}`);
        
        setFinalFlashcards(currentFlashcards => 
            currentFlashcards.map(card => {
                if (card.source === sourceToSwap) {
                    const swappedBase = swapCardFields({ question: card.question, answer: card.answer });
                    return { 
                        ...card, 
                        question: swappedBase.question,
                        answer: swappedBase.answer,
                        questionLanguage: card.answerLanguage, // Swap languages
                        answerLanguage: card.questionLanguage,
                     } as FinalFlashcardData;
                }
                return card; 
            })
        );

        // Update basic cards state too
        setBasicFlashcardsBySource(prevBasic => {
             if (!prevBasic[sourceToSwap]) return prevBasic;
             const currentBasic = prevBasic[sourceToSwap];
             const newBasic = currentBasic.map(card => {
                 const swapped = swapCardFields({question: card.question, answer: card.answer});
                 // Re-apply source/type
                 return { ...swapped, source: card.source, fileType: card.fileType };
             }) as BasicFlashcardData[];
             return { ...prevBasic, [sourceToSwap]: newBasic };
         });

        // Update detected languages display state
        const firstSource = Object.keys(basicFlashcardsBySource)[0];
        if (sourceToSwap === firstSource) {
             setDetectedLanguageNames(prev => ({ qName: prev.aName, aName: prev.qName, b: prev.b }));
        }

        toast.info(`Question & Answer swapped for "${sourceToSwap}" (preview only). Save deck to persist.`);
    }, [basicFlashcardsBySource]); // Removed setFinalFlashcards as direct dependency


    // --- Return Values --- 
    return {
        // State
        files, 
        isLoading, // Step 1 loading
        isProcessingStep2, // Step 2 loading
        error, 
        displayFlashcards, // Use this for rendering the list
        extractedTextPreview, 
        processingSummary,
        deckName, 
        isSavingDeck, 
        savedDeckId,
        needsModeConfirmationSource, // Filename needing confirmation, or null
        // Actions / Handlers
        handleFilesSelected, 
        handleSubmit, // Renamed Step 1 trigger
        handleConfirmTranslation, // New Step 2 handler
        handleForceKnowledge, // New Step 2 handler
        handleSaveDeck, 
        handleClearAll,
        handleSaveFlashcards, 
        handleDeckNameChange, 
        handleSwapSourceCards,
    };
}
```

## Directory: app/profile

### File: app/profile/page.tsx

```
"use client"

import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowLeft, LogOut } from "lucide-react"
import Link from "next/link"
import { useAuth } from "@/hooks/use-auth"
import { toast } from "sonner"
import type { AuthError } from "@supabase/supabase-js"
import { appLogger, statusLogger } from '@/lib/logger'

export default function ProfilePage() {
  const { user, signOut, loading: authLoading } = useAuth()
  const router = useRouter()
  const [signOutLoading, setSignOutLoading] = useState(false)

  useEffect(() => {
    if (!authLoading) {
      if (!user) {
        const callbackUrl = encodeURIComponent('/profile');
        appLogger.info("Profile page: User not authenticated, redirecting to login.");
        router.push(`/login?callbackUrl=${callbackUrl}`);
      }
    }
  }, [authLoading, user, router]);

  const handleSignOut = async () => {
    setSignOutLoading(true)
    const { error } = await signOut()

    if (error) {
      appLogger.error("Error signing out:", error)
      if (error instanceof Error) {
        toast.error(error.message || "An unexpected error occurred during sign out.")
      } else {
        const errorMessage = (error as AuthError)?.message || "Sign out failed. Please try again.";
        toast.error(errorMessage)
      }
      setSignOutLoading(false)
    } else {
      toast.success("Signed out successfully.")
    }
  }

  if (authLoading) {
    return (
      <main className="container mx-auto px-4 py-8">
        <div className="flex justify-between items-center mb-6">
           <h1 className="text-2xl font-bold">Profile</h1>
        </div>
        <div className="max-w-2xl mx-auto text-center">
          Loading profile...
        </div>
      </main>
    );
  }

  if (!user) {
    return (
      <main className="container mx-auto px-4 py-8">
        <div className="flex justify-between items-center mb-6">
           <h1 className="text-2xl font-bold">Profile</h1>
        </div>
        <div className="max-w-2xl mx-auto text-center">
          Redirecting to login...
        </div>
      </main>
    );
  }

  return (
    <main className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <div className="flex items-center">
          <Link href="/" className="mr-4">
            <Button variant="ghost" size="icon">
              <ArrowLeft className="h-5 w-5" />
            </Button>
          </Link>
          <h1 className="text-2xl font-bold">Profile</h1>
        </div>
      </div>

      <div className="max-w-2xl mx-auto">
        <Card className="mb-6">
          <CardHeader>
            <CardTitle>User Profile</CardTitle>
            <CardDescription>Your account information</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              <p>
                <strong>Email:</strong> {user.email}
              </p>
              <p>
                <strong>User ID:</strong> {user.id}
              </p>
              <p>
                <strong>Last Sign In:</strong>{" "}
                {user.last_sign_in_at ? new Date(user.last_sign_in_at).toLocaleString() : "N/A"}
              </p>
            </div>
          </CardContent>
          <CardFooter>
            <Button variant="destructive" onClick={handleSignOut} disabled={signOutLoading}>
              <LogOut className="mr-2 h-4 w-4" />
              {signOutLoading ? "Signing out..." : "Sign Out"}
            </Button>
          </CardFooter>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>App Settings</CardTitle>
            <CardDescription>Manage your application preferences</CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-muted-foreground">
              You can change your language preferences and voice settings in the settings page.
            </p>
          </CardContent>
          <CardFooter>
            <Button onClick={() => router.push("/settings")}>Go to Settings</Button>
          </CardFooter>
        </Card>
      </div>
    </main>
  )
}


```

## Directory: app/settings

### File: app/settings/page.tsx

```
// File: /app/settings/page.tsx
"use client";

import React, { useEffect, useState, useCallback, useRef } from "react"; // Keep imports from working version
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { ArrowLeft, Palette, RotateCcw } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
// --- Adjust imports for Palette ---
import { useSettings, DEFAULT_SETTINGS as PROVIDER_DEFAULT_SETTINGS } from "@/providers/settings-provider";
import type { Settings, FontOption, ThemePreference } from "@/providers/settings-provider"; // Now includes wordPaletteConfig
import { PREDEFINED_PALETTES, DEFAULT_PALETTE_CONFIG } from "@/lib/palettes"; // Import palette data
import type { Palette as PaletteType } from "@/lib/palettes"; // Import Palette type
// ---------------------------------
import { toast } from "sonner";
import { Switch } from "@/components/ui/switch";
import { Input } from "@/components/ui/input";
import { FONT_OPTIONS } from "@/lib/fonts";
import { Separator } from "@/components/ui/separator";
import { useTheme } from "next-themes"; // Import useTheme
import { appLogger, statusLogger } from '@/lib/logger';
// Debounce likely not needed for Selects, removing for simplicity unless proven necessary
// import { debounce } from "@/lib/utils";

// Constants (Keep all from previous working version)
const POS_OPTIONS: ReadonlyArray<string> = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other'] as const;
const GENDER_OPTIONS_LABELS: ReadonlyArray<string> = ['Male', 'Female', 'Neutral / Other'] as const; // Use refined label
const GENDER_KEYS: ReadonlyArray<string> = ['Male', 'Female', 'Default'] as const;
const GENDERED_POS: ReadonlyArray<string> = ['Noun', 'Adjective', 'Pronoun'] as const;
const BASIC_POS: ReadonlyArray<string> = ['Noun', 'Verb'] as const;
const ADVANCED_POS: ReadonlyArray<string> = ['Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other'] as const;

// Use local defaults based on provider defaults (now includes palette config)
const LOCAL_DEFAULT_SETTINGS: Settings = {
    ...PROVIDER_DEFAULT_SETTINGS, // Should have correct enable flags
    wordPaletteConfig: DEFAULT_PALETTE_CONFIG, // Use palette default
};


export default function SettingsPage() {
  // Hooks and State
  const { user, loading: authLoading } = useAuth();
  const router = useRouter();
  const { settings, updateSettings, loading: settingsLoading } = useSettings();
  const { setTheme } = useTheme(); // Get setTheme function

  // State initialization (Keep all existing state variables)
  const [appLanguage, setAppLanguage] = useState<string>(LOCAL_DEFAULT_SETTINGS.appLanguage);
  const [cardFont, setCardFont] = useState<FontOption>(LOCAL_DEFAULT_SETTINGS.cardFont);
  const [masteryThreshold, setMasteryThreshold] = useState<number>(LOCAL_DEFAULT_SETTINGS.masteryThreshold);
  const [languageDialects, setLanguageDialects] = useState<NonNullable<Settings['languageDialects']>>(
      LOCAL_DEFAULT_SETTINGS.languageDialects
  );
  const [showDifficulty, setShowDifficulty] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.showDifficulty);
  const [ttsEnabled, setTtsEnabled] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.ttsEnabled);
  const [colorOnlyNonNative, setColorOnlyNonNative] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.colorOnlyNonNative);
  const [enableBasicColorCoding, setEnableBasicColorCoding] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.enableBasicColorCoding);
  const [enableAdvancedColorCoding, setEnableAdvancedColorCoding] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.enableAdvancedColorCoding);
  // --- State uses Palette Config ---
  const [wordPaletteConfig, setWordPaletteConfig] = useState<NonNullable<Settings['wordPaletteConfig']>>(
      LOCAL_DEFAULT_SETTINGS.wordPaletteConfig
  );
  // --- Add state for new setting ---
  const [showDeckProgress, setShowDeckProgress] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.showDeckProgress);
  const [themePreference, setThemePreference] = useState<ThemePreference>(LOCAL_DEFAULT_SETTINGS.themePreference);
  // --------------------------------

  // Effects (Keep original logic)
  useEffect(() => { /* Redirect */
    if (!authLoading && !user) {
        const callbackUrl = encodeURIComponent('/settings');
        router.push(`/login?callbackUrl=${callbackUrl}`);
    }
   }, [authLoading, user, router]);

  useEffect(() => { /* Load Settings */
     if (!settingsLoading && user) {
         const currentSettings = settings ?? LOCAL_DEFAULT_SETTINGS;
         setAppLanguage(currentSettings.appLanguage);
         setCardFont(currentSettings.cardFont);
         setMasteryThreshold(currentSettings.masteryThreshold);
         setShowDifficulty(currentSettings.showDifficulty);
         setTtsEnabled(currentSettings.ttsEnabled);
         setLanguageDialects(currentSettings.languageDialects);
         setColorOnlyNonNative(currentSettings.colorOnlyNonNative);
         setEnableBasicColorCoding(currentSettings.enableBasicColorCoding);
         setEnableAdvancedColorCoding(currentSettings.enableAdvancedColorCoding);
         // --- Load Palette Config ---
         setWordPaletteConfig({ ...DEFAULT_PALETTE_CONFIG, ...(currentSettings.wordPaletteConfig ?? {}) });
         // --- Load new setting ---
         setShowDeckProgress(currentSettings.showDeckProgress);
         setThemePreference(currentSettings.themePreference); // Load theme preference
         // --------------------------
     }
  }, [settings, settingsLoading, user]);

  // Handlers (Keep original useCallback structure)
  const handleSettingChange = useCallback(async (updates: Partial<Settings>) => {
    if (!user) { toast.error("Authentication Error"); return; }
    try {
        await updateSettings(updates);
        // toast.success("Settings updated"); // Only toast on explicit saves/resets perhaps
    } catch (error) {
        appLogger.error("Failed to save settings:", error);
        toast.error("Error saving settings");
    }
   }, [user, updateSettings]); // Keep dependencies

  // Keep simple handlers wrapped in useCallback
  const handleLanguageChange = useCallback(async (value: string) => { setAppLanguage(value); await handleSettingChange({ appLanguage: value }); }, [handleSettingChange]);
  const handleFontChange = useCallback(async (value: FontOption) => { setCardFont(value); await handleSettingChange({ cardFont: value }); }, [handleSettingChange]);
  const handleMasteryThresholdChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
      const value = parseInt(e.target.value);
      if (!isNaN(value) && value >= 1 && value <= 10) {
          setMasteryThreshold(value);
          handleSettingChange({ masteryThreshold: value });
      } else if (e.target.value === '') {
          setMasteryThreshold(LOCAL_DEFAULT_SETTINGS.masteryThreshold);
      }
   }, [handleSettingChange]);
  const handleShowDifficultyChange = useCallback(async (checked: boolean) => { setShowDifficulty(checked); await handleSettingChange({ showDifficulty: checked }); }, [handleSettingChange]);
  const handleTtsEnabledChange = useCallback(async (checked: boolean) => { setTtsEnabled(checked); await handleSettingChange({ ttsEnabled: checked }); }, [handleSettingChange]);
  const handleDialectChange = useCallback((key: keyof NonNullable<Settings['languageDialects']>) => async (value: string) => {
      setLanguageDialects(prevDialects => {
          const newDialects = { ...prevDialects, [key]: value };
          handleSettingChange({ languageDialects: newDialects });
          return newDialects;
      });
   }, [handleSettingChange]);
  
   const handleColorOnlyNonNativeChange = useCallback(async (checked: boolean) => {
    setColorOnlyNonNative(checked);
    await handleSettingChange({ colorOnlyNonNative: checked });
  }, [handleSettingChange]);

  const handleEnableBasicChange = useCallback(async (checked: boolean) => { setEnableBasicColorCoding(checked); await handleSettingChange({ enableBasicColorCoding: checked }); }, [handleSettingChange]);
  const handleEnableAdvancedChange = useCallback(async (checked: boolean) => { setEnableAdvancedColorCoding(checked); await handleSettingChange({ enableAdvancedColorCoding: checked }); }, [handleSettingChange]);

  // --- NEW Palette Change Handler (Replaces handleColorChange, no debounce needed) ---
  const handlePaletteChange = useCallback((pos: string, genderKey: string) => async (selectedPaletteId: string) => {
      setWordPaletteConfig(prevConfig => {
           const currentConfig = prevConfig ?? DEFAULT_PALETTE_CONFIG;
           // Deep copy might be safer if config structure gets complex
           const newConfig = JSON.parse(JSON.stringify(currentConfig));
           if (!newConfig[pos]) newConfig[pos] = {};
           newConfig[pos][genderKey] = selectedPaletteId;
           // Save immediately
           handleSettingChange({ wordPaletteConfig: newConfig });
           return newConfig;
      });
      // Optional feedback toast
      // toast.info(`${pos} (${genderKey}) palette set to ${selectedPaletteId}`);
  }, [handleSettingChange]);
  // ---------------------------------------------------------------------------------

  // --- UPDATED Reset Handler ---
  const handleResetColors = useCallback(async () => {
      const defaultPalettes = { ...DEFAULT_PALETTE_CONFIG };
      setWordPaletteConfig(defaultPalettes); // Reset local state
      await handleSettingChange({ wordPaletteConfig: defaultPalettes }); // Save defaults
      toast.info("Color palette settings reset to default.");
  }, [handleSettingChange]);
  // ---------------------------

  // --- Add handler for new setting ---
  const handleShowDeckProgressChange = useCallback(async (checked: boolean) => {
      setShowDeckProgress(checked);
      await handleSettingChange({ showDeckProgress: checked });
  }, [handleSettingChange]);
  // -----------------------------------

  // --- Updated handler for new theme setting ---
  const handleThemeChange = useCallback(async (value: ThemePreference) => {
      // 1. Update local state
      setThemePreference(value);
      // 2. Apply theme using next-themes
      setTheme(value);
      // 3. Save preference to database
      await handleSettingChange({ themePreference: value });
      // 4. Notify user
      toast.info(`Theme set to ${value}.`);
  }, [handleSettingChange, setTheme]); // Added setTheme to dependencies
  // --------------------------------------

  // Loading/User checks
  if (settingsLoading || authLoading) { return <div className="container mx-auto p-8">Loading Settings...</div>; }
  if (!user) { return <div className="container mx-auto p-8">Redirecting to login...</div>; }

  // --- Render ---
  return (
    <div className="container mx-auto py-8"> {/* Keep Original Container */}
      <div className="flex items-center justify-between mb-8"> {/* Keep Original Header */}
        <h1 className="text-3xl font-bold">Settings</h1>
        <Button variant="outline" onClick={() => router.back()}> <ArrowLeft className="mr-2 h-4 w-4" /> Back </Button>
      </div>
      <div className="grid gap-6"> {/* Keep Original Grid */}

        {/* --- Card Settings Card (Renamed) --- */}
        <Card>
            <CardHeader>
                <CardTitle>Card Settings</CardTitle> {/* Renamed Title */}
                <CardDescription>Configure card appearance and learning behavior</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                <div className="grid gap-4">
                    {/* Language */}
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="appLanguage" className="text-right">Native Language</Label>
                        <Select value={appLanguage} onValueChange={handleLanguageChange}>
                            <SelectTrigger id="appLanguage" className="col-span-3"><SelectValue placeholder="Select language" /></SelectTrigger>
                            <SelectContent>
                                <SelectItem value="en">English</SelectItem>
                                <SelectItem value="nl">Dutch</SelectItem>
                                <SelectItem value="fr">French</SelectItem>
                                <SelectItem value="de">German</SelectItem>
                                <SelectItem value="es">Spanish</SelectItem>
                                <SelectItem value="it">Italian</SelectItem>
                            </SelectContent>
                        </Select>
                    </div>
                    {/* Font Selection */}
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="cardFont" className="text-right">Card Font</Label>
                        <Select value={cardFont} onValueChange={handleFontChange}>
                            <SelectTrigger id="cardFont" className="col-span-3"><SelectValue placeholder="Select font" /></SelectTrigger>
                            <SelectContent>
                                {(Object.entries(FONT_OPTIONS) as [FontOption, { name: string; [key: string]: any }][]).map(([key, font]) => (
                                <SelectItem key={key} value={key} style={{ fontFamily: key === 'default' ? 'var(--font-sans)' : key === 'opendyslexic' ? "'OpenDyslexic', system-ui, sans-serif" : "'Atkinson Hyperlegible', system-ui, sans-serif" }} > {font.name} </SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    </div>
                    {/* Mastery Threshold */}
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="masteryThreshold" className="text-right">Mastery Threshold</Label>
                        <div className="col-span-3 flex items-center gap-4">
                        <Input id="masteryThreshold" type="number" min={1} max={10} value={masteryThreshold} onChange={handleMasteryThresholdChange} className="w-24" />
                        <span className="text-sm text-muted-foreground">Correct answers needed to master (1-10)</span>
                        </div>
                    </div>
                </div>
                {/* Show Rating Buttons */}
                <div className="flex items-center justify-between p-4 border rounded-lg">
                    <div>
                        <h3 className="font-medium">Show Rating Buttons</h3>
                        <p className="text-sm text-muted-foreground">Display Again/Hard/Good/Easy buttons</p>
                    </div>
                    <Switch checked={showDifficulty} onCheckedChange={handleShowDifficultyChange} />
                </div>
            </CardContent>
        </Card>
        {/* --- End Card Settings Card --- */}

        {/* --- Appearance Settings Card (New) --- */}
        <Card>
            <CardHeader>
                <CardTitle>Appearance Settings</CardTitle>
                <CardDescription>Adjust the look and feel of the application</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                {/* Theme Preference */}
                <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="themePreference" className="text-right">Theme</Label>
                    <Select value={themePreference} onValueChange={handleThemeChange}>
                        <SelectTrigger id="themePreference" className="col-span-3">
                            <SelectValue placeholder="Select theme..." />
                        </SelectTrigger>
                        <SelectContent>
                            <SelectItem value="light">Light</SelectItem>
                            <SelectItem value="dark">Dark</SelectItem>
                            <SelectItem value="system">System Default</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
                <Separator />
                {/* Show Deck Progress Toggle (Moved) */}
                <div className="flex items-center justify-between">
                    <div>
                        <h3 className="font-medium">Show Deck Progress</h3>
                        <p className="text-sm text-muted-foreground">Display progress bars on deck cards</p>
                    </div>
                    <Switch checked={showDeckProgress} onCheckedChange={handleShowDeckProgressChange} />
                </div>
            </CardContent>
        </Card>

        {/* --- Speech Settings Card - RESTORED FULL CONTENT --- */}
        <Card>
            <CardHeader>
                <CardTitle>Speech Settings</CardTitle>
                <CardDescription>Configure text-to-speech and language preferences</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                {/* TTS Toggle */}
                <div className="flex items-center justify-between p-4 border rounded-lg">
                    <div>
                        <h3 className="font-medium">Text-to-Speech</h3>
                        <p className="text-sm text-muted-foreground">Enable audio playback for cards</p>
                    </div>
                    <Switch checked={ttsEnabled} onCheckedChange={handleTtsEnabledChange}/>
                </div>
                {/* Dialect Selectors */}
                {ttsEnabled && (
                <>
                    <Separator />
                    <div className="grid gap-4 pt-4">
                        {(Object.keys(languageDialects) as Array<keyof typeof languageDialects>).map((langKey) => (
                        <div key={langKey} className="grid grid-cols-4 items-center gap-4">
                            <Label htmlFor={`dialect-${langKey}`} className="text-right capitalize">{ { en: 'English', nl: 'Dutch', fr: 'French', de: 'German', es: 'Spanish', it: 'Italian' }[langKey] ?? langKey }</Label>
                            <Select value={languageDialects[langKey] ?? ''} onValueChange={handleDialectChange(langKey)}>
                                <SelectTrigger id={`dialect-${langKey}`} className="col-span-3"><SelectValue /></SelectTrigger>
                                <SelectContent>
                                    {langKey === 'en' && <> <SelectItem value="en-GB">English (UK)</SelectItem> <SelectItem value="en-US">English (US)</SelectItem> </>}
                                    {langKey === 'nl' && <> <SelectItem value="nl-NL">Dutch (NL)</SelectItem> <SelectItem value="nl-BE">Dutch (BE)</SelectItem> </>}
                                    {langKey === 'fr' && <> <SelectItem value="fr-FR">French (FR)</SelectItem> <SelectItem value="fr-BE">French (BE)</SelectItem> <SelectItem value="fr-CH">French (CH)</SelectItem> </>}
                                    {langKey === 'de' && <> <SelectItem value="de-DE">German (DE)</SelectItem> <SelectItem value="de-AT">German (AT)</SelectItem> <SelectItem value="de-CH">German (CH)</SelectItem> </>}
                                    {langKey === 'es' && <> <SelectItem value="es-ES">Spanish (ES)</SelectItem> </>}
                                    {langKey === 'it' && <> <SelectItem value="it-IT">Italian (IT)</SelectItem> <SelectItem value="it-CH">Italian (CH)</SelectItem> </>}
                                </SelectContent>
                            </Select>
                        </div>
                        ))}
                    </div>
                </>
                )}
            </CardContent>
        </Card>
        {/* --- End Speech Settings Card --- */}

        {/* --- Word Color Coding Card (MODIFIED Content) --- */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Palette className="h-5 w-5" /> Word Color Coding</CardTitle>
            <CardDescription>Assign pre-defined color palettes to words based on grammar.</CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            
             {/* Section 1: Basic */}
             <div className="border rounded-lg p-4 space-y-4">
                <div className="flex items-center justify-between">
                     <div> <h3 className="font-medium">Basic Color Coding (Nouns & Verbs)</h3> <p className="text-sm text-muted-foreground">Highlight common word types.</p> </div>
                     <Switch checked={enableBasicColorCoding} onCheckedChange={handleEnableBasicChange}/>
                </div>
                {enableBasicColorCoding && (
                    <div className="pl-2 space-y-4">
                        {BASIC_POS.map(pos => (
                            <div key={pos}>
                                <Label className="font-semibold text-base mb-3 block">{pos}</Label>
                                <div className={`grid grid-cols-1 ${pos === 'Noun' ? 'md:grid-cols-3' : 'md:grid-cols-1'} gap-x-6 gap-y-4 items-center`}>
                                    {(pos === 'Noun' ? GENDER_KEYS : ['Default']).map((genderKey, index) => (
                                        <div key={genderKey} className="flex flex-col sm:flex-row sm:items-center gap-2">
                                            <Label htmlFor={`palette-${pos}-${genderKey}`} className="text-sm w-full sm:w-24 text-left sm:text-right flex-shrink-0">
                                                {pos === 'Noun' ? GENDER_OPTIONS_LABELS[index] : 'Default Color'}
                                            </Label>
                                            {/* === Select for Palettes === */}
                                            <Select
                                                value={wordPaletteConfig?.[pos]?.[genderKey] ?? 'default'}
                                                onValueChange={handlePaletteChange(pos, genderKey)}
                                            >
                                                <SelectTrigger id={`palette-${pos}-${genderKey}`} className="flex-grow">
                                                    <SelectValue placeholder="Select palette..." />
                                                </SelectTrigger>
                                                <SelectContent>
                                                    {PREDEFINED_PALETTES.map((palette) => (
                                                        <SelectItem key={palette.id} value={palette.id}>
                                                            <div className="flex items-center gap-2">
                                                                <span style={{ backgroundColor: palette.light.background, border: '1px solid #ccc' }} className="inline-block w-4 h-4 rounded-sm flex-shrink-0"></span>
                                                                {palette.name}
                                                            </div>
                                                        </SelectItem>
                                                    ))}
                                                </SelectContent>
                                            </Select>
                                            {/* ============================ */}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
             </div>

             {/* Section 2: Advanced */}
             <div className="border rounded-lg p-4 space-y-4">
                 <div className="flex items-center justify-between">
                    <div> <h3 className="font-medium">Advanced Color Coding</h3> <p className="text-sm text-muted-foreground">Configure colors for other word types.</p> </div>
                    <Switch checked={enableAdvancedColorCoding} onCheckedChange={handleEnableAdvancedChange}/>
                 </div>
                 {enableAdvancedColorCoding && (
                     <div className="pl-2 space-y-4">
                        {ADVANCED_POS.map(pos => {
                            const isGendered = GENDERED_POS.includes(pos);
                            const relevantGenders = isGendered ? GENDER_KEYS : ['Default'];
                            const relevantLabels = isGendered ? GENDER_OPTIONS_LABELS : ['Neutral / Other'];
                            return (
                                <div key={pos}>
                                    <Label className="font-semibold text-base mb-3 block">{pos}</Label>
                                    <div className={`grid grid-cols-1 ${isGendered ? 'md:grid-cols-3' : 'md:grid-cols-1'} gap-x-6 gap-y-4 items-center`}>
                                        {relevantGenders.map((genderKey, index) => (
                                            <div key={genderKey} className="flex flex-col sm:flex-row sm:items-center gap-2">
                                                <Label htmlFor={`palette-${pos}-${genderKey}`} className="text-sm w-full sm:w-24 text-left sm:text-right flex-shrink-0">
                                                    {relevantLabels[index]}
                                                </Label>
                                                 {/* === Select for Palettes === */}
                                                <Select
                                                    value={wordPaletteConfig?.[pos]?.[genderKey] ?? 'default'}
                                                    onValueChange={handlePaletteChange(pos, genderKey)}
                                                >
                                                    <SelectTrigger id={`palette-${pos}-${genderKey}`} className="flex-grow">
                                                        <SelectValue placeholder="Select palette..." />
                                                    </SelectTrigger>
                                                    <SelectContent>
                                                        {PREDEFINED_PALETTES.map((palette) => (
                                                            <SelectItem key={palette.id} value={palette.id}>
                                                                 <div className="flex items-center gap-2">
                                                                    <span style={{ backgroundColor: palette.light.background, border: '1px solid #ccc' }} className="inline-block w-4 h-4 rounded-sm flex-shrink-0"></span>
                                                                    {palette.name}
                                                                </div>
                                                            </SelectItem>
                                                        ))}
                                                    </SelectContent>
                                                </Select>
                                                 {/* ============================ */}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            );
                        })}
                     </div>
                 )}
             </div>
                
              {/* Reset Button */}
             <div className="flex justify-end pt-4">
                 <Button variant="outline" size="sm" onClick={handleResetColors}>
                     <RotateCcw className="h-4 w-4 mr-2" />
                     Reset Palette Defaults
                 </Button>
             </div>
             {/* --- NEW Toggle --- */}
            <div className="flex items-center justify-between p-4 border rounded-lg">
                          <div>
                              <h3 className="font-medium">Apply Only to Non-Native Language</h3>
                              <p className="text-sm text-muted-foreground">
                                  Only color words not matching your app language ('{settings?.appLanguage || 'N/A'}').
                              </p>
                          </div>
                          <Switch
                              checked={colorOnlyNonNative}
                              onCheckedChange={handleColorOnlyNonNativeChange}
                              aria-labelledby="color-non-native-label"
                          />
                            <span id="color-non-native-label" className="sr-only">Apply color coding only to non-native language words</span>
                      </div>
                      {/* ---------------- */}
          </CardContent>
        </Card>
        {/* --- End Word Color Coding Card --- */}

      </div> {/* End main grid */}
    </div> // End container
  );
}
```

## Directory: app/signup

### File: app/signup/page.tsx

```
"use client"

import type React from "react"
import { useState, useEffect, Suspense } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useAuth } from "@/hooks/use-auth"
import { toast } from "sonner"
import type { AuthError } from '@supabase/supabase-js'
import { appLogger, statusLogger } from '@/lib/logger'

/**
 * Sign-up Page component.
 *
 * This component acts as the entry point for the sign-up route.
 * It wraps the main `SignupContent` component in a React Suspense
 * boundary to correctly handle client-side hooks like `useSearchParams`.
 *
 * @returns {JSX.Element} The Sign-up Page UI wrapped in Suspense.
 */
export default function SignupPage() {
  // The main export wraps SignupContent in Suspense
  return (
    <Suspense fallback={<div className="flex items-center justify-center min-h-screen">Loading Page...</div>}>
      <SignupContent />
    </Suspense>
  )
}

/**
 * Renders the sign-up form and manages the sign-up process.
 *
 * This client component handles user input for email and password,
 * performs client-side validation (password match, length),
 * interacts with the `useAuth` hook to call the `signUp` function,
 * displays loading states and feedback messages (success/error) using toasts,
 * handles redirection based on authentication state or server feedback
 * (e.g., after email confirmation request), and prevents access if the user
 * is already logged in.
 *
 * @returns {JSX.Element} The Sign-up form UI or a loading spinner.
 */
// --- Define the inner component containing the client logic ---
function SignupContent() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [confirmPassword, setConfirmPassword] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const { signUp, user, loading: authLoading } = useAuth()
  const router = useRouter()
  const searchParams = useSearchParams()

  useEffect(() => {
    if (!authLoading && user) {
      router.push("/")
    }
  }, [user, authLoading, router])

  useEffect(() => {
    const message = searchParams.get('message')
    const error = searchParams.get('error')
    if (message === 'confirmation_email_sent') {
      toast.success("Confirmation Email Sent", {
        description: "Please check your email to confirm your account."
      })
    }
    if (error) {
      toast.error("Signup Error", { description: error })
    }
    if (message || error) {
      router.replace('/signup', { scroll: false })
    }
  }, [searchParams, router])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!email || !password || !confirmPassword) {
      toast.error("Missing Information", {
        description: "Please fill in all fields."
      })
      return
    }

    if (password !== confirmPassword) {
      toast.error("Password Mismatch", {
        description: "The passwords entered do not match."
      })
      return
    }

    if (password.length < 6) {
      toast.error("Password Too Short", {
        description: "Password must be at least 6 characters long."
      })
      return
    }

    setIsLoading(true)

    try {
      const { data, error } = await signUp(email, password)

      if (error) {
        appLogger.error("Sign up error:", error)
        if (error instanceof Error) {
          toast.error(error.message || "An unexpected error occurred during sign up.")
        } else {
          toast.error((error as any).message || "Sign up failed. Please try again.")
        }
      } else if (data?.user) {
        if (data.user.identities && data.user.identities.length > 0 && !data.user.email_confirmed_at) {
          toast.info("Sign up successful! Please check your email to confirm your account.")
          router.push("/login?message=check_email")
        } else {
          toast.success("Sign up successful! Redirecting...")
          router.push("/")
        }
      } else {
        toast.error("An unexpected issue occurred during sign up. Please try again.")
      }
    } catch (err) {
      appLogger.error("Signup submit error:", err)
      toast.error("Sign Up Failed", {
        description: "An unexpected error occurred. Please try again later."
      })
    } finally {
      setIsLoading(false)
    }
  }

  if (authLoading || user) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-background">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    )
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl text-center">Create an account</CardTitle>
          <CardDescription className="text-center">Enter your email and password to sign up</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="m@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="confirmPassword">Confirm Password</Label>
              <Input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Creating account..." : "Sign up"}
            </Button>
          </CardFooter>
        </form>
        <CardFooter className="flex flex-col items-center justify-center space-y-2">
          <div className="text-sm text-muted-foreground">
            Already have an account?{" "}
            <Link href="/login" className="text-primary hover:underline">
              Sign in
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  )
}
// --- End of SignupContent component ---


```

## Directory: app/study

## Directory: app/study/select

### File: app/study/select/page.tsx

```
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getDecks } from '@/lib/actions/deckActions';
import { getUserStudySets } from '@/lib/actions/studySetActions';
import { PageHeading } from '@/components/ui/page-heading';
import { StudySelectClient } from '../../../components/study/StudySelectClient';
import type { Tables } from '@/types/database';

/**
 * Study Selection Page
 * 
 * This is a Server Component that pre-fetches both decks and study sets data
 * server-side before rendering the page, eliminating client-side data fetching delays.
 * 
 * @returns {Promise<JSX.Element>} The Study Selection page with pre-fetched data
 */
export default async function StudySelectPage() {
  // Check authentication server-side
  const supabase = createServerClient();
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  if (!session) {
    redirect("/login");
  }

  // Pre-fetch both decks and study sets in parallel server-side
  const [decksResult, studySetsResult] = await Promise.all([
    getDecks(),
    getUserStudySets()
  ]);

  const hasErrors = Boolean(decksResult.error || studySetsResult.error);

  // Type for Deck with SRS counts from StudySelectClient
  type DeckWithCounts = Tables<'decks'> & {
    new_count: number;
    learning_count: number;
    young_count: number;
    mature_count: number;
  };

  return (
    <div className="container py-6">
      <PageHeading 
        title="Choose Study Material"
        description="Select what you want to review" 
      />
      <StudySelectClient 
        initialDecks={(decksResult.data || []) as unknown as DeckWithCounts[]} 
        initialStudySets={studySetsResult.data || []}
        hasErrors={hasErrors}
      />
    </div>
  );
} 
```

## Directory: app/study/session

### File: app/study/session/page.tsx

```
// app/study/session/page.tsx
'use client';

import React, { useEffect, useState, useMemo, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { useStudySessionStore } from '@/store/studySessionStore';
import { useStudySession, type UseStudySessionReturn } from '@/hooks/useStudySession';
import { StudyFlashcardView, type StudyFlashcardViewProps } from '@/components/study-flashcard-view';
import { Loader2 as IconLoader } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Progress } from "@/components/ui/progress";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Terminal } from "lucide-react"
import { toast } from 'sonner';
import { useSettings } from '@/providers/settings-provider';
import { useTTS } from "@/hooks/use-tts";
import type { SessionType, StudyCardDb, SessionResults } from '@/types/study'; // Added SessionResults
import { appLogger } from '@/lib/logger';

const FLIP_DURATION_MS = 300;

declare global {
  interface Window {
    ttsErrorShown?: boolean;
  }
}

export default function StudySessionPage() {
  const router = useRouter();

  const currentInputFromStore = useStudySessionStore((state) => state.currentInput);
  const sessionTypeFromStore = useStudySessionStore((state) => state.currentSessionType);

  const [isPageInitialized, setIsPageInitialized] = useState(false);

  const { settings, loading: isLoadingSettings } = useSettings();

  const {
    currentCard,
    isInitializing,
    error,
    sessionType,
    isComplete,
    totalCardsInSession, // This is initialEligibleCardCount from the hook
    // currentCardNumberInSession, // We will derive a new one based on refined progress
    initialQueryCount,
    answerCard,
    sessionResults, // Full SessionResults object
    isProcessingAnswer,
    isFlipped,
    onFlip,
    currentCardStatusDisplay,
    showContinueReviewPrompt,
    onContinueReview,
    unifiedSessionPhase // Destructure this new property
  }: UseStudySessionReturn = useStudySession({
    initialInput: currentInputFromStore,
    sessionType: sessionTypeFromStore
  });

  const [isTransitioningVisual, setIsTransitioningVisual] = useState(false);
  const { speak, stop, ttsState } = useTTS({});

  const prevCardIdRef = useRef<string | null | undefined>(null);
  const prevIsFlippedRef = useRef(isFlipped);
  const speakInitiatedForQuestionRef = useRef(false);
  const speakInitiatedForAnswerRef = useRef(false);

  const isLoadingPage = isInitializing || isLoadingSettings || !isPageInitialized;

  useEffect(() => {
    if (!isPageInitialized) {
        setIsPageInitialized(true);
        return;
    }
    const checkTimer = setTimeout(() => {
        if (!isLoadingSettings && !isInitializing && (!currentInputFromStore || !sessionTypeFromStore)) {
          appLogger.warn("[SessionPage ParamCheckEffect] REDIRECTING to /study/select due to missing params.", { currentInputFromStore, sessionTypeFromStore });
          toast.warning("No study session active.", { description: "Redirecting to selection..."});
          router.replace('/study/select');
        } else {
          appLogger.info("[SessionPage ParamCheckEffect] Conditions for redirect NOT MET or still loading.", {isLoadingSettings, isInitializing, currentInputFromStore, sessionTypeFromStore});
        }
    }, 250);
    return () => {
        appLogger.info("[SessionPage ParamCheckEffect] Cleanup.");
        clearTimeout(checkTimer);
    };
  }, [isPageInitialized, currentInputFromStore, sessionTypeFromStore, router, isLoadingSettings, isInitializing]);

  useEffect(() => {
    if (currentCard?.id !== prevCardIdRef.current) {
        setIsTransitioningVisual(false);
        speakInitiatedForQuestionRef.current = false;
        speakInitiatedForAnswerRef.current = false;
        prevCardIdRef.current = currentCard?.id;
    }
  }, [currentCard?.id]);

  useEffect(() => {
    const cardForTTS = currentCard as StudyCardDb | null;
    if (!settings?.ttsEnabled || !cardForTTS || ttsState === 'loading' || isLoadingPage || isFlipped || speakInitiatedForQuestionRef.current) {
      return;
    }
    const textToSpeak = cardForTTS.question;
    const langToUse = cardForTTS.decks?.primary_language ?? 'en';
    if (textToSpeak && langToUse) {
      appLogger.info(`[SessionPage TTS - Question] Requesting speak for card ${cardForTTS.id}`);
      speakInitiatedForQuestionRef.current = true;
      stop();
      speak(textToSpeak, langToUse)
        .catch(ttsError => {
          appLogger.error("[SessionPage TTS - Question] Failed to speak text:", ttsError);
          if (typeof window !== 'undefined' && !window.ttsErrorShown) {
            toast.error("Text-to-speech error", { description: "TTS for question failed." });
            window.ttsErrorShown = true;
          }
          speakInitiatedForQuestionRef.current = false;
        });
    }
  }, [currentCard, isFlipped, settings?.ttsEnabled, isLoadingPage, speak, stop, ttsState]);

  useEffect(() => {
    const cardForTTS = currentCard as StudyCardDb | null;
    if (!settings?.ttsEnabled || !cardForTTS || ttsState === 'loading' || isLoadingPage || !isFlipped || speakInitiatedForAnswerRef.current) {
      return;
    }
    if (isFlipped && !prevIsFlippedRef.current) {
        const textToSpeak = cardForTTS.answer;
        const langToUse = cardForTTS.decks?.secondary_language ?? cardForTTS.decks?.primary_language ?? 'en';
        if (textToSpeak && langToUse) {
            appLogger.info(`[SessionPage TTS - Answer] Requesting speak for card ${cardForTTS.id}`);
            speakInitiatedForAnswerRef.current = true;
            stop();
            speak(textToSpeak, langToUse)
                .catch(ttsError => {
                    appLogger.error("[SessionPage TTS - Answer] Failed to speak text:", ttsError);
                    if (typeof window !== 'undefined' && !window.ttsErrorShown) {
                        toast.error("Text-to-speech error", { description: "TTS for answer failed." });
                        window.ttsErrorShown = true;
                    }
                    speakInitiatedForAnswerRef.current = false;
                });
        }
    }
  }, [currentCard, isFlipped, settings?.ttsEnabled, isLoadingPage, speak, stop, ttsState]);

  useEffect(() => {
    prevIsFlippedRef.current = isFlipped;
  });

  const handleFlip = useCallback(() => {
    if (isTransitioningVisual || isProcessingAnswer) return;
    setIsTransitioningVisual(true);
    onFlip();
    const timer = setTimeout(() => {
      setIsTransitioningVisual(false);
    }, FLIP_DURATION_MS);
    return () => clearTimeout(timer);
  }, [isTransitioningVisual, onFlip, isProcessingAnswer]);


  // --- REFINED PROGRESS CALCULATION ---
  const { progressValue, cardPositionText } = useMemo(() => {
    const results = sessionResults as SessionResults; // Ensure sessionResults is not null

    if (totalCardsInSession === 0) {
      return { progressValue: 0, cardPositionText: "No cards" };
    }

    let currentProgressCount = 0;
    const maxProgressCount = totalCardsInSession;

    if (sessionType === 'learn-only' || (sessionType === 'unified' && unifiedSessionPhase === 'learning')) {
      currentProgressCount = results.graduatedFromLearnCount;
    } else if (sessionType === 'review-only' || (sessionType === 'unified' && unifiedSessionPhase === 'review')) {
      // For review, each card answered (correctly or incorrectly) is considered "processed" for this pass
      // If unified, totalAnswered includes learning phase. We need a way to track review phase answers.
      // For now, using totalAnswered for review-only, and a more complex calculation for unified-review might be needed.
      // Let's assume for review-only, totalAnswered IS the progress for this phase.
      // For unified review phase, this might show total progress of entire session.
      // A simple way for unified review is to count non-learning cards answered or total - learning cards answered.
      // This needs refinement if precise phase progress is desired for unified review.
      // Using totalAnswered might be misleading if it doesn't reset between phases of unified.
      // Let's use totalAnswered for now, and acknowledge this might need phase-specific counters in SessionResults.
      currentProgressCount = results.totalAnswered; // This will be cumulative for unified
    } else {
      currentProgressCount = results.totalAnswered; // Fallback
    }

    const displayProgressCount = Math.min(currentProgressCount, maxProgressCount);
    const calculatedProgressValue = maxProgressCount > 0 ? (displayProgressCount / maxProgressCount) * 100 : 0;
    const currentCardDisplayNum = displayProgressCount + (isComplete || showContinueReviewPrompt ? 0 : 1);


    return {
      progressValue: calculatedProgressValue,
      cardPositionText: `Card ${Math.min(currentCardDisplayNum, maxProgressCount)} / ${maxProgressCount}`
    };
  }, [sessionType, unifiedSessionPhase, sessionResults, totalCardsInSession, isComplete, showContinueReviewPrompt]);
  // --- END OF REFINED PROGRESS CALCULATION ---


  if (isLoadingPage) {
     return (
        <div className="flex flex-col justify-center items-center min-h-screen">
            <IconLoader className="h-12 w-12 animate-spin text-primary mb-4" />
            <p className="text-muted-foreground">Loading session...</p>
        </div>
    );
  }

  if (error) {
     return (
        <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen">
            <Alert variant="destructive" className="max-w-md">
              <Terminal className="h-4 w-4" />
              <AlertTitle>Error Loading Session</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
            <Button onClick={() => router.push('/study/select')} className="mt-4">Go Back</Button>
        </div>
    );
  }

  if (showContinueReviewPrompt) {
    return (
        <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen text-center">
            <h1 className="text-2xl font-bold mb-3">Learning Phase Complete!</h1>
            <p className="text-muted-foreground mb-6">Ready to review cards based on Spaced Repetition?</p>
            <div className="flex gap-4">
                <Button onClick={onContinueReview} size="lg">Continue to Review</Button>
                <Button variant="outline" size="lg" onClick={() => router.push('/study/select')}>End Session</Button>
            </div>
        </div>
    );
  }

  if (isComplete) {
     const noCardsFoundInitially = initialQueryCount === 0;
     const sessionHadCards = initialQueryCount > 0;
     let title = "Session Complete!";
     let description = "Well done!";

     if (noCardsFoundInitially) {
         title = "No Cards Found";
         description = "There were no cards matching your selection criteria for this session type.";
     } else if (sessionHadCards) {
         const { correctCount = 0, incorrectCount = 0, hardCount = 0, graduatedFromLearnCount = 0, graduatedFromRelearnCount = 0, totalAnswered = 0 } = sessionResults || {};
         const accuracy = totalAnswered > 0 ? Math.round((correctCount / totalAnswered) * 100) : 0;
         if (sessionType === 'review-only') {
             title = "🎉 Review Complete! 🎉";
             description = `You reviewed ${totalAnswered} card${totalAnswered === 1 ? '' : 's'}. Correct: ${correctCount}, Hard: ${hardCount}, Incorrect: ${incorrectCount}. Accuracy: ${accuracy}%.`;
         } else if (sessionType === 'learn-only') {
             title = "🎉 Learning Complete! 🎉";
             description = `Processed ${totalAnswered} card interactions. Graduated: ${graduatedFromLearnCount}. Correct: ${correctCount}, Hard: ${hardCount}, Incorrect: ${incorrectCount}.`;
         } else { // unified
             title = "🎉 Practice Session Complete! 🎉";
             description = `Total interactions: ${totalAnswered}. Graduated Learn: ${graduatedFromLearnCount}, Graduated Relearn: ${graduatedFromRelearnCount}. Overall Correct: ${correctCount}, Hard: ${hardCount}, Incorrect: ${incorrectCount}.`;
         }
     }
     return (
        <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen text-center">
            <h1 className="text-3xl font-bold mb-4">{title}</h1>
            <p className="text-lg text-muted-foreground mb-6">{description}</p>
             <Button onClick={() => router.push('/study/select')} className="mt-4">Start New Session</Button>
        </div>
    );
  }

  if (!currentCard) {
    return (
        <div className="flex flex-col justify-center items-center min-h-screen">
            {currentCardStatusDisplay ? (
                <p className="text-muted-foreground">{currentCardStatusDisplay}</p>
            ) : (
                <p className="text-muted-foreground">Loading next card...</p>
            )}
            <Button onClick={() => router.push('/study/select')} className="mt-4">Go Back</Button>
        </div>
    );
  }

  // Use the new progressValue and cardPositionText from the useMemo hook
  // const progressValue = totalCardsInSession > 0 ? (sessionResults.totalAnswered / totalCardsInSession) * 100 : 0;
  // const cardPositionText = `Card ${currentCardNumberInSession} / ${totalCardsInSession}`;

  let displaySessionTitle = 'Practice Session';
  if (sessionType === 'learn-only') {
      displaySessionTitle = 'Learning Session';
  } else if (sessionType === 'review-only') {
      displaySessionTitle = 'Review Session (SRS)';
  } else if (sessionType === 'unified') {
      displaySessionTitle = showContinueReviewPrompt
        ? 'Learning Phase Complete'
        : unifiedSessionPhase === 'learning'
          ? 'Practice Session (Learning)'
          : 'Practice Session (Reviewing)';
  }


  return (
    <div className="container mx-auto p-4 md:p-6 flex flex-col min-h-screen">
      <div className="mb-4">
        <h1 className="text-xl font-semibold capitalize">
            {displaySessionTitle}
        </h1>
        {totalCardsInSession > 0 && (
            <div className="flex items-center gap-2 mt-2">
                <Progress value={progressValue} className="w-full h-2" />
                <span className="text-sm text-muted-foreground whitespace-nowrap">
                    {cardPositionText}
                </span>
            </div>
        )}
        {currentCardStatusDisplay && (
            <p className="text-xs text-muted-foreground mt-1">{currentCardStatusDisplay}</p>
        )}
      </div>
      <div className="flex-grow flex items-center justify-center">
          <StudyFlashcardView
            card={currentCard}
            onAnswer={answerCard}
            settings={settings}
            isFlipped={isFlipped}
            onFlip={handleFlip}
            progressText={currentCardStatusDisplay ?? undefined}
            isTransitioning={isTransitioningVisual || isProcessingAnswer}
         />
      </div>
    </div>
  );
}
```

## Directory: app/study/sets

### File: app/study/sets/page.tsx

```
// app/study/sets/page.tsx
import Link from 'next/link';
import { Button } from '@/components/ui/button';
// import { cookies } from 'next/headers'; // Not strictly needed if createServerClient handles it
import { createServerClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getUserStudySets } from '@/lib/actions/studySetActions';
import { getDecks as getDecksAction } from '@/lib/actions/deckActions'; // Import deck action
import { StudySetListClient } from '@/components/study/StudySetListClient'; // Use absolute path
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema'; // For casting criteria
import type { Tables } from '@/types/database'; // For Deck type if needed

// Define a more specific type for the study sets data passed to the client
type StudySetWithDeckNames = Tables<'study_sets'> & {
    relatedDeckNames?: string[];
};

export default async function ListStudySetsPage() {
  const supabase = createServerClient(); // cookies() can be passed if needed by your setup
  const { data: { session } } = await supabase.auth.getSession(); // Removed authError for brevity, assume redirect handles

  if (!session) {
    redirect('/login');
  }

  const [studySetsResult, decksResult] = await Promise.all([
    getUserStudySets(),
    getDecksAction() // Fetch all user decks
  ]);

  const studySetsRaw = studySetsResult.data || [];
  const allUserDecks = decksResult.data || []; // This will be DeckListItemWithCounts[]

  // Create a map for quick deck name lookup
  const decksMap = new Map(allUserDecks.map(d => [d.id, d.name]));

  const studySetsWithDeckNames: StudySetWithDeckNames[] = studySetsRaw.map(set => {
    let relatedDeckNames: string[] = [];
    // Safely access query_criteria and then deckIds
    const criteria = set.query_criteria as Partial<StudyQueryCriteria> | null; // Cast to allow checking properties
    if (criteria && criteria.deckIds && criteria.deckIds.length > 0) {
      relatedDeckNames = criteria.deckIds
        .map(id => decksMap.get(id)) // Get name from map
        .filter(name => name !== undefined) as string[]; // Filter out undefineds and assert as string[]
    }
    return { ...set, relatedDeckNames: relatedDeckNames.length > 0 ? relatedDeckNames : undefined };
  });

  return (
    <div className="py-4 px-4 md:p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Your Smart Playlists</h1>
        <Button asChild>
          <Link href="/study/sets/new">Create New Playlist</Link>
        </Button>
      </div>
      {/* Pass the augmented data to the client component */}
      <StudySetListClient initialData={studySetsWithDeckNames} />
    </div>
  );
}
```

## Directory: app/study/sets/[studySetId]

## Directory: app/study/sets/[studySetId]/edit

### File: app/study/sets/[studySetId]/edit/page.tsx

```
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { StudySetBuilder } from '@/components/study/StudySetBuilder'; // Adjust path if needed
import { getStudySet, updateStudySet, deleteStudySet } from '@/lib/actions/studySetActions'; // Import actions
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import type { Tables } from '@/types/database'; // Import Tables
import { toast } from 'sonner';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { Loader2 as IconLoader, AlertTriangle, Trash2 } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { appLogger, statusLogger } from '@/lib/logger';

// Define the DbStudySet type using Tables
type DbStudySet = Tables<'study_sets'>;

// Define the type for the data passed to the onSave callback
interface StudySetSaveData {
    name: string;
    description: string | null;
    criteria: StudyQueryCriteria;
}

export default function EditStudySetPage() {
    const router = useRouter();
    const params = useParams();
    const studySetId = params.studySetId as string; // Get ID from route params

    const [initialData, setInitialData] = useState<DbStudySet | null>(null);
    const [isLoading, setIsLoading] = useState(true); // Loading initial data
    const [isSaving, setIsSaving] = useState(false); // Saving updates
    const [isDeleting, setIsDeleting] = useState(false); // Added deleting state
    const [error, setError] = useState<string | null>(null);

    // Fetch initial study set data
    useEffect(() => {
        if (!studySetId) {
            setError("Study Set ID not found in URL.");
            setIsLoading(false);
            return;
        }

        const fetchSetData = async () => {
            setIsLoading(true);
            setError(null);
            appLogger.info(`[EditStudySetPage] Fetching data for set ID: ${studySetId}`);
            try {
                const result = await getStudySet(studySetId);
                if (result.error) {
                    setError(result.error);
                    toast.error("Failed to load study set", { description: result.error });
                    // Optionally redirect if not found/authorized
                    // router.replace('/study/sets'); 
                } else if (result.data) {
                    setInitialData(result.data);
                    appLogger.info("[EditStudySetPage] Initial data loaded:", result.data);
                } else {
                     // Handle case where data is null but no specific error (e.g., not found)
                     setError("Study set not found or you do not have permission to edit it.");
                     toast.error("Study set not found.");
                     // Optionally redirect
                     // router.replace('/study/sets');
                }
            } catch (err) {
                appLogger.error(`[EditStudySetPage] Unexpected error fetching study set:`, err);
                const message = err instanceof Error ? err.message : "An unexpected error occurred.";
                setError(message);
                toast.error("Error loading study set", { description: message });
            } finally {
                setIsLoading(false);
            }
        };

        fetchSetData();
    }, [studySetId]); // Removed router dependency as it doesn't change

    // Handle saving updates
    const handleUpdateStudySet = useCallback(async (data: StudySetSaveData) => {
        if (!studySetId) {
            toast.error("Cannot save: Study Set ID is missing.");
            return;
        }
        setIsSaving(true);
        appLogger.info(`[EditStudySetPage] Updating study set ${studySetId}:`, data);
        try {
            const result = await updateStudySet(studySetId, data); // Pass ID and updated data
            if (result.error) {
                toast.error("Failed to update study set", { description: result.error });
            } else {
                toast.success(`Study Set "${result.data?.name}" updated successfully!`);
                // Optionally navigate back or refresh data
                router.push('/study/sets'); // Navigate back to list on success
                 // Or maybe just refresh initial data if staying on page:
                 // setInitialData(result.data); // Update local state with saved data
            }
        } catch (err) {
            appLogger.error(`[EditStudySetPage] Unexpected error updating study set:`, err);
            toast.error("An unexpected error occurred while saving.");
        } finally {
            setIsSaving(false);
        }
    }, [studySetId, router]);

    // Added handleDelete function
    const handleDelete = useCallback(async () => {
        if (!studySetId || !initialData) {
            toast.error("Cannot delete: Study Set data missing.");
            return;
        }
        setIsDeleting(true);
        const setName = initialData.name;
        appLogger.info(`[EditStudySetPage] Deleting study set: ${setName} (${studySetId})`);
        try {
            const result = await deleteStudySet(studySetId);
            if (result.error) {
                toast.error(`Failed to delete "${setName}"`, { description: result.error });
            } else {
                toast.success(`Study Set "${setName}" deleted.`);
                router.push('/study/sets'); // Navigate back to list on success
            }
        } catch (err) {
            appLogger.error(`[EditStudySetPage] Unexpected error deleting study set:`, err);
            toast.error("An unexpected error occurred while deleting.");
        } finally {
            setIsDeleting(false); // Ensure state is reset even on error
        }
    }, [studySetId, initialData, router]);

    // --- Render Logic ---

    if (isLoading) {
        return (
            <div className="flex flex-col justify-center items-center h-screen">
                <IconLoader className="h-12 w-12 animate-spin text-primary" />
                <p className="mt-2 text-muted-foreground">Loading study set...</p>
            </div>
        );
    }

    if (error) {
         return (
            <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen">
                <Alert variant="destructive" className="max-w-md">
                  <AlertTriangle className="h-4 w-4" />
                  <AlertTitle>Error Loading Study Set</AlertTitle>
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
                <Button onClick={() => router.push('/study/sets')} className="mt-4" variant="outline">
                    Back to Playlists
                </Button>
            </div>
        );
    }

    if (!initialData) {
        // Should ideally be covered by error state, but acts as a final fallback
        return <div className="container mx-auto p-4">Study set data could not be loaded.</div>;
    }

    return (
        <div className="py-4 px-4 md:p-6 max-w-4xl mx-auto">
             <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Edit Smart Playlist</h1>
                <Button variant="outline" asChild>
                    <Link href="/study/sets">Cancel</Link>
                </Button>
             </div>

            <StudySetBuilder
                // Pass the fetched data, ensuring criteria is included
                initialData={{
                    id: initialData.id,
                    name: initialData.name,
                    description: initialData.description,
                    criteria: initialData.query_criteria as StudyQueryCriteria, // Cast criteria
                }}
                onSave={handleUpdateStudySet}
                isSaving={isSaving}
            />

            {/* Added Delete Section */}
            <div className="mt-8 pt-6 border-t border-dashed border-destructive/50">
                <h3 className="text-lg font-semibold text-destructive mb-2">Danger Zone</h3>
                <p className="text-sm text-muted-foreground mb-4">Deleting this playlist cannot be undone.</p>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isDeleting || isSaving}>
                       <Trash2 className="mr-2 h-4 w-4" /> Delete Playlist
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Delete "{initialData.name}"?</AlertDialogTitle>
                        <AlertDialogDescription>This action cannot be undone. This will permanently delete the smart playlist definition, but will not delete any actual cards.</AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                       <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
                       <AlertDialogAction onClick={handleDelete} disabled={isDeleting} className="bg-destructive hover:bg-destructive/90">
                            {isDeleting ? <IconLoader className="h-4 w-4 animate-spin mr-2"/> : null} Delete
                       </AlertDialogAction>
                     </AlertDialogFooter>
                   </AlertDialogContent>
                </AlertDialog>
            </div>
        </div>
    );
} 
```

## Directory: app/study/sets/new

### File: app/study/sets/new/page.tsx

```
'use client';

import React, { useState, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { StudySetBuilder } from '@/components/study/StudySetBuilder'; // Adjust path if needed
import { createStudySet } from '@/lib/actions/studySetActions'; // Import the create action
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import { toast } from 'sonner';
import { Button } from '@/components/ui/button'; // For potential cancel button
import Link from 'next/link'; // For linking back
import { appLogger, statusLogger } from '@/lib/logger';

export default function NewStudySetPage() {
  const router = useRouter();
  const [isSaving, setIsSaving] = useState(false);

  const handleSaveStudySet = useCallback(async (data: {
    name: string;
    description: string | null;
    criteria: StudyQueryCriteria;
  }) => {
    setIsSaving(true);
    appLogger.info("[NewStudySetPage] Saving new study set:", data);
    try {
      const result = await createStudySet(data);
      if (result.error) {
        toast.error("Failed to create study set", { description: result.error });
      } else {
        toast.success(`Study Set "${result.data?.name}" created successfully!`);
        // Navigate back to the list page (adjust path if different)
        router.push('/study/sets'); 
        // Optional: revalidate list page path if needed, though action might handle it
        // revalidatePath('/study/sets'); 
      }
    } catch (err) {
      appLogger.error("[NewStudySetPage] Unexpected error saving study set:", err);
      toast.error("An unexpected error occurred while saving.");
    } finally {
      setIsSaving(false);
    }
  }, [router]);

  return (
    <div className="container mx-auto p-4 md:p-6 max-w-4xl">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Create New Smart Playlist</h1>
        <Button variant="outline" asChild>
          <Link href="/study/sets">Cancel</Link>
        </Button>
      </div>

      <StudySetBuilder 
        onSave={handleSaveStudySet} 
        isSaving={isSaving} 
        // No initialData is passed for creating a new set
      />
    </div>
  );
} 
```

## Directory: app/tags

### File: app/tags/page.tsx

```
import React from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { ArrowLeft } from 'lucide-react';
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getTags } from '@/lib/actions/tagActions';
import { TagManagerClient } from '../../components/tags/TagManagerClient';

/**
 * Tags Management Page
 * 
 * This is a Server Component that pre-fetches all tags server-side
 * before rendering the page, eliminating client-side data fetching delays.
 * 
 * @returns {Promise<JSX.Element>} The Tags page with pre-fetched data
 */
export default async function ManageTagsPage() {
  // Check authentication server-side
  const supabase = createServerClient();
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  if (!session || authError) {
    redirect('/login');
  }

  // Pre-fetch all tags in a single server-side request
  const { data: tags, error: fetchError } = await getTags();

  return (
    <div className="container py-6">
      <div className="mb-6 flex items-center">
        <Button asChild variant="ghost" size="icon" className="mr-2">
          <Link href="/">
            <ArrowLeft className="h-4 w-4" />
          </Link>
        </Button>
        <h1 className="text-2xl font-bold">Manage Tags</h1>
      </div>
      
      <TagManagerClient initialTags={tags || []} />
    </div>
  );
} 
```

## Directory: components

### File: components/ClientProviders.tsx

```
/**
 * Client-side providers wrapper component.
 * 
 * This component groups all client-side context providers required by the application:
 * - ThemeProvider: Manages light/dark theme state
 * - AuthProvider: Handles authentication state and user session
 * - SettingsProvider: Manages user preferences and settings
 * - SonnerToaster: Provides toast notifications
 * 
 * @component
 * @param {Object} props - Component props
 * @param {React.ReactNode} props.children - Child components to be wrapped by providers
 * @returns {JSX.Element} Wrapped children with all necessary providers
 */

'use client'; // This component uses client-side features (Context)

import React from 'react';
import { ThemeProvider } from "@/components/theme-provider";
import { Toaster as SonnerToaster } from "sonner";
import { AuthProvider } from "@/hooks/use-auth";
import { SettingsProvider } from "@/providers/settings-provider";
import { SpeedInsights } from "@vercel/speed-insights/next";

interface ClientProvidersProps {
  children: React.ReactNode;
}

/**
 * Wraps the main application content with client-side context providers.
 */
export function ClientProviders({ children }: ClientProvidersProps) {
  return (
    <ThemeProvider 
        attribute="class" 
        defaultTheme="system" 
        enableSystem 
        disableTransitionOnChange
    >
      <AuthProvider>
        <SettingsProvider>
          {children}
          <SonnerToaster richColors closeButton />
          <SpeedInsights />
        </SettingsProvider>
      </AuthProvider>
    </ThemeProvider>
  );
} 
```

### File: components/DeckListClient.tsx

```
// components/DeckListClient.tsx
"use client";

import { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { PlusCircle, Edit, Play } from "lucide-react";
import { useRouter } from "next/navigation";
import { useStudySessionStore } from '@/store/studySessionStore';
import type { StudySessionInput, SessionType } from '@/types/study'; // Import types from types/study.ts
// import Link from 'next/link'; // Not used
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { DeckProgressBar } from "@/components/deck/DeckProgressBar";
import { useSettings } from "@/providers/settings-provider";
import { Separator } from "@/components/ui/separator";
import { toast } from 'sonner';

// Type for enhanced deck data that includes learn/review counts
interface EnhancedDeck {
  id: string;
  name: string;
  primary_language: string | null;
  secondary_language: string | null;
  is_bilingual: boolean;
  updated_at: string | null;
  new_count: number;
  learning_count: number;
  young_count: number;
  mature_count: number;
  learn_eligible_count: number;
  review_eligible_count: number;
}

interface DeckListClientProps {
  initialData?: EnhancedDeck[];
}

export function DeckListClient({ initialData = [] }: DeckListClientProps) {
  const { settings, loading: settingsLoading } = useSettings();
  const router = useRouter();
  const setStudyParameters = useStudySessionStore((state) => state.setStudyParameters);
  const clearStudyParameters = useStudySessionStore((state) => state.clearStudyParameters);

  const decks = initialData;
  const isLoading = settingsLoading; // Assuming initialData means data loading is handled by parent

  const legendStages = [
    { name: 'New', startColor: '#EC4899', endColor: '#EF4444' },
    { name: 'Learning', startColor: '#DA55C6', endColor: '#9353DD' },
    { name: 'Relearning', startColor: '#F59E0B', endColor: '#F97316' },
    { name: 'Young', startColor: '#6055DA', endColor: '#5386DD' },
    { name: 'Mature', startColor: '#55A9DA', endColor: '#53DDDD' },
  ];

  const handlePracticeDeck = (deckId: string, learnCount: number, reviewCount: number) => {
    if (learnCount === 0 && reviewCount === 0) {
        toast.info("No cards available to practice in this deck right now.");
        return;
    }
    const studyInput: StudySessionInput = { deckId: deckId };
    const sessionTypeForStore: SessionType = 'unified';

    console.log(`[DeckListClient] Starting '${sessionTypeForStore}' session for deck ${deckId}`);
    clearStudyParameters();
    setStudyParameters(studyInput, sessionTypeForStore);
    router.push('/study/session');
  };

  const handleCreateDeckClick = () => {
    router.push('/decks/create-choice');
  };

  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        <div className="h-12 w-12 rounded-full border-2 border-primary animate-spin border-b-transparent" />
      </div>
    );
  }

  const showDeckProgress = settings?.showDeckProgress ?? true;

  return (
    <TooltipProvider>
      <div className="space-y-6 py-4 px-4 md:p-6">
        <div className="flex justify-between items-center flex-wrap gap-4 mb-6">
          <h2 className="text-2xl font-semibold">Your Decks</h2>
          <div className="flex items-center gap-2 flex-wrap">
            <Button onClick={handleCreateDeckClick}>
              <PlusCircle className="mr-2 h-4 w-4" />
              Create Deck
            </Button>
          </div>
        </div>

        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {decks.length === 0 ? (
            <div className="col-span-full text-center text-muted-foreground mt-10">
              <p>You haven't created any decks yet.</p>
              <Button onClick={handleCreateDeckClick} className="mt-4">
                <PlusCircle className="mr-2 h-4 w-4" />
                Create Your First Deck
              </Button>
            </div>
          ) : (
            decks.map((deck) => {
              const totalCardsForDisplay = (deck.new_count ?? 0) +
                                 (deck.learning_count ?? 0) +
                                 (deck.young_count ?? 0) +
                                 (deck.mature_count ?? 0);

              let languageDisplay = deck.primary_language || 'N/A';
              if (deck.is_bilingual && deck.secondary_language) {
                  languageDisplay = `${deck.primary_language ?? '?'}/${deck.secondary_language ?? '?'}`;
              }

              const learnEligible = deck.learn_eligible_count ?? 0;
              const reviewEligible = deck.review_eligible_count ?? 0;
              const totalPracticeable = learnEligible + reviewEligible;

              return (
                <Card key={deck.id} className="hover:shadow-md transition-shadow flex flex-col bg-gradient-to-b from-slate-100/40 dark:from-slate-800/40 to-transparent dark:border-slate-700">
                  <CardHeader className="pt-4 pb-2 space-y-1 px-4">
                    <div className="flex justify-between items-center">
                      <CardTitle className="truncate text-lg" title={deck.name}>{deck.name}</CardTitle>
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => router.push(`/edit/${deck.id}`)}
                            className="h-7 w-7 flex-shrink-0 text-muted-foreground"
                            aria-label={`Edit deck ${deck.name}`}
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent><p>Edit Deck</p></TooltipContent>
                      </Tooltip>
                    </div>
                    <CardDescription className="text-sm">
                      {totalCardsForDisplay} card{totalCardsForDisplay !== 1 ? 's' : ''} • {languageDisplay}
                    </CardDescription>
                  </CardHeader>
                  <CardFooter className="flex justify-center pt-4 px-4 pb-4">
                    <Button
                        onClick={() => handlePracticeDeck(deck.id, learnEligible, reviewEligible)}
                        disabled={totalPracticeable === 0}
                        size="sm"
                        className="w-full bg-primary hover:bg-primary/90"
                    >
                        <Play className="h-4 w-4 mr-2" />
                        Practice {totalPracticeable > 0 ? `(${totalPracticeable})` : ''}
                    </Button>
                  </CardFooter>
                  {showDeckProgress && totalCardsForDisplay > 0 && (
                    <>
                      <Separator />
                      <CardContent className="px-4 pt-4 pb-4 bg-slate-50 dark:bg-slate-700/50 rounded-b-lg">
                        <DeckProgressBar
                          newCount={deck.new_count ?? 0}
                          learningCount={deck.learning_count ?? 0}
                          youngCount={deck.young_count ?? 0}
                          matureCount={deck.mature_count ?? 0}
                        />
                      </CardContent>
                    </>
                  )}
                </Card>
              );
            })
          )}
        </div>

        {showDeckProgress && decks.length > 0 && (
          <div className="mt-4 flex justify-end">
            <div className="text-xs text-muted-foreground flex flex-wrap gap-x-3 gap-y-1 p-2 border rounded-md bg-background shadow-sm">
              {legendStages.map(stage => (
                <span key={stage.name} className="flex items-center gap-1">
                  <span
                    className="h-2 w-3 rounded"
                    style={{ backgroundImage: `linear-gradient(to right, ${stage.startColor}, ${stage.endColor})` }}
                  ></span>
                  {stage.name}
                </span>
              ))}
            </div>
          </div>
        )}
      </div>
    </TooltipProvider>
  );
}
```

### File: components/camera-capture.tsx

```
'use client';

import { useState, useRef, useCallback, useEffect, useMemo } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Camera, Trash2, CheckCircle } from 'lucide-react';
import { appLogger } from '@/lib/logger';

interface CameraCaptureProps {
  onCapture: (images: File[]) => void;
  maxImages?: number;
}

export function CameraCapture({ onCapture, maxImages = 5 }: CameraCaptureProps) {
  const [capturedImages, setCapturedImages] = useState<File[]>([]);
  const [isCapturing, setIsCapturing] = useState(false);
  const videoRef = useRef<HTMLVideoElement>(null);
  const fileInputRef = useRef<HTMLInputElement>(null);
  const canvasRef = useRef<HTMLCanvasElement>(null);

  // Start camera
  const startCamera = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ 
        video: { 
          facingMode: 'environment', // Prefer back camera
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        } 
      });
      
      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        videoRef.current.onloadedmetadata = () => {
          if (videoRef.current) {
            videoRef.current.play().catch(err => {
              appLogger.error('Error playing video:', err);
              alert('Unable to start camera. Please check permissions or try uploading images instead.');
            });
          }
        };
        setIsCapturing(true);
      }
    } catch (err) {
      appLogger.error('Error accessing camera:', err);
      alert('Unable to access camera. Please check permissions or try uploading images instead.');
    }
  }, []);

  // Stop camera
  const stopCamera = useCallback(() => {
    if (videoRef.current && videoRef.current.srcObject) {
      const stream = videoRef.current.srcObject as MediaStream;
      stream.getTracks().forEach(track => track.stop());
      videoRef.current.srcObject = null;
      setIsCapturing(false);
    }
  }, []);

  // Capture image
  const captureImage = useCallback(() => {
    if (!videoRef.current || !canvasRef.current) return;

    const video = videoRef.current;
    const canvas = canvasRef.current;
    const context = canvas.getContext('2d');

    if (!context) return;

    // Set canvas dimensions to match video
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    // Draw video frame to canvas
    context.drawImage(video, 0, 0, canvas.width, canvas.height);
    
    // Convert canvas to blob
    canvas.toBlob((blob) => {
      if (!blob) return;
      
      // Create file from blob
      const timestamp = new Date().toISOString();
      const file = new File([blob], `camera-capture-${timestamp}.jpg`, { type: 'image/jpeg' });
      
      // Add to captured images
      setCapturedImages(prev => [...prev, file]);
      
      // If we've reached max images, stop camera
      if (capturedImages.length + 1 >= maxImages) {
        stopCamera();
      }
    }, 'image/jpeg', 0.9);
  }, [capturedImages.length, maxImages, stopCamera]);

  // Remove image
  const removeImage = useCallback((index: number) => {
    setCapturedImages(prev => prev.filter((_, i) => i !== index));
  }, []);

  // Handle file selection as alternative to camera
  const handleFileSelect = (e: React.ChangeEvent<HTMLInputElement>) => {
    const files = e.target.files;
    if (!files || files.length === 0) return;
    
    const newFiles: File[] = [];
    for (let i = 0; i < Math.min(files.length, maxImages - capturedImages.length); i++) {
      newFiles.push(files[i]);
    }
    
    setCapturedImages(prev => [...prev, ...newFiles]);
    
    // Reset the input to allow re-selection of the same file
    if (fileInputRef.current) {
      fileInputRef.current.value = '';
    }
  };

  // Submit captured images
  const handleSubmit = useCallback(() => {
    if (capturedImages.length === 0) return;
    onCapture(capturedImages);
    setCapturedImages([]);
  }, [capturedImages, onCapture]);

  // Memoize object URLs for captured images
  const objectUrls = useMemo(() =>
    capturedImages.map(image => URL.createObjectURL(image)),
    [capturedImages]
  );

  // Cleanup object URLs on unmount or when images change
  useEffect(() => {
    return () => {
      objectUrls.forEach(url => URL.revokeObjectURL(url));
    };
  }, [objectUrls]);

  return (
    <div className="flex flex-col gap-4">
      {/* Hidden elements */}
      <input
        type="file"
        accept="image/*"
        multiple
        ref={fileInputRef}
        onChange={handleFileSelect}
        className="hidden"
      />
      <canvas ref={canvasRef} className="hidden" />
      
      {/* Camera view or captured images */}
      <Card className="overflow-hidden">
        {isCapturing ? (
          <div className="relative">
            <video
              ref={videoRef}
              autoPlay
              playsInline
              muted
              onPlay={() => appLogger.info('Camera video started playing')}
              className="w-full h-auto aspect-video object-cover"
            />
            <div className="absolute bottom-4 left-0 right-0 flex justify-center">
              <Button 
                variant="secondary" 
                size="lg" 
                className="rounded-full w-14 h-14"
                onClick={captureImage}
              >
                <Camera className="h-6 w-6" />
              </Button>
            </div>
          </div>
        ) : (
          <div className="p-4">
            {capturedImages.length > 0 ? (
              <div className="grid grid-cols-2 md:grid-cols-3 gap-2">
                {capturedImages.map((image, index) => (
                  <div key={index} className="relative aspect-video">
                    <img
                      src={objectUrls[index]}
                      alt={`Captured ${index + 1}`}
                      width={1920}
                      height={1080}
                      className="w-full h-full object-cover rounded-md"
                    />
                    <Button
                      variant="destructive"
                      size="icon"
                      className="absolute top-1 right-1 w-6 h-6 rounded-full"
                      onClick={() => removeImage(index)}
                    >
                      <Trash2 className="h-3 w-3" />
                    </Button>
                  </div>
                ))}
              </div>
            ) : (
              <div className="flex flex-col items-center justify-center py-8 text-center">
                <Camera className="h-12 w-12 mb-2 text-muted-foreground" />
                <h3 className="font-medium text-lg">No images captured</h3>
                <p className="text-sm text-muted-foreground mb-4">
                  Start the camera to capture images or upload them directly
                </p>
                <div className="flex gap-2">
                  <Button onClick={startCamera}>Open Camera</Button>
                  <Button
                    variant="outline"
                    onClick={() => fileInputRef.current?.click()}
                  >
                    Upload Images
                  </Button>
                </div>
              </div>
            )}
          </div>
        )}
      </Card>
      
      {/* Controls */}
      {capturedImages.length > 0 && (
        <div className="flex justify-between">
          <div className="flex items-center gap-2">
            <span className="text-sm">
              {capturedImages.length} of {maxImages} images captured
            </span>
            {capturedImages.length < maxImages && !isCapturing && (
              <Button 
                variant="outline" 
                size="sm" 
                onClick={startCamera}
              >
                Add More
              </Button>
            )}
          </div>
          <div className="flex gap-2">
            {isCapturing && (
              <Button 
                variant="outline" 
                onClick={stopCamera}
              >
                Done
              </Button>
            )}
            <Button 
              onClick={handleSubmit}
              disabled={capturedImages.length === 0}
            >
              <CheckCircle className="mr-2 h-4 w-4" />
              Use {capturedImages.length} Image{capturedImages.length !== 1 ? 's' : ''}
            </Button>
          </div>
        </div>
      )}
      
      {isCapturing && (
        <p className="text-sm text-muted-foreground text-center">
          Aim your camera at the document or text you want to capture
        </p>
      )}
    </div>
  );
} 
```

### File: components/card-editor.tsx

```
// components/card-editor.tsx
"use client"

import type React from "react"
import { useState, useEffect, useCallback } from "react"
import { Card, CardContent, CardFooter } from "@/components/ui/card"
import { Button } from "@/components/ui/button"
import { Textarea } from "@/components/ui/textarea"
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Trash2, Save, Loader2 as IconLoader } from "lucide-react"
import type { Tables } from "@/types/database" // Use generated DB types
import { toast } from "sonner"
import { cn } from "@/lib/utils"
import { appLogger } from "@/lib/logger"

const POS_OPTIONS: ReadonlyArray<string> = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other', 'N/A'];
const GENDER_OPTIONS = [
    { value: 'Male', label: 'Male'},
    { value: 'Female', label: 'Female'},
    // Ensure 'Default' is a valid key if used for 'N/A' / 'Neutral' for DB storage
    { value: 'Default', label: 'Neutral / Other'}
];
const GENDERED_POS: ReadonlyArray<string> = ['Noun', 'Adjective', 'Pronoun'] as const;

// Use Tables<'cards'> for card data
type DbCard = Tables<'cards'>;

// Define input types based on DbCard structure (snake_case)
type CardDataInput = Pick<DbCard,
    'question' |
    'answer' |
    'question_part_of_speech' |
    'question_gender' |
    'answer_part_of_speech' |
    'answer_gender'
>;
type PartialCardDataInput = Partial<CardDataInput>;


interface CardEditorProps {
  card: Partial<DbCard> | null; // Accept Partial<DbCard> for new/existing
  onUpdate: (id: string, data: PartialCardDataInput) => void;
  onDelete: (id: string) => void;
  onCreate?: (data: CardDataInput) => Promise<string | null>; // Returns new card ID or null
}

export function CardEditor({ card, onUpdate, onDelete, onCreate }: CardEditorProps) {
  // Initialize state using snake_case fields from DbCard
  const [internalQuestion, setInternalQuestion] = useState(card?.question || '');
  const [internalAnswer, setInternalAnswer] = useState(card?.answer || '');
  const [internalQuestionPos, setInternalQuestionPos] = useState(card?.question_part_of_speech || 'N/A');
  const [internalQuestionGender, setInternalQuestionGender] = useState(card?.question_gender || 'Default'); // Assuming 'Default' maps to null or 'N/A' for DB
  const [internalAnswerPos, setInternalAnswerPos] = useState(card?.answer_part_of_speech || 'N/A');
  const [internalAnswerGender, setInternalAnswerGender] = useState(card?.answer_gender || 'Default');

  const [isSavingNew, setIsSavingNew] = useState(false);
  const isExistingCard = !!card?.id && !card.id.startsWith('new-');

  useEffect(() => {
    // This effect ensures the internal state is updated if the card prop changes.
    // This is important if the parent component updates the card data after a save.
    setInternalQuestion(card?.question || '');
    setInternalAnswer(card?.answer || '');
    setInternalQuestionPos(card?.question_part_of_speech || 'N/A');
    setInternalQuestionGender(card?.question_gender || 'Default');
    setInternalAnswerPos(card?.answer_part_of_speech || 'N/A');
    setInternalAnswerGender(card?.answer_gender || 'Default');
    setIsSavingNew(false); // Reset saving state if card instance changes
  }, [card]); // Dependency is the card prop itself.

  const handleQuestionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInternalQuestion(e.target.value);
  };

  const handleAnswerChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setInternalAnswer(e.target.value);
  };

  const handleQuestionBlur = () => {
    if (isExistingCard && card?.id && internalQuestion !== card?.question) {
      appLogger.info('[CardEditor] Question blur update for ID:', card.id);
      onUpdate(card.id, { question: internalQuestion });
    }
  };

  const handleAnswerBlur = () => {
    if (isExistingCard && card?.id && internalAnswer !== card?.answer) {
      appLogger.info('[CardEditor] Answer blur update for ID:', card.id);
      onUpdate(card.id, { answer: internalAnswer });
    }
  };

  const handleSelectChange = (
    field: keyof Pick<CardDataInput, 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>, 
    value: string
  ) => {
    const actualValue = (value === 'N/A' || value === 'Default') ? null : value;
    let changed = false;

    if (field === 'question_part_of_speech') {
      setInternalQuestionPos(value); // value here is 'N/A' or actual PoS
      if (actualValue !== card?.question_part_of_speech) changed = true;
    } else if (field === 'question_gender') {
      setInternalQuestionGender(value); // value here is 'Default' or actual Gender
      if (actualValue !== card?.question_gender) changed = true;
    } else if (field === 'answer_part_of_speech') {
      setInternalAnswerPos(value);
      if (actualValue !== card?.answer_part_of_speech) changed = true;
    } else if (field === 'answer_gender') {
      setInternalAnswerGender(value);
      if (actualValue !== card?.answer_gender) changed = true;
    }

    if (isExistingCard && card?.id && changed) {
      appLogger.info('[CardEditor] Select change update for ID:', card.id, 'Field:', field, 'Value:', actualValue);
      onUpdate(card.id, { [field]: actualValue });
    }
  };

  const handleDelete = () => {
    if (card?.id) { // Works for both existing and placeholder IDs
        onDelete(card.id);
    }
  };

  const handleCreate = async () => {
      if (!onCreate) {
          appLogger.error("onCreate prop is missing from CardEditor for a new card.");
          toast.error("Cannot save new card: Configuration error.");
          return;
      }

      const question = internalQuestion.trim();
      const answer = internalAnswer.trim();
      if (!question || !answer) {
          toast.error("Question and Answer content cannot be empty.");
          return;
      }

      const cardDataToCreate: CardDataInput = {
          question: question,
          answer: answer,
          question_part_of_speech: internalQuestionPos === 'N/A' ? null : internalQuestionPos,
          question_gender: internalQuestionGender === 'Default' ? null : internalQuestionGender,
          answer_part_of_speech: internalAnswerPos === 'N/A' ? null : internalAnswerPos,
          answer_gender: internalAnswerGender === 'Default' ? null : internalAnswerGender,
      };

      setIsSavingNew(true);
      try {
         await onCreate(cardDataToCreate);
         // Optimistic: Parent should replace this card, so state might reset via useEffect,
         // or parent could explicitly clear/update this editor instance.
         // For now, assume parent handles the transition from placeholder to real card.
      } catch (error) {
          appLogger.error("Error calling onCreate prop:", error);
          // Error is typically toasted by parent/action
      } finally {
           setIsSavingNew(false);
      }
  };

  const cardIdSuffix = card?.id || 'new-unsaved'; // More descriptive suffix

  return (
    <Card className={cn(
      "relative",
      !isExistingCard && card?.id?.startsWith('new-') ? "border-primary border-2 shadow-lg shadow-primary/20" : ""
    )}>
       {(isExistingCard || card?.id?.startsWith('new-')) && card?.id && (
          <Button
            variant="ghost"
            size="icon"
            onClick={handleDelete}
            aria-label="Delete card"
            className="absolute top-2 right-2 h-7 w-7 text-muted-foreground hover:text-destructive hover:bg-destructive/10 z-10"
            disabled={isSavingNew} // Disable delete while saving new
          >
              <Trash2 className="h-4 w-4" />
          </Button>
       )}

      <CardContent className="p-4 space-y-4">
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          {/* Question Section */}
          <div className="space-y-2">
            <Label htmlFor={`question-${cardIdSuffix}`} className="block text-sm font-medium">Question</Label>
            <Textarea
              id={`question-${cardIdSuffix}`}
              placeholder="Enter question..."
              value={internalQuestion}
              onChange={handleQuestionChange}
              onBlur={handleQuestionBlur}
              className="min-h-[100px]"
              aria-label="Question content"
              disabled={isSavingNew}
            />
            <div className="grid grid-cols-2 gap-x-4 gap-y-2 pt-2">
              <div>
                <Label htmlFor={`q-pos-${cardIdSuffix}`} className="text-xs text-muted-foreground">Type</Label>
                <Select
                  value={internalQuestionPos}
                  onValueChange={(value) => handleSelectChange('question_part_of_speech', value)}
                  name={`q-pos-${cardIdSuffix}`}
                  disabled={isSavingNew}
                >
                  <SelectTrigger id={`q-pos-${cardIdSuffix}`} className="h-9 text-xs">
                    <SelectValue placeholder="Select PoS..." />
                  </SelectTrigger>
                  <SelectContent>
                    {POS_OPTIONS.map(pos => <SelectItem key={`q-pos-${pos}`} value={pos} className="text-xs">{pos}</SelectItem>)}
                  </SelectContent>
                </Select>
              </div>
              <div>
                {GENDERED_POS.includes(internalQuestionPos) && (
                  <>
                    <Label htmlFor={`q-gender-${cardIdSuffix}`} className="text-xs text-muted-foreground">Gender</Label>
                    <Select
                      value={internalQuestionGender}
                      onValueChange={(value) => handleSelectChange('question_gender', value)}
                      name={`q-gender-${cardIdSuffix}`}
                      disabled={isSavingNew}
                    >
                      <SelectTrigger id={`q-gender-${cardIdSuffix}`} className="h-9 text-xs">
                         <SelectValue placeholder="Select Gender..." />
                      </SelectTrigger>
                      <SelectContent>
                        {GENDER_OPTIONS.map(opt => <SelectItem key={`q-gender-${opt.value}`} value={opt.value} className="text-xs">{opt.label}</SelectItem>)}
                      </SelectContent>
                    </Select>
                  </>
                )}
              </div>
            </div>
          </div>

          {/* Answer Section */}
          <div className="space-y-2">
            <Label htmlFor={`answer-${cardIdSuffix}`} className="block text-sm font-medium">Answer</Label>
            <Textarea
              id={`answer-${cardIdSuffix}`}
              placeholder="Enter answer..."
              value={internalAnswer}
              onChange={handleAnswerChange}
              onBlur={handleAnswerBlur}
              className="min-h-[100px]"
              aria-label="Answer content"
              disabled={isSavingNew}
            />
            <div className="grid grid-cols-2 gap-x-4 gap-y-2 pt-2">
              <div>
                <Label htmlFor={`a-pos-${cardIdSuffix}`} className="text-xs text-muted-foreground">Type</Label>
                <Select
                  value={internalAnswerPos}
                  onValueChange={(value) => handleSelectChange('answer_part_of_speech', value)}
                  name={`a-pos-${cardIdSuffix}`}
                  disabled={isSavingNew}
                >
                  <SelectTrigger id={`a-pos-${cardIdSuffix}`} className="h-9 text-xs">
                    <SelectValue placeholder="Select PoS..." />
                  </SelectTrigger>
                  <SelectContent>
                    {POS_OPTIONS.map(pos => <SelectItem key={`a-pos-${pos}`} value={pos} className="text-xs">{pos}</SelectItem>)}
                  </SelectContent>
                </Select>
              </div>
              <div>
                {GENDERED_POS.includes(internalAnswerPos) && (
                  <>
                    <Label htmlFor={`a-gender-${cardIdSuffix}`} className="text-xs text-muted-foreground">Gender</Label>
                    <Select
                      value={internalAnswerGender}
                      onValueChange={(value) => handleSelectChange('answer_gender', value)}
                      name={`a-gender-${cardIdSuffix}`}
                      disabled={isSavingNew}
                    >
                      <SelectTrigger id={`a-gender-${cardIdSuffix}`} className="h-9 text-xs">
                         <SelectValue placeholder="Select Gender..." />
                      </SelectTrigger>
                      <SelectContent>
                        {GENDER_OPTIONS.map(opt => <SelectItem key={`a-gender-${opt.value}`} value={opt.value} className="text-xs">{opt.label}</SelectItem>)}
                      </SelectContent>
                    </Select>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>
      </CardContent>

      {!isExistingCard && onCreate && (
        <CardFooter className="flex justify-end p-3 bg-muted/50 border-t">
           <Button onClick={handleCreate} disabled={isSavingNew || !internalQuestion.trim() || !internalAnswer.trim()} size="sm">
              {isSavingNew ? <IconLoader className="h-4 w-4 animate-spin mr-2"/> : <Save className="h-4 w-4 mr-2" />} Save New Card
           </Button>
        </CardFooter>
      )}
    </Card>
  )
}

CardEditor.displayName = 'CardEditor';
```

### File: components/create-deck-dialog.tsx

```
"use client"

import type React from "react"

import { useState, useEffect } from "react"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select"
import { Switch } from "@/components/ui/switch"
import { useDecks } from "@/hooks/use-decks"
import { useRouter } from "next/navigation"
import { useSettings } from "@/providers/settings-provider"
import { toast } from "sonner"
import { appLogger } from "@/lib/logger"

interface CreateDeckDialogProps {
  open: boolean
  onOpenChange: (open: boolean) => void
}

export function CreateDeckDialog({ open, onOpenChange }: CreateDeckDialogProps) {
  const [name, setName] = useState("")
  const [isBilingual, setIsBilingual] = useState(false)
  const [questionLanguage, setQuestionLanguage] = useState("")
  const [answerLanguage, setAnswerLanguage] = useState("")
  const [loading, setLoading] = useState(false)
  const { createDeck } = useDecks()
  const { settings } = useSettings()
  const router = useRouter()

  // Set default languages from settings
  useEffect(() => {
    if (settings?.appLanguage) {
      setQuestionLanguage(settings.appLanguage)
      setAnswerLanguage(settings.appLanguage)
    }
  }, [settings])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    if (!name.trim()) {
      toast.error("Deck name is required")
      return
    }

    try {
      setLoading(true)
      const { data: newDeckData, error: createError } = await createDeck({
        name,
        is_bilingual: isBilingual,
        primary_language: questionLanguage,
        secondary_language: answerLanguage,
      })

      if (createError) {
        appLogger.error("Error creating deck (from hook):", createError)
        toast.error("Failed to create deck", {
          description: "Please try again or check the logs for details."
        })
        return
      }

      if (!newDeckData || !newDeckData.id) {
        appLogger.error("Error creating deck: No data or ID returned from hook.")
        toast.error("Failed to create deck", {
          description: "Could not retrieve deck information after creation."
        })
        return
      }

      toast.success("Deck created successfully!")

      onOpenChange(false)
      router.push(`/edit/${newDeckData.id}`)
    } catch (error) {
      appLogger.error("Error creating deck:", error)
      toast.error("Failed to create deck", {
        description: error instanceof Error ? error.message : "An unexpected error occurred."
      })
    } finally {
      setLoading(false)
    }
  }

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[425px]">
        <form onSubmit={handleSubmit}>
          <DialogHeader>
            <DialogTitle>Create New Deck</DialogTitle>
            <DialogDescription>Create a new deck of flashcards to study with.</DialogDescription>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Name
              </Label>
              <Input
                id="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                className="col-span-3"
                placeholder="e.g., Biology 101"
                required
              />
            </div>
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="bilingual" className="text-right">
                Bilingual Mode
              </Label>
              <div className="flex items-center space-x-2 col-span-3">
                <Switch
                  id="bilingual"
                  checked={isBilingual}
                  onCheckedChange={setIsBilingual}
                />
                <Label htmlFor="bilingual">Enable separate languages for questions and answers</Label>
              </div>
            </div>
            {isBilingual ? (
              <>
                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="questionLanguage" className="text-right">
                    Question Language
                  </Label>
                  <Select value={questionLanguage} onValueChange={setQuestionLanguage}>
                    <SelectTrigger id="questionLanguage" className="col-span-3">
                      <SelectValue placeholder="Select language" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="en">English</SelectItem>
                      <SelectItem value="nl">Dutch</SelectItem>
                      <SelectItem value="fr">French</SelectItem>
                      <SelectItem value="de">German</SelectItem>
                      <SelectItem value="es">Spanish</SelectItem>
                      <SelectItem value="it">Italian</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
                <div className="grid grid-cols-4 items-center gap-4">
                  <Label htmlFor="answerLanguage" className="text-right">
                    Answer Language
                  </Label>
                  <Select value={answerLanguage} onValueChange={setAnswerLanguage}>
                    <SelectTrigger id="answerLanguage" className="col-span-3">
                      <SelectValue placeholder="Select language" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="en">English</SelectItem>
                      <SelectItem value="nl">Dutch</SelectItem>
                      <SelectItem value="fr">French</SelectItem>
                      <SelectItem value="de">German</SelectItem>
                      <SelectItem value="es">Spanish</SelectItem>
                      <SelectItem value="it">Italian</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              </>
            ) : (
              <div className="grid grid-cols-4 items-center gap-4">
                <Label htmlFor="language" className="text-right">
                  Language
                </Label>
                <Select 
                  value={questionLanguage} 
                  onValueChange={(value) => {
                    setQuestionLanguage(value)
                    setAnswerLanguage(value)
                  }}
                >
                  <SelectTrigger id="language" className="col-span-3">
                    <SelectValue placeholder="Select language" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="en">English</SelectItem>
                    <SelectItem value="nl">Dutch</SelectItem>
                    <SelectItem value="fr">French</SelectItem>
                    <SelectItem value="de">German</SelectItem>
                    <SelectItem value="es">Spanish</SelectItem>
                    <SelectItem value="it">Italian</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            )}
          </div>
          <DialogFooter>
            <Button type="submit" disabled={loading}>
              {loading ? "Creating..." : "Create Deck"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  )
}


```

### File: components/deck-header.tsx

```
// src/components/study/deck-header.tsx
import Link from "next/link";
import { ArrowLeft, RotateCcw } from "lucide-react";
import { Button } from "@/components/ui/button";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";

interface DeckHeaderProps {
  deckName: string;
  onReset: () => void;
  showReset: boolean;
}

export function DeckHeader({ deckName, onReset, showReset }: DeckHeaderProps) {
  return (
    <div className="flex flex-col sm:flex-row justify-between items-center mb-6 gap-4">
      <div className="flex items-center">
        <Link href="/" className="mr-2" aria-label="Back to decks">
          <Button variant="ghost" size="icon">
            <ArrowLeft className="h-5 w-5" />
          </Button>
        </Link>
        <h1 className="text-2xl font-bold truncate" title={deckName}>{deckName}</h1>
      </div>
      <div className="flex items-center space-x-2">
        {showReset && (
          <AlertDialog>
            <AlertDialogTrigger asChild>
              <Button variant="outline" size="sm">
                <RotateCcw className="mr-2 h-4 w-4" /> Reset Progress
              </Button>
            </AlertDialogTrigger>
            <AlertDialogContent>
              <AlertDialogHeader>
                <AlertDialogTitle>Confirm Reset</AlertDialogTitle>
                <AlertDialogDescription>
                  Reset all study progress for this deck? This cannot be undone.
                </AlertDialogDescription>
              </AlertDialogHeader>
              <AlertDialogFooter>
                <AlertDialogCancel>Cancel</AlertDialogCancel>
                <AlertDialogAction
                  onClick={onReset}
                  className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                >
                  Reset Now
                </AlertDialogAction>
              </AlertDialogFooter>
            </AlertDialogContent>
          </AlertDialog>
        )}
      </div>
    </div>
  );
}

// Optionally use export default if preferred
// export default DeckHeader;
```

### File: components/deck-list.tsx

```
// components/deck-list.tsx
"use client"

import { useState, useEffect, useCallback } from "react"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { PlusCircle, Edit, Loader2 as IconLoader } from "lucide-react"
import { useDecks } from "@/hooks/use-decks"
import { useRouter } from "next/navigation"
import { useStudySessionStore } from "@/store/studySessionStore"
import Link from 'next/link'
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"
import { DeckProgressBar } from "@/components/deck/DeckProgressBar"
import { useSettings } from "@/providers/settings-provider"
import { cn } from "@/lib/utils"
import { Separator } from "@/components/ui/separator"
import { StudyModeButtons } from "@/components/study/StudyModeButtons"
import { getCardSrsStatesByIds } from '@/lib/actions/cardActions';
import { resolveStudyQuery } from '@/lib/actions/studyQueryActions';
import { isValid, parseISO } from 'date-fns';
import { appLogger } from '@/lib/logger';

export function DeckList() {
  const { decks, loading, refetchDecks } = useDecks() // Added refetchDecks
  const { settings, loading: settingsLoading } = useSettings() // Get settings
  const [isVisible, setIsVisible] = useState(true)
  const router = useRouter() // Keep router
  const [deckCardCounts, setDeckCardCounts] = useState<{
    [deckId: string]: { learn: number; review: number }
  }>({});
  const [isLoadingCounts, setIsLoadingCounts] = useState(true);

  // Effect for handling page visibility (for spinner animation)
  useEffect(() => {
    const handleVisibilityChange = () => setIsVisible(!document.hidden);
    if (typeof document !== 'undefined') {
      document.addEventListener('visibilitychange', handleVisibilityChange);
      setIsVisible(!document.hidden); // Set initial state
      // Cleanup listener on component unmount
      return () => document.removeEventListener('visibilitychange', handleVisibilityChange);
    }
  }, [])

  // Effect to refetch decks when page becomes visible again after being hidden
  // This helps keep the list fresh if the user navigates away and back
   useEffect(() => {
     if (isVisible && !loading) {
        // Optional: Add a check to avoid refetching too frequently if needed
        appLogger.info("[DeckList] Page visible, refetching decks.");
        refetchDecks();
     }
     // eslint-disable-next-line react-hooks/exhaustive-deps
   }, [isVisible]); // Rerun only when visibility changes

  // Navigate to the edit page for a specific deck
  const handleEditDeck = (deckId: string) => {
    router.push(`/edit/${deckId}`)
  }

  // Navigate to the intermediate deck creation choice page
  const handleCreateDeckClick = () => {
    appLogger.info("[DeckList] Navigating to deck creation choice page.");
    router.push('/decks/create-choice'); // Navigate to the choice page
  }

  // Handle combined loading state
  const isLoading = loading || settingsLoading;

  // Legend data - UPDATED with hex codes
  const legendStages = [
    { name: 'New', startColor: '#EC4899', endColor: '#EF4444' },
    { name: 'Learning', startColor: '#DA55C6', endColor: '#9353DD' },
    { name: 'Young', startColor: '#6055DA', endColor: '#5386DD' },
    { name: 'Mature', startColor: '#55A9DA', endColor: '#53DDDD' },
  ];

  // Function to fetch all card counts at once
  const fetchAllDeckCardCounts = useCallback(async () => {
    if (!decks?.length) return;
    
    setIsLoadingCounts(true);
    
    try {
      appLogger.info('[DeckList] Batch fetching card counts for all decks');
      
      // For each deck, get card IDs
      const deckCardsPromises = decks.map(deck => 
        resolveStudyQuery({
          criteria: { 
            deckIds: [deck.id], 
            tagLogic: 'ANY' as const,
          }
        })
      );
      
      // Wait for all queries to complete
      const deckCardsResults = await Promise.all(deckCardsPromises);
      
      // Collect all card IDs
      const allCardIds: string[] = [];
      const deckCardIds: {[deckId: string]: string[]} = {};
      
      decks.forEach((deck, index) => {
        const cardIds = deckCardsResults[index].data || [];
        deckCardIds[deck.id] = cardIds;
        allCardIds.push(...cardIds);
      });
      
      if (allCardIds.length === 0) {
        appLogger.info('[DeckList] No cards found in any deck');
        setDeckCardCounts({});
        setIsLoadingCounts(false);
        return;
      }
      
      // Get SRS states for all cards in one request
      const srsStatesResult = await getCardSrsStatesByIds([...new Set(allCardIds)]);
      
      if (srsStatesResult.error || !srsStatesResult.data) {
        appLogger.error('Error fetching SRS states:', srsStatesResult.error);
        setIsLoadingCounts(false);
        return;
      }
      
      // Process the results
      const now = new Date();
      const cardStates = srsStatesResult.data;
      const cardStateMap = new Map();
      
      // Create a lookup for faster access
      cardStates.forEach(state => {
        cardStateMap.set(state.id, state);
      });
      
      // Calculate counts for each deck
      const newCounts: {[deckId: string]: {learn: number; review: number}} = {};
      
      Object.entries(deckCardIds).forEach(([deckId, cardIds]) => {
        let learnCount = 0;
        let reviewCount = 0;
        
        cardIds.forEach(cardId => {
          const state = cardStateMap.get(cardId);
          if (!state) return;
          
          // Learn Mode eligibility
          if (state.srs_level === 0 && 
              (state.learning_state === null || state.learning_state === 'learning')) {
            learnCount++;
          }
          
          // Review Mode eligibility
          const isGraduatedOrRelearning = 
            (state.srs_level !== null && state.srs_level !== undefined && state.srs_level >= 1) || 
            (state.srs_level === 0 && state.learning_state === 'relearning');
          
          const isDue = 
            state.next_review_due && 
            isValid(parseISO(state.next_review_due)) && 
            parseISO(state.next_review_due) <= now;
          
          if (isGraduatedOrRelearning && isDue) {
            reviewCount++;
          }
        });
        
        newCounts[deckId] = { learn: learnCount, review: reviewCount };
      });
      
      appLogger.info('[DeckList] Calculated counts for all decks:', newCounts);
      
      // Log an example of a single deck's counts for better debugging
      if (Object.keys(newCounts).length > 0) {
        const firstDeckId = Object.keys(newCounts)[0];
        appLogger.info(`[DeckList] Example count for deck ${firstDeckId}:`, newCounts[firstDeckId]);
      }
      
      // Log state before update
      appLogger.info('[DeckList] Current state before update:', deckCardCounts);
      
      // Update state
      setDeckCardCounts(newCounts);
      
      // This won't show the updated state due to React's state batching, but logging here for sequence
      appLogger.info('[DeckList] Updated deckCardCounts state');
    } catch (error) {
      appLogger.error('Error in batch card count calculation:', error);
    } finally {
      setIsLoadingCounts(false);
    }
  }, [decks]);
  
  // Fetch counts when decks load
  useEffect(() => {
    fetchAllDeckCardCounts();
  }, [fetchAllDeckCardCounts]);
  
  // Track loading state changes
  useEffect(() => {
    appLogger.info('[DeckList] isLoadingCounts changed to:', isLoadingCounts);
  }, [isLoadingCounts]);

  // Render loading state
  if (isLoading) {
    return (
      <div className="flex justify-center items-center h-64">
        {isVisible && <IconLoader className="h-12 w-12 animate-spin text-primary" />}
      </div>
    )
  }

  // Get setting value, default to true if settings not loaded yet
  const showDeckProgress = settings?.showDeckProgress ?? true;

  // Main component render
  return (
    <TooltipProvider>
      <div className="space-y-6 py-4 px-4 md:p-6">
        {/* Header section */}
        <div className="flex justify-between items-center flex-wrap gap-4 mb-6">
          {/* Title remains */}
          <h2 className="text-2xl font-semibold">Your Decks</h2>
          {/* Create button remains */}
          <div className="flex items-center gap-2 flex-wrap">
            <Button onClick={handleCreateDeckClick}>
              <PlusCircle className="mr-2 h-4 w-4" />
              Create Deck
            </Button>
          </div>
        </div>

        {/* Grid container */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
          {/* Display message if no decks exist */}
          {decks.length === 0 ? (
            <div className="col-span-full text-center text-muted-foreground mt-10">
              <p>You haven't created any decks yet.</p>
              {/* Button to create the first deck */}
              <Button onClick={handleCreateDeckClick} className="mt-4">
                <PlusCircle className="mr-2 h-4 w-4" />
                Create Your First Deck
              </Button>
            </div>
          ) : (
            // Map through existing decks and render a card for each
            decks.map((deck) => {
              const totalCards = (deck.new_count ?? 0) +
                                 (deck.learning_count ?? 0) +
                                 (deck.young_count ?? 0) +
                                 (deck.mature_count ?? 0);
              // Format language display based on whether the deck is bilingual
              let languageDisplay = deck.primary_language || 'Lang not set';
              if (deck.is_bilingual && deck.secondary_language) {
                  languageDisplay = `${deck.primary_language ?? '?'} / ${deck.secondary_language ?? '?'}`;
              }

              return (
                <Card key={deck.id} className="hover:shadow-md transition-shadow flex flex-col bg-gradient-to-b from-slate-100/40 dark:from-slate-800/40 to-transparent dark:border-slate-700">
                  <CardHeader className="pt-4 pb-2 space-y-1 px-4">
                    <div className="flex justify-between items-center">
                      {/* Deck name (truncated if long) */}
                      <CardTitle className="truncate text-lg" title={deck.name}>{deck.name}</CardTitle>
                      {/* Edit button with tooltip */}
                      <Tooltip>
                        <TooltipTrigger asChild>
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={() => handleEditDeck(deck.id)}
                            className="h-7 w-7 flex-shrink-0 text-muted-foreground"
                            aria-label={`Edit deck ${deck.name}`}
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                        </TooltipTrigger>
                        <TooltipContent>
                          <p>Edit Deck</p>
                        </TooltipContent>
                      </Tooltip>
                    </div>
                    {/* Deck metadata */}
                    <CardDescription className="text-sm">
                      {totalCards} card{totalCards !== 1 ? 's' : ''} • {languageDisplay}
                    </CardDescription>
                  </CardHeader>
                  {/* Footer with study buttons */}
                  <CardFooter className="flex justify-center pt-4 px-4 pb-4">
                    {/* Replace the buttons with the new component */}
                    <StudyModeButtons 
                      studyType="deck" 
                      contentId={deck.id} 
                      size="sm"
                      preCalculatedLearnCount={deckCardCounts[deck.id]?.learn}
                      preCalculatedReviewCount={deckCardCounts[deck.id]?.review}
                      batchFetchInProgress={isLoadingCounts}
                    />
                  </CardFooter>
                  {/* Conditionally render Separator AND DeckProgressBar */}
                  {showDeckProgress && (
                    <>
                      <Separator />
                      <CardContent className="px-4 pt-4 pb-4 bg-slate-50 dark:bg-slate-700/50 rounded-b-lg">
                        <DeckProgressBar
                          newCount={deck.new_count ?? 0}
                          learningCount={deck.learning_count ?? 0}
                          youngCount={deck.young_count ?? 0}
                          matureCount={deck.mature_count ?? 0}
                        />
                      </CardContent>
                    </>
                  )}
                </Card>
              )
            })
          )}
        </div>

        {/* Expanded Legend */}
        {showDeckProgress && decks.length > 0 && (
          <div className="mt-4 flex justify-end">
            <div className="text-xs text-muted-foreground flex flex-wrap gap-x-3 gap-y-1 p-2 border rounded-md bg-background shadow-sm">
              {legendStages.map(stage => (
                <span key={stage.name} className="flex items-center gap-1">
                  {/* Apply inline gradient style to legend chip */}
                  <span
                    className="h-2 w-3 rounded"
                    style={{ backgroundImage: `linear-gradient(to right, ${stage.startColor}, ${stage.endColor})` }}
                  ></span>
                  {stage.name}
                </span>
              ))}
            </div>
          </div>
        )}

      </div>
    </TooltipProvider>
  )
}
```

### File: components/deck-tag-editor.tsx

```
"use client";

import React, { useMemo, useState } from 'react';
import type { Tables } from '@/types/database';
import { useTags } from '@/hooks/useTags'; // Assuming this hook exists
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { X as IconX, Tag as IconTag, Check, ChevronsUpDown } from 'lucide-react';
import {
    Popover,
    PopoverContent,
    PopoverTrigger,
} from "@/components/ui/popover"
import {
    Command,
    CommandEmpty,
    CommandGroup,
    CommandInput,
    CommandItem,
    CommandList,
} from "@/components/ui/command"
import { cn } from '@/lib/utils'; // Import cn for conditional classes
import { appLogger } from '@/lib/logger';

// Define the expected props
interface DeckTagEditorProps {
    deckId: string;
    currentTags: Tables<'tags'>[]; // Tags currently on the deck
    onAddTag: (tagId: string) => Promise<void>; // Async to allow for loading state if needed
    onRemoveTag: (tagId: string) => Promise<void>; // Async
    disabled?: boolean; // Optional prop to disable interaction
}

// Type alias for Tag object
type DbTag = Tables<'tags'>;
// Type alias for Combobox options
type TagOption = { value: string; label: string };

export function DeckTagEditor({
    deckId,
    currentTags,
    onAddTag,
    onRemoveTag,
    disabled = false
}: DeckTagEditorProps) {
    // Fetch all available tags for the user
    const { allTags: allUserTags, isLoading: tagsLoading } = useTags();
    const [isAdding, setIsAdding] = useState(false);
    const [isRemoving, setIsRemoving] = useState<string | null>(null); // Store ID of tag being removed
    const [popoverOpen, setPopoverOpen] = useState(false); // State for Popover

    // Prepare options for the Combobox: Filter out tags already on the deck
    const availableTagOptions: TagOption[] = useMemo(() => {
        const currentTagIds = new Set(currentTags.map(tag => tag.id));
        return (allUserTags || [])
            .filter((tag: DbTag) => !currentTagIds.has(tag.id))
            .map((tag: DbTag) => ({ value: tag.id, label: tag.name }))
            .sort((a: TagOption, b: TagOption) => a.label.localeCompare(b.label));
    }, [allUserTags, currentTags]);

    const handleSelectTag = async (tagId: string | null) => {
        if (!tagId || disabled) return;
        setPopoverOpen(false); // Close popover on selection
        setIsAdding(true);
        try {
            await onAddTag(tagId);
        } catch (error) {
            // Error handled by the hook/action via toast
            appLogger.error("Error adding tag:", error);
        } finally {
            setIsAdding(false);
        }
    };

    const handleRemoveClick = async (tagId: string) => {
        if (disabled) return;
        setIsRemoving(tagId);
        try {
            await onRemoveTag(tagId);
        } catch (error) {
            appLogger.error("Error removing tag:", error);
        } finally {
            setIsRemoving(null);
        }
    };

    return (
        <div className="space-y-3">
            <p className="text-sm font-medium flex items-center">
                <IconTag className="h-4 w-4 mr-2 opacity-80" /> Deck Tags
            </p>
            {/* Display Current Tags as Badges */}
            <div className="flex flex-wrap gap-2">
                {currentTags.length === 0 && <p className="text-xs text-muted-foreground">No tags added yet.</p>}
                {currentTags.map((tag) => (
                    <Badge key={tag.id} variant="secondary" className="pl-2 pr-1 text-sm">
                        {tag.name}
                        <Button
                            variant="ghost"
                            size="icon"
                            className="ml-1 h-4 w-4 p-0 text-muted-foreground hover:text-destructive hover:bg-transparent disabled:opacity-50"
                            onClick={() => handleRemoveClick(tag.id)}
                            disabled={disabled || isRemoving === tag.id}
                            aria-label={`Remove tag ${tag.name}`}
                        >
                            <IconX className="h-3 w-3" />
                        </Button>
                    </Badge>
                ))}
            </div>

            {/* --- Add Tag Combobox using Popover/Command --- */}
            <div className="max-w-xs"> 
                <Popover open={popoverOpen} onOpenChange={setPopoverOpen}>
                    <PopoverTrigger asChild>
                        <Button
                            variant="outline"
                            role="combobox"
                            aria-expanded={popoverOpen}
                            className="w-full justify-between h-9 text-muted-foreground font-normal text-xs"
                            disabled={disabled || tagsLoading || isAdding}
                        >
                            {isAdding ? "Adding..." : "Add a tag..."}
                            <ChevronsUpDown className="ml-2 h-3 w-3 shrink-0 opacity-50" />
                        </Button>
                    </PopoverTrigger>
                    <PopoverContent className="w-[--radix-popover-trigger-width] max-h-[--radix-popover-content-available-height] p-0">
                        <Command shouldFilter={true}>
                            <CommandInput placeholder="Search tags..." className="h-8 text-xs" />
                            <CommandList>
                                <CommandEmpty>No matching tags found.</CommandEmpty>
                                <CommandGroup>
                                    {availableTagOptions.map((option) => (
                                        <CommandItem
                                            key={option.value}
                                            value={option.label} // Use label for filtering/display
                                            onSelect={(currentLabel) => {
                                                // Find the option by label to get the value (tagId)
                                                const selectedOption = availableTagOptions.find(opt => opt.label.toLowerCase() === currentLabel.toLowerCase());
                                                handleSelectTag(selectedOption ? selectedOption.value : null);
                                            }}
                                            className="text-xs"
                                        >
                                            {/* Checkmark logic can be added here if needed, though less common for add-only */} 
                                            {option.label}
                                        </CommandItem>
                                    ))}
                                </CommandGroup>
                            </CommandList>
                        </Command>
                    </PopoverContent>
                </Popover>
                {/* Consider adding a link/button to manage all tags (e.g., navigate to /tags) */} 
            </div>
            {/* ----------------------------------------------- */}
        </div>
    );
} 
```

### File: components/file-upload.tsx

```
'use client';

import { useRef, useState, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Card } from '@/components/ui/card';
import { Upload, File as FileIcon, X, PlusCircle } from 'lucide-react';
import React from 'react';
import { appLogger } from '@/lib/logger';

// Function to create a new File with a unique name
const createUniqueFile = (file: File): File => {
  // Extract the extension
  const nameComponents = file.name.split('.');
  const extension = nameComponents.length > 1 ? nameComponents.pop() : '';
  const baseName = nameComponents.join('.');
  
  // Create a timestamp-based name
  const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
  const uniqueName = `${baseName}_${timestamp}.${extension}`;
  
  // Create new file with unique name (but keeping same content and type)
  return new File([file], uniqueName, { type: file.type });
};

interface FileUploadProps {
  onFilesSelected: (files: File[]) => void;
  supportedFileTypes: string;
  supportedExtensions: string[];
  maxFileSize?: number; // in MB
}

export const FileUpload = (
  {
    onFilesSelected,
    supportedFileTypes,
    supportedExtensions,
    maxFileSize = 25
  }: FileUploadProps
) => {
  const [dragActive, setDragActive] = useState(false);
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [error, setError] = useState<string | null>(null);
  const inputRef = useRef<HTMLInputElement>(null);

  // Create a memoized version of the file update function to prevent unnecessary rerenders
  const updateParentFiles = useCallback(() => {
    appLogger.info(`FileUpload: Updating parent with ${selectedFiles.length} files`);
    onFilesSelected([...selectedFiles]);
  }, [selectedFiles, onFilesSelected]);

  const handleDrag = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    
    if (e.type === 'dragenter' || e.type === 'dragover') {
      setDragActive(true);
    } else if (e.type === 'dragleave') {
      setDragActive(false);
    }
  };

  const validateFiles = (files: FileList | null): boolean => {
    if (!files || files.length === 0) return false;
    
    // Check file extensions
    for (let i = 0; i < files.length; i++) {
      const file = files[i];
      const extension = file.name.split('.').pop()?.toLowerCase() || '';
      
      if (!supportedExtensions.includes(`.${extension}`)) {
        setError(`File type not supported. Please upload ${supportedFileTypes}.`);
        return false;
      }
      
      // Check file size
      if (file.size > maxFileSize * 1024 * 1024) {
        setError(`File size exceeds the ${maxFileSize}MB limit.`);
        return false;
      }
    }
    
    return true;
  };

  const handleDrop = (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault();
    e.stopPropagation();
    setDragActive(false);
    
    const { files } = e.dataTransfer;
    handleFiles(files);
  };

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { files } = e.target;
    handleFiles(files);
  };

  const handleFiles = (files: FileList | null) => {
    setError(null);
    
    if (!files || files.length === 0) {
      if (!error) {
        setError('No files were selected.');
      }
      return;
    }
    
    // Create an array of new files to add
    const newFiles: File[] = [];
    let hasError = false;
    
    // Validate each file before adding
    for (let i = 0; i < files.length; i++) {
      let file = files[i];
      const extension = file.name.split('.').pop()?.toLowerCase() || '';
      
      // Check file extension
      if (!supportedExtensions.includes(`.${extension}`)) {
        setError(`File "${file.name}" type not supported. Please upload ${supportedFileTypes}.`);
        hasError = true;
        continue;
      }
      
      // Check file size
      if (file.size > maxFileSize * 1024 * 1024) {
        setError(`File "${file.name}" exceeds the ${maxFileSize}MB limit.`);
        hasError = true;
        continue;
      }
      
      // Check if this is potentially an iOS camera photo or a duplicate filename
      const isIosPhoto = file.name === 'image.jpg' || file.name === 'image.jpeg';
      const isDuplicate = selectedFiles.some(existingFile => existingFile.name === file.name) ||
        newFiles.some(newFile => newFile.name === file.name);
      
      // Always rename iOS photos and any duplicate filenames
      if (isIosPhoto || isDuplicate) {
        appLogger.info(`Renaming file with duplicate name: ${file.name}`);
        file = createUniqueFile(file);
        appLogger.info(`New unique name: ${file.name}`);
      }
      
      newFiles.push(file);
    }
    
    // Only update state if we have files to add and no errors
    if (newFiles.length > 0) {
      appLogger.info(`Adding ${newFiles.length} new files to state`);
      // Update the state with the new files and notify parent
      setSelectedFiles(prev => {
        const updatedFiles = [...prev, ...newFiles];
        // Call the parent callback only after state update is complete
        setTimeout(() => onFilesSelected(updatedFiles), 0);
        return updatedFiles;
      });
    } else if (!hasError) {
      // If we have no files to add but also no error, set an informative error
      setError('No valid files were selected.');
    }
  };

  const handleButtonClick = () => {
    // Make sure input is reset before clicking to avoid issues with previously selected files
    if (inputRef.current) {
      inputRef.current.value = '';
    }
    
    // Then trigger the file selection
    inputRef.current?.click();
  };

  const removeFile = (index: number) => {
    appLogger.info(`Removing file at index ${index}`);
    
    setSelectedFiles(prev => {
      const newFiles = [...prev];
      appLogger.info(`Current files: ${newFiles.length}, removing index ${index}`);
      newFiles.splice(index, 1);
      appLogger.info(`New files count: ${newFiles.length}`);
      
      // Notify parent of the updated files
      setTimeout(() => onFilesSelected(newFiles), 0);
      
      return newFiles;
    });
    
    // Clear any error messages
    setError(null);
  };

  const clearFiles = () => {
    appLogger.info('Clearing all files');
    
    // Reset the selected files state
    setSelectedFiles([]);
    
    // Notify parent of cleared files
    setTimeout(() => onFilesSelected([]), 0);
    
    // Reset the file input value - important for making sure any re-selection works properly
    if (inputRef.current) {
      inputRef.current.value = '';
    }
    
    // Clear any error messages
    setError(null);
    
    // Log for debugging
    appLogger.info('All files cleared');
  };

  return (
    <div className="w-full">
      {/* File input */}
      <input
        ref={inputRef}
        type="file"
        multiple
        accept={supportedExtensions.join(',')}
        onChange={handleChange}
        className="hidden"
      />
      
      {/* Dropzone */}
      <Card
        className={`w-full p-6 border-2 border-dashed transition-colors ${
          dragActive ? 'border-primary bg-primary/5' : 'border-muted-foreground/25'
        }`}
        onDragEnter={handleDrag}
        onDragOver={handleDrag}
        onDragLeave={handleDrag}
        onDrop={handleDrop}
      >
        {selectedFiles.length > 0 ? (
          <div className="space-y-4">
            <div className="flex flex-col sm:flex-row gap-2 sm:gap-0 justify-between items-start sm:items-center">
              <h3 className="font-medium">Selected Files</h3>
              {/* On desktop, buttons stay in the header */}
              <div className="hidden sm:flex items-center gap-2">
                <Button 
                  type="button"
                  variant="outline" 
                  size="sm" 
                  onClick={handleButtonClick}
                >
                  <PlusCircle className="h-4 w-4 mr-1.5" />
                  Add More Files
                </Button>
                <Button 
                  type="button"
                  variant="ghost" 
                  size="sm" 
                  onClick={clearFiles}
                >
                  <X className="h-4 w-4 mr-1" />
                  Clear All
                </Button>
              </div>
            </div>
            
            <div className="space-y-2 mt-2">
              {selectedFiles.map((file, index) => (
                <div key={index} className="flex items-center justify-between p-2 bg-muted rounded-md">
                  <div className="flex items-center overflow-hidden max-w-[calc(100%-36px)]">
                    <FileIcon className="h-4 w-4 flex-shrink-0 mr-2 text-muted-foreground" />
                    <div className="overflow-hidden">
                      <span className="text-xs sm:text-sm font-medium truncate block">{file.name}</span>
                      <span className="text-xs text-muted-foreground">
                        ({(file.size / (1024 * 1024)).toFixed(2)} MB)
                      </span>
                    </div>
                  </div>
                  <Button
                    variant="ghost"
                    size="icon"
                    className="h-6 w-6 flex-shrink-0"
                    onClick={() => removeFile(index)}
                    type="button"
                  >
                    <X className="h-3 w-3" />
                  </Button>
                </div>
              ))}
            </div>

            {/* Mobile buttons below file list */}
            <div className="flex flex-col sm:hidden gap-2 mt-3">
              <Button 
                type="button"
                variant="outline" 
                className="w-full"
                size="sm" 
                onClick={handleButtonClick}
              >
                <PlusCircle className="h-4 w-4 mr-1.5" />
                Add More Files
              </Button>
              <Button 
                type="button"
                variant="outline" 
                size="sm"
                className="w-full" 
                onClick={clearFiles}
              >
                <X className="h-4 w-4 mr-1.5" />
                Clear All
              </Button>
            </div>

            {/* Add iOS Safari note */}
            {selectedFiles.some(file => file.name.includes('image_20') && (file.name.includes('.jpg') || file.name.includes('.jpeg'))) && (
              <div className="mt-1 text-xs text-blue-600 p-2 bg-blue-50 rounded-md">
                <strong>iOS User?</strong> We've automatically renamed your photos to ensure they can be processed individually.
              </div>
            )}
          </div>
        ) : (
          <div className="flex flex-col items-center justify-center text-center py-6 sm:py-8">
            <div className="rounded-full bg-primary/10 p-3 mb-3">
              <Upload className="h-6 w-6 sm:h-8 sm:w-8 text-primary" />
            </div>
            <h3 className="font-medium text-base sm:text-lg">Upload Files</h3>
            <p className="text-xs sm:text-sm text-muted-foreground mt-1 mb-2 sm:mb-3">
              Drag and drop or click to upload
            </p>
            <p className="text-xs text-muted-foreground">
              Supported formats: {supportedFileTypes}
            </p>
            <p className="text-xs text-muted-foreground">
              Max size: {maxFileSize}MB
            </p>
            <Button 
              type="button"
              variant="outline" 
              onClick={handleButtonClick}
              className="mt-3 sm:mt-4"
            >
              Browse Files
            </Button>
          </div>
        )}
      </Card>
      
      {/* Error message */}
      {error && (
        <p className="text-sm text-destructive mt-2">{error}</p>
      )}
    </div>
  );
}; 
```

### File: components/media-capture-tabs.tsx

```
'use client';

import React, { useCallback } from 'react';
import { FileUpload } from '@/components/file-upload';
import { appLogger } from '@/lib/logger';

interface MediaCaptureTabsProps {
  onFilesSelected: (files: File[]) => void;
  supportedFileTypes: string;
  supportedExtensions: string[];
  maxFileSize?: number; // in MB
  maxImages?: number;
}

export function MediaCaptureTabs({
  onFilesSelected,
  supportedFileTypes,
  supportedExtensions,
  maxFileSize = 25,
  maxImages = 5
}: MediaCaptureTabsProps) {
  // Use a memoized callback to avoid re-renders
  const handleFileUpload = useCallback((files: File[]) => {
    appLogger.info(`MediaCaptureTabs received ${files ? files.length : 0} files from FileUpload`);
    // Only propagate the update if we have valid inputs
    if (files && Array.isArray(files)) {
      onFilesSelected(files);
    }
  }, [onFilesSelected]);

  return (
    <FileUpload
      onFilesSelected={handleFileUpload}
      supportedFileTypes={supportedFileTypes}
      supportedExtensions={supportedExtensions}
      maxFileSize={maxFileSize}
    />
  );
} 
```

### File: components/settings-button.tsx

```
"use client"

import { Settings } from "lucide-react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

export function SettingsButton() {
  const router = useRouter()

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            onClick={() => router.push("/settings")}
          >
            <Settings className="h-5 w-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          <p>Settings</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
} 
```

### File: components/study-completion-screen.tsx

```
// components/study-completion-screen.tsx
"use client";

import Link from 'next/link';
import { ArrowLeft, Trophy } from 'lucide-react';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { StudyProgress } from '@/components/study-progress'; // Assuming this path is correct
import { DeckHeader } from '@/components/deck-header'; // Assuming this path is correct

interface StudyCompletionScreenProps {
  // Deck Info
  deckId: string;
  deckName: string;
  totalCards: number;
  cardsReviewedCount: number;

  // Progress Info
  masteredCount: number;
  totalAchievedCorrectAnswers: number;
  totalRequiredCorrectAnswers: number;
  overallProgressPercent: number;
  masteryProgressPercent: number;

  // Action Handlers
  onResetProgress: () => void; // Practice all
  onPracticeDifficult: () => void;
  onStudyAgain: () => void; // <-- Add handler for Study Again

  // Context
  difficultCardsCount: number;
  isDifficultModeCompletion: boolean; // True if completing a "difficult cards only" session

  srsProgression: {
    newToLearning: number;
    learningToReview: number;
    stayedInLearning: number;
    droppedToLearning: number;
  };
}

export function StudyCompletionScreen({
  deckId,
  deckName,
  totalCards,
  cardsReviewedCount,
  masteredCount,
  totalAchievedCorrectAnswers,
  totalRequiredCorrectAnswers,
  overallProgressPercent,
  masteryProgressPercent,
  onResetProgress,
  onPracticeDifficult,
  onStudyAgain, // <-- Destructure handler
  difficultCardsCount,
  isDifficultModeCompletion,
  srsProgression,
}: StudyCompletionScreenProps) {

  const hasRemainingDifficult = difficultCardsCount > 0;

  const title = isDifficultModeCompletion ? "Well Done! 🍪" : "Congratulations! 🎉";
  let message: string;

  if (isDifficultModeCompletion) {
    message = hasRemainingDifficult
      ? `You've mastered this set of difficult cards! However, there are still ${difficultCardsCount} difficult ${difficultCardsCount === 1 ? 'card' : 'cards'} to practice.`
      : "You've mastered all the difficult cards! Each card has been answered correctly 3 times.";
  } else {
     message = `You've mastered all ${totalCards} cards in this deck!`;
  }

  return (
    <div className="container mx-auto px-4 py-8">
      <Card className="max-w-2xl mx-auto">
        <CardHeader className="text-center">
          <div className="mx-auto mb-4 h-12 w-12 text-primary">
            <Trophy className="h-12 w-12" />
          </div>
          <CardTitle className="text-2xl">Session Complete!</CardTitle>
          <CardDescription>
            You've completed your study session for {deckName}
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Session Statistics */}
          <div className="rounded-lg bg-muted p-6">
            <h3 className="text-lg font-semibold mb-4">Session Summary</h3>
            <div className="grid gap-4 text-sm">
              <div className="flex justify-between items-center">
                <span className="text-muted-foreground">Cards Reviewed:</span>
                <span className="font-medium">{cardsReviewedCount}</span>
              </div>
              
              {/* SRS Progression */}
              <div className="border-t pt-4 mt-2">
                <h4 className="font-medium mb-3">SRS Level Changes:</h4>
                <div className="space-y-2">
                  {srsProgression.newToLearning > 0 && (
                    <div className="flex justify-between items-center text-blue-500">
                      <span>New → Learning:</span>
                      <span>+{srsProgression.newToLearning}</span>
                    </div>
                  )}
                  {srsProgression.learningToReview > 0 && (
                    <div className="flex justify-between items-center text-green-500">
                      <span>Learning → Review:</span>
                      <span>+{srsProgression.learningToReview}</span>
                    </div>
                  )}
                  {srsProgression.stayedInLearning > 0 && (
                    <div className="flex justify-between items-center text-amber-500">
                      <span>Stayed in Learning:</span>
                      <span>{srsProgression.stayedInLearning}</span>
                    </div>
                  )}
                  {srsProgression.droppedToLearning > 0 && (
                    <div className="flex justify-between items-center text-red-500">
                      <span>Dropped to Learning:</span>
                      <span>{srsProgression.droppedToLearning}</span>
                    </div>
                  )}
                </div>
              </div>
            </div>
          </div>

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row gap-3 justify-center pt-4">
            <Link href="/" passHref>
              <Button variant="outline" className="w-full sm:w-auto">
                <ArrowLeft className="mr-2 h-4 w-4" />
                Return Home
              </Button>
            </Link>
            <Button className="w-full sm:w-auto" onClick={onStudyAgain}>
              Study Again
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
}
```

### File: components/study-flashcard-view.tsx

```
"use client";

// --- Add useMemo import ---
import React, { useEffect, useState, useMemo } from "react";
// -------------------------
import { cn } from "@/lib/utils";
import type { Database, Tables } from "@/types/database";
type DbCard = Tables<'cards'>;
// --- Import Settings AND Palette types/data ---
import type { Settings } from "@/providers/settings-provider";
// Assuming palettes are defined in lib/palettes.ts or provider, adjust path:
import {
    PREDEFINED_PALETTES,
    DEFAULT_PALETTE_CONFIG,
    DARK_MODE_CARD_BG
} from "@/lib/palettes";
import type { Palette, ColorPair } from "@/lib/palettes";
// ------------------------------------------
// --- Import useTheme ---
import { useTheme } from "next-themes";
// ---------------------
import { Card, CardContent, CardFooter, CardHeader } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { ThumbsDown, ThumbsUp, Volume2, ChevronsDown, ChevronsUp } from "lucide-react"; // Keep original imports
import { getFontClass } from "@/lib/fonts";
import { useTTS } from "@/hooks/use-tts";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { appLogger } from '@/lib/logger';

type ReviewGrade = 1 | 2 | 3 | 4;

export interface StudyFlashcardViewProps {
  card: DbCard | null;
  isFlipped: boolean;
  isTransitioning: boolean;
  onFlip: () => void;
  onAnswer: (grade: ReviewGrade) => void;
  settings: Settings | null; // Now includes palette config and enable flags
  progressText?: string;
}


// --- UPDATED Helper function ---
function getWordStyles(
    pos: string | null | undefined,
    gender: string | null | undefined,
    textLanguageCode: string | undefined, // NEW: Language of the text itself
    settings: Settings | null,
    theme: string | undefined // 'light' | 'dark' | 'system'
): React.CSSProperties {
    const defaultStyle = {};
    if (!pos || pos === 'N/A' || !settings || !textLanguageCode) {
        return defaultStyle; // Cannot style without info
    }

    // --- NEW: Check if coloring should be skipped based on native language setting ---
    appLogger.debug('[getWordStyles] Checking native language:', {
        colorOnlyNonNative: settings.colorOnlyNonNative,
        appLanguage: settings.appLanguage,
        textLanguageCode: textLanguageCode,
        shouldSkip: settings.colorOnlyNonNative && settings.appLanguage === textLanguageCode
    });
    if (settings.colorOnlyNonNative && settings.appLanguage === textLanguageCode) {
        appLogger.debug(`[getWordStyles] Skipping color for native language (${textLanguageCode}) word.`);
        return defaultStyle; // Skip styling if it's the native language and setting is ON
    }
    // ---------------------------------------------------------------------------------

    const posKey = pos;
    const isBasicPos = ['Noun', 'Verb'].includes(posKey);
    const isEnabled = isBasicPos ? settings.enableBasicColorCoding : settings.enableAdvancedColorCoding;
    if (!isEnabled) { return defaultStyle; } // Styling not enabled for this PoS type

    const effectiveTheme = theme === 'dark' ? 'dark' : 'light';
    // Use paletteConfig from settings
    const paletteConfig = settings.wordPaletteConfig ?? DEFAULT_PALETTE_CONFIG;
    const genderKey = (gender && gender !== 'N/A' && paletteConfig?.[posKey]?.[gender]) ? gender : 'Default';
    const paletteId = paletteConfig?.[posKey]?.[genderKey] ?? 'default';

    if (paletteId === 'default') { return defaultStyle; }

    const selectedPalette = PREDEFINED_PALETTES.find(p => p.id === paletteId);
    if (!selectedPalette) { return defaultStyle; }

    const colorPair = selectedPalette[effectiveTheme];
    if (colorPair && colorPair.background !== 'transparent' && colorPair.text !== 'inherit') {
        return {
            backgroundColor: colorPair.background,
            color: colorPair.text,
        };
    }
    return defaultStyle;
}
// -----------------------------


export function StudyFlashcardView({
  card,
  isFlipped,
  isTransitioning,
  onFlip,
  onAnswer,
  settings,
  progressText,
}: StudyFlashcardViewProps) {

  const { speak } = useTTS({});
  const [isSpeaking, setIsSpeaking] = useState(false);
  // --- Get current theme ---
  const { theme } = useTheme();
  // -------------------------

  // --- Calculate styles using useMemo, passing text language ---
  const cardStyles = useMemo(() => {
      const defaultStyles = { questionStyle: {}, answerStyle: {}, cardRequiresDarkBg: false };
      if (!card || !settings) {
          return defaultStyles;
      }

      // --- Get language codes from the card's associated deck data ---
      // Assumes card includes decks relation: cards(..., decks(primary_language, secondary_language))
      // Use lowercase language codes ('en', 'fr', etc.) for comparison
      // TODO: Ensure card.decks is correctly typed and fetched
      // @ts-ignore - Assuming card.decks exists for now
      const questionLangCode = card.decks?.primary_language?.toLowerCase();
      // @ts-ignore - Assuming card.decks exists for now
      const answerLangCode = card.decks?.secondary_language?.toLowerCase();
      // -------------------------------------------------------------

      // Use correct snake_case field names from DbCard type
      const qStyle = getWordStyles(card.question_part_of_speech, card.question_gender, questionLangCode, settings, theme);
      const aStyle = getWordStyles(card.answer_part_of_speech, card.answer_gender, answerLangCode, settings, theme);

      // Dark mode background logic (needs slight adjustment)
      // Apply dark BG if dark theme AND (basic or advanced is enabled)
      // This prevents flickering if one side is native but the other isn't.
      const isAnyColoringEnabled = settings.enableBasicColorCoding || settings.enableAdvancedColorCoding;
      // Only require dark bg if styles actually applied and a relevant setting is enabled
      const cardRequiresDarkBg = theme === 'dark' && isAnyColoringEnabled && (Object.keys(qStyle).length > 0 || Object.keys(aStyle).length > 0);


      return {
          questionStyle: qStyle,
          answerStyle: aStyle,
          cardRequiresDarkBg: cardRequiresDarkBg
      };
  }, [card, settings, theme]); // Add theme dependency
  // ----------------------------------------------------

  // handleSpeak function (Original logic kept)
  const handleSpeak = async (text: string | null | undefined, defaultLang: string) => {
    if (!settings?.ttsEnabled || !text || isSpeaking) return;
    setIsSpeaking(true);
    try { await speak(text, defaultLang); }
    catch (error) { appLogger.error("TTS Error:", error); }
    finally { setIsSpeaking(false); }
  };

  // Language determination (Original logic kept)
  const questionLang = settings?.appLanguage ? (settings.languageDialects?.[settings.appLanguage as keyof typeof settings.languageDialects] || 'en-US') : 'en-US';
  const answerLang = questionLang;

  // useEffect for keypress (Original logic kept)
  useEffect(() => {
    if (!card) return; // Early return inside the effect is fine
    
    const handleKeyPress = (e: KeyboardEvent) => {
        if (isTransitioning) return;
        if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;
        if (!isFlipped) {
            if (e.key === ' ' || e.key === 'Enter') onFlip();
            else if ((e.key === 'p' || e.key === 't') && !isSpeaking) handleSpeak(card.question, questionLang);
        } else {
            const grade = parseInt(e.key);
            if (grade >= 1 && grade <= 4) onAnswer(grade as ReviewGrade);
            else if ((e.key === 'p' || e.key === 't') && !isSpeaking) handleSpeak(card.answer, answerLang);
        }
    };
    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [isFlipped, isTransitioning, onAnswer, onFlip, card, questionLang, answerLang, isSpeaking, handleSpeak, settings?.ttsEnabled]); 

  // Move the early return after all hooks have been called
  if (!card) { 
    return ( 
      <Card className="w-full max-w-2xl h-80 flex items-center justify-center">
        <p className="text-muted-foreground">Loading card...</p>
      </Card> 
    ); 
  }

  const fontClass = getFontClass(settings?.cardFont);

  // --- Conditionally apply dark mode background to card ---
  const cardDarkBgStyle: React.CSSProperties = cardStyles.cardRequiresDarkBg ? { backgroundColor: DARK_MODE_CARD_BG } : {};
  // -------------------------------------------------------

  return (
    <div className="w-full max-w-2xl mx-auto">
      <div
        className={`flip-card ${isFlipped ? "flipped" : ""} w-full h-80 cursor-pointer`}
        onClick={onFlip}
        role="button"
        aria-label={isFlipped ? "Flip to question" : "Flip to answer"}
        tabIndex={0}
      >
        <div className="flip-card-inner relative w-full h-full">
          {/* Front Side */}
          <div className="flip-card-front absolute w-full h-full">
            {/* Apply card background style */}
            <Card className={cn("w-full h-full flex flex-col flashcard-border", fontClass)} style={cardDarkBgStyle}>
              <CardHeader className="text-xs text-muted-foreground bg-muted/50 border-b py-2 px-4">
                 <div className="flex justify-between items-center"> <span>{progressText || '\u00A0'}</span> </div>
              </CardHeader>
              <CardContent className="p-6 text-center relative overflow-auto flex-grow flex items-center justify-center">
                 {/* Apply text style and classes to existing <p> */}
                <p className="text-xl md:text-2xl text-foreground inline-block px-2 py-1 rounded transition-colors duration-200" style={cardStyles.questionStyle}> {card.question} </p>
                {/* Original TTS Button */}
                {settings?.ttsEnabled && card.question && ( <Button variant="ghost" size="icon" className="absolute bottom-2 right-2" onClick={(e) => { e.stopPropagation(); handleSpeak(card.question, questionLang); }} disabled={isSpeaking} aria-label="Speak question"> <Volume2 className={cn("h-4 w-4", isSpeaking && "animate-pulse")} /> </Button> )}
              </CardContent>
              <CardFooter className="justify-center text-sm text-muted-foreground bg-muted/50 border-t py-3 min-h-[52px]"> Click card to reveal answer </CardFooter>
            </Card>
          </div>

          {/* Back Side */}
          <div className="flip-card-back absolute w-full h-full">
             {/* Apply card background style */}
            <Card className={cn("w-full h-full flex flex-col flashcard-border", fontClass)} style={cardDarkBgStyle}>
               <CardHeader className="text-xs text-muted-foreground bg-muted/50 border-b py-2 px-4">
                 <div className="flex justify-between items-center"> <span>{progressText || '\u00A0'}</span> </div>
               </CardHeader>
              <CardContent className="p-6 text-center relative overflow-auto flex-grow flex items-center justify-center">
                 {/* Apply text style and classes to existing <p> */}
                 <p className="text-xl md:text-2xl text-foreground inline-block px-2 py-1 rounded transition-colors duration-200" style={cardStyles.answerStyle}> {card.answer} </p>
                 {/* Original TTS Button */}
                 {settings?.ttsEnabled && card.answer && ( <Button variant="ghost" size="icon" className="absolute bottom-2 right-2" onClick={(e) => { e.stopPropagation(); handleSpeak(card.answer, answerLang); }} disabled={isSpeaking} aria-label="Speak answer"> <Volume2 className={cn("h-4 w-4", isSpeaking && "animate-pulse")} /> </Button> )}
              </CardContent>
              {/* --- Footer with ORIGINAL rating buttons --- */}
              <CardFooter className="bg-muted/50 border-t flex flex-row items-center justify-around gap-1 p-2 sm:justify-start sm:gap-2 sm:p-3">
                <TooltipProvider>
                  {/* Tooltip 1: Again - EXACT ORIGINAL BUTTON CODE */}
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button size="sm" variant="outline" className="flex-1 justify-center text-xs border-red-500 text-red-700 hover:bg-red-500/10 hover:text-red-800 dark:text-red-400 dark:hover:text-red-300 active:scale-95 transition-all duration-150 sm:w-auto sm:justify-start sm:text-sm" onClick={(e) => { e.stopPropagation(); onAnswer(1); }} disabled={isTransitioning || isSpeaking} aria-label="Again - Complete reset (Press 1)">
                        <ThumbsDown className="h-4 w-4 sm:mr-1" />
                        <ThumbsDown className="h-4 w-4 -ml-2 sm:hidden" />
                        <span className="hidden sm:inline">Again</span>
                        <span className="hidden sm:inline ml-1 opacity-50">(1)</span>
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent side="bottom"><p className="font-medium">Again (1)</p><p className="text-sm text-muted-foreground">Complete reset. Use when you completely forgot or got it wrong.</p></TooltipContent>
                  </Tooltip>
                  {/* Tooltip 2: Hard - **CHANGED ICON** */}
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button size="sm" variant="outline" className="flex-1 justify-center text-xs border-amber-500 text-amber-700 hover:bg-amber-500/10 hover:text-amber-800 dark:text-amber-400 dark:hover:text-amber-300 active:scale-95 transition-all duration-150 sm:w-auto sm:justify-start sm:text-sm" onClick={(e) => { e.stopPropagation(); onAnswer(2); }} disabled={isTransitioning || isSpeaking} aria-label="Hard - Remember with significant effort (Press 2)">
                        <ThumbsUp className="h-4 w-4 sm:mr-1" />
                        <span className="hidden sm:inline">Hard</span>
                        <span className="hidden sm:inline ml-1 opacity-50">(2)</span>
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent side="bottom"><p className="font-medium">Hard (2)</p><p className="text-sm text-muted-foreground">Remembered with significant effort. Review interval will increase slightly.</p></TooltipContent>
                  </Tooltip>
                  {/* Tooltip 3: Fair - **CHANGED LABEL & TOOLTIP** */}
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button size="sm" variant="outline" className="flex-1 justify-center text-xs border-green-500 text-green-700 hover:bg-green-500/10 hover:text-green-800 dark:text-green-400 dark:hover:text-green-300 active:scale-95 transition-all duration-150 sm:w-auto sm:justify-start sm:text-sm" onClick={(e) => { e.stopPropagation(); onAnswer(3); }} disabled={isTransitioning || isSpeaking} aria-label="Fair - Remember with some effort (Press 3)">
                        <ThumbsUp className="h-4 w-4 sm:mr-1" />
                        <span className="hidden sm:inline">Fair</span>
                        <span className="hidden sm:inline ml-1 opacity-50">(3)</span>
                      </Button>
                    </TooltipTrigger>
                     <TooltipContent side="bottom"><p className="font-medium">Fair (3)</p><p className="text-sm text-muted-foreground">Remembered with some effort. Normal interval increase.</p></TooltipContent>
                  </Tooltip>
                  {/* Tooltip 4: Easy - EXACT ORIGINAL BUTTON CODE */}
                  <Tooltip>
                    <TooltipTrigger asChild>
                      <Button size="sm" variant="outline" className="flex-1 justify-center text-xs border-blue-500 text-blue-700 hover:bg-blue-500/10 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 active:scale-95 transition-all duration-150 sm:w-auto sm:justify-start sm:text-sm" onClick={(e) => { e.stopPropagation(); onAnswer(4); }} disabled={isTransitioning || isSpeaking} aria-label="Easy - Remember effortlessly (Press 4)">
                        <ThumbsUp className="h-4 w-4 sm:mr-1" />
                        <ThumbsUp className="h-4 w-4 -ml-2 sm:hidden" />
                        <span className="hidden sm:inline">Easy</span>
                        <span className="hidden sm:inline ml-1 opacity-50">(4)</span>
                      </Button>
                    </TooltipTrigger>
                    <TooltipContent side="bottom"><p className="font-medium">Easy (4)</p><p className="text-sm text-muted-foreground">Remembered effortlessly. Larger interval increase.</p></TooltipContent>
                  </Tooltip>
                </TooltipProvider>
              </CardFooter>
              {/* ------------------------------------------------------- */}
            </Card>
          </div>
        </div>
      </div>
    </div>
  );
}
```

### File: components/study-progress.tsx

```
// src/components/study/study-progress.tsx
import { Progress } from "@/components/ui/progress";
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { HelpCircle } from "lucide-react";

interface StudyProgressProps {
    /** Current card number in the study queue */
    currentCardInQueue: number;
    /** Total number of cards in the study queue */
    totalCardsInQueue: number;
    /** SRS level counts for the current queue */
    srsLevels: {
        new: number;
        learning: number;
        review: number;
    };
}

export function StudyProgress({
    currentCardInQueue,
    totalCardsInQueue,
    srsLevels
}: StudyProgressProps) {
    // Calculate queue progress percentage
    const queueProgress = totalCardsInQueue > 0 
        ? Math.round((currentCardInQueue / totalCardsInQueue) * 100)
        : 0;

    // Calculate total cards for SRS distribution
    const totalSrsCards = srsLevels.new + srsLevels.learning + srsLevels.review;

    // Calculate percentages for SRS distribution
    const newPercent = totalSrsCards > 0 ? Math.round((srsLevels.new / totalSrsCards) * 100) : 0;
    const learningPercent = totalSrsCards > 0 ? Math.round((srsLevels.learning / totalSrsCards) * 100) : 0;
    const reviewPercent = totalSrsCards > 0 ? Math.round((srsLevels.review / totalSrsCards) * 100) : 0;

    return (
        <div className="max-w-2xl mx-auto mb-8 space-y-4">
            {/* Queue Progress */}
            <div>
                <div className="flex justify-between items-center mb-1">
                    <span className="text-sm text-muted-foreground">
                        Queue Progress ({currentCardInQueue} / {totalCardsInQueue} cards)
                    </span>
                    <span className="text-sm font-medium">{queueProgress}%</span>
                </div>
                <Progress 
                    value={queueProgress} 
                    aria-label={`Queue progress: ${queueProgress}%`} 
                    className="h-2" 
                />
            </div>

            {/* SRS Distribution */}
            <div>
                <div className="flex justify-between items-center mb-1">
                    <div className="flex items-center gap-2">
                        <span className="text-sm text-muted-foreground">
                            SRS Distribution
                        </span>
                        <TooltipProvider>
                            <Tooltip>
                                <TooltipTrigger>
                                    <HelpCircle className="h-4 w-4 text-muted-foreground" />
                                </TooltipTrigger>
                                <TooltipContent className="max-w-[300px]">
                                    <p className="font-semibold mb-2">Spaced Repetition System (SRS) Levels:</p>
                                    <ul className="list-disc pl-4 space-y-1">
                                        <li><span className="text-blue-500 font-medium">New</span>: Cards you haven't studied yet</li>
                                        <li><span className="text-amber-500 font-medium">Learning</span>: Cards being actively learned (levels 1-3)</li>
                                        <li><span className="text-green-500 font-medium">Review</span>: Cards in long-term memory (level 4+)</li>
                                    </ul>
                                </TooltipContent>
                            </Tooltip>
                        </TooltipProvider>
                    </div>
                    <div className="flex gap-4 text-xs">
                        <span className="text-blue-500">New: {srsLevels.new}</span>
                        <span className="text-amber-500">Learning: {srsLevels.learning}</span>
                        <span className="text-green-500">Review: {srsLevels.review}</span>
                    </div>
                </div>
                <div className="relative h-2 bg-muted rounded-full overflow-hidden">
                    {/* New Cards (Blue) */}
                    <div 
                        className="absolute left-0 top-0 h-full bg-blue-500" 
                        style={{ width: `${newPercent}%` }}
                        aria-label={`New cards: ${srsLevels.new}`}
                    />
                    {/* Learning Cards (Amber) */}
                    <div 
                        className="absolute h-full bg-amber-500" 
                        style={{ left: `${newPercent}%`, width: `${learningPercent}%` }}
                        aria-label={`Learning cards: ${srsLevels.learning}`}
                    />
                    {/* Review Cards (Green) */}
                    <div 
                        className="absolute h-full bg-green-500" 
                        style={{ left: `${newPercent + learningPercent}%`, width: `${reviewPercent}%` }}
                        aria-label={`Review cards: ${srsLevels.review}`}
                    />
                </div>
            </div>
        </div>
    );
}

// Optionally use export default if preferred
// export default StudyProgress;
```

### File: components/study-session.tsx

```
/**
 * Study session component that manages the overall study experience.
 * 
 * This component orchestrates the study session by:
 * - Managing the current card and session state
 * - Handling card progression and review scheduling
 * - Providing study controls and progress tracking
 * - Integrating with the spaced repetition system
 * 
 * @component
 * @param {Object} props - Component props
 * @param {Card[]} props.cards - Array of cards to study
 * @param {() => void} props.onComplete - Callback when the study session is completed
 * @param {(cardId: string, rating: number) => void} props.onRateCard - Callback for rating a card
 * @returns {JSX.Element} The complete study session interface
 */

import type { Tables } from '@/types/database';

// Define the card type from database schema
type Card = Tables<'cards'>;

export function StudySession({
  cards,
  onComplete,
  onRateCard,
}: {
  cards: Card[];
  onComplete: () => void;
  onRateCard: (cardId: string, rating: number) => void;
}) {
// ... existing code ...
} 
```

### File: components/table-editor.tsx

```
// components/table-editor.tsx
"use client"
import { useMemo } from "react"
import { Table, TableBody, TableCell, TableHead, TableHeader, TableRow } from "@/components/ui/table"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input" // Using Input for simpler inline editing
import { Trash2, Plus } from "lucide-react"
import type { Tables } from "@/types/database" // Import Tables
import { debounce } from "@/lib/utils"

const DEBOUNCE_WAIT_MS = 500;

// Use Tables<'cards'> as the source of truth for card type
type DbCard = Tables<'cards'>;

interface TableEditorProps {
  cards: DbCard[]; // Expect DbCard array
  onUpdate: (id: string, question: string, answer: string) => void; // Simple update for Q/A
  onDelete: (id: string) => void;
  onAdd: () => void;
}

export function TableEditor({ cards, onUpdate, onDelete, onAdd }: TableEditorProps) {
  // Debounced update handlers remain the same, onUpdate is simple
  const debouncedUpdateHandlers = useMemo(() => {
    const handlers: Record<string, (question: string, answer: string) => void> = {};
    cards.forEach(card => {
      // Ensure card.id is not null or undefined before using it as a key
      if (card.id) {
        handlers[card.id] = debounce((question: string, answer: string) => {
          onUpdate(card.id!, question, answer); // Use non-null assertion if ID is guaranteed here
        }, DEBOUNCE_WAIT_MS);
      }
    });
    return handlers;
  }, [cards, onUpdate]);

  return (
    <div className="space-y-4">
      <div className="flex justify-end">
        <Button onClick={onAdd}>
          <Plus className="mr-2 h-4 w-4" />
          Add Card
        </Button>
      </div>

      <div className="border rounded-md overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="w-[calc(50%-2rem)]">Question</TableHead>
              <TableHead className="w-[calc(50%-2rem)]">Answer</TableHead>
              <TableHead className="w-[4rem] text-right pr-2">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {cards.length === 0 ? (
              <TableRow>
                <TableCell colSpan={3} className="text-center py-8 text-muted-foreground">
                  No cards in this deck yet. Click "Add Card" to get started.
                </TableCell>
              </TableRow>
            ) : (
              cards.map((card) => ( // card is now DbCard
                <TableRow key={card.id}>
                  <TableCell className="py-1">
                    <Input
                      defaultValue={card.question} // Access question directly
                      onChange={(e) => {
                        const newQuestion = e.target.value;
                        // Ensure card.id and card.answer are not null/undefined
                        if (card.id && card.answer !== null && card.answer !== undefined) {
                           debouncedUpdateHandlers[card.id]?.(newQuestion, card.answer);
                        }
                      }}
                      placeholder="Enter question"
                      className="h-9 text-sm"
                    />
                  </TableCell>
                  <TableCell className="py-1">
                    <Input
                      defaultValue={card.answer} // Access answer directly
                      onChange={(e) => {
                        const newAnswer = e.target.value;
                        // Ensure card.id and card.question are not null/undefined
                         if (card.id && card.question !== null && card.question !== undefined) {
                            debouncedUpdateHandlers[card.id]?.(card.question, newAnswer);
                         }
                      }}
                      placeholder="Enter answer"
                      className="h-9 text-sm"
                    />
                  </TableCell>
                  <TableCell className="py-1 text-right pr-2">
                    <Button variant="ghost" size="icon" className="h-8 w-8" onClick={() => card.id && onDelete(card.id)}>
                      <Trash2 className="h-4 w-4 text-muted-foreground hover:text-destructive" />
                    </Button>
                  </TableCell>
                </TableRow>
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  )
}
```

### File: components/tags-button.tsx

```
'use client'

import { Tags } from "lucide-react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

/**
 * A button component that navigates to the tag management page.
 */
export function TagsButton() {
  const router = useRouter()

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            onClick={() => router.push("/tags")} // Navigate to /tags page
            aria-label="Manage Tags"
          >
            <Tags className="h-5 w-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          <p>Manage Tags</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
} 
```

### File: components/theme-provider.tsx

```
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

```

### File: components/tts-toggle-button.tsx

```
"use client"

import { Volume2, VolumeX } from "lucide-react"
import { Button } from "@/components/ui/button"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"
import { useSettings } from "@/providers/settings-provider"

export function TTSToggleButton() {
  const { settings, updateSettings } = useSettings()

  const toggleTTS = () => {
    updateSettings({ ttsEnabled: !settings?.ttsEnabled })
  }

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            onClick={toggleTTS}
          >
            {settings?.ttsEnabled ? (
              <Volume2 className="h-5 w-5" />
            ) : (
              <VolumeX className="h-5 w-5" />
            )}
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          <p>{settings?.ttsEnabled ? 'Disable' : 'Enable'} text-to-speech</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
} 
```

### File: components/user-nav.tsx

```
"use client"

import { User } from "lucide-react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"

export function UserNavButton() {
  const router = useRouter()

  return (
    <TooltipProvider>
      <Tooltip>
        <TooltipTrigger asChild>
          <Button
            variant="outline"
            size="icon"
            onClick={() => router.push("/profile")}
          >
            <User className="h-5 w-5" />
          </Button>
        </TooltipTrigger>
        <TooltipContent>
          <p>Profile</p>
        </TooltipContent>
      </Tooltip>
    </TooltipProvider>
  )
} 
```

## Directory: components/deck

### File: components/deck/DeckProgressBar.tsx

```
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { cn } from '@/lib/utils';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";

interface DeckProgressBarProps {
  newCount: number;
  learningCount: number;
  youngCount: number;
  matureCount: number;
  onClick?: () => void;
}

// Custom hook to track element width
function useElementWidth(elementRef: React.RefObject<HTMLElement | null>) {
  const [width, setWidth] = useState(0);

  useEffect(() => {
    const currentElement = elementRef.current;
    if (!currentElement) return;

    const resizeObserver = new ResizeObserver(entries => {
      for (let entry of entries) {
        setWidth(entry.contentRect.width);
      }
    });

    resizeObserver.observe(currentElement);

    // Initial width set
    setWidth(currentElement.offsetWidth);

    return () => resizeObserver.disconnect();
  }, [elementRef]);

  return width;
}

export function DeckProgressBar({
  newCount,
  learningCount,
  youngCount,
  matureCount,
}: Omit<DeckProgressBarProps, 'onClick'>) {
  const totalCount = newCount + learningCount + youngCount + matureCount;
  const rootRef = useRef<HTMLDivElement>(null);
  const [hasAnimated, setHasAnimated] = useState(false);

  useEffect(() => {
    const timer = setTimeout(() => {
      setHasAnimated(true);
    }, 50);
    return () => clearTimeout(timer);
  }, []);

  // Define stages with gradient hex codes
  const stages = [
    { name: 'New', count: newCount, percentage: totalCount > 0 ? (newCount / totalCount) * 100 : 0, startColor: '#EC4899', endColor: '#EF4444' }, // Keep pink-500 to red-500
    { name: 'Learning', count: learningCount, percentage: totalCount > 0 ? (learningCount / totalCount) * 100 : 0, startColor: '#DA55C6', endColor: '#9353DD' },
    { name: 'Young', count: youngCount, percentage: totalCount > 0 ? (youngCount / totalCount) * 100 : 0, startColor: '#6055DA', endColor: '#5386DD' },
    { name: 'Mature', count: matureCount, percentage: totalCount > 0 ? (matureCount / totalCount) * 100 : 0, startColor: '#55A9DA', endColor: '#53DDDD' },
  ];

  // Placeholder for zero cards
  if (totalCount === 0) {
    return (
      <div
        ref={rootRef}
        className="h-3 w-full bg-muted rounded-lg flex items-center justify-center px-2"
      >
        <span className="text-xs text-muted-foreground">No cards yet</span>
      </div>
    );
  }

  // Calculate percentages safely
  const newPercentage = stages[0].percentage;
  const learningPercentage = stages[1].percentage;
  const youngPercentage = stages[2].percentage;
  const maturePercentage = stages[3].percentage;

  const ariaLabel = `Deck progress: ${Math.round(maturePercentage)}% mature, ${Math.round(youngPercentage)}% young, ${Math.round(learningPercentage)}% learning, ${Math.round(newPercentage)}% new. Total ${totalCount} cards.`;

  return (
    <div
      ref={rootRef}
      tabIndex={0}
      aria-label={ariaLabel}
      className={cn(
        "relative w-full h-3 rounded-lg overflow-hidden bg-muted",
        "focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background"
      )}
    >
      {/* Flex container for slices and gutters */}
      <div className="absolute inset-0 flex w-full h-full gap-px bg-border">
        {stages.map((stage) => {
          const label = `${stage.name} ${stage.count}`;
          const tooltipLabel = `${stage.name} ${stage.count} cards`;

          return (
            <Tooltip key={stage.name}>
              <TooltipTrigger asChild>
                {stage.percentage > 0 ? (
                  <div
                    className="h-full transition-colors"
                    style={{
                      width: `${stage.percentage}%`,
                      backgroundImage: `linear-gradient(to right, ${stage.startColor}, ${stage.endColor})`,
                    }}
                  />
                ) : (
                   <span style={{ width: '0px' }} />
                )}
              </TooltipTrigger>
              <TooltipContent>
                <p>{tooltipLabel}</p>
              </TooltipContent>
            </Tooltip>
          );
        })}
      </div>
      {/* Animation Overlay */}
      <div
        className={cn(
          'absolute inset-0 bg-background transition-transform duration-600 ease-out',
          hasAnimated ? '-translate-x-full' : 'translate-x-0'
        )}
      />
    </div>
  );
}
```

### File: components/deck/EditableCardTable.tsx

```
// components/deck/EditableCardTable.tsx
"use client";

import React, { useState, useMemo, useCallback, useEffect } from 'react';
import { debounce } from '@/lib/utils';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Trash2, Loader2 } from 'lucide-react';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from '@/components/ui/alert-dialog';
import { toast } from 'sonner';
import { updateCard as updateCardAction, deleteCard as deleteCardAction } from '@/lib/actions/cardActions'; // Renamed to avoid conflict
import type { Tables } from '@/types/database';
import { appLogger, statusLogger } from '@/lib/logger';

// Use Tables<'cards'> for card data
type DbCard = Tables<'cards'>;
// Define input type for updateCardAction (snake_case)
type UpdateCardPayload = Partial<Pick<DbCard, 'question' | 'answer'>>;


interface EditableCardRowProps {
  card: DbCard;
  onDelete: (cardId: string) => Promise<void>; // Parent handles actual deletion and state update
  onCardUpdatedInParent: (updatedCard: DbCard) => void; // To notify parent of successful save
}

function EditableCardRow({ card, onDelete, onCardUpdatedInParent }: EditableCardRowProps) {
  const [questionContent, setQuestionContent] = useState(card.question ?? '');
  const [answerContent, setAnswerContent] = useState(card.answer ?? '');
  const [isSaving, setIsSaving] = useState(false);
  const [isDeleting, setIsDeleting] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);

  // Sync with prop changes (e.g., if parent updates the card after optimistic update)
  useEffect(() => {
    setQuestionContent(card.question ?? '');
    setAnswerContent(card.answer ?? '');
  }, [card.question, card.answer]);


  const debouncedUpdate = useMemo(
    () =>
      debounce(async (field: 'question' | 'answer', value: string) => {
        const trimmedValue = value.trim();
        if (!trimmedValue) {
          toast.info(`Cannot save empty ${field}.`);
          return;
        }

        // Check if value actually changed from the card prop to prevent unnecessary saves
        if ((field === 'question' && card.question === trimmedValue) ||
            (field === 'answer' && card.answer === trimmedValue)) {
            // appLogger.info(`[EditableCardRow] No actual change detected for ${field} on card ${card.id}. Skipping save.`);
            return;
        }

        setIsSaving(true);
        const payload: UpdateCardPayload = { [field]: trimmedValue };
        const result = await updateCardAction(card.id, payload);
        setIsSaving(false);

        if (result?.error) {
          toast.error(`Failed to update ${field}`, { description: String(result.error) });
          // Revert UI to original prop value on error
          if (field === 'question') setQuestionContent(card.question ?? '');
          if (field === 'answer') setAnswerContent(card.answer ?? '');
        } else if (result.data) {
          // toast.success(`Card ${field} updated!`); // Optional: can be too noisy
          onCardUpdatedInParent(result.data); // Notify parent of successful update with new data
        }
      }, 750),
    [card.id, card.question, card.answer, onCardUpdatedInParent] // card.question/answer for checking change
  );

  const handleQuestionChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setQuestionContent(e.target.value);
    debouncedUpdate('question', e.target.value);
  };

  const handleAnswerChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
    setAnswerContent(e.target.value);
    debouncedUpdate('answer', e.target.value);
  };

  const handleDeleteConfirm = async () => {
      setIsDeleting(true);
      await onDelete(card.id);
      // Parent will remove the row from its state, which re-renders the table
      // No need to setIsDeleting(false) if row is removed.
      setShowDeleteConfirm(false);
  };

  return (
    <TableRow>
      <TableCell className="align-top py-2">
        <Textarea
          value={questionContent}
          onChange={handleQuestionChange}
          placeholder="Question content"
          className="min-h-[60px] resize-y text-sm"
          rows={2}
          aria-label={`Question content for card ${card.id}`}
          disabled={isDeleting}
        />
      </TableCell>
      <TableCell className="align-top py-2">
        <Textarea
          value={answerContent}
          onChange={handleAnswerChange}
          placeholder="Answer content"
          className="min-h-[60px] resize-y text-sm"
          rows={2}
          aria-label={`Answer content for card ${card.id}`}
          disabled={isDeleting}
        />
      </TableCell>
      <TableCell className="align-middle py-2 text-right">
        {isSaving && <Loader2 className="h-4 w-4 animate-spin inline-block mr-2" aria-label="Saving..."/>}
        <AlertDialog open={showDeleteConfirm} onOpenChange={setShowDeleteConfirm}>
          <AlertDialogTrigger asChild>
            <Button
              variant="ghost"
              size="icon"
              className="h-8 w-8" // Slightly larger hit area
              disabled={isDeleting || isSaving}
              aria-label={`Delete Card ${card.id}`}
            >
              {isDeleting ? (
                  <Loader2 className="h-4 w-4 animate-spin" />
              ) : (
                  <Trash2 className="h-4 w-4 text-muted-foreground hover:text-destructive" />
              )}
            </Button>
          </AlertDialogTrigger>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Are you sure?</AlertDialogTitle>
              <AlertDialogDescription>
                This action cannot be undone. This will permanently delete this flashcard.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={handleDeleteConfirm}
                disabled={isDeleting}
                className="bg-destructive hover:bg-destructive/90"
              >
                {isDeleting ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                Delete
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </TableCell>
    </TableRow>
  );
}


interface EditableCardTableProps {
  initialCards: DbCard[]; // Expect full DbCard objects
  deckId: string; // Still needed for context, though not directly used in this component if actions are global
  onCardUpdated: (updatedCard: DbCard) => void; // Callback to parent when a card is successfully updated via action
  // onDeleteCard from parent is now passed directly to EditableCardRow and handled there
}

export function EditableCardTable({ initialCards, onCardUpdated }: EditableCardTableProps) {
  // The 'cards' state is now managed by the parent useEditDeck hook.
  // This component receives 'initialCards' and renders them.
  // Updates are propagated upwards via onCardUpdated.
  // Deletions are handled by the parent after confirmation.

  const [cardsToDisplay, setCardsToDisplay] = useState<DbCard[]>(initialCards);

  // Sync with initialCards prop if it changes (e.g., parent adds/removes a card)
  useEffect(() => {
    setCardsToDisplay(initialCards);
  }, [initialCards]);


  const handleDeleteCardFromParent = useCallback(async (cardId: string) => {
    const result = await deleteCardAction(cardId); // Call the server action directly
    if (result?.error) {
        toast.error("Failed to delete card", { description: String(result.error) });
    } else {
        toast.success("Card deleted successfully.");
        // Update local display list
        setCardsToDisplay((prevCards) => prevCards.filter((c) => c.id !== cardId));
        // No need to call onCardUpdated for delete, parent already knows via its own handler
    }
  }, []);


  return (
    <div className="space-y-4">
      <div className="border rounded-md overflow-x-auto">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead className="min-w-[200px] w-[45%] pl-4">Question</TableHead>
              <TableHead className="min-w-[200px] w-[45%]">Answer</TableHead>
              <TableHead className="w-[10%] text-right pr-4">Actions</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {cardsToDisplay.length === 0 ? (
              <TableRow>
                <TableCell colSpan={3} className="text-center h-24 text-muted-foreground">
                  No cards in this deck. Add new cards using the "Add Card" button below or in the Card View.
                </TableCell>
              </TableRow>
            ) : (
              cardsToDisplay.map((card) => (
                <EditableCardRow
                  key={card.id}
                  card={card}
                  onDelete={handleDeleteCardFromParent} // Pass the direct delete handler
                  onCardUpdatedInParent={onCardUpdated}    // Pass the update notification handler
                />
              ))
            )}
          </TableBody>
        </Table>
      </div>
    </div>
  );
}
```

## Directory: components/layout

### File: components/layout/Header.tsx

```
'use client';

import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Menu, Settings, Volume2 } from 'lucide-react';
import Image from 'next/image';
import { UserNavButton } from '@/components/user-nav';
import { TTSToggleButton } from '@/components/tts-toggle-button';

interface HeaderProps {
  onToggleMobileSidebar: () => void;
}

export function Header({ onToggleMobileSidebar }: HeaderProps) {
  return (
    <header className="fixed top-0 left-0 right-0 z-40 flex h-16 items-center justify-between border-b bg-background px-4 md:px-6">
      {/* Hamburger Menu for Mobile */}
      <Button
        variant="outline"
        size="icon"
        className="md:hidden mr-3" // Only show on mobile, ADDED mr-3 for spacing
        onClick={onToggleMobileSidebar}
        aria-label="Toggle Menu"
      >
        <Menu className="h-5 w-5" />
      </Button>

      {/* App Title/Logo - Updated with Image and Text */}
      <div className="flex items-center md:ml-0">
        <Link href="/" className="flex items-center gap-2 font-semibold group">
          <Image 
            src="/favicon.svg"
            alt="StudyCards Logo" 
            width={28}
            height={28}
            className="transition-transform group-hover:scale-110"
          />
          <span className="text-lg">StudyCards</span>
        </Link>
      </div>

      {/* Spacer to push icons to the right */}
      <div className="flex-1 md:hidden"></div>

      {/* Right-side icons */}
      <div className="flex items-center gap-3">
         {/* Settings Button - Hidden on mobile */}
        <Link href="/settings" className="hidden md:inline-flex"> {/* Hide Link on mobile */}
          <Button variant="ghost" size="icon" aria-label="Settings">
            <Settings className="h-5 w-5" />
          </Button>
        </Link>
        {/* Use the actual TTSToggleButton component */}
        <div className="hidden md:inline-flex"> {/* Wrapper to maintain layout */} 
          <TTSToggleButton />
        </div>
        {/* User/Profile Button (Using Functional Component) - Always visible */} 
        <UserNavButton />
      </div>
    </header>
  );
} 
```

### File: components/layout/ResponsiveLayout.tsx

```
'use client';

import { useState, useCallback, ReactNode } from 'react';
import { Header } from './Header';
import { Sidebar } from './Sidebar';
import { cn } from '@/lib/utils';

interface ResponsiveLayoutProps {
  children: ReactNode;
}

export function ResponsiveLayout({ children }: ResponsiveLayoutProps) {
  const [isMobileSidebarOpen, setIsMobileSidebarOpen] = useState(false);
  const [isDesktopSidebarCollapsed, setIsDesktopSidebarCollapsed] = useState(false);

  const toggleMobileSidebar = useCallback(() => {
    setIsMobileSidebarOpen((prev) => !prev);
  }, []);

  const closeMobileSidebar = useCallback(() => {
    setIsMobileSidebarOpen(false);
  }, []);

  const toggleDesktopSidebar = useCallback(() => {
    setIsDesktopSidebarCollapsed((prev) => !prev);
  }, []);

  const collapsedWidth = 'md:pl-20';
  const expandedWidth = 'md:pl-64';

  return (
    <div className="flex min-h-screen flex-col">
      <Header onToggleMobileSidebar={toggleMobileSidebar} />
      <div className="flex flex-1">
        <Sidebar 
          isOpen={isMobileSidebarOpen} 
          onClose={closeMobileSidebar} 
          isCollapsed={isDesktopSidebarCollapsed}
          onToggleCollapse={toggleDesktopSidebar}
        />
        <main className={cn(
          "flex-1 bg-muted/40 pt-16 transition-all duration-300 ease-in-out",
          isDesktopSidebarCollapsed ? collapsedWidth : expandedWidth
        )}>
          {children}
        </main>
      </div>
    </div>
  );
} 
```

### File: components/layout/Sidebar.tsx

```
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { useState } from 'react';
import {
  Sheet,
  SheetContent,
  SheetOverlay,
  SheetClose,
  SheetTitle,
  SheetDescription,
} from '@/components/ui/sheet';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils'; // Assuming you have a utility for classnames
import {
  Tooltip,
  TooltipProvider,
  TooltipContent,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import {
  BookOpen,
  Tags,
  Settings,
  LayoutDashboard,
  List,
  PlusCircle,
  LogOut,
  PanelLeftClose,
  PanelLeftOpen,
} from 'lucide-react';
import { CreateDeckDialog } from '@/components/create-deck-dialog';
import { type LucideProps } from 'lucide-react'; // Changed import for LucideProps

// Define explicit types for navigation items
type LucideIconComponent = React.ComponentType<LucideProps>; // Defined LucideIconComponent type

type NavLink = {
  href: string;
  label: string;
  icon: LucideIconComponent; // Used LucideIconComponent
  id?: undefined; // Explicitly state id is not expected for link items
};

type NavButtonAction = {
  id: 'create-deck'; // Specific ID for this button type
  label: string;
  icon: LucideIconComponent; // Used LucideIconComponent
  href?: undefined; // Explicitly state href is not expected for this button item
};

type NavItemUnion = NavLink | NavButtonAction;

interface NavGroupDefinition {
  group: string;
  items: NavItemUnion[];
}

interface SidebarProps {
  isOpen: boolean;
  onClose: () => void;
  isCollapsed: boolean;
  onToggleCollapse: () => void;
}

const navItems: NavGroupDefinition[] = [
  {
    group: 'Practice',
    items: [
      { href: '/study/select', label: 'Practice', icon: BookOpen },
      { href: '/', label: 'Decks', icon: LayoutDashboard },
      { href: '/study/sets', label: 'Playlists', icon: List },
    ],
  },
  {
    group: 'Prepare',
    items: [
      { href: '/tags', label: 'Manage Tags', icon: Tags },
      { href: '/decks/create-choice', label: 'Create Deck', icon: PlusCircle },
    ],
  },
  {
    group: 'Other',
    items: [
      { href: '/settings', label: 'Settings', icon: Settings },
      // Add Logout or other links here
      // Example: { href: '/logout', label: 'Logout', icon: LogOut }
    ],
  },
];

function NavigationContent({ isCollapsed, onClose }: { isCollapsed: boolean; onClose?: () => void }) {
  const pathname = usePathname();

  return (
    <>
      <nav className="flex flex-col gap-4 py-4">
        {navItems.map((group) => (
          <div key={group.group} className={cn("px-3", isCollapsed && "px-1")}>
            <div className="space-y-1">
              {group.items.map((item: NavItemUnion) => { // Added NavItemUnion type for item
                if ('href' in item && typeof item.href === 'string') {
                  // This is a NavLink item
                  return (
                    <Tooltip key={item.href}>
                      <TooltipTrigger asChild>
                        <Button
                          variant={pathname === item.href ? 'secondary' : 'ghost'}
                          className={cn(
                            "w-full justify-start",
                            isCollapsed && "justify-center h-10"
                          )}
                          asChild
                          onClick={onClose} // onClose for closing mobile sheet
                        >
                          <Link href={item.href} aria-label={item.label}>
                            <item.icon className={cn("h-4 w-4", !isCollapsed && "mr-2")} />
                            <span className={cn(isCollapsed && "hidden")}>{item.label}</span>
                          </Link>
                        </Button>
                      </TooltipTrigger>
                      {isCollapsed && (
                        <TooltipContent side="right">
                          <p>{item.label}</p>
                        </TooltipContent>
                      )}
                    </Tooltip>
                  );
                }
                return null; // Fallback for items that don't match (shouldn't happen with correct types)
              })}
            </div>
          </div>
        ))}
      </nav>
    </>
  );
}

export function Sidebar({ isOpen, onClose, isCollapsed, onToggleCollapse }: SidebarProps) {
  return (
    <TooltipProvider>
      {/* Mobile Sidebar using Sheet */}
      <Sheet open={isOpen} onOpenChange={(open) => !open && onClose()}>
        <SheetOverlay className="md:hidden" />
        <SheetContent side="left" className="w-64 p-0 md:hidden">
          <SheetTitle className="sr-only">Navigation Menu</SheetTitle>
          <SheetDescription className="sr-only">Main navigation links for the application.</SheetDescription>
          <NavigationContent isCollapsed={false} onClose={onClose} />
        </SheetContent>
      </Sheet>

      {/* Desktop Sidebar - Now collapsible */}
      <aside 
        className={cn(
          "hidden md:fixed md:left-0 md:top-0 md:bottom-0 md:z-30 md:flex md:h-full md:flex-col md:border-r bg-background pt-16",
          "transition-all duration-300 ease-in-out",
          isCollapsed ? "md:w-20" : "md:w-64"
        )}
      >
        <div className="flex-1 overflow-y-auto overflow-x-hidden">
             <NavigationContent isCollapsed={isCollapsed} />
        </div>
        <div className="mt-auto border-t p-2">
           <Button 
              variant="ghost" 
              size="icon" 
              className="w-full hidden md:block" 
              onClick={onToggleCollapse}
              aria-label={isCollapsed ? "Expand Sidebar" : "Collapse Sidebar"}
           >
              {isCollapsed ? <PanelLeftOpen className="h-5 w-5" /> : <PanelLeftClose className="h-5 w-5" />}
           </Button>
        </div>
      </aside>
    </TooltipProvider>
  );
} 
```

## Directory: components/study

### File: components/study/StudyModeButtons.tsx

```
// components/study/StudyModeButtons.tsx
'use client';

import { useState, useEffect, useRef } from 'react';
import { Button } from '@/components/ui/button';
import { useRouter } from 'next/navigation';
import { resolveStudyQuery } from '@/lib/actions/studyQueryActions';
import { getCardSrsStatesByIds } from '@/lib/actions/cardActions';
import { useStudySessionStore } from '@/store/studySessionStore';
import type { StudySessionInput, SessionType } from '@/types/study';
import { Loader2 as IconLoader, GraduationCap, Play } from 'lucide-react';
import { toast } from 'sonner';
import { isValid, parseISO } from 'date-fns';
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema'; // Import for criteria construction

interface StudyModeButtonsProps {
  studyType: 'deck' | 'studySet';
  contentId: string;
  className?: string;
  size?: 'default' | 'sm' | 'lg';
  learnLabel?: string;
  reviewLabel?: string;
  preCalculatedLearnCount?: number;
  preCalculatedReviewCount?: number;
  batchFetchInProgress?: boolean;
}

export function StudyModeButtons({
  studyType,
  contentId,
  className = '',
  size = 'default',
  learnLabel = 'Learn',
  reviewLabel = 'Review',
  preCalculatedLearnCount,
  preCalculatedReviewCount,
  batchFetchInProgress = false
}: StudyModeButtonsProps) {
  const router = useRouter();
  const setStudyParameters = useStudySessionStore((state) => state.setStudyParameters);
  const clearStudyParameters = useStudySessionStore((state) => state.clearStudyParameters);

  const [isLoading, setIsLoading] = useState(
    preCalculatedLearnCount === undefined &&
    (batchFetchInProgress || preCalculatedReviewCount === undefined)
  );
  const [learnCount, setLearnCount] = useState(preCalculatedLearnCount ?? 0);
  const [reviewCount, setReviewCount] = useState(preCalculatedReviewCount ?? 0);
  const [error, setError] = useState<string | null>(null);
  const fetchedRef = useRef<{[key: string]: boolean}>({});

  useEffect(() => {
    console.log(`[StudyModeButtons] Mounted for ${contentId}: preLearn=${preCalculatedLearnCount}, preRev=${preCalculatedReviewCount}, batchInProg=${batchFetchInProgress}`);
  }, [contentId, preCalculatedLearnCount, preCalculatedReviewCount, batchFetchInProgress]);

  useEffect(() => {
    if (preCalculatedLearnCount !== undefined && preCalculatedReviewCount !== undefined) {
      setIsLoading(false);
      setLearnCount(preCalculatedLearnCount);
      setReviewCount(preCalculatedReviewCount);
    }
  }, [preCalculatedLearnCount, preCalculatedReviewCount]);

  useEffect(() => {
    console.log(`[StudyModeButtons] Loading state for ${contentId} is now:`, isLoading);
  }, [isLoading, contentId]);

  useEffect(() => {
    if (preCalculatedLearnCount !== undefined && preCalculatedReviewCount !== undefined) return;
    if (batchFetchInProgress) {
      console.log(`[StudyModeButtons] Skipping fetch for ${contentId} - batch fetch in progress by parent`);
      return;
    }
    if (fetchedRef.current[contentId]) {
      console.log(`[StudyModeButtons] Skipping fetch for ${contentId} - already fetched`);
      return;
    }

    const fetchCardCounts = async () => {
      if (!contentId) return;
      fetchedRef.current[contentId] = true;
      setIsLoading(true);
      setError(null);
      try {
        console.log(`[StudyModeButtons] Fetching counts for ${studyType} ID: ${contentId}`);

        // Explicitly construct the payload for resolveStudyQuery
        let queryPayloadForAction: Parameters<typeof resolveStudyQuery>[0];
        if (studyType === 'studySet') {
            queryPayloadForAction = { studySetId: contentId };
        } else { // deck
            const criteriaForDeck: StudyQueryCriteria = {
                deckId: contentId,
                tagLogic: 'ANY', // Default, other filters can be added if needed by StudyModeButtons
            };
            queryPayloadForAction = { criteria: criteriaForDeck };
        }

        const cardIdsResult = await resolveStudyQuery(queryPayloadForAction); // Use the correctly shaped payload
        // ... (rest of the logic for srsStatesResult and setting counts remains the same)
        if (cardIdsResult.error || !cardIdsResult.data) {
            throw new Error(cardIdsResult.error || `Failed to fetch card IDs for ${studyType} ${contentId}`);
        }
        const cardIds = cardIdsResult.data;
        if (cardIds.length === 0) {
            setLearnCount(0); setReviewCount(0); setIsLoading(false); return;
        }
        const srsStatesResult = await getCardSrsStatesByIds(cardIds);
        if (srsStatesResult.error || !srsStatesResult.data) {
            throw new Error(srsStatesResult.error || `Failed to fetch SRS states for ${studyType} ${contentId}`);
        }
        const cardStates = srsStatesResult.data;
        const now = new Date();
        const learnEligibleCards = cardStates.filter(card =>
            card.srs_level === 0 && (card.learning_state === null || card.learning_state === 'learning')
        );
        const reviewEligibleCards = cardStates.filter(card => {
            const isGraduatedOrRelearning = (card.srs_level != null && card.srs_level >= 1) || (card.srs_level === 0 && card.learning_state === 'relearning');
            const isDue = card.next_review_due && isValid(parseISO(card.next_review_due)) && parseISO(card.next_review_due) <= now;
            return isGraduatedOrRelearning && isDue;
        });
        setLearnCount(learnEligibleCards.length);
        setReviewCount(reviewEligibleCards.length);

      } catch (err) {
        const message = err instanceof Error ? err.message : "Error checking available cards";
        console.error(`[StudyModeButtons] Error fetching counts for ${contentId}:`, message);
        setError(message);
        setLearnCount(0); setReviewCount(0);
      } finally {
        setIsLoading(false);
      }
    };
    fetchCardCounts();
  }, [contentId, studyType, preCalculatedLearnCount, preCalculatedReviewCount, batchFetchInProgress]);

  const handleStartStudying = (sessionTypeToStart: SessionType) => {
    let studyInputForStore: StudySessionInput;

    if (studyType === 'studySet') {
      studyInputForStore = { studySetId: contentId };
    } else { // deck
      // For a deck, StudySessionInput expects a deckId directly
      studyInputForStore = { deckId: contentId };
    }

    console.log(`[StudyModeButtons] Starting '${sessionTypeToStart}' session with input:`, studyInputForStore);

    if (sessionTypeToStart === 'learn-only' && learnCount === 0) {
      toast.info("No new cards available to learn in this selection.");
      return;
    }
    if (sessionTypeToStart === 'review-only' && reviewCount === 0) {
      toast.info("No cards currently due for review in this selection.");
      return;
    }

    clearStudyParameters();
    setStudyParameters(studyInputForStore, sessionTypeToStart);
    router.push('/study/session');
  };

  // ... (rest of the JSX remains the same) ...
  return (
    <div className={`flex gap-2 ${className}`}>
      {isLoading ? (
        <div className="flex items-center text-muted-foreground text-sm h-9">
          <IconLoader className="w-4 h-4 mr-2 animate-spin" />
          Loading...
        </div>
      ) : error ? (
        <div className="flex items-center text-destructive text-sm h-9" title={error}>
            Error
        </div>
      ) : (
        <>
          <Button
            variant="secondary"
            size={size}
            className="bg-rose-500 hover:bg-rose-600 text-white"
            onClick={() => handleStartStudying('learn-only')}
            disabled={learnCount === 0}
            title={learnCount === 0 ? "No cards to learn" : `${learnLabel} ${learnCount} card(s)`}
          >
            <GraduationCap className="h-4 w-4 mr-1" /> {learnLabel} {learnCount > 0 && `(${learnCount})`}
          </Button>
          <Button
            variant="secondary"
            size={size}
            className="bg-blue-500 hover:bg-blue-600 text-white"
            onClick={() => handleStartStudying('review-only')}
            disabled={reviewCount === 0}
            title={reviewCount === 0 ? "No cards to review" : `${reviewLabel} ${reviewCount} card(s)`}
          >
            <Play className="h-4 w-4 mr-1" /> {reviewLabel} {reviewCount > 0 && `(${reviewCount})`}
          </Button>
        </>
      )}
    </div>
  );
}
```

### File: components/study/StudySelectClient.tsx

```
// components/study/StudySelectClient.tsx
"use client";

import { useState } from 'react';
import { useRouter } from 'next/navigation';
// Assuming StudySetSelector is now in the same directory or adjust path
import { StudySetSelector } from './StudySetSelector'; // Changed path
import { useStudySessionStore } from '@/store/studySessionStore';
// CORRECTED IMPORTS:
import type { StudySessionInput, SessionType } from '@/types/study';
import { toast } from 'sonner';
import type { Tables } from '@/types/database';

type Deck = Tables<'decks'> & {
   new_count: number;
   learning_count: number;
   young_count: number;
   mature_count: number;
   learn_eligible_count?: number;
   review_eligible_count?: number;
};
type StudySet = Tables<'study_sets'>;

interface StudySelectClientProps {
  initialDecks: Deck[];
  initialStudySets: StudySet[];
  hasErrors: boolean;
}

export function StudySelectClient({
  initialDecks,
  initialStudySets,
  hasErrors
}: StudySelectClientProps) {
  const router = useRouter();
  const { setStudyParameters, clearStudyParameters } = useStudySessionStore();
  const [error] = useState<string | null>(hasErrors ? 'There was an issue loading some data' : null);

  // onStartStudying now expects SessionType from StudySetSelector
  const handleStartStudying = async (input: StudySessionInput, sessionType: SessionType) => {
    try {
      console.log(`[StudySelectClient] Setting params for ${sessionType} session:`, input);
      clearStudyParameters();
      setStudyParameters(input, sessionType); // Pass SessionType to store
      router.push('/study/session');
    } catch (error) {
      console.error('Error starting study session:', error);
      toast.error('Failed to start study session');
    }
  };

  return (
    <>
      {error && (
        <div className="mt-6 mb-6 p-4 border border-destructive/50 rounded-lg bg-destructive/10 text-destructive">
          {error}
        </div>
      )}
      <StudySetSelector
        decks={initialDecks}
        studySets={initialStudySets}
        isLoadingStudySets={false}
        onStartStudying={handleStartStudying} // This callback now expects SessionType
      />
    </>
  );
}
```

### File: components/study/StudySetBuilder.tsx

```
// components/study/StudySetBuilder.tsx
'use client';

import React, { useCallback } from 'react';
import {
    useStudySetForm,
    type StudySetBuilderFormData, // Ensure this is exported from the hook
    type SrsStage // Ensure this is exported from the hook
} from '@/hooks/useStudySetForm'; // Corrected: UseStudySetFormReturn not needed directly here
import {
    Form, FormControl, FormDescription, FormField, FormItem, FormLabel, FormMessage
} from '@/components/ui/form';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Select as UISelect, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from '@/components/ui/checkbox';
import { Popover, PopoverTrigger, PopoverContent } from '@/components/ui/popover';
import {
    Command, CommandInput, CommandList, CommandItem, CommandGroup, CommandEmpty
} from '@/components/ui/command';
import { Calendar } from "@/components/ui/calendar";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Label } from "@/components/ui/label";
import { Badge } from "@/components/ui/badge";
import { cn } from "@/lib/utils";
import {
    CalendarIcon, Check, ChevronsUpDown, Loader2 as IconLoader, Languages, GripVertical, Tag, Filter
} from "lucide-react";
import { format, isValid } from "date-fns";
import type { DateRange } from "react-day-picker";
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import type { Tables } from "@/types/database";

type DbTag = Tables<'tags'>;

interface StudySetBuilderProps {
  initialData?: { id?: string; name: string; description?: string | null; criteria: StudyQueryCriteria; };
  onSave: (data: { name: string; description: string | null; criteria: StudyQueryCriteria }) => Promise<void>;
  isSaving?: boolean;
}

const ANY_LANGUAGE_PLACEHOLDER_VALUE = "__ANY_LANGUAGE__";

const languageOptions = [
    { value: ANY_LANGUAGE_PLACEHOLDER_VALUE, label: "-- Any Language --" },
    { value: "en", label: "English" }, { value: "fr", label: "French" },
    { value: "es", label: "Spanish" }, { value: "de", label: "German" },
    { value: "it", label: "Italian" }, { value: "nl", label: "Dutch" },
];

export function StudySetBuilder({ initialData, onSave, isSaving = false }: StudySetBuilderProps) {
  const {
    form,
    isLoading,
    allTags, // Used in renderMultiSelectPopover
    decks,   // Used in renderMultiSelectPopover
    onSubmit,
    watchedOperators,
    watchedFilterValues,
    allowedOperators,
    srsStageOptions
  } = useStudySetForm({ initialData, onSave, isSaving });

  const { control, watch, setValue, resetField } = form;
  const { includeTags } = watchedFilterValues;

  const renderDateValueInputs = useCallback((
      opFieldKey: keyof Pick<StudySetBuilderFormData, "createdDateOperator" | "updatedDateOperator" | "lastReviewedOperator" | "nextReviewDueOperator">,
      daysFieldKey: keyof Pick<StudySetBuilderFormData, "createdDateValueDays" | "updatedDateValueDays" | "lastReviewedValueDays" | "nextReviewDueValueDays">,
      dateFieldKey: keyof Pick<StudySetBuilderFormData, "createdDateValueDate" | "updatedDateValueDate" | "lastReviewedValueDate" | "nextReviewDueValueDate">,
      rangeFieldKey: keyof Pick<StudySetBuilderFormData, "createdDateValueRange" | "updatedDateValueRange" | "lastReviewedValueRange" | "nextReviewDueValueRange">
  ) => {
      const operator = watch(opFieldKey);
      const showDays = operator === 'newerThanDays' || operator === 'olderThanDays';
      const showDate = operator === 'onDate';
      const showRange = operator === 'betweenDates';
      const showAnyValueInput = showDays || showDate || showRange;

      return (
          <div className={`flex-grow grid grid-cols-1 sm:grid-cols-2 gap-2 ${showAnyValueInput ? 'mt-2 sm:mt-0' : 'hidden'}`}>
              <FormField control={control} name={daysFieldKey} render={({ field }) => (
                  <FormItem className={showDays ? '' : 'hidden'}>
                      <FormLabel className="sr-only">Days</FormLabel>
                      <FormControl><Input type="text" pattern="\d*" placeholder="Days" {...field} value={field.value ?? ''} disabled={isLoading || !showDays} /></FormControl>
                      <FormMessage />
                  </FormItem>
              )} />
              <FormField control={control} name={dateFieldKey} render={({ field }) => (
                  <FormItem className={`flex flex-col ${showDate ? '' : 'hidden'}`}>
                      <FormLabel className="sr-only">Date</FormLabel>
                      <Popover><PopoverTrigger asChild><FormControl><Button variant={"outline"} className={cn("w-full justify-start text-left font-normal", !field.value && "text-muted-foreground")} disabled={isLoading || !showDate}><CalendarIcon className="mr-2 h-4 w-4" />{field.value && isValid(field.value) ? format(field.value, "PPP") : <span>Pick a date</span>}</Button></FormControl></PopoverTrigger><PopoverContent className="w-auto p-0" align="start"><Calendar mode="single" selected={field.value ?? undefined} onSelect={field.onChange} initialFocus /></PopoverContent></Popover>
                      <FormMessage />
                  </FormItem>
              )} />
              <FormField control={control} name={rangeFieldKey} render={({ field }) => {
                const currentRange = field.value ?? undefined;
                return (
                  <FormItem className={`flex flex-col ${showRange ? '' : 'hidden'}`}>
                    <FormLabel className="sr-only">Date Range</FormLabel>
                    <Popover><PopoverTrigger asChild><FormControl><Button id={rangeFieldKey} variant={"outline"} className={cn("w-full justify-start text-left font-normal", !currentRange?.from && !currentRange?.to && "text-muted-foreground")} disabled={isLoading || !showRange}><CalendarIcon className="mr-2 h-4 w-4" />{(currentRange?.from && isValid(currentRange.from)) && (currentRange?.to && isValid(currentRange.to)) ? (<>{format(currentRange.from, "LLL dd, y")} - {format(currentRange.to, "LLL dd, y")}</>) : (currentRange?.from && isValid(currentRange.from)) ? (`From ${format(currentRange.from, "LLL dd, y")}`) : (currentRange?.to && isValid(currentRange.to)) ? (`To ${format(currentRange.to, "LLL dd, y")}`) : (<span>Pick a date range</span>)}</Button></FormControl></PopoverTrigger><PopoverContent className="w-auto p-0" align="start"><Calendar initialFocus mode="range" defaultMonth={currentRange?.from} selected={currentRange} onSelect={field.onChange} numberOfMonths={2} /></PopoverContent></Popover>
                    <FormMessage />
                  </FormItem>
                );
              }} />
          </div>
      );
  }, [control, isLoading, watch]);

  const renderMultiSelectPopover = useCallback((
      field: keyof Pick<StudySetBuilderFormData, "selectedDeckIds" | "selectedSrsStages" | "includeTags" | "excludeTags">,
      options: { value: string; label: string }[],
      selectedValuesProp: string[] | SrsStage[] | undefined,
      placeholder: string,
      groupLabel: string
    ) => {
        const selectedValues = Array.isArray(selectedValuesProp) ? selectedValuesProp.map(String) : [];
        return (
            <Popover>
                <PopoverTrigger asChild>
                    <Button variant="outline" role="combobox" className="w-full justify-between font-normal min-h-[40px] h-auto py-2">
                        <span className="flex flex-wrap gap-1">
                            {selectedValues.length > 0
                                ? selectedValues.map(val => {
                                    const option = options.find(opt => opt.value === val);
                                    return option ? <Badge key={val} variant="secondary" className="text-xs px-1.5 py-0.5">{option.label}</Badge> : null;
                                  }).filter(Boolean)
                                : <span className="text-muted-foreground">{placeholder}</span>
                            }
                        </span>
                        <ChevronsUpDown className="ml-2 h-4 w-4 shrink-0 opacity-50" />
                    </Button>
                </PopoverTrigger>
                <PopoverContent className="w-[--radix-popover-trigger-width] p-0">
                    <Command>
                        <CommandInput placeholder={`Search ${groupLabel.toLowerCase()}...`} />
                        <CommandList>
                            <CommandEmpty>No {groupLabel.toLowerCase()} found.</CommandEmpty>
                            <CommandGroup>
                                {options.map((option) => (
                                    <CommandItem
                                        key={option.value}
                                        value={option.label} // Search/display by label
                                        onSelect={() => {    // Act on value (ID)
                                            const currentSelected = selectedValues || [];
                                            const newSelected = currentSelected.includes(option.value)
                                                ? currentSelected.filter(v => v !== option.value)
                                                : [...currentSelected, option.value];
                                            setValue(field, newSelected as any, { shouldValidate: true, shouldDirty: true });
                                        }}
                                    >
                                        <Check className={cn("mr-2 h-4 w-4", selectedValues.includes(option.value) ? "opacity-100" : "opacity-0")} />
                                        {option.label}
                                    </CommandItem>
                                ))}
                            </CommandGroup>
                        </CommandList>
                    </Command>
                </PopoverContent>
            </Popover>
        );
    // Corrected dependencies for renderMultiSelectPopover
    }, [setValue, allTags, decks]); // It uses allTags and decks indirectly if options are derived from them

  return (
    <Form {...form}>
      <form onSubmit={onSubmit} className="space-y-8">
        <FormField control={control} name="name" render={({ field }) => (<FormItem><FormLabel>Smart Playlist Name</FormLabel><FormControl><Input placeholder="e.g., Hard French Verbs" {...field} disabled={isLoading} /></FormControl><FormMessage /></FormItem>)} />
        <FormField control={control} name="description" render={({ field }) => (<FormItem><FormLabel>Description (Optional)</FormLabel><FormControl><Textarea placeholder="e.g., All irregular -er verbs from Chapter 3, due this week" {...field} value={field.value ?? ''} onChange={field.onChange} disabled={isLoading} /></FormControl><FormMessage /></FormItem>)} />

        <hr/>
        <Card className="dark:border-slate-700">
            <CardHeader className="pb-4">
                <CardTitle className="text-lg font-semibold flex items-center"><Filter className="mr-2 h-5 w-5 text-primary"/> Filter Criteria</CardTitle>
                <FormDescription>Define rules to dynamically include cards in this playlist.</FormDescription>
            </CardHeader>
            <CardContent className="space-y-6 pt-0">
                <FormField control={control} name="selectedDeckIds" render={({ field }) => (
                    <FormItem>
                        <FormLabel>Decks</FormLabel>
                        {renderMultiSelectPopover("selectedDeckIds", decks.map(d => ({ value: d.id, label: d.name })), field.value, "Any Deck", "Decks")}
                        <FormDescription>Include cards from these specific decks. Leave empty for all decks.</FormDescription>
                        <FormMessage />
                    </FormItem>
                )} />

                <div className="space-y-4">
                    <FormField control={control} name="includeTags" render={({ field }) => (
                        <FormItem>
                            <FormLabel>Include Deck Tags</FormLabel>
                            {renderMultiSelectPopover("includeTags", allTags.map(t => ({ value: t.id, label: t.name })), field.value, "Any Tag", "Tags")}
                            <FormMessage />
                        </FormItem>
                    )} />
                    <FormField control={control} name="tagLogic" render={({ field }) => (
                        <FormItem className={(field.value && includeTags && includeTags.length > 1) ? 'mt-2 pl-2' : 'hidden'}>
                            <FormLabel>Tag Logic</FormLabel>
                            <UISelect onValueChange={field.onChange} value={field.value ?? 'ANY'} disabled={isLoading || !(includeTags && includeTags.length > 1)}>
                                <FormControl><SelectTrigger className="w-full sm:w-[220px]"><SelectValue /></SelectTrigger></FormControl>
                                <SelectContent><SelectItem value="ANY">Match ANY selected tag</SelectItem><SelectItem value="ALL">Match ALL selected tags</SelectItem></SelectContent>
                            </UISelect>
                            <FormMessage />
                        </FormItem>
                    )}/>
                    <FormField control={control} name="excludeTags" render={({ field }) => (
                        <FormItem>
                            <FormLabel>Exclude Deck Tags</FormLabel>
                            {renderMultiSelectPopover("excludeTags", allTags.map(t => ({ value: t.id, label: t.name })), field.value, "None", "Tags")}
                            <FormDescription>Cards with any of these deck tags will be excluded.</FormDescription>
                            <FormMessage />
                        </FormItem>
                    )} />
                </div>

                <FormField control={control} name="containsLanguage" render={({ field }) => (
                    <FormItem>
                        <FormLabel className="flex items-center"><Languages className="mr-2 h-5 w-5 text-muted-foreground" /> Card Language</FormLabel>
                        <UISelect
                            onValueChange={(value) => field.onChange(value === ANY_LANGUAGE_PLACEHOLDER_VALUE ? null : value)}
                            value={field.value ?? ANY_LANGUAGE_PLACEHOLDER_VALUE}
                            disabled={isLoading}
                        >
                            <FormControl><SelectTrigger><SelectValue placeholder="-- Any Language --" /></SelectTrigger></FormControl>
                            <SelectContent>
                                {languageOptions.map(opt => <SelectItem key={opt.value} value={opt.value}>{opt.label}</SelectItem>)}
                            </SelectContent>
                        </UISelect>
                        <FormDescription>Show cards where either side matches this language (based on deck settings).</FormDescription>
                        <FormMessage />
                    </FormItem>
                )} />

                <FormField control={control} name="selectedSrsStages" render={({ field }) => (
                    <FormItem>
                        <FormLabel className="flex items-center"><GripVertical className="mr-2 h-5 w-5 text-muted-foreground"/> Card SRS Stage</FormLabel>
                        {renderMultiSelectPopover(
                            "selectedSrsStages",
                            srsStageOptions.map(stage => ({ value: stage, label: stage.charAt(0).toUpperCase() + stage.slice(1) })),
                            field.value,
                            "Any Stage",
                            "SRS Stages"
                        )}
                        <FormDescription>Include cards from any of the selected SRS stages.</FormDescription>
                        <FormMessage />
                    </FormItem>
                )} />
            </CardContent>
        </Card>

        <Card className="dark:border-slate-700">
            <CardHeader className="pb-2">
                <CardTitle className="text-base font-medium flex items-center"><CalendarIcon className="mr-2 h-5 w-5 text-muted-foreground"/> Date Filters</CardTitle>
            </CardHeader>
            <CardContent className="space-y-6 pt-4">
                <div className="space-y-3">
                    <Label className="text-sm font-medium">Card Created Date</Label>
                    <div className="flex flex-col sm:flex-row items-start sm:items-end gap-2">
                        <FormField control={control} name="createdDateOperator" render={({ field }) => (<FormItem className="w-full sm:flex-shrink-0 sm:w-auto sm:min-w-[180px]"><FormLabel className="sr-only">Condition</FormLabel><UISelect onValueChange={(value) => { field.onChange(value === 'any' ? null : value); resetField("createdDateValueDays"); resetField("createdDateValueDate"); resetField("createdDateValueRange");}} value={field.value ?? 'any'} disabled={isLoading}><FormControl><SelectTrigger><SelectValue placeholder="Any Date" /></SelectTrigger></FormControl><SelectContent><SelectItem value="any">Any Date</SelectItem>{allowedOperators.createdUpdatedOps.map(op => <SelectItem key={`cd-${op}`} value={op}>{op.replace(/([A-Z])/g, ' $1').trim()}</SelectItem>)}</SelectContent></UISelect><FormMessage /></FormItem>)} />
                        {renderDateValueInputs('createdDateOperator', 'createdDateValueDays', 'createdDateValueDate', 'createdDateValueRange')}
                    </div>
                </div>
                <div className="space-y-3">
                    <Label className="text-sm font-medium">Card Last Updated Date</Label>
                    <div className="flex flex-col sm:flex-row items-start sm:items-end gap-2">
                        <FormField control={control} name="updatedDateOperator" render={({ field }) => (<FormItem className="w-full sm:flex-shrink-0 sm:w-auto sm:min-w-[180px]"><FormLabel className="sr-only">Condition</FormLabel><UISelect onValueChange={(value) => { field.onChange(value === 'any' ? null : value); resetField("updatedDateValueDays"); resetField("updatedDateValueDate"); resetField("updatedDateValueRange");}} value={field.value ?? 'any'} disabled={isLoading}><FormControl><SelectTrigger><SelectValue placeholder="Any Date" /></SelectTrigger></FormControl><SelectContent><SelectItem value="any">Any Date</SelectItem>{allowedOperators.createdUpdatedOps.map(op => <SelectItem key={`ud-${op}`} value={op}>{op.replace(/([A-Z])/g, ' $1').trim()}</SelectItem>)}</SelectContent></UISelect><FormMessage /></FormItem>)} />
                        {renderDateValueInputs('updatedDateOperator', 'updatedDateValueDays', 'updatedDateValueDate', 'updatedDateValueRange')}
                    </div>
                </div>
                <div className="space-y-3">
                   <Label className="text-sm font-medium">Card Last Reviewed Date</Label>
                   <div className="flex flex-col sm:flex-row items-start sm:items-end gap-2">
                       <FormField control={control} name="lastReviewedOperator" render={({ field }) => (<FormItem className="w-full sm:flex-shrink-0 sm:w-auto sm:min-w-[180px]"><FormLabel className="sr-only">Condition</FormLabel><UISelect onValueChange={(value) => { field.onChange(value === 'any' ? null : value); resetField("lastReviewedValueDays"); resetField("lastReviewedValueDate"); resetField("lastReviewedValueRange");}} value={field.value ?? 'any'} disabled={isLoading}><FormControl><SelectTrigger><SelectValue placeholder="Any / Never" /></SelectTrigger></FormControl><SelectContent><SelectItem value="any">Any / Never</SelectItem>{allowedOperators.lastReviewedOps.map(op => <SelectItem key={`lr-${op}`} value={op}>{op.replace(/([A-Z])/g, ' $1').trim()}</SelectItem>)}</SelectContent></UISelect><FormMessage /></FormItem>)} />
                       {renderDateValueInputs('lastReviewedOperator', 'lastReviewedValueDays', 'lastReviewedValueDate', 'lastReviewedValueRange')}
                   </div>
               </div>
               <div className="space-y-3">
                   <Label className="text-sm font-medium">Card Next Review Due Date</Label>
                   <div className="flex flex-col sm:flex-row items-start sm:items-end gap-2">
                       <FormField control={control} name="nextReviewDueOperator" render={({ field }) => (<FormItem className="w-full sm:flex-shrink-0 sm:w-auto sm:min-w-[180px]"><FormLabel className="sr-only">Condition</FormLabel><UISelect onValueChange={(value) => { field.onChange(value === 'any' ? null : value); resetField("nextReviewDueValueDays"); resetField("nextReviewDueValueDate"); resetField("nextReviewDueValueRange");}} value={field.value ?? 'any'} disabled={isLoading}><FormControl><SelectTrigger><SelectValue placeholder="Any / Never / Due" /></SelectTrigger></FormControl><SelectContent><SelectItem value="any">Any / Never / Due</SelectItem>{allowedOperators.nextReviewDueOps.map(op => <SelectItem key={`nr-${op}`} value={op}>{op.replace(/([A-Z])/g, ' $1').trim()}</SelectItem>)}</SelectContent></UISelect><FormMessage /></FormItem>)} />
                       {renderDateValueInputs('nextReviewDueOperator', 'nextReviewDueValueDays', 'nextReviewDueValueDate', 'nextReviewDueValueRange')}
                   </div>
               </div>
            </CardContent>
        </Card>

        <Button type="submit" disabled={isLoading || isSaving} className="w-full text-base py-6">
            {isSaving ? <IconLoader className="animate-spin mr-2 h-5 w-5" /> : null}
            {initialData?.id ? 'Update Smart Playlist' : 'Create Smart Playlist'}
        </Button>
      </form>
    </Form>
  );
}
```

### File: components/study/StudySetListClient.tsx

```
// components/study/StudySetListClient.tsx
"use client";

import React, { useState, useEffect, useCallback } from 'react'; // Added useEffect, useCallback
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip";
import { Edit, Play, Loader2 as IconLoader } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';
import type { Tables } from '@/types/database';
import { useStudySessionStore } from '@/store/studySessionStore';
import type { StudySessionInput, SessionType } from '@/types/study';
import { resolveStudyQuery } from '@/lib/actions/studyQueryActions';
import { getCardSrsStatesByIds } from '@/lib/actions/cardActions';
import { isValid, parseISO } from 'date-fns';
import { toast } from 'sonner';
import { appLogger } from '@/lib/logger';
import { useRouter } from 'next/navigation'; // Import useRouter

// Updated type for the study set data passed from the server component
type StudySetWithDeckNames = Tables<'study_sets'> & {
  relatedDeckNames?: string[];
};

interface StudySetListClientProps {
  initialData?: StudySetWithDeckNames[];
}

// PlaylistPracticeButton sub-component (same as previously corrected version)
interface PlaylistPracticeButtonProps {
  studySetId: string;
  studySetName: string;
}
function PlaylistPracticeButton({ studySetId, studySetName }: PlaylistPracticeButtonProps) {
  const router = useRouter();
  const { setStudyParameters, clearStudyParameters } = useStudySessionStore();
  const [isLoadingCounts, setIsLoadingCounts] = useState(true);
  const [learnEligibleCount, setLearnEligibleCount] = useState(0);
  const [reviewEligibleCount, setReviewEligibleCount] = useState(0);
  const [fetchError, setFetchError] = useState<string | null>(null);

  useEffect(() => {
    let isMounted = true;
    const fetchCounts = async () => {
      setIsLoadingCounts(true); setFetchError(null);
      try {
        appLogger.info(`[PlaylistPracticeButton] Fetching card IDs for StudySet: ${studySetId}`);
        const idResult = await resolveStudyQuery({ studySetId });
        if (!isMounted) return;
        if (idResult.error || !idResult.data) throw new Error(idResult.error || "Failed to resolve study set card IDs.");
        if (idResult.data.length === 0) { if(isMounted){setLearnEligibleCount(0); setReviewEligibleCount(0); setIsLoadingCounts(false);} return; }
        const srsStatesResult = await getCardSrsStatesByIds(idResult.data);
        if (!isMounted) return;
        if (srsStatesResult.error || !srsStatesResult.data) throw new Error(srsStatesResult.error || "Failed to fetch SRS states.");
        const cardStates = srsStatesResult.data;
        const now = new Date();
        const learnCards = cardStates.filter(c => c.srs_level === 0 && (c.learning_state === null || c.learning_state === 'learning')).length;
        const reviewCards = cardStates.filter(c => {
          const isReviewable = (c.srs_level != null && c.srs_level >= 1) || (c.srs_level === 0 && c.learning_state === 'relearning');
          const isDue = c.next_review_due && isValid(parseISO(c.next_review_due)) && parseISO(c.next_review_due) <= now;
          return isReviewable && isDue;
        }).length;
        if(isMounted){setLearnEligibleCount(learnCards); setReviewEligibleCount(reviewCards);}
      } catch (err) {
        const message = err instanceof Error ? err.message : "Error fetching counts.";
        appLogger.error(`[PlaylistPracticeButton] Error for ${studySetId}:`, message);
        if(isMounted) setFetchError(message);
      } finally {
        if(isMounted) setIsLoadingCounts(false);
      }
    };
    fetchCounts();
    return () => { isMounted = false; };
  }, [studySetId]);

  const totalPracticeable = learnEligibleCount + reviewEligibleCount;
  const handlePractice = () => {
    if (totalPracticeable === 0 && !isLoadingCounts && !fetchError) { toast.info(`No cards currently available to practice in "${studySetName}".`); return; }
    if (fetchError && !isLoadingCounts){ toast.error(`Cannot start practice for "${studySetName}" due to an error loading card counts.`); return; }
    const studyInput: StudySessionInput = { studySetId };
    const sessionType: SessionType = 'unified';
    appLogger.info(`[PlaylistPracticeButton] Starting '${sessionType}' session for StudySet ${studySetId}`);
    clearStudyParameters(); setStudyParameters(studyInput, sessionType); router.push('/study/session');
  };
  if (isLoadingCounts) return <Button size="sm" disabled className="w-full justify-center"><IconLoader className="h-4 w-4 mr-2 animate-spin" /> Checking Cards...</Button>;
  if(fetchError) return <Button size="sm" variant="outline" className="w-full justify-center border-destructive text-destructive hover:bg-destructive/10" onClick={handlePractice} title={fetchError}><Play className="h-4 w-4 mr-2" /> Practice (Error)</Button>;
  return <Button onClick={handlePractice} disabled={totalPracticeable === 0} size="sm" className="w-full bg-primary hover:bg-primary/90 justify-center" title={totalPracticeable === 0 ? `No cards to practice in "${studySetName}"` : `Practice ${totalPracticeable} card(s) from "${studySetName}"`}><Play className="h-4 w-4 mr-2" />Practice {totalPracticeable > 0 ? `(${totalPracticeable})` : ''}</Button>;
}


export function StudySetListClient({ initialData = [] }: StudySetListClientProps) {
  const studySets = initialData;

  if (studySets.length === 0) {
    return (
      <p className="text-center text-muted-foreground mt-10">You haven't created any smart playlists yet.</p>
    );
  }

  return (
    <TooltipProvider>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {studySets.map((set) => (
          <Card key={set.id} className="hover:shadow-md transition-shadow flex flex-col bg-gradient-to-b from-slate-100/40 dark:from-slate-800/40 to-transparent dark:border-slate-700">
            <CardHeader className="pt-4 pb-2 space-y-1 px-4">
              <div className="flex justify-between items-center">
                <CardTitle className="truncate" title={set.name}>{set.name}</CardTitle>
                <Tooltip>
                  <TooltipTrigger asChild>
                    <Button variant="ghost" size="icon" className="h-7 w-7 flex-shrink-0 text-muted-foreground" aria-label={`Edit ${set.name}`} asChild>
                      <Link href={`/study/sets/${set.id}/edit`}><Edit className="h-4 w-4" /></Link>
                    </Button>
                  </TooltipTrigger>
                  <TooltipContent><p>Edit Playlist</p></TooltipContent>
                </Tooltip>
              </div>
              <CardDescription>
                {set.description || `Updated ${formatDistanceToNow(new Date(set.updated_at), { addSuffix: true })}`}
              </CardDescription>
              {/* Display Related Deck Names */}
              {set.relatedDeckNames && set.relatedDeckNames.length > 0 && (
                <div className="mt-1 pt-1 border-t border-dashed border-slate-200 dark:border-slate-700">
                    <p className="text-xs text-muted-foreground">
                        <span className="font-medium">Decks:</span> {set.relatedDeckNames.join(', ')}
                    </p>
                </div>
              )}
            </CardHeader>
            {/* Removed CardContent that was empty */}
            <CardFooter className="flex justify-end items-center mt-auto pt-4 px-4 pb-4">
              <PlaylistPracticeButton studySetId={set.id} studySetName={set.name} />
            </CardFooter>
          </Card>
        ))}
      </div>
    </TooltipProvider>
  );
}
```

### File: components/study/StudySetSelector.tsx

```
// components/study/StudySetSelector.tsx
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { resolveStudyQuery } from '@/lib/actions/studyQueryActions';
import { getCardSrsStatesByIds } from '@/lib/actions/cardActions';
import type { StudySessionInput, SessionType } from '@/types/study';
import { isValid, parseISO } from 'date-fns';
import { toast } from 'sonner';
import { Loader2 as IconLoader, GraduationCap, Play } from 'lucide-react';
import type { Tables } from "@/types/database";
import type { StudyQueryCriteria } from "@/lib/schema/study-query.schema";
import { appLogger } from '@/lib/logger';


type DbDeck = Pick<Tables<'decks'>, 'id' | 'name'>;
type DbStudySet = Pick<Tables<'study_sets'>, 'id' | 'name'>;

interface StudySetSelectorProps {
  decks: DbDeck[];
  studySets?: DbStudySet[];
  isLoadingStudySets?: boolean;
  onStartStudying: (input: StudySessionInput, sessionType: SessionType) => void;
}

type SelectionSourceType = 'all' | 'deck' | 'studySet';

export function StudySetSelector({
  decks = [],
  studySets = [],
  isLoadingStudySets = false,
  onStartStudying
}: StudySetSelectorProps) {
  const [selectionSource, setSelectionSource] = useState<SelectionSourceType>('all');
  const [selectedDeckId, setSelectedDeckId] = useState<string | undefined>(undefined);
  const [selectedStudySetId, setSelectedStudySetId] = useState<string | undefined>(undefined);
  const [selectedSessionType, setSelectedSessionType] = useState<SessionType>('learn-only');

  const [isLoadingCounts, setIsLoadingCounts] = useState<boolean>(false);
  const [learnCount, setLearnCount] = useState<number>(0);
  const [reviewCount, setReviewCount] = useState<number>(0);
  const [countError, setCountError] = useState<string | null>(null);

  const getCurrentStudyInput = useCallback((): StudySessionInput | null => {
    if (selectionSource === 'all') {
      const criteriaForAll: StudyQueryCriteria = { allCards: true, tagLogic: 'ANY' };
      return { criteria: criteriaForAll };
    } else if (selectionSource === 'deck' && selectedDeckId) {
      const criteriaForDeck: StudyQueryCriteria = { deckId: selectedDeckId, tagLogic: 'ANY' };
      return { criteria: criteriaForDeck };
    } else if (selectionSource === 'studySet' && selectedStudySetId) {
      return { studySetId: selectedStudySetId };
    }
    return null;
  }, [selectionSource, selectedDeckId, selectedStudySetId]);

  useEffect(() => {
    const fetchCardCounts = async () => {
        const currentStudySessionInput = getCurrentStudyInput();
        if (!currentStudySessionInput) {
            setLearnCount(0); setReviewCount(0); setIsLoadingCounts(false); return;
        }
        setIsLoadingCounts(true); setCountError(null);
        try {
            let queryPayloadForAction: Parameters<typeof resolveStudyQuery>[0];
            if (currentStudySessionInput.studySetId) {
                queryPayloadForAction = { studySetId: currentStudySessionInput.studySetId };
            } else if (currentStudySessionInput.criteria) {
                queryPayloadForAction = { criteria: currentStudySessionInput.criteria };
            } else {
                throw new Error("Invalid input for fetching card counts from StudySetSelector.");
            }

            const cardIdsResult = await resolveStudyQuery(queryPayloadForAction);
            if (cardIdsResult.error || !cardIdsResult.data) {
                throw new Error(cardIdsResult.error || "Failed to fetch card IDs for counts");
            }
            const cardIds = cardIdsResult.data;
            if (cardIds.length === 0) {
                setLearnCount(0); setReviewCount(0); setIsLoadingCounts(false); return;
            }
            const srsStatesResult = await getCardSrsStatesByIds(cardIds);
            if (srsStatesResult.error || !srsStatesResult.data) {
                throw new Error(srsStatesResult.error || "Failed to fetch SRS states for counts");
            }
            const cardStates = srsStatesResult.data;
            const now = new Date();
            const learnEligibleCards = cardStates.filter(card =>
                card.srs_level === 0 && (card.learning_state === null || card.learning_state === 'learning')
            );
            const reviewEligibleCards = cardStates.filter(card => {
                const isGraduatedOrRelearning = (card.srs_level != null && card.srs_level >= 1) || (card.srs_level === 0 && card.learning_state === 'relearning');
                const isDue = card.next_review_due && isValid(parseISO(card.next_review_due)) && parseISO(card.next_review_due) <= now;
                return isGraduatedOrRelearning && isDue;
            });
            appLogger.info(`[StudySetSelector] Counts for ${selectionSource} (${selectedDeckId || selectedStudySetId || 'all'}): Learn=${learnEligibleCards.length}, Review=${reviewEligibleCards.length}`);
            setLearnCount(learnEligibleCards.length);
            setReviewCount(reviewEligibleCards.length);
        } catch (error) {
            const message = error instanceof Error ? error.message : "Error checking available cards";
            appLogger.error("[StudySetSelector] Error in fetchCardCounts:", message);
            setCountError(message);
            setLearnCount(0); setReviewCount(0);
        } finally {
            setIsLoadingCounts(false);
        }
    };
    fetchCardCounts();
}, [selectionSource, selectedDeckId, selectedStudySetId, getCurrentStudyInput]);


  const handleInitiateStudy = () => {
    const currentInput = getCurrentStudyInput();
    if (!currentInput) {
      toast.error("Please select a valid study option.");
      return;
    }

    if (selectedSessionType === 'learn-only' && learnCount === 0) {
      toast.info("No new cards available to learn in this selection.");
      return;
    }
    if (selectedSessionType === 'review-only' && reviewCount === 0) {
      toast.info("No cards currently due for review in this selection.");
      return;
    }
    // For 'unified', this component doesn't offer it, but if it did:
    // if (selectedSessionType === 'unified' && learnCount === 0 && reviewCount === 0) {
    //     toast.info("No cards available to practice in this selection.");
    //     return;
    // }

    onStartStudying(currentInput, selectedSessionType);
  };

  const isStartButtonDisabled =
    (selectionSource === 'deck' && !selectedDeckId) ||
    (selectionSource === 'studySet' && !selectedStudySetId) ||
    (selectedSessionType === 'learn-only' && learnCount === 0 && !isLoadingCounts) ||
    (selectedSessionType === 'review-only' && reviewCount === 0 && !isLoadingCounts) ||
    isLoadingCounts;

  return (
    <div className="space-y-6 p-4 border rounded-lg bg-background/60 dark:bg-slate-800/30">
      <h3 className="text-lg font-medium">Select Cards to Study</h3>
      <RadioGroup
        value={selectionSource}
        onValueChange={(value) => {
          setSelectionSource(value as SelectionSourceType);
          setSelectedDeckId(undefined);
          setSelectedStudySetId(undefined);
        }}
        className="flex flex-wrap gap-4"
      >
        <div className="flex items-center space-x-2">
          <RadioGroupItem value="all" id="r-all" />
          <Label htmlFor="r-all">All My Cards</Label>
        </div>
        <div className="flex items-center space-x-2">
          <RadioGroupItem value="deck" id="r-deck" />
          <Label htmlFor="r-deck">From a Deck</Label>
        </div>
        <div className="flex items-center space-x-2">
          <RadioGroupItem value="studySet" id="r-studySet" disabled={isLoadingStudySets} />
          <Label htmlFor="r-studySet" className={isLoadingStudySets ? "text-muted-foreground" : ""}>
            Smart Playlist {isLoadingStudySets ? "(Loading...)" : ""}
          </Label>
        </div>
      </RadioGroup>

      {selectionSource === 'deck' && (
         <div className="space-y-2 mt-4">
          <Label htmlFor="deck-select">Choose deck</Label>
          <Select value={selectedDeckId} onValueChange={setSelectedDeckId}>
            <SelectTrigger id="deck-select" className="w-full sm:w-[280px]"><SelectValue placeholder="Select a deck..." /></SelectTrigger>
            <SelectContent>
              {decks.length > 0 ? (
                decks.map((deck) => (
                  <SelectItem key={deck.id} value={deck.id}>{deck.name}</SelectItem>
                ))
              ) : (
                <SelectItem value="no-decks" disabled>No decks available</SelectItem>
              )}
            </SelectContent>
          </Select>
        </div>
      )}
      {selectionSource === 'studySet' && (
         <div className="space-y-2 mt-4">
          <Label htmlFor="study-set-select">Choose playlist</Label>
          <Select value={selectedStudySetId} onValueChange={setSelectedStudySetId} disabled={isLoadingStudySets}>
            <SelectTrigger id="study-set-select" className="w-full sm:w-[280px]"><SelectValue placeholder="Select a smart playlist..." /></SelectTrigger>
            <SelectContent>
              {isLoadingStudySets ? ( <SelectItem value="loading" disabled>Loading playlists...</SelectItem>
              ) : studySets.length > 0 ? (
                studySets.map((set) => ( <SelectItem key={set.id} value={set.id}>{set.name}</SelectItem> ))
              ) : ( <SelectItem value="no-sets" disabled>No smart playlists saved</SelectItem> )}
            </SelectContent>
          </Select>
        </div>
      )}

      {countError && (<div className="text-destructive text-sm mt-2">{countError}</div>)}
      {isLoadingCounts && (
        <div className="flex items-center text-muted-foreground text-sm mt-2">
          <IconLoader className="w-4 h-4 mr-2 animate-spin" /> Checking available cards...
        </div>
      )}
      <hr className="my-4"/>
      <div className="space-y-4">
        <Label className="text-base font-medium">Choose Study Type</Label>
        <RadioGroup
          value={selectedSessionType}
          onValueChange={(value) => setSelectedSessionType(value as SessionType)}
          className="flex flex-col sm:flex-row gap-4 sm:gap-6"
        >
           <div className="flex items-center space-x-2">
            <RadioGroupItem value="learn-only" id="st-learn" disabled={(learnCount === 0 && !isLoadingCounts)} />
            <Label htmlFor="st-learn" className={(!isLoadingCounts && learnCount === 0) ? "text-muted-foreground cursor-not-allowed" : "cursor-pointer"}>
              Learn New {(!isLoadingCounts && learnCount > 0) && `(${learnCount})`}
            </Label>
          </div>
          <div className="flex items-center space-x-2">
            <RadioGroupItem value="review-only" id="st-review" disabled={(reviewCount === 0 && !isLoadingCounts)} />
            <Label htmlFor="st-review" className={(!isLoadingCounts && reviewCount === 0) ? "text-muted-foreground cursor-not-allowed" : "cursor-pointer"}>
              Review Due (SRS) {(!isLoadingCounts && reviewCount > 0) && `(${reviewCount})`}
            </Label>
          </div>
        </RadioGroup>
        <p className="text-sm text-muted-foreground">
          {selectedSessionType === 'learn-only'
            ? "Focus on new cards or cards still in early learning steps."
            : "Review cards that are due based on Spaced Repetition."
          }
        </p>
      </div>
      <div className="flex justify-center pt-4">
        <Button
          onClick={handleInitiateStudy}
          disabled={isStartButtonDisabled}
          className="w-full sm:w-auto"
          size="lg"
        >
          {isLoadingCounts ? <><IconLoader className="mr-2 h-4 w-4 animate-spin" />Checking Cards...</> :
           selectedSessionType === 'learn-only' ? <><GraduationCap className="mr-2 h-5 w-5" /> Start Learning {learnCount > 0 && `(${learnCount})`}</> :
           <><Play className="mr-2 h-5 w-5" /> Start Reviewing {reviewCount > 0 && `(${reviewCount})`}</>
          }
        </Button>
      </div>
    </div>
  );
}
```

## Directory: components/tags

### File: components/tags/TagManager.tsx

```
'use client';

import React, { useState } from 'react';
import { useTags } from '@/hooks/useTags';
import { createTag, deleteTag } from '@/lib/actions/tagActions';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Badge } from '@/components/ui/badge';
import { toast } from 'sonner';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { Loader2 as IconLoader, X as IconX, Plus as IconPlus, Trash2 as IconTrash } from 'lucide-react';
import type { Tables } from "@/types/database";
type DbTag = Tables<'tags'>;
import { Label } from '@/components/ui/label';

/**
 * TagManager Component
 * Allows users to view, create, and delete their global tags.
 */
export function TagManager() {
  const { allTags, isLoading: isLoadingTags, error: tagsError, refetchAllTags } = useTags();
  const [newTagName, setNewTagName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  const [isDeleting, setIsDeleting] = useState<{ [tagId: string]: boolean }>({});

  // --- Handlers ---

  const handleCreateTag = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const trimmedName = newTagName.trim();
    if (!trimmedName) {
      toast.error("Tag name cannot be empty.");
      return;
    }

    setIsCreating(true);
    const result = await createTag(trimmedName);
    setIsCreating(false);

    if (result.error) {
      toast.error(`Failed to create tag: ${result.error}`);
    } else {
      toast.success(`Tag "${result.data?.name}" created.`);
      setNewTagName(''); // Clear input
      await refetchAllTags(); // Refresh the list
    }
  };

  const handleDeleteTag = async (tag: DbTag) => {
    setIsDeleting(prev => ({ ...prev, [tag.id]: true }));
    const result = await deleteTag(tag.id);
    setIsDeleting(prev => ({ ...prev, [tag.id]: false }));

    if (result.error) {
      toast.error(`Failed to delete tag "${tag.name}": ${result.error}`);
    } else {
      toast.success(`Tag "${tag.name}" deleted.`);
      await refetchAllTags(); // Refresh the list
    }
  };

  // --- Render Logic ---

  return (
    <div className="space-y-6">
      {/* Create Tag Form */}
      <form onSubmit={handleCreateTag} className="flex items-end gap-2">
        <div className="flex-grow">
            <Label htmlFor="new-tag-name" className="sr-only">New tag name</Label>
            <Input
                id="new-tag-name"
                type="text"
                placeholder="Enter new tag name..."
                value={newTagName}
                onChange={(e) => setNewTagName(e.target.value)}
                disabled={isCreating}
                maxLength={50} // Match schema validation
            />
        </div>
        <Button type="submit" disabled={isCreating || !newTagName.trim()}>
          {isCreating ? <IconLoader className="h-4 w-4 animate-spin mr-2" /> : <IconPlus className="h-4 w-4 mr-2" />}
          Create Tag
        </Button>
      </form>

      <hr />

      {/* Tag List */}
      <div>
        <h3 className="text-lg font-medium mb-3">Your Tags</h3>
        {isLoadingTags ? (
          <div className="flex items-center space-x-2 text-muted-foreground">
            <IconLoader className="h-4 w-4 animate-spin" />
            <span>Loading tags...</span>
          </div>
        ) : tagsError ? (
          <p className="text-sm text-destructive">Error loading tags: {tagsError}</p>
        ) : allTags.length === 0 ? (
          <p className="text-sm text-muted-foreground">You haven't created any tags yet.</p>
        ) : (
          <ul className="space-y-2">
            {allTags.map((tag) => (
              <li key={tag.id} className="flex items-center justify-between p-2 border rounded-md hover:bg-muted/50">
                <span className="text-sm font-medium">{tag.name}</span>
                 <AlertDialog>
                   <AlertDialogTrigger asChild>
                      <Button
                        variant="ghost"
                        size="icon"
                        disabled={isDeleting[tag.id]}
                        aria-label={`Delete tag ${tag.name}`}
                        className="h-7 w-7 text-muted-foreground hover:text-destructive hover:bg-destructive/10"
                      >
                        {isDeleting[tag.id] ? (
                          <IconLoader className="h-4 w-4 animate-spin" />
                        ) : (
                          <IconTrash className="h-4 w-4" />
                        )}
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                        <AlertDialogDescription>
                          This action cannot be undone. Deleting the tag "<strong className='font-semibold'>{tag.name}</strong>" will remove it from all associated cards.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel disabled={isDeleting[tag.id]}>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                          onClick={() => handleDeleteTag(tag)}
                          disabled={isDeleting[tag.id]}
                          className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                        >
                          {isDeleting[tag.id] && <IconLoader className="h-4 w-4 animate-spin mr-2" />} 
                          Delete Tag
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
} 
```

### File: components/tags/TagManagerClient.tsx

```
"use client";

import React, { useState } from 'react';
import { createTag, deleteTag } from '@/lib/actions/tagActions';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { toast } from 'sonner';
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog"
import { Loader2 as IconLoader, X as IconX, Plus as IconPlus, Trash2 as IconTrash } from 'lucide-react';
import type { Tables } from "@/types/database";
import { Label } from '@/components/ui/label';

type Tag = Tables<'tags'>;

interface TagManagerClientProps {
  initialTags: Tag[];
}

/**
 * TagManagerClient Component
 * Allows users to view, create, and delete their global tags.
 * Receives pre-fetched tags data from the server component.
 */
export function TagManagerClient({ initialTags }: TagManagerClientProps) {
  const [allTags, setAllTags] = useState<Tag[]>(initialTags);
  const [newTagName, setNewTagName] = useState('');
  const [isCreating, setIsCreating] = useState(false);
  const [isDeleting, setIsDeleting] = useState<{ [tagId: string]: boolean }>({});

  // --- Handlers ---

  const handleCreateTag = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    const trimmedName = newTagName.trim();
    if (!trimmedName) {
      toast.error("Tag name cannot be empty.");
      return;
    }

    setIsCreating(true);
    const result = await createTag(trimmedName);
    setIsCreating(false);

    if (result.error) {
      toast.error(`Failed to create tag: ${result.error}`);
    } else {
      toast.success(`Tag "${result.data?.name}" created.`);
      setNewTagName(''); // Clear input
      // Add the new tag to the local state
      if (result.data) {
        setAllTags(prev => [...prev, result.data!]);
      }
    }
  };

  const handleDeleteTag = async (tag: Tag) => {
    setIsDeleting(prev => ({ ...prev, [tag.id]: true }));
    const result = await deleteTag(tag.id);
    setIsDeleting(prev => ({ ...prev, [tag.id]: false }));

    if (result.error) {
      toast.error(`Failed to delete tag "${tag.name}": ${result.error}`);
    } else {
      toast.success(`Tag "${tag.name}" deleted.`);
      // Remove the tag from the local state
      setAllTags(prev => prev.filter(t => t.id !== tag.id));
    }
  };

  // --- Render Logic ---

  return (
    <div className="space-y-6">
      {/* Create Tag Form */}
      <form onSubmit={handleCreateTag} className="flex items-end gap-2">
        <div className="flex-grow">
            <Label htmlFor="new-tag-name" className="sr-only">New tag name</Label>
            <Input
                id="new-tag-name"
                type="text"
                placeholder="Enter new tag name..."
                value={newTagName}
                onChange={(e) => setNewTagName(e.target.value)}
                disabled={isCreating}
                maxLength={50} // Match schema validation
            />
        </div>
        <Button type="submit" disabled={isCreating || !newTagName.trim()}>
          {isCreating ? <IconLoader className="h-4 w-4 animate-spin mr-2" /> : <IconPlus className="h-4 w-4 mr-2" />}
          Create Tag
        </Button>
      </form>

      <hr />

      {/* Tag List */}
      <div>
        <h3 className="text-lg font-medium mb-3">Your Tags</h3>
        {allTags.length === 0 ? (
          <p className="text-sm text-muted-foreground">You haven't created any tags yet.</p>
        ) : (
          <ul className="space-y-2">
            {allTags.map((tag) => (
              <li key={tag.id} className="flex items-center justify-between p-2 border rounded-md hover:bg-muted/50">
                <span className="text-sm font-medium">{tag.name}</span>
                 <AlertDialog>
                   <AlertDialogTrigger asChild>
                      <Button
                        variant="ghost"
                        size="icon"
                        disabled={isDeleting[tag.id]}
                        aria-label={`Delete tag ${tag.name}`}
                        className="h-7 w-7 text-muted-foreground hover:text-destructive hover:bg-destructive/10"
                      >
                        {isDeleting[tag.id] ? (
                          <IconLoader className="h-4 w-4 animate-spin" />
                        ) : (
                          <IconTrash className="h-4 w-4" />
                        )}
                      </Button>
                    </AlertDialogTrigger>
                    <AlertDialogContent>
                      <AlertDialogHeader>
                        <AlertDialogTitle>Are you sure?</AlertDialogTitle>
                        <AlertDialogDescription>
                          This action cannot be undone. Deleting the tag "<strong className='font-semibold'>{tag.name}</strong>" will remove it from all associated cards.
                        </AlertDialogDescription>
                      </AlertDialogHeader>
                      <AlertDialogFooter>
                        <AlertDialogCancel disabled={isDeleting[tag.id]}>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                          onClick={() => handleDeleteTag(tag)}
                          disabled={isDeleting[tag.id]}
                          className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                        >
                          {isDeleting[tag.id] && <IconLoader className="h-4 w-4 animate-spin mr-2" />} 
                          Delete Tag
                        </AlertDialogAction>
                      </AlertDialogFooter>
                    </AlertDialogContent>
                  </AlertDialog>
              </li>
            ))}
          </ul>
        )}
      </div>
    </div>
  );
} 
```

## Directory: components/ui

### File: components/ui/accordion.tsx

```
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

```

### File: components/ui/alert-dialog.tsx

```
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

```

### File: components/ui/alert.tsx

```
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

```

### File: components/ui/aspect-ratio.tsx

```
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

```

### File: components/ui/avatar.tsx

```
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

```

### File: components/ui/badge.tsx

```
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

```

### File: components/ui/breadcrumb.tsx

```
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

```

### File: components/ui/button.tsx

```
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

```

### File: components/ui/calendar.tsx

```
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

```

### File: components/ui/card.tsx

```
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

```

### File: components/ui/carousel.tsx

```
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

```

### File: components/ui/chart.tsx

```
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

```

### File: components/ui/checkbox.tsx

```
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

```

### File: components/ui/collapsible.tsx

```
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

```

### File: components/ui/command.tsx

```
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

```

### File: components/ui/context-menu.tsx

```
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

```

### File: components/ui/dialog.tsx

```
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

```

### File: components/ui/drawer.tsx

```
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

```

### File: components/ui/dropdown-menu.tsx

```
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

```

### File: components/ui/form.tsx

```
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

```

### File: components/ui/hover-card.tsx

```
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

```

### File: components/ui/input-otp.tsx

```
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

```

### File: components/ui/input.tsx

```
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

```

### File: components/ui/label.tsx

```
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

```

### File: components/ui/menubar.tsx

```
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

```

### File: components/ui/navigation-menu.tsx

```
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

```

### File: components/ui/page-heading.tsx

```
import React from 'react';
import { ArrowLeft } from 'lucide-react';
import Link from 'next/link';

interface PageHeadingProps {
  title: string;
  description?: string;
  backHref?: string;
}

export function PageHeading({ title, description, backHref }: PageHeadingProps) {
  return (
    <div className="space-y-2">
      <div className="flex items-center">
        {backHref && (
          <Link 
            href={backHref} 
            className="mr-4 inline-flex h-8 w-8 items-center justify-center rounded-md hover:bg-muted"
            aria-label="Go back"
          >
            <ArrowLeft className="h-4 w-4" />
          </Link>
        )}
        <h1 className="text-xl font-semibold tracking-tight">{title}</h1>
      </div>
      {description && (
        <p className="text-sm text-muted-foreground">{description}</p>
      )}
    </div>
  );
} 
```

### File: components/ui/pagination.tsx

```
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}

```

### File: components/ui/popover.tsx

```
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

```

### File: components/ui/progress.tsx

```
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

```

### File: components/ui/radio-group.tsx

```
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

```

### File: components/ui/resizable.tsx

```
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

```

### File: components/ui/scroll-area.tsx

```
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

```

### File: components/ui/select.tsx

```
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

```

### File: components/ui/separator.tsx

```
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

```

### File: components/ui/sheet.tsx

```
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

```

### File: components/ui/sidebar.tsx

```
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        if (typeof document !== 'undefined') {
          document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
        }
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      if (typeof window === 'undefined') return

      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

```

### File: components/ui/skeleton.tsx

```
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

```

### File: components/ui/slider.tsx

```
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

```

### File: components/ui/sonner.tsx

```
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }

```

### File: components/ui/switch.tsx

```
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

```

### File: components/ui/table.tsx

```
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

```

### File: components/ui/tabs.tsx

```
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

```

### File: components/ui/textarea.tsx

```
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

```

### File: components/ui/toggle-group.tsx

```
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

```

### File: components/ui/toggle.tsx

```
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

```

### File: components/ui/tooltip.tsx

```
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

```

## Directory: docs

## Directory: docs/setup

### File: docs/setup/setup-fonts.sh

```
#!/bin/bash

# Create fonts directory if it doesn't exist
mkdir -p public/fonts

# Download OpenDyslexic font
curl -L -o public/fonts/OpenDyslexic-Regular.woff2 "https://github.com/antijingoist/opendyslexic/raw/master/compiled/OpenDyslexic-Regular.woff2"

# Download Atkinson Hyperlegible font
curl -L -o public/fonts/AtkinsonHyperlegible-Regular.woff2 "https://github.com/googlefonts/atkinson-hyperlegible/raw/main/fonts/webfonts/AtkinsonHyperlegible-Regular.woff2"

echo "Fonts have been downloaded to public/fonts/" 
```

## Directory: hooks

### File: hooks/use-auth.tsx

```
"use client"

import type React from "react"

import { useState, useEffect, createContext, useContext, useCallback } from "react"
import { useRouter } from "next/navigation"
import { useSupabase } from "@/hooks/use-supabase"
import type { Session, User, AuthError } from "@supabase/supabase-js"
import { appLogger, statusLogger } from '@/lib/logger'

/**
 * @typedef AuthContextType
 * @property {User | null} user The currently authenticated Supabase user, or null if not logged in.
 * @property {Session | null} session The current Supabase session, or null if not logged in.
 * @property {boolean} loading True while the authentication state is being determined (initial load), false otherwise.
 * @property {(email: string, password: string) => Promise<{ error: AuthError | Error | null }>} signIn Function to sign in a user with email and password. Returns an error object if sign-in fails.
 * @property {(email: string, password: string) => Promise<{ data: any | null; error: AuthError | Error | null }>} signUp Function to sign up a new user. Returns data and error objects. Requires email confirmation by default.
 * @property {() => Promise<{ error: AuthError | Error | null }>} signOut Function to sign out the current user. Returns an error object if sign-out fails.
 * @property {(email: string) => Promise<{ error: AuthError | Error | null }>} resetPassword Function to initiate the password reset process for a given email. Returns an error object if the request fails.
 */
interface AuthContextType {
  user: User | null
  session: Session | null
  loading: boolean
  signIn: (email: string, password: string) => Promise<{ error: AuthError | Error | null }>
  signUp: (email: string, password: string) => Promise<{ data: any | null; error: AuthError | Error | null }>
  signOut: () => Promise<{ error: AuthError | Error | null }>
  resetPassword: (email: string) => Promise<{ error: AuthError | Error | null }>
}

const AuthContext = createContext<AuthContextType | undefined>(undefined)

const DEBUG_AUTH = process.env.NODE_ENV !== 'production'

const logAuth = (...args: any[]) => {
  if (DEBUG_AUTH) {
    appLogger.info('[Auth Debug]:', ...args);
  }
};
const logAuthError = (...args: any[]) => {
  if (DEBUG_AUTH) {
    appLogger.error('[Auth Error]:', ...args);
  }
};

/**
 * Provides authentication state and functions to its children components.
 * Manages user session, loading state, and interactions with Supabase auth.
 * @param {object} props - Component props.
 * @param {React.ReactNode} props.children - Child components to be wrapped by the provider.
 */
export function AuthProvider({ children }: { children: React.ReactNode }) {
  const { supabase } = useSupabase()
  const router = useRouter()
  const [user, setUser] = useState<User | null>(null)
  const [session, setSession] = useState<Session | null>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    logAuth("Auth useEffect triggered...");

    // --- Guard Clause ---
    // Only proceed if the Supabase client is initialized.
    if (!supabase) {
      logAuth("Supabase client not ready yet, waiting...");
      // Keep loading true until supabase client is available.
      // Note: If supabase NEVER becomes available (e.g., missing env vars caught in useSupabase),
      // loading might stay true indefinitely. Consider adding a timeout or error state if needed.
      setLoading(true); 
      return; 
    }
    // --- End Guard Clause ---

    logAuth("Supabase client is ready. Proceeding with auth checks.");
    setLoading(true); // Ensure loading is true while we check the session

    let initialSessionFetched = false; // Flag to track if initial fetch completed

    const getSession = async () => {
      logAuth("Attempting to get session...");
      try {
        // Supabase client is guaranteed to be non-null here
        const { data: { session: currentSession }, error } = await supabase.auth.getSession();

        if (error) {
          logAuthError("Error getting session in useEffect:", error);
        }
        logAuth("getSession result:", currentSession ? "Session found" : "No session");
        setSession(currentSession);
        setUser(currentSession?.user ?? null);
      } catch (error) {
        logAuthError("Unexpected error during getSession:", error);
        setSession(null); // Ensure clean state on error
        setUser(null);
      } finally {
        initialSessionFetched = true;
        // Only set loading false if the listener is also set (or failed to set)
        // This check prevents flicker if onAuthStateChange runs immediately after getSession
        if (authListener) { 
            logAuth("getSession finally block: setting loading false (listener ready).");
            setLoading(false);
        } else {
            logAuth("getSession finally block: listener not ready yet, keeping loading true.");
        }
      }
    };

    getSession(); // Call getSession now that supabase is confirmed

    logAuth("Setting up onAuthStateChange listener...");
    const { data: { subscription: authListener } } = supabase.auth.onAuthStateChange((event, newSession) => {
      logAuth("onAuthStateChange triggered:", event, newSession ? "Session found" : "No session");
      setSession(newSession);
      setUser(newSession?.user ?? null);
      // Set loading to false once the listener provides an update OR
      // if the initial getSession has already finished. This handles cases
      // where the listener fires very quickly or after the initial check.
      if (!loading || initialSessionFetched) {
          logAuth("onAuthStateChange: setting loading false.");
          setLoading(false);
      }
    });

    // Cleanup function
    return () => {
      logAuth("Cleaning up auth useEffect: Unsubscribing...");
      authListener?.unsubscribe();
    };

    // This effect depends only on the supabase client instance.
    // It runs once when supabase is null (returns early),
    // and again when supabase becomes non-null.
  }, [supabase]);

  /**
   * Signs in a user using email and password.
   * Relies on onAuthStateChange to update user/session state.
   */
  const signIn = useCallback(
    async (email: string, password: string): Promise<{ error: AuthError | Error | null }> => {
      // Add guard clause for supabase availability
      if (!supabase) {
        logAuthError("Sign in failed: Supabase client not available.");
        return { error: new Error("Authentication service not ready.") };
      }
      setLoading(true);
      let errorResult: AuthError | Error | null = null;
      try {
        const { error } = await supabase.auth.signInWithPassword({ email, password })
        errorResult = error
        if (errorResult) {
          logAuthError("Sign in error:", errorResult)
        } else {
          logAuth("Sign in successful (state update via listener)")
        }
      } catch (err) {
        logAuthError("Unexpected error during sign in API call:", err)
        setLoading(false)
        errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during sign in")
      }
      return { error: errorResult }
    },
    [supabase],
  )

  /**
   * Signs up a new user. Requires email confirmation.
   */
  const signUp = useCallback(
    async (email: string, password: string): Promise<{ data: any | null; error: AuthError | Error | null }> => {
      // Add guard clause for supabase availability
      if (!supabase) {
        logAuthError("Sign up failed: Supabase client not available.");
        return { data: null, error: new Error("Authentication service not ready.") };
      }
      setLoading(true);
      let errorResult: AuthError | Error | null = null;
      try {
        const emailRedirectTo = typeof window !== "undefined"
            ? `${window.location.origin}/auth/callback`
            : undefined

        const { data, error } = await supabase.auth.signUp({
          email,
          password,
          options: { emailRedirectTo },
        })
        errorResult = error
        if (errorResult) {
          logAuthError("Error during sign up:", errorResult)
        } else {
          logAuth("Sign up successful (pending confirmation)", data)
        }
        setLoading(false)
        return { data, error: errorResult }
      } catch (err) {
        logAuthError("Unexpected error during sign up:", err)
        setLoading(false)
        errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during sign up")
        return { data: null, error: errorResult }
      }
    },
    [supabase],
  )

  /**
   * Signs out the currently authenticated user.
   * Navigates the user to the login page upon successful sign out.
   */
  const signOut = useCallback(async (): Promise<{ error: AuthError | Error | null }> => {
    // Add guard clause for supabase availability
    if (!supabase) {
      logAuthError("Sign out failed: Supabase client not available.");
      // Still attempt navigation? Or return error? Let's return error for consistency.
      return { error: new Error("Authentication service not ready.") };
    }
    setLoading(true);
    let errorResult: AuthError | Error | null = null;
    try {
      const { error: signOutError } = await supabase.auth.signOut()
      errorResult = signOutError
      if (errorResult) {
        logAuthError("Error during sign out:", errorResult)
      } else {
        logAuth("Sign out successful - redirecting")
        router.push("/login")
      }
    } catch (err) {
      logAuthError("Unexpected error during sign out:", err)
      errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during sign out")
    }
    return { error: errorResult }
  }, [supabase, router])

  /**
   * Sends a password reset email to the user.
   */
  const resetPassword = useCallback(
    async (email: string): Promise<{ error: AuthError | Error | null }> => {
      // Add guard clause for supabase availability
      if (!supabase) {
        logAuthError("Password reset failed: Supabase client not available.");
        return { error: new Error("Authentication service not ready.") };
      }
      let errorResult: AuthError | Error | null = null;
      try {
        const redirectTo = typeof window !== 'undefined' ? `${window.location.origin}/auth/update-password` : undefined
        const { error } = await supabase.auth.resetPasswordForEmail(email, { redirectTo })
        errorResult = error
        if (errorResult) {
          logAuthError("Error requesting password reset:", errorResult)
        } else {
          logAuth("Password reset email sent successfully for:", email)
        }
      } catch (err) {
        logAuthError("Unexpected error during password reset:", err)
        errorResult = err instanceof Error ? err : new Error("An unexpected error occurred during password reset")
      }
      return { error: errorResult }
    },
    [supabase],
  )

  const value = {
    user,
    session,
    loading,
    signIn,
    signUp,
    signOut,
    resetPassword,
  }

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>
}

/**
 * Custom hook for managing authentication state and operations.
 * 
 * This hook provides:
 * - User authentication state management
 * - Login and logout functionality
 * - User session management
 * - Error handling for auth operations
 * 
 * @returns {Object} Authentication functions and state
 * @returns {User | null} returns.user - The currently authenticated user
 * @returns {boolean} returns.loading - Whether auth operations are in progress
 * @returns {string | null} returns.error - Error message if auth operation fails
 * @returns {(email: string, password: string) => Promise<void>} returns.login - Function to log in a user
 * @returns {() => Promise<void>} returns.logout - Function to log out the current user
 * @returns {() => Promise<void>} returns.refreshSession - Function to refresh the user's session
 */
export function useAuth() {
  const context = useContext(AuthContext)
  if (context === undefined) {
    throw new Error("useAuth must be used within an AuthProvider")
  }
  return context
}


```

### File: hooks/use-decks.tsx

```
// hooks/useDecks.ts
'use client';

import { useState, useEffect, useCallback, useRef } from 'react';
import {
  getDecks as getDecksAction,
  getDeck as getDeckAction,
  createDeck as createDeckAction,
  updateDeck as updateDeckAction,
  deleteDeck as deleteDeckAction,
  type DeckListItemWithCounts
} from '@/lib/actions/deckActions';
import type { Database, Tables } from "@/types/database";
import type { ActionResult } from "@/lib/actions/types";
import { useAuth } from "@/hooks/use-auth";
import { toast } from "sonner";
import { appLogger, statusLogger } from '@/lib/logger';

import type { CreateDeckInput as CreateDeckParams, UpdateDeckInput as UpdateDeckParams } from '@/lib/schema/deckSchemas';
import type { DeckWithCardsAndTags } from '@/lib/actions/deckActions';

// Export these types so they can be used by other modules
export type { UpdateDeckParams, DeckWithCardsAndTags };

type DeckListItem = DeckListItemWithCounts;

interface UseDecksReturn {
    decks: DeckListItem[];
    loading: boolean;
    error: string | null;
    getDeck: (id: string) => Promise<ActionResult<DeckWithCardsAndTags | null>>;
    createDeck: (params: CreateDeckParams) => Promise<ActionResult<Tables<'decks'>>>;
    updateDeck: (id: string, params: UpdateDeckParams) => Promise<ActionResult<Tables<'decks'>>>;
    deleteDeck: (id: string) => Promise<ActionResult<null>>;
    refetchDecks: () => Promise<void>;
}

const logDecks = (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
        appLogger.info('[Decks Hook]:', ...args);
    }
};
const logDecksError = (...args: any[]) => {
    if (process.env.NODE_ENV !== 'production') {
        appLogger.error('[Decks Hook Error]:', ...args);
    }
};

export function useDecks(): UseDecksReturn {
  const [decks, setDecks] = useState<DeckListItem[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const { user, loading: authLoading } = useAuth();
  const isFetchingList = useRef(false);

  const fetchDeckList = useCallback(async () => {
    if (authLoading || !user) {
      setDecks([]);
      setLoading(false);
      setError(null);
      if (!authLoading) logDecks("No user, clearing deck list.");
      return;
    }
    if (isFetchingList.current) {
      logDecks("Fetch already in progress, skipping.");
      return;
    }
    logDecks("Fetching deck list via getDecksAction (which uses new RPC)...");
    setLoading(true);
    setError(null);
    isFetchingList.current = true;
    try {
      const result = await getDecksAction();
      if (result.error) {
        logDecksError("Error fetching deck list:", result.error);
        toast.error("Failed to load decks", { description: result.error });
        setDecks([]);
        setError(result.error);
      } else {
        logDecks(`Fetched ${result.data?.length ?? 0} decks.`);
        setDecks(result.data || []);
        setError(null);
      }
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : "An unexpected error occurred.";
      logDecksError("Unexpected error fetching deck list:", errorMessage);
      toast.error("Failed to load decks", { description: errorMessage });
      setDecks([]);
      setError(errorMessage);
    } finally {
      setLoading(false);
      isFetchingList.current = false;
    }
  }, [user, authLoading]);

  useEffect(() => {
    fetchDeckList();
  }, [fetchDeckList]);

  const createDeck = useCallback(async (params: CreateDeckParams): Promise<ActionResult<Tables<'decks'>>> => {
    if (!user) return { data: null, error: "User not authenticated" };
    const toastId = toast.loading("Creating deck...");
    const result = await createDeckAction(params);

    if (!result.error && result.data) {
      toast.success(`Deck "${result.data.name}" created.`, { id: toastId });
      const newDeckItem: DeckListItem = {
        id: result.data.id,
        name: result.data.name,
        primary_language: result.data.primary_language,
        secondary_language: result.data.secondary_language,
        is_bilingual: result.data.is_bilingual,
        // FIX: Ensure updated_at is handled correctly. If DB guarantees it, direct assignment is fine.
        // If action might return null for it, provide a fallback.
        // The DB schema for decks defines updated_at as string | null.
        // The RPC get_decks_with_complete_srs_counts defines updated_at as timestamptz (non-null).
        // Assuming the action for createDeck returns it non-null as per its SELECT.
        updated_at: result.data.updated_at || new Date().toISOString(), // Fallback if create action somehow returns null
        new_count: 0, learning_count: 0, young_count: 0, mature_count: 0,
        learn_eligible_count: 0, review_eligible_count: 0,
      };
      setDecks((prev) => [...prev, newDeckItem].sort((a, b) => a.name.localeCompare(b.name)));
    } else if (result.error) {
      logDecksError("Create action failed:", result.error);
      toast.error("Failed to create deck", { id: toastId, description: result.error });
    }
    return result;
  }, [user]);

  const getDeck = useCallback(async (id: string): Promise<ActionResult<DeckWithCardsAndTags | null>> => {
    if (!user) return { data: null, error: "User not authenticated" };
    if (!id) return { data: null, error: "Deck ID required" };
    const result = await getDeckAction(id);
    if (result.error) {
      toast.error("Failed to load deck details", { description: result.error });
    }
    return result;
  }, [user]);

  const updateDeck = useCallback(async (id: string, params: UpdateDeckParams): Promise<ActionResult<Tables<'decks'>>> => {
    if (!user) return { data: null, error: "User not authenticated" };
    if (!id) return { data: null, error: "Deck ID required" };
    logDecks("Calling updateDeck action for ID:", id, "with params:", params);
    const result = await updateDeckAction(id, params);
    if (!result.error && result.data) {
      logDecks("Update action successful for ID:", id);
      toast.success(`Deck "${result.data.name}" updated.`);
      await fetchDeckList();
    } else if (result.error) {
      logDecksError("Update action failed for ID:", id, "Error:", result.error);
      toast.error("Failed to update deck", { description: result.error });
    }
    return result;
  }, [user, fetchDeckList]);

  const deleteDeck = useCallback(async (id: string): Promise<ActionResult<null>> => {
    if (!user) return { data: null, error: "User not authenticated" };
    if (!id) return { data: null, error: "Deck ID required" };

    const originalDecks = decks;
    setDecks((prev) => prev.filter(d => d.id !== id));
    const toastId = toast.loading("Deleting deck...");
    logDecks("Calling deleteDeck action for ID:", id);
    const result = await deleteDeckAction(id);

    if (result.error) {
      toast.error("Failed to delete deck", { id: toastId, description: result.error });
      logDecksError("Delete action failed for ID:", id, "Error:", result.error);
      setDecks(originalDecks);
    } else {
      logDecks("Delete action successful for ID:", id);
      toast.success("Deck deleted.", { id: toastId });
    }
    return result;
  }, [user, decks]);

  const refetchDecks = useCallback(async () => {
    logDecks("Explicit refetch triggered.");
    await fetchDeckList();
  }, [fetchDeckList]);

  return {
    decks,
    loading,
    error,
    getDeck,
    createDeck,
    updateDeck,
    deleteDeck,
    refetchDecks,
  };
}
```

### File: hooks/use-mobile.tsx

```
"use client"

import * as React from "react"

const MOBILE_BREAKPOINT = 768

/**
 * Custom hook for detecting mobile device state.
 * 
 * This hook provides:
 * - Mobile device detection
 * - Responsive state management
 * - Window resize handling
 * 
 * @returns {boolean} Whether the current device is considered mobile
 */
export function useMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    if (typeof window === 'undefined') return

    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

```

### File: hooks/use-supabase.tsx

```
"use client";

import { createBrowserClient } from "@supabase/ssr";
import { useState, useEffect } from "react";
import type { SupabaseClient } from "@supabase/supabase-js";
import { appLogger, statusLogger } from '@/lib/logger';

// Assume Database type is defined elsewhere or use 'any'
// import type { Database } from '@/types/supabase';
type Database = any; // Replace with your actual Database type if generated

/**
 * Custom hook for accessing the Supabase client instance.
 * 
 * This hook provides:
 * - Access to the Supabase client for database operations
 * - Automatic cookie handling for authentication
 * - Consistent client instance across the application
 * 
 * @returns {SupabaseClient} The Supabase client instance
 * @throws {Error} If the Supabase client cannot be initialized
 */
export function useSupabase() {
  // Initialize state to null. Client will be created after mount.
  const [supabase, setSupabase] = useState<SupabaseClient<Database> | null>(null);

  useEffect(() => {
    // Create the client only on the client side after initial render.
    const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
    const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

    // Robust check for environment variables.
    if (!supabaseUrl || supabaseUrl.trim() === '' || !supabaseAnonKey || supabaseAnonKey.trim() === '') {
      // Log error or handle appropriately. Maybe set an error state?
      appLogger.error(
        "Supabase URL or Anon Key is missing or empty in useSupabase hook. Cannot create client."
      );
      // Optionally throw or set an error state here if needed.
      // For now, we just prevent client creation.
      return; // Don't attempt to create client if keys are missing
    }

    // Create and set the Supabase client instance.
    const client = createBrowserClient<Database>(supabaseUrl, supabaseAnonKey);
    setSupabase(client);

    // No cleanup needed for the client itself, Supabase handles connections.
    // If there were listeners setup here, we'd return a cleanup function.
  }, []); // Empty dependency array ensures this runs once on mount

  // Return the client state. Components using this hook must handle the initial null value.
  return { supabase };
}

// Optional: Define Database type based on Supabase schema
// You can generate this using: npx supabase gen types typescript --project-id <your-project-id> > types/supabase.ts
// Then import it here: import type { Database } from '@/types/supabase';
// If you don't have it, use generic SupabaseClient type or remove <Database> generic
// NOTE: The previous type definition was below the hook, moved it up for better organization.
// type Database = any; // Replace with your actual Database type if generated

// Removed the old Database type definition from here
```

### File: hooks/use-tts.ts

```
"use client";

import { useState, useCallback, useRef, useEffect } from 'react';
import { useSettings } from '@/providers/settings-provider';
import { appLogger, statusLogger } from '@/lib/logger';
// --- Import the new action ---
import { generateTtsAction } from '@/lib/actions/ttsActions';

// Language code mapping for fallbacks
const LANGUAGE_CODES: Record<string, string> = {
  // ISO codes with dialects
  // English dialects
  en: "en-GB",  // Default to UK English
  "en-GB": "en-GB",
  "en-US": "en-US",
  
  // Dutch dialects
  nl: "nl-NL",  // Default to Netherlands Dutch
  "nl-BE": "nl-BE",
  "nl-NL": "nl-NL",
  
  // French dialects
  fr: "fr-FR",  // Default to France French
  "fr-BE": "fr-BE",
  "fr-FR": "fr-FR",
  "fr-CH": "fr-CH",
  
  // German dialects
  de: "de-DE",  // Default to Germany German
  "de-DE": "de-DE",
  "de-AT": "de-AT",
  "de-CH": "de-CH",
  
  // Spanish dialect
  es: "es-ES",  // Default to Spain Spanish
  "es-ES": "es-ES",
  
  // Italian dialects
  it: "it-IT",  // Default to Italy Italian
  "it-IT": "it-IT",
  "it-CH": "it-CH",
  
  // Full names (for backward compatibility)
  english: "en-GB",
  dutch: "nl-NL",
  french: "fr-FR",
  german: "de-DE",
  spanish: "es-ES",
  italian: "it-IT",
};

// --- Interfaces (Keep as is) ---
interface UseTTSProps {
    onAudioStart?: () => void;
    onAudioEnd?: () => void;
}

type TTSState = 'idle' | 'loading' | 'playing' | 'error';

interface UseTTSResult {
    ttsState: TTSState;
    speak: (text: string, languageCode: string) => Promise<void>;
    stop: () => void;
    currentLanguage: string | null;
}

// --- Helper function to log errors (Keep as is) ---
function logTTSError(message: string, error?: any) {
    appLogger.error(`[TTS Hook Error]: ${message}`, error instanceof Error ? error.message : error || '');
    // Optionally send to an error tracking service
}

export function useTTS({ onAudioStart, onAudioEnd }: UseTTSProps): UseTTSResult {
    const [ttsState, setTtsState] = useState<TTSState>('idle');
    const { settings } = useSettings();
    const audioRef = useRef<HTMLAudioElement | null>(null);
    const [currentLanguage, setCurrentLanguage] = useState<string | null>(null);

    // --- Ensure Audio Element Exists (Keep as is) ---
    useEffect(() => {
        if (!audioRef.current) {
            audioRef.current = new Audio();
            audioRef.current.onplay = () => {
                setTtsState('playing');
                onAudioStart?.(); // Call callback if provided
            };
            audioRef.current.onended = () => {
                setTtsState('idle');
                onAudioEnd?.(); // Call callback if provided
            };
            audioRef.current.onerror = () => {
                // Access the error property from the audio element itself
                const error = audioRef.current?.error;
                logTTSError('Audio playback error', error?.message || 'Unknown audio error');
                setTtsState('error');
                onAudioEnd?.(); // Also call on end for errors
            };
        }
        // Cleanup function to pause and clear src on unmount
        return () => {
            if (audioRef.current) {
                 audioRef.current.pause();
                 audioRef.current.removeAttribute('src'); // Clear source
            }
        };
    }, [onAudioStart, onAudioEnd]); // Dependencies for callbacks

    // --- Stop Function (Keep as is) ---
    const stop = useCallback(() => {
        if (audioRef.current) {
            audioRef.current.pause();
            audioRef.current.currentTime = 0; // Reset playback position
             audioRef.current.removeAttribute('src'); // Clear source to prevent re-play if src changes
            setTtsState('idle');
            onAudioEnd?.(); // Ensure end callback is called on explicit stop
        }
    }, [onAudioEnd]);

    // --- Speak Function (Simplified version based on old client implementation) ---
    const speak = useCallback(async (text: string, language: string) => {
        if (!text || !language) {
            logTTSError('Missing text or language code for TTS.');
            return;
        }
        
        appLogger.info(`[TTS Debug] Original language: "${language}"`);
        appLogger.info(`[TTS Debug] Settings:`, settings);
        
        // Stop any currently playing audio before starting new request
        stop();

        try {
            setTtsState('loading');
            
            // Get basic language info - directly use the working client-side implementation logic
            const langToUse = language?.toLowerCase() || 'en';
            const baseLanguage = langToUse.split('-')[0];
            
            // DIRECTLY PORT THE WORKING VERSION
            // This is the exact language mapping logic from the working client implementation
            appLogger.info(`[TTS Debug] Base language: "${baseLanguage}"`);
            
            // Create a copy of the EXACT implementation from the working version
            const mappedLanguage = settings?.languageDialects?.[baseLanguage as keyof typeof settings.languageDialects] || 
                                  LANGUAGE_CODES[langToUse] || 
                                  "en-GB";
                                  
            appLogger.info(`[TTS Debug] Mapped language: "${mappedLanguage}"`);
            appLogger.info(`[TTS Debug] Final mapping: ${language} → ${mappedLanguage}`);
            
            setCurrentLanguage(mappedLanguage);

            // Call the server action with mapped language
            const { audioContent, error: ttsError } = await generateTtsAction(
                text,
                mappedLanguage // Use the mapped language
            );

            if (ttsError || !audioContent) {
                throw new Error(ttsError || 'TTS Action returned no audio content.');
            }

            // --- Play the audio --- 
            if (audioRef.current) {
                const audioSrc = `data:audio/mp3;base64,${audioContent}`;
                audioRef.current.src = audioSrc;
                await audioRef.current.play();
            } else {
                throw new Error("Audio element not available.");
            }

        } catch (error: any) {
            logTTSError('TTS Error (action call or playback)', error);
            if (audioRef.current) {
                audioRef.current.removeAttribute('src'); // Clear src on error
            }
            setTtsState('error');
            onAudioEnd?.(); // Ensure end callback fires on error
        }
    }, [settings, stop, onAudioEnd]);

    return { ttsState, speak, stop, currentLanguage };
} 
```

### File: hooks/useCardTags.ts

```
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getCardTags } from '@/lib/actions/tagActions';
import type { Tables } from '@/types/database';
import { appLogger, statusLogger } from '@/lib/logger';

interface UseCardTagsReturn {
  cardTags: Tables<'tags'>[];
  isLoading: boolean;
  error: string | null;
  refetchCardTags: () => Promise<void>;
}

/**
 * Custom hook for managing card-tag relationships.
 * 
 * This hook provides:
 * - Tag assignment and removal for cards
 * - Card-tag relationship state management
 * - Error handling for tag operations
 * - Loading state management
 * 
 * @param {string} cardId - ID of the card to manage tags for
 * @returns {Object} Card-tag management functions and state
 * @returns {Tag[]} returns.cardTags - Array of tags assigned to the card
 * @returns {boolean} returns.loading - Whether tag operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {() => Promise<void>} returns.refreshCardTags - Function to refresh the card's tags
 */
export function useCardTags(cardId: string): UseCardTagsReturn {
  const [cardTags, setCardTags] = useState<Tables<'tags'>[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Function to fetch card tags that can be used in both useEffect and refetch
  const fetchCardTags = useCallback(async () => {
    // Only fetch if cardId is valid
    if (!cardId) {
      appLogger.info(`[useCardTags] Skipping fetch for invalid cardId: ${cardId}`);
      setCardTags([]);
      setIsLoading(false);
      setError(null);
      return;
    }

    appLogger.info(`[useCardTags] Fetching tags for card: ${cardId}`);
    setIsLoading(true);
    setError(null);
    try {
      const result = await getCardTags(cardId);
      if (result.error) {
        setError(result.error);
        setCardTags([]); // Clear tags on error
      } else {
        setCardTags(result.data || []);
      }
    } catch (err) {
      appLogger.error(`Unexpected error fetching tags for card ${cardId}:`, err);
      setError('An unexpected error occurred while fetching card tags.');
      setCardTags([]);
    } finally {
      setIsLoading(false);
    }
  }, [cardId]);

  // Fetch on mount or when cardId changes
  useEffect(() => {
    appLogger.info(`[useCardTags] useEffect triggered for cardId: ${cardId}`);
    fetchCardTags();
  }, [fetchCardTags, cardId]);

  return { cardTags, isLoading, error, refetchCardTags: fetchCardTags };
} 
```

### File: hooks/useDecks.ts

```
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getDecks } from '@/lib/actions/deckActions'; // Assuming this action exists now
import type { Database, Tables } from "@/types/database"; // Ensure correct path
import { appLogger, statusLogger } from '@/lib/logger';

type DbDeck = Tables<'decks'>; // Get the full DbDeck type

interface UseDecksReturn {
  decks: Pick<DbDeck, 'id' | 'name'>[]; // Return only id and name as fetched by getDecks
  isLoading: boolean;
  error: string | null;
  refetchDecks: () => Promise<void>;
}

/**
 * Custom hook for managing deck operations and state.
 * 
 * This hook provides:
 * - Deck creation, reading, updating, and deletion
 * - Deck state management
 * - Error handling for deck operations
 * - Loading state management
 * 
 * @returns {Object} Deck management functions and state
 * @returns {Deck[]} returns.decks - Array of user's decks
 * @returns {boolean} returns.loading - Whether deck operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {(title: string, description?: string) => Promise<void>} returns.createDeck - Function to create a new deck
 * @returns {(deckId: string, updates: Partial<Deck>) => Promise<void>} returns.updateDeck - Function to update a deck
 * @returns {(deckId: string) => Promise<void>} returns.deleteDeck - Function to delete a deck
 * @returns {() => Promise<void>} returns.refreshDecks - Function to refresh the decks list
 */
export function useDecks(): UseDecksReturn {
  const [decks, setDecks] = useState<Pick<DbDeck, 'id' | 'name'>[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchDecks = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await getDecks();
      if (result.error) {
        setError(result.error);
        setDecks([]); // Clear decks on error
      } else {
        // Ensure data is an array, default to empty array if null/undefined
        setDecks(result.data || []); 
      }
    } catch (err) {
      appLogger.error("Unexpected error fetching decks:", err);
      setError('An unexpected error occurred while fetching decks.');
      setDecks([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch on mount
  useEffect(() => {
    fetchDecks();
  }, [fetchDecks]);

  return { decks, isLoading, error, refetchDecks: fetchDecks };
} 
```

### File: hooks/useStudySession.ts

```
// hooks/useStudySession.ts
'use client';

import { useState, useEffect, useCallback, useMemo, useRef } from 'react';
import { resolveStudyQuery } from '@/lib/actions/studyQueryActions';
import { getCardsByIds } from '@/lib/actions/cardActions';
import { updateCardProgress } from '@/lib/actions/progressActions';
import { useSettings, type Settings, DEFAULT_SETTINGS } from '@/providers/settings-provider';
import type { Tables } from '@/types/database';

import {
    SessionCard,
    InternalCardState,
    SessionType,
    SessionResults,
    StudyCardDb,
    StudySessionInput,
    CardStateUpdateOutcome
} from '@/types/study';
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import {
    handleInitialLearningAnswer,
    handleRelearningAnswer,
    handleReviewAnswer
} from '@/lib/study/card-state-handlers';
import {
    initializeQueue,
    findNextCardIndex,
    updateQueueAfterAnswer,
    getNextDueCheckDelay
} from '@/lib/study/session-queue-manager';
import {
    type ReviewGrade
} from '@/lib/srs';
import { debounce } from "@/lib/utils";
import { toast } from 'sonner';
import { parseISO, isValid as isValidDate, isToday, isPast } from 'date-fns';
import { appLogger } from '@/lib/logger';

const PROGRESS_UPDATE_DEBOUNCE_MS = 1500;
const FLIP_DURATION_MS = 300;
const PROCESSING_DELAY_MS = FLIP_DURATION_MS + 50;

export interface UseStudySessionReturn {
    currentCard: StudyCardDb | null;
    isInitializing: boolean;
    error: string | null;
    sessionType: SessionType | null;
    isComplete: boolean;
    totalCardsInSession: number;
    currentCardNumberInSession: number;
    initialQueryCount: number;
    isProcessingAnswer: boolean;
    isFlipped: boolean;
    onFlip: () => void;
    sessionResults: SessionResults;
    answerCard: (grade: ReviewGrade) => Promise<void>;
    currentCardStatusDisplay: string | null;
    showContinueReviewPrompt: boolean;
    onContinueReview: () => void;
    isLoadingSettings: boolean;
    unifiedSessionPhase: 'learning' | 'review' | 'complete';
}

interface UseStudySessionProps {
    initialInput: StudySessionInput | null;
    sessionType: SessionType | null;
}

export function useStudySession({
    initialInput,
    sessionType
}: UseStudySessionProps): UseStudySessionReturn {
    const { settings, loading: isLoadingSettings } = useSettings();

    const [sessionQueue, setSessionQueue] = useState<SessionCard[]>([]);
    const [currentCardIndex, setCurrentCardIndex] = useState<number>(0);
    const [isFlipped, setIsFlipped] = useState<boolean>(false);
    const [isComplete, setIsComplete] = useState<boolean>(false);
    const [isLoadingData, setIsLoadingData] = useState<boolean>(true);
    const [isProcessingAnswer, setIsProcessingAnswer] = useState<boolean>(false);
    const [sessionResults, setSessionResults] = useState<SessionResults>({
        totalAnswered: 0, correctCount: 0, hardCount: 0, incorrectCount: 0,
        graduatedFromLearnCount: 0, graduatedFromRelearnCount: 0, lapsedToRelearnCount: 0,
    });
    const [error, setError] = useState<string | null>(null);
    const [initialQueryCount, setInitialQueryCount] = useState<number>(0);
    const [initialEligibleCardCount, setInitialEligibleCardCount] = useState<number>(0);
    const [showContinueReviewPrompt, setShowContinueReviewPrompt] = useState<boolean>(false);
    const [unifiedSessionPhase, setUnifiedSessionPhase] = useState<'learning' | 'review' | 'complete'>('complete');

    const dueCheckTimerRef = useRef<NodeJS.Timeout | null>(null);
    const settingsRef = useRef<Settings | null>(null);

    // Refs to track previous prop values for debugging the initialization effect
    const prevInitialInputRef = useRef<StudySessionInput | null | undefined>(undefined);
    const prevSessionTypeRef = useRef<SessionType | null | undefined>(undefined);
    const prevSettingsRefHook = useRef<Settings | null | undefined>(undefined);
    const prevIsLoadingSettingsRef = useRef<boolean | undefined>(undefined);
    const initEffectRunCountRef = useRef(0);

    useEffect(() => {
        settingsRef.current = settings;
    }, [settings]);

    const debouncedUpdateProgress = useCallback( /* ... same as previous correct version ... */
      debounce(async (cardId: string, dbPayload: Partial<Tables<'cards'>>, grade: ReviewGrade) => {
        if (!cardId || Object.keys(dbPayload).length === 0) {
            appLogger.warn("[useStudySession] Debounced update: No cardId or empty payload.");
            return;
        }
        appLogger.info(`[useStudySession] DebouncedUpdateProgress: Saving card ${cardId} with grade ${grade}`);

        const currentSettings = settingsRef.current ?? DEFAULT_SETTINGS;
        let finalLearningState: 'learning' | 'relearning' | null = null;
        if (dbPayload.learning_state === 'learning') finalLearningState = 'learning';
        else if (dbPayload.learning_state === 'relearning') finalLearningState = 'relearning';

        const validatedFieldsPayload = {
            srs_level: dbPayload.srs_level ?? 0,
            easiness_factor: dbPayload.easiness_factor ?? currentSettings.defaultEasinessFactor,
            interval_days: dbPayload.interval_days ?? 0,
            next_review_due: dbPayload.next_review_due ?? new Date().toISOString(),
            learning_state: finalLearningState,
            learning_step_index: dbPayload.learning_step_index === undefined ? null : dbPayload.learning_step_index,
            failed_attempts_in_learn: dbPayload.failed_attempts_in_learn ?? 0,
            hard_attempts_in_learn: dbPayload.hard_attempts_in_learn ?? 0,
            attempt_count: (dbPayload.attempt_count === null || dbPayload.attempt_count === undefined) ? undefined : dbPayload.attempt_count,
            correct_count: (dbPayload.correct_count === null || dbPayload.correct_count === undefined) ? undefined : dbPayload.correct_count,
            incorrect_count: (dbPayload.incorrect_count === null || dbPayload.incorrect_count === undefined) ? undefined : dbPayload.incorrect_count,
        };

        try {
          const result = await updateCardProgress({ cardId, grade, updatedFields: validatedFieldsPayload });
          if (result.error) {
            appLogger.error(`[useStudySession] Error saving card ${cardId} progress:`, result.error);
            toast.error(`Failed to save progress for a card.`);
          } else {
            appLogger.info(`[useStudySession] Successfully saved progress for card ${cardId}.`);
          }
        } catch (e) {
          appLogger.error(`[useStudySession] Exception saving progress for card ${cardId}:`, e);
          toast.error(`Exception saving progress for a card.`);
        }
      }, PROGRESS_UPDATE_DEBOUNCE_MS),
      []
    );

    useEffect(() => {
        initEffectRunCountRef.current += 1;
        const runCount = initEffectRunCountRef.current;
        const logPrefix = `[useStudySession #${runCount}] INIT EFFECT:`;

        // Log current and previous prop values for comparison
        if (runCount > 1) { // Only log changes after the first run
            if (initialInput !== prevInitialInputRef.current) {
                appLogger.warn(`${logPrefix} initialInput CHANGED!`, { prev: prevInitialInputRef.current, new: initialInput });
            }
            if (sessionType !== prevSessionTypeRef.current) {
                appLogger.warn(`${logPrefix} sessionType CHANGED!`, { prev: prevSessionTypeRef.current, new: sessionType });
            }
            if (settings !== prevSettingsRefHook.current) {
                // This checks for reference change.
                // For deep content change, you might need to JSON.stringify and compare, but reference is often the culprit.
                appLogger.warn(`${logPrefix} settings REFERENCE CHANGED! Is context value memoized?`);
            }
            if (isLoadingSettings !== prevIsLoadingSettingsRef.current) {
                appLogger.warn(`${logPrefix} isLoadingSettings CHANGED!`, { prev: prevIsLoadingSettingsRef.current, new: isLoadingSettings });
            }
        } else {
            appLogger.info(`${logPrefix} First run. Props:`, { initialInput, sessionType, settingsExists: !!settings, isLoadingSettings });
        }


        let isMounted = true;
        async function initializeNewSession() {
            if (!initialInput || !sessionType || !settings || isLoadingSettings) {
                appLogger.info(`${logPrefix} Deferred: Dependencies not ready.`, { hasInitialInput: !!initialInput, hasSessionType: !!sessionType, hasSettings: !!settings, isLoadingSettings });
                if (isMounted) setIsLoadingData(true);
                return;
            }

            appLogger.info(`${logPrefix} Initializing new session logic. Type: ${sessionType}`, { currentInitialInput: initialInput });
            if(isMounted) {
                setIsLoadingData(true); setError(null); setIsComplete(false); setSessionQueue([]);
                setCurrentCardIndex(0); setInitialEligibleCardCount(0);
                setSessionResults({ totalAnswered: 0, correctCount: 0, hardCount: 0, incorrectCount: 0, graduatedFromLearnCount: 0, graduatedFromRelearnCount: 0, lapsedToRelearnCount: 0 });
                setIsFlipped(false); setInitialQueryCount(0); setShowContinueReviewPrompt(false);
                setUnifiedSessionPhase(sessionType === 'unified' ? 'learning' : 'complete');
            }
            if (dueCheckTimerRef.current) clearTimeout(dueCheckTimerRef.current);

            try {
                let queryPayloadForAction: Parameters<typeof resolveStudyQuery>[0];
                if (initialInput.studySetId) {
                    queryPayloadForAction = { studySetId: initialInput.studySetId };
                    appLogger.info(`${logPrefix} Using studySetId: ${initialInput.studySetId}`);
                } else if (initialInput.deckId) {
                    // CORRECTED: Use deckIds (array) for the criteria
                    const criteriaForDeck: StudyQueryCriteria = {
                        deckIds: [initialInput.deckId], // Pass deckId as an array to deckIds
                        tagLogic: 'ANY',
                    };
                    queryPayloadForAction = { criteria: criteriaForDeck };
                    appLogger.info(`${logPrefix} Constructed criteria for single deckId:`, criteriaForDeck);
                } else if (initialInput.criteria) {
                    // Ensure the criteria from store/input already matches StudyQueryCriteria structure
                    // (which should now also use deckIds if applicable)
                    const criteriaFromInput = initialInput.criteria;
                    queryPayloadForAction = {
                         criteria: {
                            ...criteriaFromInput,
                            tagLogic: criteriaFromInput.tagLogic || (criteriaFromInput.includeTags && criteriaFromInput.includeTags.length > 0 ? 'ANY' : 'ANY'),
                        }
                    };
                    appLogger.info(`${logPrefix} Using criteria directly from initialInput:`, queryPayloadForAction.criteria);
                } else {
                    appLogger.error(`${logPrefix} Critical error: initialInput is invalid.`, initialInput);
                    throw new Error("Invalid initialInput structure for study session.");
                }

                appLogger.info(`${logPrefix} FINAL Calling resolveStudyQuery with:`, queryPayloadForAction);
                const queryResult = await resolveStudyQuery(queryPayloadForAction);

                if (!isMounted) return;
                if (queryResult.error || !queryResult.data) throw new Error(queryResult.error || 'Failed to resolve study query.');
                const cardIds = queryResult.data;
                if(isMounted) setInitialQueryCount(cardIds.length);
                appLogger.info(`${logPrefix} Resolved ${cardIds.length} card IDs.`);

                if (cardIds.length === 0) {
                    if (isMounted) { setIsComplete(true); setIsLoadingData(false); } return;
                }
                const cardsResult = await getCardsByIds(cardIds);
                if (!isMounted) return;
                if (cardsResult.error || !cardsResult.data) throw new Error(cardsResult.error || 'Failed to fetch card data.');
                const fetchedDbCards = cardsResult.data as StudyCardDb[];
                appLogger.info(`${logPrefix} Fetched ${fetchedDbCards.length} card data objects.`);
                const newQueue = initializeQueue(fetchedDbCards, sessionType, settings);
                if (!isMounted) return;
                appLogger.info(`${logPrefix} Queue initialized. Length: ${newQueue.length}`);
                if (newQueue.length === 0) {
                    if (isMounted) setIsComplete(true);
                } else {
                    if (isMounted) {
                        if (newQueue.length === 0) {
                            setIsComplete(true);
                            appLogger.info(`${logPrefix} No eligible cards for this session type. Session complete.`);
                        } else {
                            setSessionQueue(newQueue);
                            setInitialEligibleCardCount(newQueue.length);
                            appLogger.info(`${logPrefix} Queue initialized with ${newQueue.length} cards.`);
                    
                            // CORRECTLY SET unifiedSessionPhase based on initial queue content for 'unified' sessions
                            if (sessionType === 'unified') {
                                const hasLearningCardsInInitialQueue = newQueue.some(
                                    item => item.card.srs_level === 0 && (item.card.learning_state === null || item.card.learning_state === 'learning')
                                );
                                if (hasLearningCardsInInitialQueue) {
                                    setUnifiedSessionPhase('learning');
                                    appLogger.info(`${logPrefix} Unified session starting in 'learning' phase.`);
                                } else {
                                    setUnifiedSessionPhase('review'); // Skip learning phase if no learnable cards
                                    appLogger.info(`${logPrefix} Unified session skipping to 'review' phase (no initial learning cards).`);
                                }
                            } else {
                                setUnifiedSessionPhase('complete'); // Not a unified session or no cards
                            }
                        }
                    }
                }
            } catch (err) {
                if (isMounted) {
                    appLogger.error(`${logPrefix} Error during session initialization:`, err);
                    setError(err instanceof Error ? err.message : 'Unknown initialization error.');
                    setIsComplete(true);
                }
            } finally {
                if (isMounted) setIsLoadingData(false);
            }
        }

        initializeNewSession();

        // Update refs at the end of this effect's execution context
        // so the *next* run can compare against these values.
        prevInitialInputRef.current = initialInput;
        prevSessionTypeRef.current = sessionType;
        prevSettingsRefHook.current = settings;
        prevIsLoadingSettingsRef.current = isLoadingSettings;

        return () => {
            isMounted = false;
            if (dueCheckTimerRef.current) clearTimeout(dueCheckTimerRef.current);
            appLogger.info(`${logPrefix} CLEANUP.`);
        };
    }, [initialInput, sessionType, settings, isLoadingSettings]); // Dependencies of the main initialization effect

    // ... (useEffect for currentCardIndex and timer - no changes from previous) ...
    useEffect(() => {
        if (isLoadingData || isComplete) {
            if (isComplete && dueCheckTimerRef.current) { clearTimeout(dueCheckTimerRef.current); dueCheckTimerRef.current = null; }
            return;
        }
        if (sessionQueue.length > 0) {
            const nextIndex = findNextCardIndex(sessionQueue);
            // Only call setCurrentCardIndex if the index actually needs to change
            if (currentCardIndex !== nextIndex || (currentCardIndex === sessionQueue.length && nextIndex < sessionQueue.length) ) {
                 setCurrentCardIndex(nextIndex);
            }

            if (dueCheckTimerRef.current) clearTimeout(dueCheckTimerRef.current);
            const delay = getNextDueCheckDelay(sessionQueue);
            if (delay !== null) {
                dueCheckTimerRef.current = setTimeout(() => {
                    // appLogger.info("[useStudySession] Due check timer fired.");
                    const newNextIdx = findNextCardIndex(sessionQueue); // Recheck based on current queue
                    if(currentCardIndex !== newNextIdx) setCurrentCardIndex(newNextIdx); // Only update if it actually changed
                }, delay);
            }
        } else if (!isLoadingData && !isComplete && !showContinueReviewPrompt) {
            setIsComplete(true);
        }
        return () => { if (dueCheckTimerRef.current) clearTimeout(dueCheckTimerRef.current); };
    }, [sessionQueue, isLoadingData, isComplete, currentCardIndex, showContinueReviewPrompt]);


    // ... (Memos for currentQueueItem, currentCard, totalCardsInSession, currentCardNumberInSession - no changes) ...
    const currentQueueItem = useMemo(() => { /* ... */
        if (isLoadingData || isComplete || sessionQueue.length === 0 || currentCardIndex >= sessionQueue.length) {
            return null;
        }
        return sessionQueue[currentCardIndex];
    }, [isLoadingData, isComplete, sessionQueue, currentCardIndex]);

    const currentCard = currentQueueItem ? currentQueueItem.card : null;
    const totalCardsInSession = useMemo(() => initialEligibleCardCount, [initialEligibleCardCount]);
    const currentCardNumberInSession = useMemo(() => { /* ... */
        if (totalCardsInSession === 0) return 0;
        return Math.min(sessionResults.totalAnswered + 1, totalCardsInSession);
    }, [sessionResults.totalAnswered, totalCardsInSession]);

    // ... (onFlip callback - no changes) ...
    const onFlip = useCallback(() => { /* ... */
        if (!currentQueueItem || isProcessingAnswer || isComplete) return;
        setIsFlipped(prev => !prev);
    }, [currentQueueItem, isProcessingAnswer, isComplete]);

    // ... (answerCard callback - no changes) ...
    const answerCard = useCallback(async (grade: ReviewGrade) => { /* ... */
        if (!currentQueueItem || isProcessingAnswer || isComplete || !settingsRef.current) {
            appLogger.warn("[useStudySession] answerCard: Guarded return");
            return;
        }
        const currentSettings = settingsRef.current;
        setIsProcessingAnswer(true);
        if (!isFlipped) setIsFlipped(true);

        setTimeout(async () => {
            const { card: answeredDbCard, internalState: answeredInternalState } = currentQueueItem;
            let outcome: CardStateUpdateOutcome;

            if (answeredDbCard.srs_level === 0 && (answeredDbCard.learning_state === 'learning' || answeredDbCard.learning_state === null)) {
                outcome = handleInitialLearningAnswer(answeredDbCard, answeredInternalState, grade, currentSettings);
            } else if (answeredDbCard.srs_level === 0 && answeredDbCard.learning_state === 'relearning') {
                outcome = handleRelearningAnswer(answeredDbCard, answeredInternalState, grade, currentSettings);
            } else if (answeredDbCard.srs_level !== null && answeredDbCard.srs_level >= 1 && answeredDbCard.learning_state === null) {
                outcome = handleReviewAnswer(answeredDbCard, answeredInternalState, grade, currentSettings);
            } else {
                appLogger.error("[useStudySession] answerCard: Unhandled card state:", answeredDbCard);
                setIsProcessingAnswer(false); return;
            }

            setSessionResults(prev => {
                const newResults = { ...prev, totalAnswered: prev.totalAnswered + 1 };
                if (grade === 1) newResults.incorrectCount++;
                else if (grade === 2) newResults.hardCount++;
                else if (grade >= 3) newResults.correctCount++;
                if (outcome.sessionResultCategory === 'graduatedLearn') newResults.graduatedFromLearnCount++;
                if (outcome.sessionResultCategory === 'graduatedRelearn') newResults.graduatedFromRelearnCount++;
                if (outcome.sessionResultCategory === 'lapsed') newResults.lapsedToRelearnCount++;
                return newResults;
            });

            debouncedUpdateProgress(answeredDbCard.id, outcome.dbUpdatePayload, grade);
            const nextQueue = updateQueueAfterAnswer(sessionQueue, answeredDbCard.id, outcome, currentSettings);

            if (sessionType === 'unified' && unifiedSessionPhase === 'learning') {
                const remainingLearning = nextQueue.some(item => item.card.srs_level === 0 && (item.card.learning_state === 'learning' || item.card.learning_state === null));
                if (!remainingLearning) {
                    appLogger.info("[useStudySession] Learning phase of unified session complete.");
                    const hasReviewCards = nextQueue.some(item => (item.card.srs_level !== null && item.card.srs_level >= 1) || item.card.learning_state === 'relearning');
                    if (hasReviewCards) {
                        appLogger.info("[useStudySession] Review cards exist, showing prompt.");
                        setShowContinueReviewPrompt(true);
                        setSessionQueue(nextQueue);
                        setIsFlipped(false); setIsProcessingAnswer(false); return;
                    } else {
                        appLogger.info("[useStudySession] No review cards, unified session complete.");
                        setUnifiedSessionPhase('complete');
                    }
                }
            }

            setTimeout(() => {
                setSessionQueue(nextQueue);
                if (nextQueue.length === 0 && !showContinueReviewPrompt) {
                    setIsComplete(true); setCurrentCardIndex(0);
                } else if (!showContinueReviewPrompt) {
                    setIsFlipped(false);
                }
                setIsProcessingAnswer(false);
            }, PROCESSING_DELAY_MS);
        }, FLIP_DURATION_MS);
    }, [currentQueueItem, isProcessingAnswer, isComplete, settingsRef, sessionQueue, debouncedUpdateProgress, sessionType, unifiedSessionPhase, isFlipped]);

    // ... (onContinueReview callback - no changes) ...
    const onContinueReview = useCallback(() => { /* ... */
        appLogger.info("[useStudySession] User continuing to review phase.");
        setShowContinueReviewPrompt(false);
        setUnifiedSessionPhase('review');
        const nextIndex = findNextCardIndex(sessionQueue);
        setCurrentCardIndex(nextIndex);
        setIsFlipped(false);
    }, [sessionQueue]); // Added sessionQueue dependency

    // ... (currentCardStatusDisplay memo - ensure settingsRef.current is used) ...
    const currentCardStatusDisplay = useMemo(() => { /* ... */
        if (isLoadingData || isLoadingSettings) return 'Loading...';
        if (error) return `Error: ${error}`;
        if (showContinueReviewPrompt) return "Learning phase complete. Continue to review?";
        if (isComplete) return totalCardsInSession > 0 ? 'Session Complete!' : 'No cards to study.';
        const currentSettings = settingsRef.current; // Use the ref
        if (!currentSettings) return "Loading settings...";
        if (!currentQueueItem) {
            const delay = getNextDueCheckDelay(sessionQueue);
            if (delay !== null) {
                const diffSeconds = Math.ceil(delay / 1000);
                if (diffSeconds <= 1) return `Next card in ~1s`;
                if (diffSeconds < 60) return `Next card in ${diffSeconds}s`;
                const diffMinutes = Math.ceil(delay / (1000 * 60));
                return `Next card in ~${diffMinutes}m`;
            }
            return sessionQueue.length > 0 ? "Preparing next card..." : "No cards currently due.";
        }
        const { card, internalState } = currentQueueItem;
        if (card.srs_level === 0 && (card.learning_state === 'learning' || card.learning_state === null )) {
            if (currentSettings.studyAlgorithm === 'dedicated-learn' || currentSettings.enableDedicatedLearnMode) {
                return `Streak: ${internalState.streak}/${currentSettings.masteryThreshold}`;
            } else {
                const stepIdx = internalState.learningStepIndex ?? 0;
                const totalSteps = currentSettings.initialLearningStepsMinutes?.length || 0;
                return `Learn Step: ${stepIdx + 1}${totalSteps > 0 ? `/${totalSteps}` : ''}`;
            }
        } else if (card.srs_level === 0 && card.learning_state === 'relearning') {
            const stepIdx = internalState.learningStepIndex ?? 0;
            const totalSteps = currentSettings.relearningStepsMinutes?.length || 0;
            return `Relearning: Step ${stepIdx + 1}${totalSteps > 0 ? `/${totalSteps}` : ''}`;
        } else if (card.srs_level !== null && card.srs_level >= 1) {
            let levelText = `Lvl ${card.srs_level}`;
            if (card.srs_level === 1) levelText = "Status: New to Review";
            else if (card.srs_level >= 2 && card.srs_level <= 4) levelText = "Status: Getting Familiar";
            else if (card.srs_level > 4) levelText = "Status: Well Known";
        
            let dueText = `Interval: ${Math.round(card.interval_days || 0)}d`; // Default due text
            if (card.next_review_due) {
                const dueDate = parseISO(card.next_review_due);
                if (isValidDate(dueDate)) {
                    if (isToday(dueDate)) dueText = "Due Today!";
                    else if (isPast(dueDate)) dueText = "Review Now!";
                }
            }
            return `${levelText} • ${dueText}`;
        }
        return 'Studying...';
    }, [
        isLoadingData, isLoadingSettings, error, isComplete, currentQueueItem, sessionQueue,
        showContinueReviewPrompt, totalCardsInSession // settingsRef is stable, currentSettings is derived inside
    ]);


    return {
        currentCard, isInitializing: isLoadingData || isLoadingSettings, error, sessionType,
        isComplete, totalCardsInSession, currentCardNumberInSession, initialQueryCount,
        isProcessingAnswer, isFlipped, onFlip, sessionResults, answerCard,
        currentCardStatusDisplay, showContinueReviewPrompt, onContinueReview, isLoadingSettings, unifiedSessionPhase,
    };
}
```

### File: hooks/useStudySetForm.ts

```
// hooks/useStudySetForm.ts
"use client";

import { useCallback, useMemo } from 'react';
import { useForm, UseFormReturn } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import * as z from 'zod';
import { StudyQueryCriteriaSchema, StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import { useTags } from '@/hooks/useTags';
import { useDecks } from '@/hooks/useDecks';
import type { Tables } from "@/types/database";
import { toast } from 'sonner';
import { format, isValid, parseISO } from "date-fns";
import { DateRange } from "react-day-picker";

type DbTag = Tables<'tags'>;
type DeckListItem = Pick<Tables<'decks'>, 'id' | 'name'>;

const DateDaysOperators = ['newerThanDays', 'olderThanDays'] as const;
const DateSpecificOperators = ['onDate', 'betweenDates'] as const;
const NullableDateOperators = ['never'] as const;
const DueDateOperators = ['isDue'] as const;
const SrsStageEnum = z.enum(['new', 'learning', 'relearning', 'young', 'mature']);
export type SrsStage = z.infer<typeof SrsStageEnum>;

type CreatedUpdatedDateOp = typeof DateDaysOperators[number] | typeof DateSpecificOperators[number];
type LastReviewedDateOp = CreatedUpdatedDateOp | typeof NullableDateOperators[number];
type NextReviewDateOp = CreatedUpdatedDateOp | typeof NullableDateOperators[number] | typeof DueDateOperators[number];

// Zod Schema for the FORM data (Updated: removed includeLearning)
const studySetFormSchema = z.object({
  name: z.string().trim().min(1, 'Study set name is required').max(100, 'Name too long'),
  description: z.string().trim().max(500, 'Description too long').optional().nullable(),
  selectedDeckIds: z.array(z.string().uuid()).optional().default([]),
  includeTags: z.array(z.string().uuid()).optional().default([]),
  tagLogic: z.enum(['ANY', 'ALL']).optional().default('ANY'),
  excludeTags: z.array(z.string().uuid()).optional().default([]),
  containsLanguage: z.string().length(2).or(z.literal('')).optional().nullable(),
  createdDateOperator: z.string().nullable().optional(),
  createdDateValueDays: z.string().regex(/^\d*$/, "Must be a number").nullable().optional(),
  createdDateValueDate: z.date().nullable().optional(),
  createdDateValueRange: z.custom<DateRange>((val): val is DateRange => typeof val === 'object' && val !== null && (val.from !== undefined || val.to !== undefined), "Invalid date range").nullable().optional(),
  updatedDateOperator: z.string().nullable().optional(),
  updatedDateValueDays: z.string().regex(/^\d*$/, "Must be a number").nullable().optional(),
  updatedDateValueDate: z.date().nullable().optional(),
  updatedDateValueRange: z.custom<DateRange>((val): val is DateRange => typeof val === 'object' && val !== null && (val.from !== undefined || val.to !== undefined), "Invalid date range").nullable().optional(),
  lastReviewedOperator: z.string().nullable().optional(),
  lastReviewedValueDays: z.string().regex(/^\d*$/, "Must be a number").nullable().optional(),
  lastReviewedValueDate: z.date().nullable().optional(),
  lastReviewedValueRange: z.custom<DateRange>((val): val is DateRange => typeof val === 'object' && val !== null && (val.from !== undefined || val.to !== undefined), "Invalid date range").nullable().optional(),
  nextReviewDueOperator: z.string().nullable().optional(),
  nextReviewDueValueDays: z.string().regex(/^\d*$/, "Must be a number").nullable().optional(),
  nextReviewDueValueDate: z.date().nullable().optional(),
  nextReviewDueValueRange: z.custom<DateRange>((val): val is DateRange => typeof val === 'object' && val !== null && (val.from !== undefined || val.to !== undefined), "Invalid date range").nullable().optional(),
  selectedSrsStages: z.array(SrsStageEnum).optional().default([]),
  // includeLearning removed from here
}).strict();

export type StudySetBuilderFormData = z.infer<typeof studySetFormSchema>;

type GenericDateFilterObject = { operator: string; value?: string | [string, string] };

const parseDateCriteriaForForm = ( /* ... same as previous correct version ... */
    criteriaValue?: StudyQueryCriteria[keyof Pick<StudyQueryCriteria, 'createdDate' | 'updatedDate' | 'lastReviewed' | 'nextReviewDue'>]
): { operator: string | null; days: string | null; date: Date | null; range: DateRange | null } => {
    const defaultValue = { operator: null, days: null, date: null, range: null };
    if (!criteriaValue?.operator) return defaultValue;
    const op = criteriaValue.operator;
    const value = 'value' in criteriaValue ? criteriaValue.value : undefined;
    try {
        if ((op === 'newerThanDays' || op === 'olderThanDays') && typeof value === 'string' && /^\d+$/.test(value)) {
            return { ...defaultValue, operator: op, days: value };
        } else if (op === 'onDate' && typeof value === 'string') {
            const parsedDate = parseISO(value);
            return { ...defaultValue, operator: op, date: isValid(parsedDate) ? parsedDate : null };
        } else if (op === 'betweenDates' && Array.isArray(value) && value.length === 2) {
            const fromDate = value[0] && typeof value[0] === 'string' ? parseISO(value[0]) : undefined;
            const toDate = value[1] && typeof value[1] === 'string' ? parseISO(value[1]) : undefined;
            if ((fromDate && isValid(fromDate)) || (toDate && isValid(toDate))) {
                return { ...defaultValue, operator: op, range: { from: fromDate, to: toDate } };
            }
        } else if (op === 'never' || op === 'isDue') {
            return { ...defaultValue, operator: op };
        }
    } catch (e) { console.error("Error parsing date criteria for form:", e); }
    return defaultValue;
};


interface UseStudySetFormProps {
    initialData?: { id?: string; name: string; description?: string | null; criteria: StudyQueryCriteria };
    onSave: (data: { name: string; description: string | null; criteria: StudyQueryCriteria }) => Promise<void>;
    isSaving?: boolean;
}

export interface UseStudySetFormReturn {
    form: UseFormReturn<StudySetBuilderFormData>;
    isLoading: boolean;
    tagsError: string | null;
    decksError: string | null;
    allTags: DbTag[];
    decks: DeckListItem[];
    onSubmit: (e?: React.BaseSyntheticEvent) => Promise<void>;
    watchedOperators: {
        createdDateOperator: string | null | undefined;
        updatedDateOperator: string | null | undefined;
        lastReviewedOperator: string | null | undefined;
        nextReviewDueOperator: string | null | undefined;
    };
    watchedFilterValues: {
        // includeLearning removed
        includeTags: string[] | undefined;
        excludeTags: string[] | undefined;
        selectedDeckIds: string[] | undefined;
        selectedSrsStages: SrsStage[] | undefined;
    };
    allowedOperators: {
        createdUpdatedOps: readonly CreatedUpdatedDateOp[];
        lastReviewedOps: readonly LastReviewedDateOp[];
        nextReviewDueOps: readonly NextReviewDateOp[];
    };
    srsStageOptions: readonly SrsStage[];
}

export function useStudySetForm({ initialData, onSave, isSaving = false }: UseStudySetFormProps): UseStudySetFormReturn {
  const { allTags, isLoading: isLoadingTags, error: tagsError } = useTags();
  const { decks, isLoading: isLoadingDecks, error: decksError } = useDecks();

  const initialCreated = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.createdDate), [initialData]);
  const initialUpdated = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.updatedDate), [initialData]);
  const initialLastReviewed = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.lastReviewed), [initialData]);
  const initialNextReviewDue = useMemo(() => parseDateCriteriaForForm(initialData?.criteria?.nextReviewDue), [initialData]);
  // initialIncludeLearning removed

  const form = useForm<StudySetBuilderFormData>({
    resolver: zodResolver(studySetFormSchema),
    defaultValues: {
      name: initialData?.name || '',
      description: initialData?.description ?? null,
      selectedDeckIds: initialData?.criteria?.deckIds || [],
      includeTags: initialData?.criteria?.includeTags || [],
      tagLogic: initialData?.criteria?.tagLogic || 'ANY',
      excludeTags: initialData?.criteria?.excludeTags || [],
      containsLanguage: initialData?.criteria?.containsLanguage || null,
      createdDateOperator: initialCreated.operator,
      createdDateValueDays: initialCreated.days,
      createdDateValueDate: initialCreated.date,
      createdDateValueRange: initialCreated.range,
      updatedDateOperator: initialUpdated.operator,
      updatedDateValueDays: initialUpdated.days,
      updatedDateValueDate: initialUpdated.date,
      updatedDateValueRange: initialUpdated.range,
      lastReviewedOperator: initialLastReviewed.operator,
      lastReviewedValueDays: initialLastReviewed.days,
      lastReviewedValueDate: initialLastReviewed.date,
      lastReviewedValueRange: initialLastReviewed.range,
      nextReviewDueOperator: initialNextReviewDue.operator,
      nextReviewDueValueDays: initialNextReviewDue.days,
      nextReviewDueValueDate: initialNextReviewDue.date,
      nextReviewDueValueRange: initialNextReviewDue.range,
      selectedSrsStages: initialData?.criteria?.srsStages || [],
      // includeLearning removed
    },
    mode: 'onChange',
  });

  const watchedOperatorsArray = form.watch(['createdDateOperator', 'updatedDateOperator', 'lastReviewedOperator', 'nextReviewDueOperator']);
  // includeLearning removed from watchedFilterValuesArray
  const watchedFilterValuesArray = form.watch(['includeTags', 'excludeTags', 'selectedDeckIds', 'selectedSrsStages']);
  const [createdDateOperator, updatedDateOperator, lastReviewedOperator, nextReviewDueOperator] = watchedOperatorsArray;
  // includeLearning removed
  const [includeTags, excludeTags, selectedDeckIds, selectedSrsStages] = watchedFilterValuesArray;

  const mapDateFilterToCriteria = useCallback(( /* ... same as previous correct version ... */
    operator?: string | null,
    days?: string | null,
    date?: Date | null,
    range?: DateRange | null
  ): GenericDateFilterObject | undefined => {
    if (!operator || operator === 'any') return undefined;
    if ((operator === 'newerThanDays' || operator === 'olderThanDays') && days && /^\d+$/.test(days) && parseInt(days, 10) > 0) {
      return { operator, value: days };
    }
    if (operator === 'onDate' && date && isValid(date)) {
      return { operator, value: format(date, 'yyyy-MM-dd') };
    }
    if (operator === 'betweenDates' && range && range.from && range.to && isValid(range.from) && isValid(range.to)) {
      return { operator, value: [format(range.from, 'yyyy-MM-dd'), format(range.to, 'yyyy-MM-dd')] };
    }
    if (operator === 'never' || operator === 'isDue') {
      return { operator };
    }
    return undefined;
  }, []);

  const handleFormSubmit = useCallback(form.handleSubmit(async (formData: StudySetBuilderFormData) => {
    const criteriaToBuild: { [key: string]: any } = {};

    if (formData.selectedDeckIds && formData.selectedDeckIds.length > 0) {
      criteriaToBuild.deckIds = formData.selectedDeckIds;
    }
    if (formData.includeTags && formData.includeTags.length > 0) {
      criteriaToBuild.includeTags = formData.includeTags;
      criteriaToBuild.tagLogic = formData.tagLogic ?? 'ANY';
    }
    if (formData.excludeTags && formData.excludeTags.length > 0) {
      criteriaToBuild.excludeTags = formData.excludeTags;
    }
    if (formData.containsLanguage && formData.containsLanguage.length === 2) {
        criteriaToBuild.containsLanguage = formData.containsLanguage;
    }

    const createdDateFilter = mapDateFilterToCriteria(formData.createdDateOperator, formData.createdDateValueDays, formData.createdDateValueDate, formData.createdDateValueRange);
    if (createdDateFilter) criteriaToBuild.createdDate = createdDateFilter;
    const updatedDateFilter = mapDateFilterToCriteria(formData.updatedDateOperator, formData.updatedDateValueDays, formData.updatedDateValueDate, formData.updatedDateValueRange);
    if (updatedDateFilter) criteriaToBuild.updatedDate = updatedDateFilter;
    const lastReviewedFilter = mapDateFilterToCriteria(formData.lastReviewedOperator, formData.lastReviewedValueDays, formData.lastReviewedValueDate, formData.lastReviewedValueRange);
    if (lastReviewedFilter) criteriaToBuild.lastReviewed = lastReviewedFilter;
    const nextReviewDueFilter = mapDateFilterToCriteria(formData.nextReviewDueOperator, formData.nextReviewDueValueDays, formData.nextReviewDueValueDate, formData.nextReviewDueValueRange);
    if (nextReviewDueFilter) criteriaToBuild.nextReviewDue = nextReviewDueFilter;

    if (formData.selectedSrsStages && formData.selectedSrsStages.length > 0) {
        criteriaToBuild.srsStages = formData.selectedSrsStages;
    }

    // includeLearning mapping removed
    // The includeLearning flag can still be part of StudyQueryCriteria for other uses,
    // but it's not set via this specific form anymore.

    const parsedFinalCriteria = StudyQueryCriteriaSchema.safeParse(criteriaToBuild);
    if (!parsedFinalCriteria.success) {
        console.error("Validation of final criteria failed:", parsedFinalCriteria.error.format());
        const errorMessages = parsedFinalCriteria.error.errors.map(err => `${err.path.join('.') || 'criteria'}: ${err.message}`).join('; ');
        toast.error("Error constructing query.", { description: errorMessages || "Some filter values are invalid." });
        return;
    }

    console.log("Generated Criteria for Save:", parsedFinalCriteria.data);
    await onSave({
      name: formData.name,
      description: formData.description ?? null,
      criteria: parsedFinalCriteria.data
    }).catch(err => {
      toast.error("Save failed.");
      console.error("onSave callback error:", err);
    });
  }), [form, onSave, mapDateFilterToCriteria]);

  const isLoadingOverall = isLoadingTags || isLoadingDecks || isSaving;

  return {
    form,
    isLoading: isLoadingOverall,
    tagsError,
    decksError,
    allTags: allTags || [],
    decks: (decks || []) as DeckListItem[],
    onSubmit: handleFormSubmit,
    watchedOperators: { createdDateOperator, updatedDateOperator, lastReviewedOperator, nextReviewDueOperator },
    watchedFilterValues: { /* includeLearning removed */ includeTags, excludeTags, selectedDeckIds, selectedSrsStages },
    allowedOperators: {
        createdUpdatedOps: [...DateDaysOperators, ...DateSpecificOperators],
        lastReviewedOps: [...DateDaysOperators, ...DateSpecificOperators, ...NullableDateOperators],
        nextReviewDueOps: [...DateDaysOperators, ...DateSpecificOperators, ...NullableDateOperators, ...DueDateOperators],
    },
    srsStageOptions: [...SrsStageEnum.options]
  };
}
```

### File: hooks/useStudySets.ts

```
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getUserStudySets } from '@/lib/actions/studySetActions'; // Adjust path if needed
import type { Database, Tables } from "@/types/database"; // Corrected path to the actual file
import { appLogger, statusLogger } from '@/lib/logger';

// Assuming DbStudySet is the type for rows in your 'study_sets' table
type DbStudySet = Tables<'study_sets'>;

interface UseStudySetsReturn {
  studySets: DbStudySet[];
  isLoading: boolean;
  error: string | null;
  refetchStudySets: () => Promise<void>;
}

/**
 * Custom hook for managing study sets (smart playlists).
 * 
 * This hook provides:
 * - Study set creation, reading, updating, and deletion
 * - Study set state management
 * - Error handling for study set operations
 * - Loading state management
 * 
 * @returns {Object} Study set management functions and state
 * @returns {StudySet[]} returns.studySets - Array of user's study sets
 * @returns {boolean} returns.loading - Whether study set operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {(name: string, queryCriteria: StudyQueryCriteria) => Promise<void>} returns.createStudySet - Function to create a new study set
 * @returns {(studySetId: string, updates: Partial<StudySet>) => Promise<void>} returns.updateStudySet - Function to update a study set
 * @returns {(studySetId: string) => Promise<void>} returns.deleteStudySet - Function to delete a study set
 * @returns {() => Promise<void>} returns.refreshStudySets - Function to refresh the study sets list
 */
export function useStudySets(): UseStudySetsReturn {
  const [studySets, setStudySets] = useState<DbStudySet[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchStudySets = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    appLogger.info("[useStudySets] Fetching study sets...");
    try {
      const result = await getUserStudySets();
      if (result.error) {
        appLogger.error("[useStudySets] Error fetching study sets:", result.error);
        setError(result.error);
        setStudySets([]); // Clear sets on error
      } else {
        appLogger.info(`[useStudySets] Successfully fetched ${result.data?.length ?? 0} sets.`);
        setStudySets(result.data || []); // Ensure data is an array
      }
    } catch (err) {
      appLogger.error("[useStudySets] Unexpected error during fetch:", err);
      setError('An unexpected error occurred while fetching study sets.');
      setStudySets([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch on mount
  useEffect(() => {
    fetchStudySets();
  }, [fetchStudySets]);

  return { studySets, isLoading, error, refetchStudySets: fetchStudySets };
} 
```

### File: hooks/useTags.ts

```
'use client';

import { useState, useEffect, useCallback } from 'react';
import { getTags } from '@/lib/actions/tagActions';
import type { Tables } from '@/types/database';
import { appLogger, statusLogger } from '@/lib/logger';

interface UseTagsReturn {
  allTags: Tables<'tags'>[];
  isLoading: boolean;
  error: string | null;
  refetchAllTags: () => Promise<void>;
}

/**
 * Custom hook for managing tag operations and state.
 * 
 * This hook provides:
 * - Tag creation, reading, updating, and deletion
 * - Tag state management
 * - Error handling for tag operations
 * - Loading state management
 * 
 * @returns {Object} Tag management functions and state
 * @returns {Tag[]} returns.tags - Array of user's tags
 * @returns {boolean} returns.loading - Whether tag operations are in progress
 * @returns {string | null} returns.error - Error message if any operation fails
 * @returns {(name: string) => Promise<void>} returns.createTag - Function to create a new tag
 * @returns {(tagId: string, newName: string) => Promise<void>} returns.updateTag - Function to update a tag's name
 * @returns {(tagId: string) => Promise<void>} returns.deleteTag - Function to delete a tag
 * @returns {() => Promise<void>} returns.refreshTags - Function to refresh the tags list
 */
export function useTags(): UseTagsReturn {
  const [allTags, setAllTags] = useState<Tables<'tags'>[]>([]);
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  const fetchTags = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await getTags();
      if (result.error) {
        setError(result.error);
        setAllTags([]); // Clear tags on error
      } else {
        setAllTags(result.data || []);
      }
    } catch (err) {
      appLogger.error("Unexpected error fetching all tags:", err);
      setError('An unexpected error occurred while fetching tags.');
      setAllTags([]);
    } finally {
      setIsLoading(false);
    }
  }, []);

  // Initial fetch on mount
  useEffect(() => {
    fetchTags();
  }, [fetchTags]);

  return { allTags, isLoading, error, refetchAllTags: fetchTags };
} 
```

## Directory: lib

### File: lib/fonts.ts

```
// lib/fonts.ts
import localFont from 'next/font/local';
import type { FontOption } from "@/providers/settings-provider"; // Assuming this type is defined correctly

// --- 1. Define and Load Local Fonts using next/font ---

// Define OpenDyslexic font object
export const openDyslexicFont = localFont({
  src: [
    {
      // IMPORTANT: Adjust this path relative to THIS FILE (lib/fonts.ts)
      // If lib is at the root, and public is at the root, this should work.
      // If lib is inside src/, use '../../public/fonts/...'
      path: '../public/fonts/OpenDyslexic-Regular.woff2',
      weight: '400', // Or 'normal'
      style: 'normal',
    },
  ],
  variable: '--font-open-dyslexic', // CSS variable name for Tailwind
  display: 'swap', // Recommended: improves perceived performance
  // preload: false, // Optional: Set to false if you only load it conditionally (might not be needed here)
});

// Define Atkinson Hyperlegible font object
export const atkinsonFont = localFont({
  src: [
    {
      path: '../public/fonts/AtkinsonHyperlegible-Regular.woff2', // Adjust path
      weight: '400',
      style: 'normal',
    },
  ],
  variable: '--font-atkinson', // CSS variable name for Tailwind
  display: 'swap',
  // preload: false, // Optional
});

// --- 2. Define Font Metadata (for UI, like Settings) ---
// We remove the 'family' property as it's now handled by the CSS variables

export const FONT_OPTIONS: Record<FontOption | 'default', { name: string; description: string }> = {
  default: {
    name: 'Default',
    // Assuming '--font-sans' is defined elsewhere (e.g., in layout.tsx with Inter)
    description: 'System default font',
  },
  opendyslexic: {
    name: 'OpenDyslexic',
    description: 'Designed to improve readability for readers with dyslexia',
  },
  atkinson: {
    name: 'Atkinson Hyperlegible',
    description: 'Focuses on letterform distinction to increase character recognition',
  },
} as const; // Using 'as const' is good practice here

// --- 3. Helper Function to Get Tailwind Class ---
// This remains the same and is still useful

export function getFontClass(font: FontOption | 'default' | undefined): string {
  switch (font) {
    case 'opendyslexic':
      return 'font-opendyslexic'; // This class needs to be defined in tailwind.config.js
    case 'atkinson':
      return 'font-atkinson';   // This class needs to be defined in tailwind.config.js
    case 'default':
    default:
      return 'font-sans';         // Assumes 'font-sans' is your configured default
  }
}

// --- Type Definitions (if not already defined elsewhere) ---
// Ensure FontOption includes the keys you use ('opendyslexic', 'atkinson')
// Example:
// export type FontOption = 'opendyslexic' | 'atkinson';

// If settings can be undefined or 'default', the getFontClass signature should handle it,
// which the updated version above does.
```

### File: lib/localStorageUtils.ts

```
// lib/localStorageUtils.ts

import type { Tables } from "@/types/database";
import { appLogger, statusLogger } from '@/lib/logger';

// Define the card type from database, ensuring it aligns with Tables<'cards'>
type DbCard = Tables<'cards'>;

// Extend the DbDeck type to include the cards array
// This local interface represents a deck object as stored in/retrieved from local storage
interface DbDeckLocalStorage extends Tables<'decks'> {
  cards: DbCard[]; // cards array should contain objects matching Tables<'cards'>
}

const STORAGE_KEY = "studyCards-decks";

export function getDecksFromLocalStorage(): DbDeckLocalStorage[] {
  try {
    if (typeof window === 'undefined' || !window.localStorage) {
        appLogger.info("localStorage is not available. Cannot get decks.");
        return [];
    }
    const savedDecks = localStorage.getItem(STORAGE_KEY);
    if (savedDecks) {
      const parsedDecks = JSON.parse(savedDecks) as Array<any>; // Parse as any initially for safety
      if (Array.isArray(parsedDecks)) {
        // Map to ensure structure and snake_case, and keep date strings as strings
        return parsedDecks.map(deck => {
          const { cards, ...deckProperties } = deck;
          return {
            ...deckProperties, // Spread existing deck properties
            cards: Array.isArray(cards) ? cards.map((card: any) => ({
              ...card, // Spread existing card properties
              // Ensure last_reviewed_at remains string | null, matching Tables<'cards'>
              // No Date object conversion here.
            })) : [],
          } as DbDeckLocalStorage; // Assert to the local storage type
        });
      }
    }
  } catch (error) {
    appLogger.error("Error accessing localStorage in getDecksFromLocalStorage:", error);
  }
  return [];
}

export function saveDecksToLocalStorage(decks: DbDeckLocalStorage[]): void {
  try {
    if (typeof window === 'undefined' || !window.localStorage) {
        appLogger.info("localStorage is not available. Cannot save decks.");
        return;
    }
    // When saving, ensure dates are ISO strings if they were Date objects in memory
    // However, DbDeckLocalStorage already expects last_reviewed_at as string | null
    localStorage.setItem(STORAGE_KEY, JSON.stringify(decks));
  } catch (error) {
    appLogger.error("Error saving to localStorage in saveDecksToLocalStorage:", error);
  }
}
```

### File: lib/logger.ts

```
/* eslint-disable no-console */
import pino from 'pino';
import log from 'loglevel'; // Import loglevel

const isProduction = process.env.NODE_ENV === 'production';
const isBrowser = typeof window !== 'undefined';
const isOnVercel = !!process.env.VERCEL; // Check for Vercel environment

// --- appLogger setup with loglevel --- 
const appChannel = 'app';
const appLogLevel = isProduction ? 'info' : 'debug';

if (!isBrowser && !isProduction) {
  // Server-side Development: Customize method factory for structured JSON output
  const originalFactory = log.methodFactory;
  log.methodFactory = (methodName, logLevel, loggerName) => {
    const rawMethod = originalFactory(methodName, logLevel, loggerName);
    return (...args: any[]) => {
      // Format into JSON object
      const logObject: Record<string, any> = {
        level: methodName.toUpperCase(), // e.g., INFO, WARN
        channel: appChannel,
        time: Date.now(), // Or use a more sophisticated timestamp
      };

      if (args.length === 1 && typeof args[0] === 'string') {
        logObject.msg = args[0];
      } else if (args.length === 1 && typeof args[0] === 'object') {
        // If single argument is an object, merge it (excluding potential Error properties)
        // Error objects will be handled by the next condition more specifically
        if (!(args[0] instanceof Error)) {
            Object.assign(logObject, args[0]);
        }
      }

      // Handle Error objects specifically
      const errorArg = args.find(arg => arg instanceof Error);
      if (errorArg) {
        logObject.err = {
          message: errorArg.message,
          stack: errorArg.stack,
          name: errorArg.name,
        };
        // If there are other arguments, add them as 'details' or merge them
        const otherArgs = args.filter(arg => !(arg instanceof Error));
        if (otherArgs.length > 0) {
            if (otherArgs.length === 1 && typeof otherArgs[0] === 'string') {
                logObject.msg = otherArgs[0]; // If a string message accompanies an error
            } else {
                logObject.details = otherArgs.length === 1 ? otherArgs[0] : otherArgs;
            }
        }
      } else if (args.length > 1) {
        // If multiple arguments and no error, assume first is msg and rest are details
        logObject.msg = args[0];
        logObject.details = args.slice(1).length === 1 ? args.slice(1)[0] : args.slice(1);
      }
      
      console.log(JSON.stringify(logObject));
    };
  };
  log.setLevel(appLogLevel as log.LogLevelDesc); 
  console.log(`[Logger Setup] appLogger (server-dev) using loglevel with JSON output, level: ${appLogLevel}`);
} else if (isBrowser && !isProduction) {
  // Client-side Development: Default loglevel behavior (uses console.* directly)
  log.setLevel(appLogLevel as log.LogLevelDesc);
  console.log(`[Logger Setup] appLogger (client-dev) using loglevel with direct console output, level: ${appLogLevel}`);
} else {
  // Production (Server & Client): Customize for JSON output if server, default for client
  if (!isBrowser) { // Production Server
    const originalFactory = log.methodFactory;
    log.methodFactory = (methodName, logLevel, loggerName) => {
      const rawMethod = originalFactory(methodName, logLevel, loggerName);
      return (...args: any[]) => {
        const logObject: Record<string, any> = {
          level: methodName.toUpperCase(),
          channel: appChannel,
          time: Date.now(),
        };
        if (args.length === 1 && typeof args[0] === 'string') logObject.msg = args[0];
        else if (args.length > 0) {
            logObject.msg = args[0];
            if (args.length > 1) logObject.details = args.slice(1).length === 1 ? args.slice(1)[0] : args.slice(1);
        }
        console.log(JSON.stringify(logObject));
      };
    };
  }
  log.setLevel(appLogLevel as log.LogLevelDesc);
  console.log(`[Logger Setup] appLogger (production) initialized, level: ${appLogLevel}`);
}

export const appLogger = log.getLogger(appChannel);

// --- statusLogger setup with pino --- 
let statusLoggerTransport: pino.TransportSingleOptions | undefined = {
  target: 'pino/file',
  options: { destination: './logs/status.log', mkdir: true },
};

if (isOnVercel && isProduction) {
  // On Vercel production, disable file logging for statusLogger, fallback to stdout
  console.log('[Logger Setup] statusLogger (Vercel prod) falling back to stdout, file logging disabled.');
  statusLoggerTransport = undefined; 
}

export const statusLogger = pino({
  level: 'info',
  name: 'status',
  formatters: {
    level(label: string) {
      return { level: label, channel: 'status' };
    },
  },
  transport: statusLoggerTransport,
});

// --- Test statusLogger --- 
// statusLogger.info({ action: 'logger_init', message: 'statusLogger initialized and test log written.' }); // Test line removed
// -------------------------

// Example usage:
// appLogger.info('Application event');
// statusLogger.info('System status update'); 
```

### File: lib/palettes.ts

```
// lib/palettes.ts

export interface ColorPair {
  background: string; // Hex code
  text: string;       // Hex code
}

export interface Palette {
  id: string;         // Unique ID for storing in settings
  name: string;       // User-friendly name
  light: ColorPair;   // Colors for light theme background
  dark: ColorPair;    // Colors for dark theme background (with grey card)
}

//use url for inspiration
//https://venngage.com/tools/accessible-color-palette-generator


export const PREDEFINED_PALETTES: ReadonlyArray<Palette> = [
  { id: 'default', name: 'Default (No Color)', light: { background: 'transparent', text: 'inherit' }, dark: { background: 'transparent', text: 'inherit' } }, // Option to disable for a specific type
  { id: 'bw', name: 'Black/White', light: { background: '#000000', text: '#FFFFFF' }, dark: { background: '#000000', text: '#FFFFFF' } },
  { id: 'blue-hc', name: 'Blue - High Contrast', light: { background: '#0035B0', text: '#FFFFFF' }, dark: { background: '#99CAFF', text: '#000000' } },
  { id: 'purple-hc', name: 'Purple - High Contrast', light: { background: '#8D03C7', text: '#FFFFFF' }, dark: { background: '#E8B2FF', text: '#000000' } },
  { id: 'green-hc', name: 'Green - High Contrast', light: { background: '#00640A', text: '#FFFFFF' }, dark: { background: '#9CE9A4', text: '#000000' } },
  { id: 'gold-hc', name: 'Gold/Brown - High Contrast', light: { background: '#755200', text: '#FFFFFF' }, dark: { background: '#FFD26A', text: '#000000' } },
  { id: 'red-hc', name: 'Red/Salmon - High Contrast', light: { background: '#9D0000', text: '#FFFFFF' }, dark: { background: '#FF9191', text: '#000000' } }, 
  { id: 'blue', name: 'Blue', light: { background: '#2546F0', text: '#FFFFFF' }, dark: { background: '#2546F0', text: '#FFFFFF' } },
  { id: 'purple', name: 'Purple', light: { background: '#6D00AE', text: '#FFFFFF' }, dark: { background: '#6D00AE', text: '#FFFFFF' } },
  { id: 'green', name: 'Green', light: { background: '#89CE00', text: '#000000' }, dark: { background: '#89CE00', text: '#000000' } },
  { id: 'gold ', name: 'Gold/Brown', light: { background: '#FCC400', text: '#000000' }, dark: { background: '#FCC400', text: '#000000' } },
  { id: 'red', name: 'Red', light: { background: '#E40001', text: '#FFFFFF' }, dark: { background: '#E40001', text: '#FFFFFF' } },
] as const;

// Define default palette assignments
export const DEFAULT_PALETTE_CONFIG: Record<string, Record<string, string>> = {
  // Assign default palette IDs
  Noun: { Male: 'blue', Female: 'green', Default: 'bw' }, // Example: Blue for Male Nouns, Red for Female, B/W for Neutral/Other
  Verb: { Default: 'red' },
  Adjective: { Male: 'gold', Female: 'gold', Default: 'gold' }, // Use same for M/F/Default
  Adverb: { Default: 'purple' },
  Pronoun: { Male: 'blue', Female: 'blue', Default: 'blue' }, // Use same for M/F/Default
  Preposition: { Default: 'default' }, // Example: Default = no color
  Interjection: { Default: 'default' },
  Other: { Default: 'default' },
};

// Define the dark mode card background color from the image
export const DARK_MODE_CARD_BG = '#686868'; // Adjust this grey as needed
```

### File: lib/srs.ts

```
// lib/srs.ts
import { addDays, addMinutes, startOfDay, isAfter } from 'date-fns';
import type { Settings } from "@/providers/settings-provider"; // Import the correct Settings type
import { appLogger, statusLogger } from '@/lib/logger';



/**
 * Represents the relevant SRS state of a card before a review or step calculation.
 * Matches necessary fields from the 'cards' table data model + internal state.
 */
export interface Sm2InputCardState {
  srsLevel: number;               // Current repetition count (n)
  easinessFactor: number;         // Current Easiness Factor (EF). Assuming NOT NULL after first review/graduation.
  intervalDays: number;           // Interval used to schedule *this* review (I(n-1)). Can be fractional for step intervals.
  learningState: 'learning' | 'relearning' | null; // Current phase
  learningStepIndex: number | null; // Current step index within learning/relearning
  nextReviewDue?: Date | string | null; // ADD this field, make optional for flexibility
  // failedAttemptsInLearn and hardAttemptsInLearn are tracked by the hook, not part of this input state object
}

/**
 * Represents the grade given by the user after reviewing a card.
 */
export type ReviewGrade = 1 | 2 | 3 | 4;

/**
 * Represents the data payload needed to update the card's SRS state
 * in the database. Contains the *next* state fields.
 */
export interface Sm2UpdatePayload {
  srsLevel: number;           // The new repetition count (n')
  easinessFactor: number;     // The new Easiness Factor (EF')
  intervalDays: number;       // The new interval in days (I(n')). Can be fractional.
  nextReviewDue: Date;        // The calculated next review date/time.
  lastReviewGrade: ReviewGrade; // The grade that led to this update. (Hook sets this)
  learningState: 'learning' | 'relearning' | null; // The new phase
  learningStepIndex: number | null; // The new step index

  // Note: failedAttemptsInLearn and hardAttemptsInLearn are *not* included here.
  // The hook manages and updates these counters separately based on grades in the 'learning' state.
}


// --- Core SM-2 Calculation (for Review State Progression or Lapse) ---
/**
 * Calculates the next SM-2 state for a card that is currently in the
 * standard Review phase (srsLevel >= 1, learningState === null).
 * Also handles the transition FROM Review TO Relearning on Grade 1 (Lapse).
 *
 * @param current The current SRS state of the card before review (must have srsLevel >= 1).
 * @param grade The user's assessment of recall difficulty (1-4).
 * @param settings The user's application settings.
 * @returns An object containing the updated SRS fields (Sm2UpdatePayload).
 */
export function calculateSm2State(
  current: Sm2InputCardState,
  grade: ReviewGrade,
  settings: Settings // Use imported Settings type
): Sm2UpdatePayload {
  // This function should *only* be called for cards with current.srsLevel >= 1
  if (current.srsLevel < 1) {
       appLogger.error("[calculateSm2State] Called with card not in Review state (srsLevel < 1). This function is for Review -> Review or Review -> Relearning transitions only.", current);
       // Return a default or throw, depending on desired error handling.
       // Returning current state as a fallback (might not be desired):
       return {
            srsLevel: current.srsLevel,
            easinessFactor: current.easinessFactor,
            intervalDays: current.intervalDays,
            nextReviewDue: current.nextReviewDue ? new Date(current.nextReviewDue) : addDays(startOfDay(new Date()), 1),
            lastReviewGrade: grade,
            learningState: current.learningState,
            learningStepIndex: current.learningStepIndex,
       };
  }

  const currentEasinessFactor = current.easinessFactor; // srsLevel >= 1 implies EF is not null
  const previousIntervalDays = current.intervalDays; // srsLevel >= 1 implies interval is not null

  let newSrsLevel: number;
  let newEasinessFactor: number;
  let newIntervalDays: number; // Will be integer days for review intervals
  let newLearningState: 'learning' | 'relearning' | null = null; // Default to staying in Review
  let newLearningStepIndex: number | null = null; // Default to not being in steps

  const quality = grade + 1; // Map 1->2, 2->3, 3->4, 4->5 for standard EF formula

  // --- Calculate New Easiness Factor ---
  // This formula applies regardless of lapse vs. success in Review
  const efDelta = 0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02);
  newEasinessFactor = Math.max(settings.minEasinessFactor, currentEasinessFactor + efDelta);


  // --- Handle Lapse (Grade 1 from Review) ---
  if (grade === 1) {
      appLogger.info("[calculateSm2State] Grade 1 (Again) in Review. Lapsing to Relearning.");
      const relearningIntervalMinutes = settings.relearningStepsMinutes[0]; // First relearning step
      const nextReviewDue = addMinutes(new Date(), relearningIntervalMinutes);

      newSrsLevel = 0; // Reset level on lapse
      // EF penalty already applied above as part of standard EF calculation
      newIntervalDays = relearningIntervalMinutes / (60 * 24); // Store interval as fractional days
      newLearningState = 'relearning'; // Card is now in relearning state
      newLearningStepIndex = 0; // Start at step 0 of relearning

      return {
        srsLevel: newSrsLevel,
        easinessFactor: newEasinessFactor, // Penalized EF
        intervalDays: newIntervalDays, // Fractional days
        nextReviewDue: nextReviewDue,
        lastReviewGrade: grade, // Hook sets this
        learningState: newLearningState,
        learningStepIndex: newLearningStepIndex,
      };
  }

  // --- Handle Success (Grade 2, 3, or 4 from Review) ---
  appLogger.info(`[calculateSm2State] Grade ${grade} (Hard/Good/Easy) in Review. Successful recall.`);
  newSrsLevel = current.srsLevel + 1; // Increment level for successful review

  // Calculate next interval based on Anki's SM-2 interpretation for review phase (level >= 1 -> next level >= 2)
  let intervalBase: number;
  if (current.srsLevel === 1) { // Transitioning from level 1 to 2 (first successful review to second)
       intervalBase = 6; // This is I(2) in Anki, based on I(1)=1. Interval is fixed.
  } else { // Transitioning from level >= 2 to >= 3 (standard review growth)
      intervalBase = previousIntervalDays; // Base interval is the previous interval
  }

  const multiplier = (grade === 2) ? 1.2 : newEasinessFactor; // Anki Hard multiplier (1.2), otherwise use the new EF

  newIntervalDays = Math.round(intervalBase * multiplier);


  // Ensure interval is at least 1 day for Review phase
  newIntervalDays = Math.max(1, newIntervalDays);
  // Ensure new srsLevel is at least 1 (as we are in Review) - should be >= 2 here anyway
  newSrsLevel = Math.max(1, newSrsLevel);


  const nextReviewDue = addDays(startOfDay(new Date()), newIntervalDays);

  return {
    srsLevel: newSrsLevel, // Incremented level
    easinessFactor: newEasinessFactor, // Updated EF
    intervalDays: newIntervalDays, // Integer days
    nextReviewDue: nextReviewDue,
    lastReviewGrade: grade, // Hook sets this
    learningState: null, // Stays in Review
    learningStepIndex: null, // Not in steps
  };
}


// --- NEW Helper Function: Calculation for Initial EF upon Graduation ---
/**
 * Calculates the initial Easiness Factor when a card graduates from
 * the Initial Learning state based on its performance during learning.
 *
 * @param failedAttempts Total Grade 1s ('Again') received during the initial learning phase for this card.
 * @param hardAttempts Total Grade 2s ('Hard') received during the initial learning phase for this card.
 * @param settings The user's application settings.
 * @returns The calculated initial EF (min 1.3).
 */
export function calculateInitialEasinessFactor(
    failedAttempts: number, // Total Grade 1s in initial learning state for this card
    hardAttempts: number,   // Total Grade 2s in initial learning state for this card
    settings: Settings // Use imported Settings type
): number {
    let ef = settings.defaultEasinessFactor;
    ef -= failedAttempts * settings.learnAgainPenalty; // Subtract penalty for each 'Again'
    ef -= hardAttempts * settings.learnHardPenalty;   // Subtract penalty for each 'Hard' (smaller penalty)
    return Math.max(settings.minEasinessFactor, ef); // Ensure it doesn't go below minimum
}

// --- NEW Helper Function: Calculate Next Step in Initial Learning (Standard SM-2 Mode) ---
/**
 * Calculates the next step and due time for a card in the Initial Learning state
 * when using the Standard SM-2 learning algorithm (`settings.studyAlgorithm === 'standard-sm2'`).
 *
 * @param currentStepIndex The card's current step index (0-based) within settings.initialLearningStepsMinutes.
 * @param grade The user's assessment of recall difficulty (1-4).
 * @param settings The user's application settings.
 * @returns An object indicating the next step index (or 'graduated'), its due time, and the step's interval in minutes.
 */
export function calculateNextStandardLearnStep(
    currentStepIndex: number,
    grade: ReviewGrade,
    settings: Settings // Use imported Settings type
): { nextStepIndex: number | 'graduated'; nextDueTime: Date; intervalMinutes: number | null; } {
    const steps = settings.initialLearningStepsMinutes;
    let nextStepIndex: number | 'graduated';
    let intervalMinutes: number | null = null; // The interval for the *next* step

    if (!steps || steps.length === 0) {
        appLogger.error("Standard learning steps not defined or empty in settings. Graduating immediately.");
        return { nextStepIndex: 'graduated', nextDueTime: new Date(), intervalMinutes: null };
    }

    if (grade === 1) { // Again: Go back to first step
        nextStepIndex = 0;
        intervalMinutes = steps[0];
    } else if (grade === 4) { // Easy: Skip all steps and graduate
        nextStepIndex = 'graduated';
        intervalMinutes = null; // Graduation interval handled by createGraduationPayload
    } else { // Hard (2) or Good (3): Move forward
        // Hard moves one step (current + 1)
        // Good moves two steps (current + 2) - standard Anki behavior for steps > 1
        const stepsToAdvance = (grade === 2) ? 1 : 2;
        const potentialNextIndex = currentStepIndex + stepsToAdvance;

        if (potentialNextIndex >= steps.length) {
            nextStepIndex = 'graduated'; // Completed steps
            intervalMinutes = null; // Graduation interval handled by createGraduationPayload
        } else {
            nextStepIndex = potentialNextIndex;
            intervalMinutes = steps[nextStepIndex];
        }
    }

    const nextDueTime = nextStepIndex === 'graduated'
        ? new Date() // Card is immediately due for graduation processing
        : addMinutes(new Date(), intervalMinutes!); // Card is due after the step interval

    return { nextStepIndex, nextDueTime, intervalMinutes };
}


// --- NEW Helper Function: Calculate Next Step in Relearning ---
/**
 * Calculates the next step and due time for a card in the Relearning state (`learning_state = 'relearning'`).
 *
 * @param currentStepIndex The card's current step index (0-based) within settings.relearningStepsMinutes.
 * @param grade The user's assessment of recall difficulty (1-4).
 * @param settings The user's application settings.
 * @returns An object indicating the next step index (or 'graduatedFromRelearning'), its due time, and the step's interval in minutes.
 */
export function calculateNextRelearningStep(
    currentStepIndex: number,
    grade: ReviewGrade, // Note: Grades 2, 3, 4 often behave similarly in relearning
    settings: Settings // Use imported Settings type
): { nextStepIndex: number | 'graduatedFromRelearning'; nextDueTime: Date; intervalMinutes: number | null; } {
    const steps = settings.relearningStepsMinutes;
    let nextStepIndex: number | 'graduatedFromRelearning';
    let intervalMinutes: number | null = null; // The interval for the *next* step

     if (!steps || steps.length === 0) {
        appLogger.error("Relearning steps not defined or empty in settings. Defaulting to immediate re-entry to review.");
        return { nextStepIndex: 'graduatedFromRelearning', nextDueTime: new Date(), intervalMinutes: null };
    }

    if (grade === 1) { // Again: Go back to first relearning step
        nextStepIndex = 0;
        intervalMinutes = steps[0];
    } else { // Hard (2), Good (3), Easy (4): Success in relearning - move one step forward
        const potentialNextIndex = currentStepIndex + 1;

        if (potentialNextIndex >= steps.length) {
            nextStepIndex = 'graduatedFromRelearning'; // Completed relearning steps
            intervalMinutes = null; // Re-entering Review handled separately
        } else {
            nextStepIndex = potentialNextIndex;
            intervalMinutes = steps[nextStepIndex];
        }
    }

    const nextDueTime = nextStepIndex === 'graduatedFromRelearning'
        ? new Date() // Card is immediately due for re-entry processing
        : addMinutes(new Date(), intervalMinutes!); // Card is due after the step interval

    return { nextStepIndex, nextDueTime, intervalMinutes };
}

// --- Helper for Initial Graduation Payload (Learning -> Review Transition) ---
/**
 * Constructs the payload for the first Review state (srs_level=1) when a card
 * graduates from the Initial Learning phase (either algorithm).
 *
 * @param grade The grade that triggered graduation (typically 3 or 4, but could be 2 if last step reached).
 * @param failedAttemptsInLearn Total Grade 1s recorded *during initial learning* for this card.
 * @param hardAttemptsInLearn Total Grade 2s recorded *during initial learning* for this card.
 * @param settings The user's application settings.
 * @returns An Sm2UpdatePayload object representing the initial Review state.
 */
export function createGraduationPayload(
    grade: ReviewGrade, // The grade that caused graduation
    failedAttemptsInLearn: number,
    hardAttemptsInLearn: number,
    settings: Settings // Use imported Settings type
): Sm2UpdatePayload {
     const initialEF = calculateInitialEasinessFactor(failedAttemptsInLearn, hardAttemptsInLearn, settings);
     // Use Easy Interval if graduated with Grade 4, otherwise use Graduating Interval
     const initialIntervalDays = grade === 4 ? settings.easyIntervalDays : settings.graduatingIntervalDays;

     return {
        srsLevel: 1, // Enters review phase at level 1
        easinessFactor: initialEF, // Calculated based on learning performance
        intervalDays: initialIntervalDays, // Integer days
        nextReviewDue: addDays(startOfDay(new Date()), initialIntervalDays),
        lastReviewGrade: grade, // The grade that triggered graduation
        learningState: null, // No longer in learning state
        learningStepIndex: null,
     };
}

// --- Helper for Relearning Graduation Payload (Relearning -> Review Transition) ---
/**
 * Constructs the payload when a card graduates from the Relearning state and
 * re-enters the standard Review phase.
 *
 * @param grade The grade that triggered graduation from Relearning (typically >= 2).
 * @param currentCardEf The card's Easiness Factor *before* starting Relearning (i.e., the EF it had when it lapsed). This should be the EF used for the new state.
 * @param settings The user's application settings.
 * @returns An Sm2UpdatePayload object representing the state upon re-entering Review.
 */
export function createRelearningGraduationPayload(
    grade: ReviewGrade, // The grade that caused graduation from Relearning
    currentCardEf: number, // Use the EF it had when it lapsed (passed from hook)
    settings: Settings // Use imported Settings type
): Sm2UpdatePayload {
     // The EF was already penalized when the card *lapsed* from Review. We keep that penalized EF.
     const newEasinessFactor = Math.max(settings.minEasinessFactor, currentCardEf);

     // Anki often uses a specific interval after relearning. A common approach is the Graduating Interval (1 day).
     const intervalAfterRelearning = settings.graduatingIntervalDays; // Use graduating interval as re-entry interval

     return {
        srsLevel: 1, // Re-entering Review at level 1 (common practice after lapse/relearn)
        easinessFactor: newEasinessFactor, // Keep the penalized EF
        intervalDays: intervalAfterRelearning, // Integer days
        nextReviewDue: addDays(startOfDay(new Date()), intervalAfterRelearning),
        lastReviewGrade: grade, // The grade that triggered relearning graduation
        learningState: null, // No longer in relearning state
        learningStepIndex: null,
     };
}
```

### File: lib/study-utils.ts

```
// lib/study-utils.ts
import type { Tables, Json } from "@/types/database";
import type { Settings } from "@/providers/settings-provider";
import { appLogger, statusLogger } from '@/lib/logger';

// Define type aliases for better readability using Tables from database types
type DbCard = Tables<'cards'>;

// Extend the deck type to include cards relationship.
// This local interface represents a deck object in memory that also holds its cards.
interface DbDeckWithCards extends Tables<'decks'> {
  cards: DbCard[];
}

// Constants (remain the same)
export const DEFAULT_MASTERY_THRESHOLD = 3;
export const STUDY_SAVE_DEBOUNCE_MS = 2000;
export const TTS_DELAY_MS = 100;
export const DECK_LOAD_RETRY_DELAY_MS = 500;
export const MAX_DECK_LOAD_RETRIES = 5;
export const FLIP_ANIMATION_MIDPOINT_MS = 150;
export const FLIP_ANIMATION_DURATION_MS = 300;

export const DIFFICULTY_WEIGHTS = {
  INCORRECT_RATIO: 0.8,
  ATTEMPTS: 0.1,
  FORGETFULNESS: 0.1
} as const;

export const DAYS_FOR_MAX_FORGETFULNESS = 5;
export const ATTEMPTS_NORMALIZATION_FACTOR = 5;
export const DIFFICULTY_THRESHOLD = 0.55;

/**
 * Prepares cards for a study session, excluding mastered cards and applying weighted randomization.
 */
export const prepareStudyCards = (cards: DbCard[], settings?: Settings | null): DbCard[] => {
  if (!Array.isArray(cards)) return [];

  const threshold = settings?.masteryThreshold ?? DEFAULT_MASTERY_THRESHOLD;

  const availableCards = cards.filter(
    (card) => card && (card.correct_count ?? 0) < threshold // Use nullish coalescing for counts
  );

  if (availableCards.length === 0) return [];

  const weightedCards = availableCards.map((card) => {
    const correct = card.correct_count ?? 0;
    const incorrect = card.incorrect_count ?? 0;
    const correctRatio = correct / (correct + incorrect + 1);
    const weight = 1 - correctRatio;
    return { card, weight };
  });

  weightedCards.sort((a, b) => {
    const weightDiff = b.weight - a.weight;
    if (Math.abs(weightDiff) < 0.2) {
      return Math.random() - 0.5;
    }
    return weightDiff;
  });

  return weightedCards.map((wc) => wc.card);
};

/**
 * Calculates the mastery count for a given set of cards.
 */
export const calculateMasteredCount = (cards: DbCard[], settings?: Settings | null): number => {
  if (!Array.isArray(cards)) return 0;
  const threshold = settings?.masteryThreshold ?? DEFAULT_MASTERY_THRESHOLD;
  return cards.filter((card) => card && (card.correct_count ?? 0) >= threshold).length;
};

/**
 * Determines the next state of the study session.
 */
export const determineNextCardState = (
  currentStudyCards: DbCard[],
  currentCardIndex: number,
  answeredCard: DbCard, // Expects a full DbCard with updated stats
  masteryThreshold: number
): { nextStudyCards: DbCard[]; nextIndex: number; cardJustMastered: boolean } => {
  let nextStudyCards = [...currentStudyCards];
  let nextIndex = currentCardIndex;
  let cardJustMastered = false;

  if ((answeredCard.correct_count ?? 0) >= masteryThreshold) {
    cardJustMastered = true;
    appLogger.info(`study-utils: Card ${answeredCard.id} mastered and will be removed.`);
    nextStudyCards = currentStudyCards.filter(card => card.id !== answeredCard.id);
    nextIndex = Math.min(currentCardIndex, nextStudyCards.length - 1);
    if (nextIndex < 0) nextIndex = 0;
  } else {
    if (currentStudyCards.length > 0) {
      nextIndex = (currentCardIndex + 1) % currentStudyCards.length;
    }
    if (nextStudyCards.length === 0) {
        nextIndex = 0;
    }
  }
  return { nextStudyCards, nextIndex, cardJustMastered };
};

/**
 * Creates the necessary state components for resetting a deck's progress.
 */
export const createResetDeckState = (deck: DbDeckWithCards, settings: Settings | null): { resetDeck: DbDeckWithCards; initialStudyCards: DbCard[] } => {
  appLogger.info("study-utils: Preparing reset state for deck:", deck.name);

  const resetCards = deck.cards.map((card: DbCard) => ({
    ...card,
    correct_count: 0,
    incorrect_count: 0,
    last_reviewed_at: null, // Corrected from last_studied, matches DbCard type
    attempt_count: 0,
    difficulty_score: card.difficulty_score === undefined ? 0 : (card.difficulty_score ?? 0), // Handle potential undefined if not set
    // Also reset SRS fields for a full progress reset
    srs_level: 0,
    easiness_factor: settings?.defaultEasinessFactor ?? 2.5,
    interval_days: 0,
    learning_state: null,
    learning_step_index: null,
    failed_attempts_in_learn: 0,
    hard_attempts_in_learn: 0,
    next_review_due: null,
    last_review_grade: null,
  }));

  const resetDeck: DbDeckWithCards = {
    ...deck,
    cards: resetCards,
    // progress field from Tables<'decks'> is Json, pass it as is or reset its sub-fields
    // Assuming we keep the existing Json blob structure and just reset card-specific parts
    progress: deck.progress, // Or reset: { streak: 0, correct: 0, incorrect: 0, lastStudied: null } if progress has a known structure
  };

  const initialStudyCards = prepareStudyCards(resetCards, settings);

  return { resetDeck, initialStudyCards };
};
```

### File: lib/utils.ts

```
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"
import type { Tables } from "@/types/database";
import { appLogger, statusLogger } from '@/lib/logger';

/**
 * General utility functions for the application.
 * 
 * This module provides:
 * - Object transformation utilities
 * - Type conversion helpers
 * - Common helper functions
 * 
 * @module utils
 */

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


/**
 * Detects the user's system language based on the browser settings.
 * Returns a language code (e.g., "en", "fr") or a default of "en" if unavailable.
 */
export function detectSystemLanguage(): string {
  if (typeof navigator !== "undefined" && navigator.language) {
    // Return only the primary language (e.g., "en" from "en-US")
    return navigator.language.split('-')[0];
  }
  // Fallback default language
  return "en";
}

/**
 * Debounces a function, ensuring it is only called after a specified delay
 * since the last time it was invoked.
 *
 * @param func The function to debounce.
 * @param wait The number of milliseconds to delay.
 * @returns A debounced version of the function.
 */
export function debounce<T extends (...args: any[]) => any>(func: T, wait: number): (...args: Parameters<T>) => void {
  let timeout: NodeJS.Timeout | null = null;
  return function executedFunction(...args: Parameters<T>) {
    const later = () => {
      timeout = null;
      func(...args);
    };
    if (timeout) {
      clearTimeout(timeout);
    }
    timeout = setTimeout(later, wait);
  };
}

/**
 * Converts object keys from camelCase to snake_case.
 * 
 * @param {Object} obj - The object to convert
 * @returns {Object} A new object with snake_case keys
 */
export function convertPayloadToSnakeCase(obj: Record<string, any>): Record<string, any> {
  const newObj: Record<string, any> = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const snakeKey = key.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
      newObj[snakeKey] = obj[key];
    }
  }
  return newObj;
}

/**
 * Converts object keys from snake_case to camelCase.
 * 
 * @param {Object} obj - The object to convert
 * @returns {Object} A new object with camelCase keys
 */
export function convertPayloadToCamelCase(obj: Record<string, any>): Record<string, any> {
  const newObj: Record<string, any> = {};
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      const camelKey = key.replace(/_([a-z])/g, (match, letter) => letter.toUpperCase());
      newObj[camelKey] = obj[key];
    }
  }
  return newObj;
}

// --- Update type to include language fields ---
type SwappableCardFields = {
  question?: string | null;
  answer?: string | null;
  questionPartOfSpeech?: string | null;
  questionGender?: string | null;
  answerPartOfSpeech?: string | null;
  answerGender?: string | null;
  // Add language fields
  questionLanguage?: string | null;
  answerLanguage?: string | null;
  // Allow other properties
  [key: string]: any;
};
// ------------------------------------------

/**
* Swaps question/answer content, classifications, and languages.
* Returns a new object with swapped fields, preserving other properties.
* Handles null/undefined values correctly during the swap.
*
* @template T - An object type that includes SwappableCardFields (like ApiFlashcard)
* @param {T} card - The card object to swap fields for.
* @returns {T} A new card object with swapped fields.
*/
export function swapCardFields<T extends SwappableCardFields>(card: T): T {
  // Clone the original card object
  const swappedCard = { ...card };

  // Swap core text content
  const tempQuestion = swappedCard.question;
  swappedCard.question = swappedCard.answer;
  swappedCard.answer = tempQuestion;

  // Swap classification fields
  const tempQPos = swappedCard.questionPartOfSpeech;
  swappedCard.questionPartOfSpeech = swappedCard.answerPartOfSpeech;
  swappedCard.answerPartOfSpeech = tempQPos;

  const tempQGender = swappedCard.questionGender;
  swappedCard.questionGender = swappedCard.answerGender;
  swappedCard.answerGender = tempQGender;

  // --- NEW: Swap language fields ---
  const tempQLang = swappedCard.questionLanguage;
  swappedCard.questionLanguage = swappedCard.answerLanguage;
  swappedCard.answerLanguage = tempQLang;
  // --------------------------------

  appLogger.info('[swapCardFields] Swapped card data (incl. languages):', { original: card, swapped: swappedCard });
  return swappedCard;
}
```

## Directory: lib/actions

### File: lib/actions/cardActions.ts

```
"use server";

import { createActionClient } from "@/lib/supabase/server";
import type { Database, Tables } from "@/types/database";
import { z } from 'zod';
import { revalidatePath } from 'next/cache';
import type { ActionResult } from '@/lib/actions/types';
import { appLogger, statusLogger } from '@/lib/logger';

// isCalledFromDynamicRoute function remains unchanged (if still needed elsewhere)

// getCardsByIds function remains unchanged (already updated select)
export async function getCardsByIds(
    cardIds: string[]
): Promise<ActionResult<Tables<'cards'>[]>> {
    appLogger.info(`[getCardsByIds] Action started for ${cardIds.length} cards`);

    if (!cardIds || cardIds.length === 0) {
        appLogger.info("[getCardsByIds] No card IDs provided.");
        return { data: [], error: null };
    }

    try {
        const supabase = await createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            appLogger.error('[getCardsByIds] Auth error or no user:', authError);
            return { data: [], error: authError?.message || 'Not authenticated' };
        }

        appLogger.info(`[getCardsByIds] User authenticated: ${user.id}, fetching ${cardIds.length} cards`);

        const validCardIds = cardIds.filter(id => /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(id));
        if (validCardIds.length !== cardIds.length) {
             appLogger.warn("[getCardsByIds] Some invalid UUIDs were filtered out.");
        }
        if (validCardIds.length === 0) {
             appLogger.info("[getCardsByIds] No valid card IDs remaining after filtering.");
            return { data: [], error: null };
        }

        // Select clause already updated previously
        const { data: dbCards, error: dbError } = await supabase
            .from('cards')
            .select(`
                *,
                question_part_of_speech,
                question_gender,
                answer_part_of_speech,
                answer_gender,
                decks ( primary_language, secondary_language )
            `)
            .in('id', validCardIds)
            .eq('user_id', user.id);

        if (dbError) {
            appLogger.error('[getCardsByIds] Database error:', dbError);
            return { data: [], error: dbError.message || 'Database query failed' };
        }

        if (!dbCards || dbCards.length === 0) {
            appLogger.info('[getCardsByIds] No cards found or user does not have access');
            return { data: [], error: null };
        }

        appLogger.info(`[getCardsByIds] Successfully fetched ${dbCards.length} cards`);
        return { data: dbCards as Tables<'cards'>[], error: null };

    } catch (error) {
        appLogger.error('[getCardsByIds] Caught unexpected error:', error);
        return { data: [], error: error instanceof Error ? error.message : 'Unknown error fetching cards by IDs' };
    }
}


// getCardById function remains unchanged (already updated select)
export async function getCardById(
    cardId: string,
    isDynamicRoute = false
): Promise<ActionResult<Tables<'cards'>>> {
    appLogger.info(`[getCardById] Fetching card: ${cardId}`);
    const supabase = await createActionClient();

    const { data: { user }, error: authError } = await supabase.auth.getUser();

    if (authError || !user) {
        appLogger.error('[getCardById] Auth error or no user:', authError);
        return { data: null, error: authError?.message || 'Not authenticated' };
    }

    appLogger.info("Fetching single card:", cardId, "for user:", user.id);

    try {
         // Select clause already updated previously
         const { data: dbCard, error } = await supabase
            .from('cards')
             .select(`
                 *,
                 question_part_of_speech,
                 question_gender,
                 answer_part_of_speech,
                 answer_gender
              `)
             .eq('id', cardId)
             .maybeSingle<Tables<'cards'>>();

        if (error) {
            appLogger.error('[getCardById] Database error:', error);
            return { data: null, error: error.message || 'Database query failed' };
        }

        if (!dbCard) {
            appLogger.info("getCardById: Card not found:", cardId);
            return { data: null, error: null }; // Not an error, just not found
        }

        return { data: dbCard, error: null };

    } catch (error) {
         appLogger.error('[getCardById] Caught unexpected error:', error);
        return { data: null, error: error instanceof Error ? error.message : 'Unknown error fetching card' };
    }
}


// --- UPDATED Zod Schemas ---
const baseCardSchema = z.object({
    question: z.string().trim().min(1, "Question cannot be empty."),
    answer: z.string().trim().min(1, "Answer cannot be empty."),
    // Optional classification fields
    question_part_of_speech: z.string().optional().nullable(),
    question_gender: z.string().optional().nullable(),
    answer_part_of_speech: z.string().optional().nullable(),
    answer_gender: z.string().optional().nullable(),
});

// Schema for creating (requires Q/A, classifications optional)
const createCardSchema = baseCardSchema;
// --- FIX: Add export ---
export type CreateCardInput = z.infer<typeof createCardSchema>;

// Schema for updating (all fields optional)
const updateCardSchema = baseCardSchema.partial();
// --- FIX: Add export ---
export type UpdateCardInput = z.infer<typeof updateCardSchema>;


/**
 * Creates a single new flashcard (e.g., for manual addition).
 * For bulk creation (AI flow), use createCardsBatch.
 *
 * @param deckId - ID of the deck to create the card in
 * @param inputData - Card data including Q/A and optional classifications
 * @returns The created card
 */
export async function createCard(
    deckId: string,
    inputData: CreateCardInput // Expects object with optional classifications
): Promise<ActionResult<Tables<'cards'>>> {
    appLogger.info(`[createCard - Single] Action started for deckId: ${deckId}`);
    if (!deckId) return { data: null, error: 'Deck ID is required.' };

    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
             appLogger.error('[createCard - Single] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }

        const validation = createCardSchema.safeParse(inputData);
        if (!validation.success) {
             appLogger.warn("[createCard - Single] Validation failed:", validation.error.errors);
             return { data: null, error: validation.error.errors[0].message };
        }
        // Extract all fields from validated data
        const {
            question,
            answer,
            question_part_of_speech,
            question_gender,
            answer_part_of_speech,
            answer_gender
        } = validation.data;

        // Verify user owns the target deck (unchanged)
        const { count: deckCount, error: deckCheckError } = await supabase
            .from('decks')
            .select('id', { count: 'exact', head: true })
            .eq('id', deckId)
            .eq('user_id', user.id);

        if (deckCheckError || deckCount === 0) {
             appLogger.error('[createCard - Single] Deck ownership check failed:', deckCheckError);
             return { data: null, error: 'Target deck not found or access denied.' };
        }

        appLogger.info(`[createCard - Single] User: ${user.id}, Creating card in deck ${deckId}`);

        // Insert Payload (Uses validated data)
        const insertPayload: Database['public']['Tables']['cards']['Insert'] = {
            user_id: user.id,
            deck_id: deckId,
            question: question,
            answer: answer,
            question_part_of_speech: question_part_of_speech ?? 'N/A',
            question_gender: question_gender ?? 'N/A',
            answer_part_of_speech: answer_part_of_speech ?? 'N/A',
            answer_gender: answer_gender ?? 'N/A',
            // Set SRS defaults explicitly
            srs_level: 0,
            easiness_factor: 2.5,
            interval_days: 0,
            stability: null,
            difficulty: null,
            next_review_due: null,
            last_reviewed_at: null,
            last_review_grade: null,
            attempt_count: 0,
            correct_count: 0,
            incorrect_count: 0,
        };

        const { data: newCard, error: insertError } = await supabase
            .from('cards')
            .insert(insertPayload)
             // Select clause already updated previously
            .select(`
                *,
                question_part_of_speech,
                question_gender,
                answer_part_of_speech,
                answer_gender,
                decks(primary_language, secondary_language)
            `)
            .single();

        if (insertError) {
            appLogger.error('[createCard - Single] Insert error:', insertError);
            return { data: null, error: insertError.message || 'Failed to create card.' };
        }

        if (!newCard) {
             appLogger.error('[createCard - Single] Insert succeeded but no data returned.');
             return { data: null, error: 'Failed to retrieve created card data.' };
        }

        appLogger.info(`[createCard - Single] Success, New Card ID: ${newCard.id}`);
        revalidatePath(`/edit/${deckId}`);
        return { data: newCard as Tables<'cards'>, error: null };

    } catch (error) {
        appLogger.error('[createCard - Single] Caught unexpected error:', error);
        return { data: null, error: error instanceof Error ? error.message : 'Unknown error creating card' };
    }
}


/**
 * Updates an existing flashcard.
 *
 * @param cardId - ID of the card to update
 * @param inputData - Partial card object including optional classifications
 * @returns The updated card
 */
export async function updateCard(
    cardId: string,
    inputData: UpdateCardInput // Uses updated schema type
): Promise<ActionResult<Tables<'cards'>>> {
    appLogger.info(`[updateCard] Action started for cardId: ${cardId}`);
    if (!cardId) return { data: null, error: 'Card ID is required.' };

    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
             appLogger.error('[updateCard] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }

        const validation = updateCardSchema.safeParse(inputData);
        if (!validation.success) {
             appLogger.warn("[updateCard] Validation failed:", validation.error.errors);
             return { data: null, error: validation.error.errors[0].message };
        }
        const updatePayload = validation.data; // Contains validated optional fields

        if (Object.keys(updatePayload).length === 0) {
             return { data: null, error: "No fields provided for update." };
        }

        appLogger.info(`[updateCard] User: ${user.id}, Updating card ${cardId} with:`, updatePayload);

        // Update logic remains largely the same, Supabase handles optional fields
        const { data: updatedCard, error: updateError } = await supabase
            .from('cards')
            .update({
                ...updatePayload,
                updated_at: new Date().toISOString() // Manually set updated_at
            })
            .eq('id', cardId)
            .eq('user_id', user.id)
            // Select clause already updated previously
            .select(`
                *,
                question_part_of_speech,
                question_gender,
                answer_part_of_speech,
                answer_gender,
                decks(primary_language, secondary_language)
            `)
            .single();

        if (updateError) {
            appLogger.error('[updateCard] Update error:', updateError);
            return { data: null, error: updateError.message || 'Failed to update card.' };
        }

        if (!updatedCard) {
             appLogger.warn(`[updateCard] Card ${cardId} not found or not authorized for update.`);
             return { data: null, error: 'Card not found or update failed.' };
        }

        appLogger.info(`[updateCard] Success, ID: ${updatedCard.id}`);
        // Revalidation logic remains the same
        return { data: updatedCard as Tables<'cards'>, error: null };

    } catch (error) {
        appLogger.error('[updateCard] Caught unexpected error:', error);
        return { data: null, error: error instanceof Error ? error.message : 'Unknown error updating card' };
    }
}


// Batch Creation Action (already updated)
export async function createCardsBatch(
    deckId: string,
    cardsData: CreateCardInput[] // Expects array of objects matching the schema
): Promise<ActionResult<{ insertedCount: number }>> {
    appLogger.info(`[createCardsBatch] Action started for deckId: ${deckId}, batch size: ${cardsData?.length}`);
    if (!deckId) return { data: null, error: 'Deck ID is required.' };
    if (!cardsData || cardsData.length === 0) {
        appLogger.info('[createCardsBatch] No card data provided.');
        return { data: { insertedCount: 0 }, error: null }; // Not an error, just nothing to insert
    }

    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
             appLogger.error('[createCardsBatch] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }

        // Verify user owns the target deck ONCE (Unchanged)
        const { count: deckCount, error: deckCheckError } = await supabase
            .from('decks')
            .select('id', { count: 'exact', head: true })
            .eq('id', deckId)
            .eq('user_id', user.id);

        if (deckCheckError || deckCount === 0) {
             appLogger.error('[createCardsBatch] Deck ownership check failed:', deckCheckError);
             return { data: null, error: 'Target deck not found or access denied.' };
        }

        appLogger.info(`[createCardsBatch] User: ${user.id}, Preparing ${cardsData.length} cards for batch insert into deck ${deckId}`);

        // Map and Filter in one go using reduce
        const cardsToInsert = cardsData.reduce<Database['public']['Tables']['cards']['Insert'][]>((acc, inputCard) => {
            const validation = createCardSchema.safeParse(inputCard);
            if (!validation.success) {
                appLogger.warn("[createCardsBatch] Skipping invalid card data:", validation.error.errors, inputCard);
                return acc;
            }

            const {
                question,
                answer,
                question_part_of_speech,
                question_gender,
                answer_part_of_speech,
                answer_gender
            } = validation.data;

            acc.push({
                user_id: user.id,
                deck_id: deckId,
                question: question,
                answer: answer,
                question_part_of_speech: question_part_of_speech ?? 'N/A',
                question_gender: question_gender ?? 'N/A',
                answer_part_of_speech: answer_part_of_speech ?? 'N/A',
                answer_gender: answer_gender ?? 'N/A',
                srs_level: 0,
                easiness_factor: 2.5,
                interval_days: 0,
                stability: null,
                difficulty: null,
                next_review_due: null,
                last_reviewed_at: null,
                last_review_grade: null,
                attempt_count: 0,
                correct_count: 0,
                incorrect_count: 0,
            });
            return acc;
        }, []);


        if (cardsToInsert.length === 0) {
            appLogger.warn(`[createCardsBatch] No valid cards remaining after validation for deck ${deckId}.`);
            return { data: { insertedCount: 0 }, error: null };
        }

        appLogger.info(`[createCardsBatch] Inserting ${cardsToInsert.length} valid cards...`);

        const { error: insertError } = await supabase
            .from('cards')
            .insert(cardsToInsert);

        if (insertError) {
            appLogger.error('[createCardsBatch] Batch insert error:', insertError);
            return { data: null, error: insertError.message || 'Failed to create cards in batch.' };
        }

        const insertedCount = cardsToInsert.length;
        appLogger.info(`[createCardsBatch] Success, Inserted Count: ${insertedCount}`);
        revalidatePath(`/edit/${deckId}`);
        return { data: { insertedCount }, error: null };

    } catch (error) {
        appLogger.error('[createCardsBatch] Caught unexpected error:', error);
        return { data: null, error: error instanceof Error ? error.message : 'Unknown error creating cards in batch' };
    }
}


// getCardsByDeckId function remains unchanged (already updated select)
export async function getCardsByDeckId(deckId: string): Promise<ActionResult<Tables<'cards'>[]>> {
    // Implementation already updated...
    appLogger.info(`[getCardsByDeckId] Fetching cards for deck: ${deckId}`);
    const supabase = createActionClient();

    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
        appLogger.error('[getCardsByDeckId] Auth error:', authError);
        return { data: null, error: authError?.message || 'Not authenticated' };
    }

    const { data, error } = await supabase
        .from('cards')
        .select(`
            *,
            question_part_of_speech,
            question_gender,
            answer_part_of_speech,
            answer_gender
        `)
        .eq('deck_id', deckId)
        .eq('user_id', user.id);

    if (error) {
        appLogger.error(`[getCardsByDeckId] Error fetching cards for deck ${deckId}:`, error);
        return { data: null, error: error.message || 'Failed to fetch cards' };
    }

    return { data: (data || []) as Tables<'cards'>[], error: null };
}


// deleteCard function remains unchanged
export async function deleteCard(cardId: string): Promise<ActionResult<null>> {
    // Implementation remains the same...
    appLogger.info(`[deleteCard] Action started for cardId: ${cardId}`);
    if (!cardId) return { data: null, error: 'Card ID is required.' };

    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            appLogger.error('[deleteCard] Auth error:', authError);
            return { data: null, error: authError?.message || 'Not authenticated' };
        }

        const { error: deleteError } = await supabase
            .from('cards')
            .delete()
            .eq('id', cardId)
            .eq('user_id', user.id);

        if (deleteError) {
            appLogger.error('[deleteCard] Delete error:', deleteError);
            return { data: null, error: deleteError.message || 'Failed to delete card.' };
        }

        return { data: null, error: null };

    } catch (error) {
        appLogger.error('[deleteCard] Caught unexpected error:', error);
        return { data: null, error: error instanceof Error ? error.message : 'Unknown error deleting card' };
    }
}

/**
 * Efficiently retrieves only SRS state information for a list of card IDs
 * Used for optimized card counting by SRS state without fetching full card data
 */
export async function getCardSrsStatesByIds(cardIds: string[]): Promise<ActionResult<Partial<Tables<'cards'>>[]>> {
  try {
    // If no card IDs provided, return empty result
    if (!cardIds?.length) {
      return { data: [], error: null };
    }

    // Create Supabase client
    const supabase = createActionClient();
    
    // Check authentication
    const { data: { user }, error: authError } = await supabase.auth.getUser();
    if (authError || !user) {
      appLogger.error('Error in authentication:', authError);
      return { error: 'Not authenticated', data: null };
    }

    // Limited to 1000 cards for performance reasons
    const limitedCardIds = cardIds.slice(0, 1000);

    // Fetch only the SRS-related fields we need for counting
    const { data, error } = await supabase
      .from('cards')
      .select(`
        id,
        srs_level,
        learning_state,
        next_review_due,
        learning_step_index,
        failed_attempts_in_learn,
        hard_attempts_in_learn
      `)
      .in('id', limitedCardIds)
      .eq('user_id', user.id);

    if (error) {
      appLogger.error('Error fetching card SRS states:', error);
      return { error: error.message, data: null };
    }

    return { data, error: null };
  } catch (error) {
    appLogger.error('Error in getCardSrsStatesByIds:', error);
    return {
      error: error instanceof Error ? error.message : 'Unknown error getting card SRS states',
      data: null
    };
  }
}
```

### File: lib/actions/deckActions.ts

```
// lib/actions/deckActions.ts
'use server';

import { createActionClient } from "@/lib/supabase/server";
import type { Database, Tables, Json, TablesUpdate } from "@/types/database"; // Import TablesUpdate
import type { ActionResult } from "@/lib/actions/types";
import { revalidatePath } from 'next/cache';
import { appLogger, statusLogger } from '@/lib/logger';

export type DeckListItemWithCounts = {
    id: string;
    name: string;
    primary_language: string | null;
    secondary_language: string | null;
    is_bilingual: boolean;
    updated_at: string;
    new_count: number;
    learning_count: number;
    young_count: number;
    mature_count: number;
    learn_eligible_count: number;
    review_eligible_count: number;
};

type DeckWithTags = Tables<'decks'> & { tags: Tables<'tags'>[] };
export type DeckWithCardsAndTags = DeckWithTags & { cards: Tables<'cards'>[] };

import { createDeckSchema, updateDeckSchema } from '@/lib/schema/deckSchemas';
import type { CreateDeckInput, UpdateDeckInput } from '@/lib/schema/deckSchemas';


export async function getDecks(): Promise<ActionResult<DeckListItemWithCounts[]>> {
    appLogger.info("[deckActions - getDecks] Action started - fetching via RPC get_decks_with_complete_srs_counts");
    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            appLogger.error('[deckActions - getDecks] Auth error or no user:', authError);
            return { data: null, error: authError?.message || 'Not authenticated' };
        }

        appLogger.info(`[deckActions - getDecks] User authenticated: ${user.id}, calling RPC get_decks_with_complete_srs_counts`);

        const { data: rpcData, error: rpcError } = await supabase.rpc(
            'get_decks_with_complete_srs_counts',
            { p_user_id: user.id }
        );

        if (rpcError) {
            appLogger.error('[deckActions - getDecks] Supabase RPC failed:', rpcError);
            return { data: null, error: rpcError.message || 'Failed to fetch decks via RPC.' };
        }

        const processedData = (rpcData || []).map(deck => ({
            ...deck,
            new_count: Number(deck.new_count ?? 0),
            learning_count: Number(deck.learning_count ?? 0),
            young_count: Number(deck.young_count ?? 0),
            mature_count: Number(deck.mature_count ?? 0),
            learn_eligible_count: Number(deck.learn_eligible_count ?? 0),
            review_eligible_count: Number(deck.review_eligible_count ?? 0),
            // Ensure primary_language and secondary_language are handled if RPC can return null
            // but your type DeckListItemWithCounts expects string (though it allows null now)
            primary_language: deck.primary_language, // Assuming RPC returns string or null matching type
            secondary_language: deck.secondary_language,
            is_bilingual: deck.is_bilingual,
            updated_at: deck.updated_at,
        }));

        appLogger.info(`[deckActions - getDecks] Successfully fetched and processed ${processedData.length} decks via RPC.`);
        return { data: processedData as DeckListItemWithCounts[], error: null };

    } catch (err: any) {
        appLogger.error('[deckActions - getDecks] Caught unexpected error:', err);
        return { data: null, error: err.message || 'An unexpected error occurred while fetching decks.' };
    }
}

export async function getDeck(
    deckId: string
): Promise<ActionResult<DeckWithCardsAndTags | null>> {
    appLogger.info(`[deckActions - getDeck] Action started for deckId: ${deckId}`);
    if (!deckId) {
        return { data: null, error: 'Deck ID is required.' };
    }
    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            appLogger.error('[deckActions - getDeck] Auth error or no user:', authError);
            return { data: null, error: authError?.message || 'Not authenticated' };
        }
        appLogger.info(`[deckActions - getDeck] User authenticated: ${user.id}, fetching deck ${deckId}`);
        const { data: deckData, error: dbError } = await supabase
            .from('decks')
            .select(`*, cards (*), tags (*)`)
            .eq('id', deckId)
            .eq('user_id', user.id)
            .maybeSingle();
        if (dbError) {
            appLogger.error('[deckActions - getDeck] Database error:', dbError);
            return { data: null, error: dbError.message || 'Failed to fetch deck data.' };
        }
        if (!deckData) {
            appLogger.info('[deckActions - getDeck] Deck not found or not authorized:', deckId);
            return { data: null, error: null };
        }
        const deckWithDetails = {
            ...deckData,
            cards: (deckData.cards || []) as Tables<'cards'>[],
            tags: (deckData.tags || []) as Tables<'tags'>[]
        };
        appLogger.info(`[deckActions - getDeck] Successfully fetched deck ${deckId} with ${deckWithDetails.cards.length} cards and ${deckWithDetails.tags.length} tags.`);
        return { data: deckWithDetails as DeckWithCardsAndTags, error: null };
    } catch (error) {
        appLogger.error('[deckActions - getDeck] Caught unexpected error:', error);
        const errorMessage = error instanceof Error ? error.message : 'An unknown error occurred.';
        return { data: null, error: errorMessage };
    }
}

export async function createDeck(
    inputData: CreateDeckInput
): Promise<ActionResult<Tables<'decks'>>> {
    appLogger.info(`[deckActions - createDeck] Action started.`);
    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
             appLogger.error('[deckActions - createDeck] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }
        const validation = createDeckSchema.safeParse(inputData);
        if (!validation.success) {
             appLogger.warn("[deckActions - createDeck] Validation failed:", validation.error.format());
             return { data: null, error: validation.error.flatten().fieldErrors.name?.[0] || "Invalid input." };
        }
        const { name, primary_language, secondary_language, is_bilingual } = validation.data;
        appLogger.info(`[deckActions - createDeck] User: ${user.id}, Creating deck: ${name}`);
        const { data: newDeck, error: insertError } = await supabase
            .from('decks')
            .insert({
                user_id: user.id,
                name,
                primary_language: primary_language ?? 'en',
                secondary_language: secondary_language ?? primary_language ?? 'en',
                is_bilingual: is_bilingual ?? false,
            })
            .select()
            .single();
        if (insertError) {
            appLogger.error('[deckActions - createDeck] Insert error:', insertError);
            return { data: null, error: insertError.message || 'Failed to create deck.' };
        }
        appLogger.info(`[deckActions - createDeck] Success, ID: ${newDeck?.id}`);
        revalidatePath('/');
        revalidatePath('/study/select');
        return { data: newDeck, error: null };
    } catch (error) {
        appLogger.error('[deckActions - createDeck] Caught unexpected error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error creating deck';
        return { data: null, error: errorMessage };
    }
}

export async function updateDeck(
    deckId: string,
    inputData: UpdateDeckInput
): Promise<ActionResult<Tables<'decks'>>> {
     appLogger.info(`[deckActions - updateDeck] Action started for deckId: ${deckId}`);
     if (!deckId) return { data: null, error: 'Deck ID is required.' };
     try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
             appLogger.error('[deckActions - updateDeck] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }
        const validation = updateDeckSchema.safeParse(inputData);
        if (!validation.success) {
             appLogger.warn("[deckActions - updateDeck] Validation failed:", validation.error.format());
             return { data: null, error: validation.error.flatten().fieldErrors.name?.[0] || "Invalid input." };
        }
        const updatesFromSchema = validation.data;

        // FIX: Prepare payload for Supabase, converting nulls to undefined for optional fields
        // if the DB schema doesn't want explicit nulls for updates where a value previously existed.
        // However, `TablesUpdate<'decks'>` usually defines optional fields as `string | undefined`, not `string | null | undefined`.
        // The `updateDeckSchema` uses `.nullable().optional()`, so `updatesFromSchema` can have `null`.
        // We need to ensure the payload passed to `.update()` matches `Partial<TablesUpdate<'decks'>>`.
        const dbUpdatePayload: Partial<TablesUpdate<'decks'>> = {};
        if (updatesFromSchema.name !== undefined) dbUpdatePayload.name = updatesFromSchema.name;
        if (updatesFromSchema.is_bilingual !== undefined) dbUpdatePayload.is_bilingual = updatesFromSchema.is_bilingual ?? undefined; // Handle null for boolean

        // For string fields that can be null in schema but undefined in DB update type
        dbUpdatePayload.primary_language = updatesFromSchema.primary_language === null ? undefined : updatesFromSchema.primary_language;
        dbUpdatePayload.secondary_language = updatesFromSchema.secondary_language === null ? undefined : updatesFromSchema.secondary_language;

        // Remove any keys that are explicitly undefined to avoid sending them
        Object.keys(dbUpdatePayload).forEach(keyStr => {
            const key = keyStr as keyof typeof dbUpdatePayload;
            if (dbUpdatePayload[key] === undefined) {
                delete dbUpdatePayload[key];
            }
        });


        if (Object.keys(dbUpdatePayload).length === 0) {
             return { data: null, error: "No valid fields provided for update." };
        }

        appLogger.info(`[deckActions - updateDeck] User: ${user.id}, Updating deck ${deckId} with:`, dbUpdatePayload);

        const { data: updatedDeck, error: updateError } = await supabase
            .from('decks')
            .update(dbUpdatePayload) // Use the explicitly typed payload
            .eq('id', deckId)
            .eq('user_id', user.id)
            .select()
            .single();
        if (updateError) {
            appLogger.error('[deckActions - updateDeck] Update error:', updateError);
            return { data: null, error: updateError.message || 'Failed to update deck.' };
        }
        if (!updatedDeck) {
             appLogger.warn(`[deckActions - updateDeck] Deck ${deckId} not found or not authorized for update.`);
             return { data: null, error: 'Deck not found or update failed.' };
        }
        appLogger.info(`[deckActions - updateDeck] Success, ID: ${updatedDeck.id}`);
        revalidatePath('/');
        revalidatePath('/study/select');
        revalidatePath(`/edit/${deckId}`);
        return { data: updatedDeck, error: null };
    } catch (error) {
        appLogger.error('[deckActions - updateDeck] Caught unexpected error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error updating deck';
        return { data: null, error: errorMessage };
    }
}

export async function deleteDeck(
    deckId: string
): Promise<ActionResult<null>> {
     appLogger.info(`[deckActions - deleteDeck] Action started for deckId: ${deckId}`);
     if (!deckId) return { data: null, error: 'Deck ID is required.' };
      try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
             appLogger.error('[deckActions - deleteDeck] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }
        appLogger.info(`[deckActions - deleteDeck] User: ${user.id}, Deleting deck ${deckId}`);
        const { error: deleteError, count } = await supabase
            .from('decks')
            .delete()
            .eq('id', deckId)
            .eq('user_id', user.id);
        if (deleteError) {
            appLogger.error('[deckActions - deleteDeck] Delete error:', deleteError);
            return { data: null, error: deleteError.message || 'Failed to delete deck.' };
        }
         if (count === 0) {
             appLogger.warn("[deckActions - deleteDeck] Delete affected 0 rows for ID:", deckId);
        }
        appLogger.info(`[deckActions - deleteDeck] Success for ID: ${deckId}`);
        revalidatePath('/');
        revalidatePath('/study/select');
        return { data: null, error: null };
    } catch (error) {
        appLogger.error('[deckActions - deleteDeck] Caught unexpected error:', error);
        const errorMessage = error instanceof Error ? error.message : 'Unknown error deleting deck';
        return { data: null, error: errorMessage };
    }
}

/**
 * @deprecated Prefer using the main `getDecks()` function which now uses the new RPC.
 */
export async function getDecksWithSrsCounts(): Promise<ActionResult<DeckListItemWithCounts[]>> {
  appLogger.warn("[deckActions - getDecksWithSrsCounts] This function is deprecated. Use getDecks() instead.");
  return getDecks();
}
```

### File: lib/actions/progressActions.ts

```
"use server";

import { createActionClient, createDynamicRouteClient } from "@/lib/supabase/server";
// import { cookies } from "next/headers";
import type { Database, Tables, TablesUpdate } from "@/types/database";
import type { ActionResult } from '@/lib/actions/types';
import { updateCardProgressSchema, cardUpdateFieldsSchema } from "@/lib/schema/card.schema"; // Remove .ts extension
import type { z } from 'zod';
import { appLogger, statusLogger } from '@/lib/logger';

/**
 * Server actions for managing study progress and SRS state.
 * 
 * This module provides:
 * - Card progress tracking and updates
 * - SRS state management
 * - Study session progress persistence
 * 
 * @module progressActions
 */

/**
 * Updates a card's progress and SRS state based on a review grade.
 * 
 * @param {object} input - The input object matching updateCardProgressSchema.
 * @param {string} input.cardId - ID of the card to update.
 * @param {number} input.grade - The grade given to the card (1-4).
 * @param {object} input.updatedFields - An object containing the card fields to update (matching cardUpdateFieldsSchema).
 * @returns {Promise<ActionResult<Tables<'cards'>>>} The result of the action, containing the updated card data or an error.
 */
export async function updateCardProgress(
    input: z.infer<typeof updateCardProgressSchema> // Use Zod type for input
): Promise<ActionResult<Tables<'cards'>>> { // Return ActionResult

    const validationResult = updateCardProgressSchema.safeParse(input);

    if (!validationResult.success) {
        appLogger.error('[updateCardProgress] Invalid input:', validationResult.error.flatten());
        return { data: null, error: "Invalid input: " + validationResult.error.flatten().fieldErrors };
    }

    const { cardId, grade, updatedFields } = validationResult.data;

    appLogger.info(`[updateCardProgress] Action started for cardId: ${cardId}`, { grade, updatedFields });
    
    try {
        const supabase = createActionClient(); // No need to await createActionClient
        
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            appLogger.error('[updateCardProgress] Auth error or no user:', authError);
            return { data: null, error: authError?.message || 'Not authenticated' };
        }
        
        // Construct the DB update payload from validated fields
        // The keys in updatedFields are already snake_case as defined in the schema
        const dbUpdatePayload: Partial<TablesUpdate<'cards'>> = {
            ...updatedFields, // Spread all validated fields
            last_reviewed_at: new Date().toISOString(), // Set timestamp
            last_review_grade: grade, // Set the grade that triggered this update
            user_id: user.id // Ensure user_id is set for RLS, though update might handle it
        };
        
        appLogger.info("[updateCardProgress] DB update payload prepared:", dbUpdatePayload);

        // Perform the update
        appLogger.info(`[updateCardProgress] Updating card ${cardId}`);
        const { data: updatedCardData, error: updateError } = await supabase
            .from('cards')
            .update(dbUpdatePayload)
            .eq('id', cardId)
            .eq('user_id', user.id) // Ensure RLS check on update
            .select('*')
            .single();
            
        appLogger.info("[updateCardProgress] Supabase update result:", { updateError });

        if (updateError) {
            appLogger.error("[updateCardProgress] Error during Supabase update:", updateError);
             // Consider mapping specific DB error codes (like 23503 FK violation) to user-friendly messages
            return { data: null, error: updateError.message || "Failed to update card progress." };
        }
        
        if (!updatedCardData) {
             appLogger.error("[updateCardProgress] No data returned after update.");
             return { data: null, error: "Failed to confirm card update." };
        }

        appLogger.info("[updateCardProgress] Successfully updated card:", cardId);
        return { data: updatedCardData, error: null }; // Return success with updated card

    } catch (error: unknown) {
        appLogger.error("[updateCardProgress] Caught unexpected error:", error); // Log the full error object
        const errorMsg = error instanceof Error ? error.message : "An unknown error occurred.";
        // Log specific details if available (e.g., PostgreSQL error code)
        if (error && typeof error === 'object' && 'code' in error) {
           appLogger.error("[updateCardProgress] DB Error Code:", error.code);
        }
        return { data: null, error: `Failed to update card progress: ${errorMsg}` };
    }
}

/**
 * Resets a card's progress and SRS state.
 * 
 * @param {Object} params - Progress reset parameters
 * @param {string} params.cardId - ID of the card to reset
 * @returns {Promise<ActionResult<Tables<'cards'>>>} The result of the action, containing the reset card data or an error.
 * @throws {Error} If progress reset fails or user is not authenticated
 */
export async function resetCardProgress({
  cardId,
}: {
  cardId: string;
}): Promise<ActionResult<Tables<'cards'>>> { // Return ActionResult
    appLogger.info(`[resetCardProgress] Action started for cardId: ${cardId}`);
    
    if (!cardId || typeof cardId !== 'string' || !cardId.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/)) {
        appLogger.error("[resetCardProgress] Invalid Card ID provided.");
        return { data: null, error: "Invalid Card ID provided." };
    }

    try {
        const supabase = createActionClient();
        
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
            appLogger.error('[resetCardProgress] Auth error or no user:', authError);
            return { data: null, error: authError?.message || 'Not authenticated' };
        }
        
        // Reset payload - include new fields with default/reset values
        const resetPayload: Partial<TablesUpdate<'cards'>> = {
            last_reviewed_at: null,
            next_review_due: null,
            srs_level: 0,
            easiness_factor: 2.5, // Use DB default or settings default?
            interval_days: 0,
            last_review_grade: null,
            correct_count: 0,
            incorrect_count: 0,
            attempt_count: 0,
            // Reset new fields
            learning_state: null,
            learning_step_index: null,
            failed_attempts_in_learn: 0,
            hard_attempts_in_learn: 0,
            user_id: user.id
        };
        
        appLogger.info("[resetCardProgress] DB reset payload prepared:", resetPayload);

        // Perform the reset
        appLogger.info(`[resetCardProgress] Resetting card ${cardId}`);
        const { data: resetResult, error: resetError } = await supabase
            .from('cards')
            .update(resetPayload)
            .eq('id', cardId)
            .eq('user_id', user.id) // Ensure RLS check
            .select('*')
            .single();
            
        appLogger.info("[resetCardProgress] Supabase reset result:", { resetError });

        if (resetError) {
            appLogger.error("[resetCardProgress] Error during Supabase reset:", resetError);
            return { data: null, error: resetError.message || "Failed to reset card progress." };
        }

        if (!resetResult) {
            appLogger.error("[resetCardProgress] No data returned after reset.");
            return { data: null, error: "Failed to confirm card reset." };
        }

        appLogger.info("[resetCardProgress] Successfully reset card:", cardId);
        return { data: resetResult, error: null }; // Return success with reset card

    } catch (error: unknown) {
        appLogger.error("[resetCardProgress] Caught unexpected error:", error); // Log the full error object
        const errorMsg = error instanceof Error ? error.message : "An unknown error occurred.";
        return { data: null, error: `Failed to reset card progress: ${errorMsg}` };
    }
} 
```

### File: lib/actions/settingsActions.ts

```
// lib/actions/settingsActions.ts
"use server";

import { createActionClient } from '@/lib/supabase/server';
// import { revalidatePath } from 'next/cache';
import { z } from 'zod';
// Ensure types/database includes the new settings columns
import type { Database, Tables, Json } from "@/types/database";
import type { ActionResult } from '@/lib/actions/types';
// Import the Settings type used by the frontend/provider
import type { Settings, FontOption } from "@/providers/settings-provider";
import { appLogger, statusLogger } from '@/lib/logger';

type DbSettings = Tables<'settings'>;

// --- UPDATED Zod Schema ---
const updateSettingsSchema = z.object({
  appLanguage: z.string().optional(),
  cardFont: z.enum(["default", "opendyslexic", "atkinson"]).optional(),
  showDifficulty: z.boolean().optional().nullable(),
  masteryThreshold: z.number().int().min(1).max(10).optional().nullable(),
  ttsEnabled: z.boolean().optional().nullable(),
  srs_algorithm: z.enum(['sm2', 'fsrs']).optional(),
  languageDialects: z.record(z.string()).optional().nullable(),
  enableBasicColorCoding: z.boolean().optional().nullable(),
  enableAdvancedColorCoding: z.boolean().optional().nullable(),
  // --- Replaced wordColorConfig with wordPaletteConfig ---
  wordPaletteConfig: z.record(z.record(z.string())).optional().nullable(), // Expects { PoS: { Gender: PaletteID }}
  // ------------------------------------------------------
}).partial();


// getUserSettings function (Remains unchanged)
export async function getUserSettings(): Promise<ActionResult<DbSettings | null>> {
    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) return { data: null, error: authError?.message || 'Not authenticated' };

        const { data, error } = await supabase
            .from('settings')
            .select('*')
            .eq('user_id', user.id)
            .maybeSingle();

        if (error) return { data: null, error: error.message || "Failed to fetch settings." };
        return { data: data, error: null };

    } catch (error: any) {
        return { data: null, error: error.message || 'Unknown error fetching settings' };
    }
}

/**
 * Updates user settings.
 */
export async function updateUserSettings({
  updates,
}: {
  updates: Partial<Settings>; // Expect camelCase from provider
}): Promise<ActionResult<DbSettings | null>> {
    appLogger.info(`[updateUserSettings] Action started.`);
    try {
        const supabase = createActionClient();
        const { data: { user }, error: authError } = await supabase.auth.getUser();

        if (authError || !user) {
             appLogger.error('[updateUserSettings] Auth error:', authError);
             return { data: null, error: authError?.message || 'Not authenticated' };
        }

        // Manual Mapping from frontend camelCase to DB snake_case
        const dbPayload: Partial<DbSettings> = {};

        // Map fields 
        if ('appLanguage' in updates && updates.appLanguage !== undefined) dbPayload.app_language = updates.appLanguage;
        if ('cardFont' in updates && updates.cardFont !== undefined) dbPayload.card_font = updates.cardFont;
        if ('showDifficulty' in updates && updates.showDifficulty !== undefined) dbPayload.show_difficulty = updates.showDifficulty;
        if ('ttsEnabled' in updates && updates.ttsEnabled !== undefined) dbPayload.tts_enabled = updates.ttsEnabled;
        if ('languageDialects' in updates && updates.languageDialects !== undefined) dbPayload.language_dialects = updates.languageDialects as Json;
        if ('colorOnlyNonNative' in updates && updates.colorOnlyNonNative !== undefined) dbPayload.color_only_non_native = updates.colorOnlyNonNative;
        if ('enableBasicColorCoding' in updates && updates.enableBasicColorCoding !== undefined) dbPayload.enable_basic_color_coding = updates.enableBasicColorCoding;
        if ('enableAdvancedColorCoding' in updates && updates.enableAdvancedColorCoding !== undefined) dbPayload.enable_advanced_color_coding = updates.enableAdvancedColorCoding;
        if ('wordPaletteConfig' in updates && updates.wordPaletteConfig !== undefined) dbPayload.word_palette_config = updates.wordPaletteConfig as Json;
        if ('showDeckProgress' in updates && updates.showDeckProgress !== undefined) dbPayload.show_deck_progress = updates.showDeckProgress;
        if ('themePreference' in updates && updates.themePreference !== undefined) dbPayload.theme_light_dark_mode = String(updates.themePreference);

        // --- NEW Study Algorithm Mappings ---
        // Note: studyAlgorithm itself might not map directly if derived from enableDedicatedLearnMode
        if ('enableDedicatedLearnMode' in updates && updates.enableDedicatedLearnMode !== undefined) dbPayload.enable_dedicated_learn_mode = updates.enableDedicatedLearnMode;
        if ('masteryThreshold' in updates && updates.masteryThreshold !== undefined) dbPayload.mastery_threshold = updates.masteryThreshold;
        if ('customLearnRequeueGap' in updates && updates.customLearnRequeueGap !== undefined) dbPayload.custom_learn_requeue_gap = updates.customLearnRequeueGap;
        if ('graduatingIntervalDays' in updates && updates.graduatingIntervalDays !== undefined) dbPayload.graduating_interval_days = updates.graduatingIntervalDays;
        if ('easyIntervalDays' in updates && updates.easyIntervalDays !== undefined) dbPayload.easy_interval_days = updates.easyIntervalDays;
        if ('relearningStepsMinutes' in updates && updates.relearningStepsMinutes !== undefined) dbPayload.relearning_steps_minutes = updates.relearningStepsMinutes;
        if ('initialLearningStepsMinutes' in updates && updates.initialLearningStepsMinutes !== undefined) dbPayload.initial_learning_steps_minutes = updates.initialLearningStepsMinutes;
        if ('lapsedEfPenalty' in updates && updates.lapsedEfPenalty !== undefined) dbPayload.lapsed_ef_penalty = updates.lapsedEfPenalty;
        if ('learnAgainPenalty' in updates && updates.learnAgainPenalty !== undefined) dbPayload.learn_again_penalty = updates.learnAgainPenalty;
        if ('learnHardPenalty' in updates && updates.learnHardPenalty !== undefined) dbPayload.learn_hard_penalty = updates.learnHardPenalty;
        if ('minEasinessFactor' in updates && updates.minEasinessFactor !== undefined) dbPayload.min_easiness_factor = updates.minEasinessFactor;
        if ('defaultEasinessFactor' in updates && updates.defaultEasinessFactor !== undefined) dbPayload.default_easiness_factor = updates.defaultEasinessFactor;
        // ------------------------------------

        if (Object.keys(dbPayload).length === 0) {
             appLogger.info("[updateUserSettings] No valid fields provided for update after mapping.");
             const { data: currentSettings } = await getUserSettings();
             return { data: currentSettings, error: null };
        }

        // Add updated_at timestamp
        dbPayload.updated_at = new Date().toISOString();

        appLogger.info(`[updateUserSettings] User: ${user.id}, Upserting payload:`, dbPayload);

        // Perform Upsert (unchanged logic)
        const { data: updatedSettings, error: upsertError } = await supabase
            .from('settings')
            .upsert({ ...dbPayload, user_id: user.id }, { onConflict: 'user_id' })
            .select()
            .single();

        if (upsertError) {
            appLogger.error('[updateUserSettings] Upsert error:', upsertError);
            return { data: null, error: upsertError.message || 'Failed to update settings.' };
        }

        if (!updatedSettings) {
             appLogger.error('[updateUserSettings] No data returned after upsert.');
             return { data: null, error: 'Failed to confirm settings update.' };
        }

        appLogger.info(`[updateUserSettings] Success for user: ${user.id}`);
        return { data: updatedSettings, error: null }; // Return raw DB data

    } catch (error: any) {
        appLogger.error('[updateUserSettings] Caught unexpected error:', error);
        return { data: null, error: error.message || 'Unknown error updating settings' };
    }
}
```

### File: lib/actions/storageActions.ts

```
'use server'

import { createActionClient } from '@/lib/supabase/server';
import { v4 as uuidv4 } from 'uuid';
import { appLogger, statusLogger } from '@/lib/logger';

const UPLOAD_BUCKET = 'ai-uploads';
const EXPIRY_SECONDS = 3600; // 1 hour

/**
 * Uploads a file to Supabase Storage using FormData from a Server Action
 * @param formData The FormData object containing the file, fileName, and fileType
 * @returns Object containing the file path and URL
 */
export async function uploadFileToStorage(formData: FormData) {
  const file = formData.get('file') as File | null;
  const fileName = formData.get('fileName') as string | null;
  const fileType = formData.get('fileType') as string | null;

  if (!file) {
    throw new Error('No file found in FormData');
  }
  if (!fileType) {
    throw new Error('No fileType found in FormData');
  }

  const supabase = createActionClient();
  
  // Get the authenticated user
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    appLogger.error('Authentication error in uploadFileToStorage', authError);
    throw new Error('You must be logged in to upload files');
  }
  
  // Convert File to ArrayBuffer/Buffer for upload
  const fileBuffer = await file.arrayBuffer();
  
  // Create a unique filename (use provided fileName if available)
  const fileExt = fileName ? `.${fileName.split('.').pop()}` : '';
  const storageFileName = fileName || `${uuidv4()}${fileExt}`;
  
  // Path format: userId/uniqueId-filename
  const path = `${user.id}/${storageFileName}`;
  
  appLogger.info(`[StorageAction] Preparing upload. User ID: ${user.id}, Path: ${path}, Bucket: ${UPLOAD_BUCKET}, Type: ${fileType}`);
  
  // Upload the file buffer
  const { data, error } = await supabase.storage
    .from(UPLOAD_BUCKET)
    .upload(path, fileBuffer, { // Use fileBuffer here
      contentType: fileType,
      upsert: true,
    });
  
  if (error) {
    appLogger.error('[StorageAction] Supabase Storage upload error:', error);
    appLogger.error('Error uploading file to Supabase Storage', error);
    throw new Error(`Failed to upload file: ${error.message}`);
  }
  
  appLogger.info(`[StorageAction] Upload successful for path: ${path}`);
  
  // Get a URL for the file (temporary, signed URL)
  const { data: signedUrlData, error: signedUrlError } = await supabase.storage
    .from(UPLOAD_BUCKET)
    .createSignedUrl(path, EXPIRY_SECONDS);
  
  if (signedUrlError) {
    appLogger.error('[StorageAction] Error creating signed URL:', signedUrlError);
    appLogger.error('Error creating signed URL', signedUrlError);
    throw new Error(`Failed to create file URL: ${signedUrlError.message}`);
  }
  
  appLogger.info(`[StorageAction] Signed URL created for path: ${path}`);
  
  return {
    path,
    signedUrl: signedUrlData.signedUrl,
  };
}

/**
 * Retrieves a file from Supabase Storage
 * @param path The path of the file in Supabase Storage
 * @returns The file as an ArrayBuffer
 */
export async function getFileFromStorage(path: string) {
  const supabase = createActionClient();
  
  // Get the authenticated user
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    appLogger.error('Authentication error in getFileFromStorage', authError);
    throw new Error('You must be logged in to access files');
  }
  
  // Validate that the path belongs to the user
  if (!path.startsWith(`${user.id}/`)) {
    throw new Error('You do not have permission to access this file');
  }
  
  // Download the file
  const { data, error } = await supabase.storage
    .from(UPLOAD_BUCKET)
    .download(path);
  
  if (error) {
    appLogger.error('Error downloading file from Supabase Storage', error);
    throw new Error(`Failed to download file: ${error.message}`);
  }
  
  return await data.arrayBuffer();
}

/**
 * Deletes a file from Supabase Storage
 * @param path The path of the file in Supabase Storage
 */
export async function deleteFileFromStorage(path: string) {
  const supabase = createActionClient();
  
  // Get the authenticated user
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  
  if (authError || !user) {
    appLogger.error('Authentication error in deleteFileFromStorage', authError);
    throw new Error('You must be logged in to delete files');
  }
  
  // Validate that the path belongs to the user
  if (!path.startsWith(`${user.id}/`)) {
    throw new Error('You do not have permission to delete this file');
  }
  
  // Delete the file
  const { error } = await supabase.storage
    .from(UPLOAD_BUCKET)
    .remove([path]);
  
  if (error) {
    appLogger.error('Error deleting file from Supabase Storage', error);
    throw new Error(`Failed to delete file: ${error.message}`);
  }
  
  return { success: true };
} 
```

### File: lib/actions/studyQueryActions.ts

```
"use server";

import { createActionClient } from '@/lib/supabase/server';
import { cookies } from 'next/headers';
import { StudyQueryCriteriaSchema, type StudyQueryCriteria, type ResolvedCardId } from "@/lib/schema/study-query.schema";
import { getStudySet } from '@/lib/actions/studySetActions'; // Import action to get study set details
import { ZodError } from 'zod';
import type { Database, Json } from "@/types/database"; // Import Json type if not global
import type { ActionResult } from '@/lib/actions/types'; // Import shared type
import { appLogger, statusLogger } from '@/lib/logger';

/**
 * Server actions for resolving study queries and fetching card IDs.
 * 
 * This module provides:
 * - Query resolution for study sets and criteria
 * - Card ID fetching based on query criteria
 * - Integration with database functions for complex queries
 * 
 * @module studyQueryActions
 */

// Define the expected input shape (either criteria or studySetId)
type ResolveStudyQueryInput = 
  | { criteria: StudyQueryCriteria; studySetId?: never } 
  | { criteria?: never; studySetId: string };

/**
 * Resolves a study query to get matching card IDs.
 * 
 * @param {Object} params - Query parameters
 * @param {StudyQueryCriteria} params.queryCriteria - The query criteria to resolve
 * @param {string} [params.studySetId] - Optional study set ID to use predefined criteria
 * @returns {Promise<string[]>} Array of card IDs matching the query
 * @throws {Error} If query resolution fails or user is not authenticated
 */
export async function resolveStudyQuery(
  input: ResolveStudyQueryInput
): Promise<ActionResult<string[]>> {
  // const cookieStore = cookies(); // No longer needed for createActionClient
  const supabase = createActionClient(); // Use the action client consistent with other actions

  // 1. Authentication
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    appLogger.error('Auth error in resolveStudyQuery:', authError);
    return { data: null, error: 'Authentication required.' };
  }

  let criteriaToUse: StudyQueryCriteria | null = null;
  let validationError: string | null = null;

  // 2. Determine and Validate Criteria
  try {
    if ('studySetId' in input && input.studySetId) {
        appLogger.info("[resolveStudyQuery] Resolving via studySetId:", input.studySetId);
        // Fetch the study set
        const studySetResult = await getStudySet(input.studySetId);

        if (studySetResult.error) {
            appLogger.error(`[resolveStudyQuery] Error fetching study set ${input.studySetId}:`, studySetResult.error);
            return { data: null, error: studySetResult.error };
        }
        if (!studySetResult.data) {
            appLogger.warn(`[resolveStudyQuery] Study set ${input.studySetId} not found or not authorized.`);
            return { data: null, error: 'Study set not found.' };
        }

        // Validate the criteria fetched from the study set
        // Supabase stores JSONB as any/unknown, so parse it.
        try {
          const parsedCriteria = StudyQueryCriteriaSchema.safeParse(studySetResult.data.query_criteria);
          if (!parsedCriteria.success) {
            appLogger.error(`[resolveStudyQuery] Invalid criteria found in study set ${input.studySetId}:`, parsedCriteria.error.errors);
            // Instead of failing, use a safe default criteria
            appLogger.info("[resolveStudyQuery] Using safe default criteria for malformed study set");
            criteriaToUse = {
              allCards: true,
              tagLogic: 'ANY',
            };
          } else {
            criteriaToUse = parsedCriteria.data;
          }
        } catch (err) {
          appLogger.error(`[resolveStudyQuery] Error parsing study set criteria:`, err);
          // Fallback to safe default criteria
          criteriaToUse = {
            allCards: true,
            tagLogic: 'ANY',
          };
        }
        
    } else if ('criteria' in input && input.criteria) {
        appLogger.info("[resolveStudyQuery] Resolving via provided criteria:", input.criteria);
        // Validate the provided criteria
        const parsedCriteria = StudyQueryCriteriaSchema.safeParse(input.criteria);
         if (!parsedCriteria.success) {
             appLogger.error('[resolveStudyQuery] Invalid criteria provided:', parsedCriteria.error.errors);
             validationError = `Invalid query criteria: ${parsedCriteria.error.errors.map(e => e.message).join(', ')}`;
         } else {
            criteriaToUse = parsedCriteria.data;
         }
    } else {
         appLogger.error('[resolveStudyQuery] Invalid input: Neither criteria nor studySetId provided.');
         validationError = 'Invalid input: Must provide either criteria or studySetId.';
    }

    // Handle validation errors from either path
    if (validationError) {
         return { data: null, error: validationError };
    }
    
    // Ensure criteria were successfully determined
    if (!criteriaToUse) {
         appLogger.error('[resolveStudyQuery] Criteria could not be determined from input.');
         return { data: null, error: 'Failed to determine study criteria.' };
    }

    // 3. RPC Call to the Database Function
    appLogger.info("[resolveStudyQuery] Calling RPC with criteria:", criteriaToUse);
    const { data, error: rpcError } = await supabase.rpc(
      'resolve_study_query', 
      {
        p_user_id: user.id,
        // Cast criteriaToUse to Json if Supabase types require it, otherwise direct pass should work
        p_query_criteria: criteriaToUse as unknown as Json, 
        // TODO: Potentially pass orderby info if needed from criteria or separate param?
        // p_order_by_field: criteriaToUse.orderBy?.field ?? 'created_at', 
        // p_order_by_direction: criteriaToUse.orderBy?.direction ?? 'DESC' 
      }
    );

    if (rpcError) {
      appLogger.error('Supabase RPC error in resolveStudyQuery:', rpcError);
      return { data: null, error: 'Failed to retrieve study cards. Please try again.' };
    }

    // Log the raw data received from RPC for inspection
    appLogger.info("[resolveStudyQuery] Raw RPC data:", JSON.stringify(data, null, 2));

    // 4. Process and Return Data
    // The RPC function directly returns an array of UUID strings.
    // No mapping is needed.
    const cardIds: string[] = data ? data : []; 
    
    // Log the mapped card IDs for inspection
    appLogger.info("[resolveStudyQuery] Final cardIds array:", JSON.stringify(cardIds, null, 2)); // Renamed log

    appLogger.info(`[resolveStudyQuery] Resolved ${cardIds.length} card IDs.`);
    return { data: cardIds, error: null };

  } catch (error) {
    // Catch unexpected errors during the process
    appLogger.error('Unexpected error in resolveStudyQuery:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
} 
```

### File: lib/actions/studySetActions.ts

```
"use server";

import { createActionClient } from '@/lib/supabase/server';
import { revalidatePath } from "next/cache";
// import { z } from 'zod'; // No longer needed directly if schemas are imported
import { studyQueryCriteriaSchema } from '@/lib/schema/study-query.schema'; // Import the criteria schema
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
// Import the newly created study set schemas
import { studySetInputSchema, partialStudySetInputSchema } from '@/lib/schema/study-set.schema';
import type { Database, Tables } from "@/types/database"; // Assuming types_db defines Tables<'study_sets'> 
import type { ActionResult } from '@/lib/actions/types'; // Import shared type
import { appLogger, statusLogger } from '@/lib/logger';

// Define DbStudySet based on your types_db or manually if needed
type DbStudySet = Tables<'study_sets'>;

// Zod schema for creating/updating study sets (validates name, description, criteria)
// REMOVE local definition
/*
const studySetInputSchema = z.object({
    name: z.string().trim().min(1, 'Study set name is required').max(100),
    description: z.string().trim().max(500).optional().nullable(),
    criteria: studyQueryCriteriaSchema, // Validate the criteria object
});
*/

// Zod schema for partial updates
// REMOVE local definition
// const partialStudySetInputSchema = studySetInputSchema.partial(); 

// Helper to get Supabase client and user (Ensure correct usage)
async function getSupabaseAndUser() {
  const supabase = createActionClient(); // Use the action client
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    appLogger.error("[getSupabaseAndUser - studySetActions] Auth error:", authError);
    return { supabase: null, user: null, error: authError?.message || 'Authentication required.' }; 
  }
  return { supabase, user, error: null };
}

/**
 * Server actions for managing study sets.
 * 
 * This module provides:
 * - Study set creation, reading, updating, and deletion
 * - Query criteria management
 * - Study set filtering and resolution
 * 
 * @module studySetActions
 */

/**
 * Creates a new study set.
 * 
 * @param {Object} params - Study set creation parameters
 * @param {string} params.name - Name of the study set
 * @param {string} [params.description] - Optional description of the study set
 * @param {StudyQueryCriteria} params.queryCriteria - Query criteria for the study set
 * @returns {Promise<StudySet>} The created study set
 * @throws {Error} If study set creation fails or user is not authenticated
 */
export async function createStudySet(
    data: { name: string; description?: string | null; criteria: StudyQueryCriteria }
): Promise<ActionResult<DbStudySet>> {
    const { supabase, user, error: authError } = await getSupabaseAndUser();
    if (authError || !supabase || !user) {
        return { data: null, error: authError };
    }

    appLogger.info("[createStudySet] User:", user.id, "Input Data:", data);

    // Validate input data
    const validation = studySetInputSchema.safeParse(data);
    if (!validation.success) {
        appLogger.warn("[createStudySet] Validation failed:", validation.error.errors);
        return { data: null, error: validation.error.errors[0].message };
    }

    const { name, description, criteria } = validation.data;

    try {
        const { data: newStudySet, error: insertError } = await supabase
            .from('study_sets')
            .insert({
                user_id: user.id,
                name: name,
                description: description,
                query_criteria: criteria as any, // Cast criteria to 'any' if Supabase types aren't precise for JSONB
            })
            .select()
            .single();

        if (insertError) {
            appLogger.error("[createStudySet] Insert error:", insertError);
            // Handle potential unique name constraint if needed (though not in schema def above)
            // if (insertError.code === '23505') { ... }
            return { data: null, error: 'Failed to create study set.' };
        }

        appLogger.info("[createStudySet] Success, ID:", newStudySet?.id);
        revalidatePath('/study-sets'); // Revalidate page listing study sets
        return { data: newStudySet, error: null };

    } catch (err) {
        appLogger.error("[createStudySet] Unexpected error:", err);
        return { data: null, error: 'An unexpected error occurred.' };
    }
}

/**
 * Fetches all study sets for the current user.
 * 
 * @returns {Promise<StudySet[]>} Array of user's study sets
 * @throws {Error} If study set fetch fails or user is not authenticated
 */
export async function getUserStudySets(): Promise<ActionResult<DbStudySet[]>> {
    const { supabase, user, error: authError } = await getSupabaseAndUser();
    if (authError || !supabase || !user) {
        return { data: null, error: authError };
    }

    appLogger.info("[getUserStudySets] User:", user.id);

    try {
        const { data: studySets, error: fetchError } = await supabase
            .from('study_sets')
            .select('*') // Select all columns
            .eq('user_id', user.id)
            .order('name', { ascending: true }); // Order by name

        if (fetchError) {
            appLogger.error("[getUserStudySets] Fetch error:", fetchError);
            return { data: null, error: 'Failed to fetch study sets.' };
        }

        appLogger.info(`[getUserStudySets] Found ${studySets?.length ?? 0} sets.`);
        return { data: studySets || [], error: null };

    } catch (err) {
        appLogger.error("[getUserStudySets] Unexpected error:", err);
        return { data: null, error: 'An unexpected error occurred.' };
    }
}

/**
 * Fetches a single study set by its ID.
 * 
 * @param {Object} params - Study set fetch parameters
 * @param {string} params.studySetId - ID of the study set to fetch
 * @returns {Promise<StudySet>} The fetched study set
 * @throws {Error} If study set fetch fails or user is not authenticated
 */
export async function getStudySet(studySetId: string): Promise<ActionResult<DbStudySet | null>> {
    const { supabase, user, error: authError } = await getSupabaseAndUser();
    if (authError || !supabase || !user) {
        return { data: null, error: authError };
    }

    // Basic ID validation
    if (!studySetId || typeof studySetId !== 'string') {
        return { data: null, error: 'Invalid Study Set ID provided.' };
    }

    appLogger.info("[getStudySet] User:", user.id, "Set ID:", studySetId);

    try {
        const { data: studySet, error: fetchError } = await supabase
            .from('study_sets')
            .select('*')
            .eq('id', studySetId)
            .eq('user_id', user.id) // Ensure user ownership
            .maybeSingle(); // Use maybeSingle to return null if not found

        if (fetchError) {
            appLogger.error("[getStudySet] Fetch error:", fetchError);
            return { data: null, error: 'Failed to fetch study set.' };
        }

        if (!studySet) {
            appLogger.info("[getStudySet] Not found or unauthorized for ID:", studySetId);
             // Return null data but not necessarily an error if simply not found
             return { data: null, error: null }; 
        }

        appLogger.info("[getStudySet] Found:", studySet.id);
        return { data: studySet, error: null };

    } catch (err) {
        appLogger.error("[getStudySet] Unexpected error:", err);
        return { data: null, error: 'An unexpected error occurred.' };
    }
}

/**
 * Updates an existing study set.
 * 
 * @param {Object} params - Study set update parameters
 * @param {string} params.studySetId - ID of the study set to update
 * @param {Partial<StudySet>} params.updates - Partial study set object containing fields to update
 * @returns {Promise<StudySet>} The updated study set
 * @throws {Error} If study set update fails or user is not authenticated
 */
export async function updateStudySet(
    studySetId: string,
    data: Partial<{ name: string; description: string | null; criteria: StudyQueryCriteria }> 
): Promise<ActionResult<DbStudySet>> {
    const { supabase, user, error: authError } = await getSupabaseAndUser();
    if (authError || !supabase || !user) {
        return { data: null, error: authError };
    }

    if (!studySetId || typeof studySetId !== 'string') {
        return { data: null, error: 'Invalid Study Set ID provided.' };
    }
    
    // Validate the partial input data 
    const validation = partialStudySetInputSchema.safeParse(data);
     if (!validation.success) {
        appLogger.warn("[updateStudySet] Validation failed:", validation.error.errors);
        return { data: null, error: validation.error.errors[0].message };
    }
    
    const updateData = validation.data;

    // Ensure there's something to update
    if (Object.keys(updateData).length === 0) {
         return { data: null, error: "No update data provided." };
    }

    appLogger.info("[updateStudySet] User:", user.id, "Set ID:", studySetId, "Update Data:", updateData);

    try {
        // Update and fetch the updated row
        const { data: updatedStudySet, error: updateError } = await supabase
            .from('study_sets')
            .update({
                name: updateData.name,
                description: updateData.description,
                query_criteria: updateData.criteria, // Map criteria to query_criteria
                updated_at: new Date().toISOString(), // Explicitly set updated_at
             })
            .eq('id', studySetId)
            .eq('user_id', user.id) // Ensure user ownership
            .select()
            .single();

        if (updateError) {
            appLogger.error("[updateStudySet] Update error:", updateError);
            // Handle potential unique name constraint if name is being updated
             // if (updateError.code === '23505') { ... }
            return { data: null, error: 'Failed to update study set.' };
        }
        
        if (!updatedStudySet) {
             // This might happen if the ID didn't exist or RLS failed
             appLogger.warn("[updateStudySet] Update affected 0 rows for ID:", studySetId);
             return { data: null, error: 'Study set not found or update failed.' };
        }

        appLogger.info("[updateStudySet] Success, ID:", updatedStudySet.id);
        revalidatePath('/study-sets'); // Revalidate list page
        revalidatePath(`/study-sets/${studySetId}`); // Revalidate specific set page (if exists)
        return { data: updatedStudySet, error: null };

    } catch (err) {
        appLogger.error("[updateStudySet] Unexpected error:", err);
        return { data: null, error: 'An unexpected error occurred.' };
    }
}

/**
 * Deletes a study set.
 * 
 * @param {Object} params - Study set deletion parameters
 * @param {string} params.studySetId - ID of the study set to delete
 * @returns {Promise<void>}
 * @throws {Error} If study set deletion fails or user is not authenticated
 */
export async function deleteStudySet(studySetId: string): Promise<ActionResult<null>> {
    const { supabase, user, error: authError } = await getSupabaseAndUser();
    if (authError || !supabase || !user) {
        return { data: null, error: authError };
    }

     if (!studySetId || typeof studySetId !== 'string') {
        return { data: null, error: 'Invalid Study Set ID provided.' };
    }

    appLogger.info("[deleteStudySet] User:", user.id, "Set ID:", studySetId);

    try {
        const { error: deleteError, count } = await supabase
            .from('study_sets')
            .delete()
            .eq('id', studySetId)
            .eq('user_id', user.id); // Ensure user ownership

        if (deleteError) {
            appLogger.error("[deleteStudySet] Delete error:", deleteError);
            return { data: null, error: 'Failed to delete study set.' };
        }
        
        if (count === 0) {
             appLogger.warn("[deleteStudySet] Delete affected 0 rows for ID:", studySetId);
             // Don't necessarily return error if it just wasn't found
             // return { data: null, error: 'Study set not found or not authorized.' };
        }

        appLogger.info("[deleteStudySet] Success for ID:", studySetId);
        revalidatePath('/study-sets'); // Revalidate list page
        return { data: null, error: null }; // Success

    } catch (err) {
        appLogger.error("[deleteStudySet] Unexpected error:", err);
        return { data: null, error: 'An unexpected error occurred.' };
    }
}

/**
 * Alias for getUserStudySets to maintain backward compatibility
 */
export const getStudySets = getUserStudySets; 
```

### File: lib/actions/tagActions.ts

```
"use server";

import { createActionClient } from '@/lib/supabase/server';
import { revalidatePath } from "next/cache";
import { z } from 'zod';
import type { Database, Tables } from "@/types/database";
import type { ActionResult } from '@/lib/actions/types';
import { createCardsBatch, type CreateCardInput } from './cardActions'; // Assume CreateCardInput is defined
import { appLogger, statusLogger } from '@/lib/logger';

// Zod schema for tag validation
const tagSchema = z.object({
  name: z.string().trim().min(1, 'Tag name is required').max(50, 'Tag name too long'),
});

// Common response structure
interface TagActionResponse<T = any> {
  data: T | null;
  error: string | null;
}

// Helper to get Supabase client and user
async function getSupabaseAndUser() {
  const supabase = createActionClient();
  const { data: { user }, error: authError } = await supabase.auth.getUser();
  if (authError || !user) {
    appLogger.error("[getSupabaseAndUser] Auth error:", authError);
    return { supabase: null, user: null, error: 'Authentication required.' };
  }
  return { supabase, user, error: null };
}

/**
 * Server actions for managing tags and deck-tag relationships.
 * 
 * This module provides:
 * - Tag creation, reading, updating, and deletion
 * - Deck-tag relationship management
 * - Tag query and filtering operations
 * 
 * @module tagActions
 */

/**
 * Fetches all tags for the current user.
 * 
 * @returns {Promise<Tag[]>} Array of user's tags
 * @throws {Error} If tag fetch fails or user is not authenticated
 */
export async function getTags(): Promise<TagActionResponse<Tables<'tags'>[]>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  try {
    const { data: tags, error: fetchError } = await supabase
      .from('tags')
      .select('id, user_id, name, created_at')
      .eq('user_id', user.id)
      .order('name');

    if (fetchError) {
      appLogger.error('Error fetching tags:', fetchError);
      return { data: null, error: 'Failed to fetch tags.' };
    }

    return { data: tags ?? [], error: null };

  } catch (error) {
    appLogger.error('Unexpected error in getTags:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
}

/**
 * Creates a new tag for the authenticated user.
 * Enforces unique constraint (user_id, name).
 * Ref: Section 4 Data Models
 */
export async function createTag(name: string): Promise<ActionResult<Tables<'tags'>>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  try {
    // 1. Validate input
    const validation = tagSchema.safeParse({ name });
    if (!validation.success) {
      return { data: null, error: validation.error.errors[0].message };
    }
    const validatedName = validation.data.name;

    // 2. Insert new tag (DB handles unique constraint)
    const { data: tag, error: insertError } = await supabase
      .from('tags')
      .insert({ name: validatedName, user_id: user.id })
      .select('id, user_id, name, created_at')
      .single();

    if (insertError) {
      if (insertError.code === '23505') { // Handle unique constraint violation
        return { data: null, error: 'A tag with this name already exists.' };
      }
      appLogger.error('Error creating tag:', insertError);
      return { data: null, error: 'Failed to create tag.' };
    }

    // Revalidate paths where tags might be displayed
    revalidatePath('/tags'); // Example path, adjust as needed
    revalidatePath('/edit'); // Example path

    return { data: tag, error: null };

  } catch (error) {
    // Catch Zod errors specifically if not using safeParse (though safeParse is preferred)
    // if (error instanceof z.ZodError) {
    //   return { data: null, error: error.errors[0].message };
    // }
    appLogger.error('Unexpected error in createTag:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
}

/**
 * Deletes a tag and removes all its associations in deck_tags.
 * Relies on ON DELETE CASCADE for deck_tags cleanup.
 * Ref: Section 4 Data Models
 */
export async function deleteTag(tagId: string): Promise<TagActionResponse<null>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  if (!tagId) {
    return { data: null, error: 'Tag ID is required for deletion.' };
  }

  try {
    // Delete tag (RLS + user_id check ensures ownership)
    const { error: deleteError } = await supabase
      .from('tags')
      .delete()
      .eq('id', tagId)
      .eq('user_id', user.id);

    if (deleteError) {
      appLogger.error('Error deleting tag:', deleteError);
      return { data: null, error: 'Failed to delete tag.' };
    }

    // Revalidate relevant paths
    revalidatePath('/tags');
    revalidatePath('/edit');

    return { data: null, error: null }; // Success

  } catch (error) {
    appLogger.error('Unexpected error in deleteTag:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
}

/**
 * Associates a tag with a deck.
 * Ensures the user owns both the tag and the deck.
 */
export async function addTagToDeck(
  deckId: string,
  tagId: string
): Promise<ActionResult<null>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  if (!deckId || !tagId) {
    return { data: null, error: 'Deck ID and Tag ID are required.' };
  }

  try {
    // Optional: Verify user owns the deck and tag (RLS should handle this too)
    // Insert into deck_tags table. The DB schema should enforce FK constraints and uniqueness.
    const { error: insertError } = await supabase
      .from('deck_tags')
      .insert({ deck_id: deckId, tag_id: tagId, user_id: user.id });

    if (insertError) {
      if (insertError.code === '23505') { // unique_violation
        // Already exists, consider it a success (or return a specific message)
        appLogger.info(`Deck tag association already exists: deck=${deckId}, tag=${tagId}`);
        return { data: null, error: null };
      }
       if (insertError.code === '23503') { // foreign_key_violation
         appLogger.error('Add deck tag FK violation:', insertError);
         return { data: null, error: 'Deck or Tag not found.' };
       }
      appLogger.error('Error adding tag to deck:', insertError);
      return { data: null, error: 'Failed to add tag to deck.' };
    }

    // Revalidate paths where deck tags might be displayed
    revalidatePath(`/edit/${deckId}`);
    revalidatePath('/'); // Revalidate dashboard/deck list if tags are shown there

    return { data: null, error: null }; // Success

  } catch (error) {
    appLogger.error('Unexpected error in addTagToDeck:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
}

/**
 * Removes the association between a tag and a deck.
 */
export async function removeTagFromDeck(
  deckId: string,
  tagId: string
): Promise<ActionResult<null>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  if (!deckId || !tagId) {
    return { data: null, error: 'Deck ID and Tag ID are required.' };
  }

  try {
    // Delete the association from deck_tags table (RLS + user_id check)
    const { error: deleteError } = await supabase
      .from('deck_tags')
      .delete()
      .eq('deck_id', deckId)
      .eq('tag_id', tagId)
      .eq('user_id', user.id);

    if (deleteError) {
      appLogger.error('Error removing tag from deck:', deleteError);
      return { data: null, error: 'Failed to remove tag from deck.' };
    }

    // Check if any row was actually deleted? Supabase delete doesn't return count easily
    // If the row didn't exist, it's still effectively a success.

    // Revalidate relevant paths
    revalidatePath(`/edit/${deckId}`);
    revalidatePath('/');

    return { data: null, error: null }; // Success

  } catch (error) {
    appLogger.error('Unexpected error in removeTagFromDeck:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
}

/**
 * Fetches all tags associated with a specific deck for the current user.
 */
export async function getDeckTags(deckId: string): Promise<ActionResult<Tables<'tags'>[]>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  if (!deckId) {
    return { data: null, error: 'Deck ID is required.' };
  }

  try {
    // Query deck_tags, join with tags, filter by deck_id and user_id
    const { data, error: fetchError } = await supabase
      .from('deck_tags')
      .select(`
        tags (*)
      `)
      .eq('deck_id', deckId)
      .eq('user_id', user.id);

    if (fetchError) {
      appLogger.error('Error fetching deck tags:', fetchError);
      return { data: null, error: 'Failed to fetch deck tags.' };
    }

    // Extract the tag objects from the join result
    // The result is an array of objects like { tags: { id: ..., name: ... } } or { tags: null }
    const tags = data?.map(item => item.tags).filter(tag => tag !== null) as Tables<'tags'>[] ?? [];

    return { data: tags, error: null };

  } catch (error) {
    appLogger.error('Unexpected error in getDeckTags:', error);
    return { data: null, error: 'An unexpected error occurred.' };
  }
}

/**
 * Fetches all tags associated with a specific card (via its deck) for the current user.
 */
export async function getCardTags(cardId: string): Promise<ActionResult<Tables<'tags'>[]>> {
  const { supabase, user, error: authError } = await getSupabaseAndUser();
  if (authError || !supabase || !user) {
    return { data: null, error: authError };
  }

  if (!cardId) {
    return { data: null, error: "Card ID is required." };
  }

  try {
    // 1. Fetch the card to get its deck_id
    const { data: card, error: cardError } = await supabase
      .from('cards')
      .select('id, deck_id')
      .eq('id', cardId)
      // RLS policy on cards table ensures user can only access cards in their own decks.
      // Direct user_id check here is not needed and column doesn't exist on cards table.
      .single();

    if (cardError) {
      appLogger.error(`Error fetching card ${cardId} to get deck_id:`, cardError);
      return { data: null, error: "Failed to fetch card details to retrieve tags." };
    }

    if (!card || !card.deck_id) {
      appLogger.error(`Card ${cardId} not found or has no deck_id.`);
      return { data: null, error: "Card not found or not associated with a deck." };
    }

    // 2. Call getDeckTags with the obtained deck_id
    // Make sure getDeckTags is imported or defined above if in the same file.
    return getDeckTags(card.deck_id);

  } catch (error) {
    appLogger.error(`Unexpected error in getCardTags for card ${cardId}:`, error);
    return { data: null, error: 'An unexpected error occurred while fetching tags for the card.' };
  }
}

/**
 * Creates a new study set for the user.
 */

```

### File: lib/actions/ttsActions.ts

```
// lib/actions/ttsActions.ts
"use server";

import { TextToSpeechClient } from '@google-cloud/text-to-speech';
import { google } from '@google-cloud/text-to-speech/build/protos/protos';
import { appLogger } from '@/lib/logger';

// Consider initializing the client outside the function for potential reuse
// if appropriate for your serverless environment's lifecycle.
// const ttsClient = new TextToSpeechClient();

/**
 * Server actions for Text-to-Speech (TTS) functionality.
 * 
 * This module provides:
 * - TTS audio generation
 * - Language and voice selection
 * - Audio caching and management
 * 
 * @module ttsActions
 */

/**
 * Generates speech audio from text using Google Cloud TTS.
 *
 * @param text The text to synthesize.
 * @param languageCode The BCP-47 language code (e.g., 'en-US', 'es-ES').
 * @param ssmlGender Optional SSML gender ('SSML_VOICE_GENDER_UNSPECIFIED', 'MALE', 'FEMALE', 'NEUTRAL').
 * @param voiceName Optional specific voice name (e.g., 'en-US-Wavenet-D').
 * @returns Promise<{ audioContent: string | null, error: string | null }> - Base64 encoded audio content or error message.
 */
export async function generateTtsAction(
    text: string,
    languageCode: string,
    ssmlGender: google.cloud.texttospeech.v1.SsmlVoiceGender = google.cloud.texttospeech.v1.SsmlVoiceGender.NEUTRAL,
    voiceName?: string | null // Make voiceName optional
): Promise<{ audioContent: string | null; error: string | null; }> {

    // Check for Google Cloud credentials in environment variables
    // Supports both GOOGLE_APPLICATION_CREDENTIALS file path and individual vars
    const hasCredentialsFile = !!process.env.GOOGLE_APPLICATION_CREDENTIALS;
    const hasIndividualCreds = !!process.env.GCP_PROJECT_ID && 
                              !!process.env.GCP_SERVICE_ACCOUNT_EMAIL && 
                              !!process.env.GCP_PRIVATE_KEY;

    if (!hasCredentialsFile && !hasIndividualCreds) {
         appLogger.error("TTS Action Error: Google Cloud credentials are not set properly in environment variables.");
         return { audioContent: null, error: "Server configuration error: Missing TTS credentials." };
    }

    if (!text || !languageCode) {
        appLogger.warn("TTS Action Warning: Missing text or languageCode.");
        return { audioContent: null, error: "Missing required parameters for TTS generation." };
    }

    // Add detailed logging about language code
    appLogger.info(`[TTS Action] EXACT language code received: "${languageCode}" (type: ${typeof languageCode})`);
    appLogger.info(`[TTS Action] Is language code a valid BCP-47 code with dialect? ${languageCode.includes('-') ? 'Yes' : 'No'}`);
    
    // Add server-side language mapping for safety
    let mappedCode = languageCode;
    
    // Simple backup mapping if no dialect is present
    if (!languageCode.includes('-')) {
        const baseCode = languageCode.toLowerCase();
        const mapping: Record<string, string> = {
            'nl': 'nl-NL',
            'en': 'en-GB',
            'fr': 'fr-FR',
            'de': 'de-DE',
            'es': 'es-ES',
            'it': 'it-IT'
        };
        
        if (mapping[baseCode]) {
            mappedCode = mapping[baseCode];
            appLogger.info(`[TTS Action] Applied server-side mapping: ${languageCode} → ${mappedCode}`);
        }
    }
    
    appLogger.info(`[generateTtsAction] Generating TTS for text: "${text.substring(0, 50)}...", lang: ${mappedCode}, gender: ${ssmlGender}, voice: ${voiceName ?? 'default'}`);

    // Initialize client here for serverless compatibility
    // If using long-running server, initialize outside the function.
    const ttsClient = new TextToSpeechClient({
        projectId: process.env.GCP_PROJECT_ID,
        credentials: {
            client_email: process.env.GCP_SERVICE_ACCOUNT_EMAIL,
            private_key: process.env.GCP_PRIVATE_KEY
        }
    });

    const request: google.cloud.texttospeech.v1.ISynthesizeSpeechRequest = {
        input: { text: text },
        voice: {
            languageCode: mappedCode, // Use the mapped code
            ssmlGender: ssmlGender,
            // Only include name if it's provided
            ...(voiceName && { name: voiceName })
        },
        audioConfig: { audioEncoding: 'MP3' },
    };

    try {
        const [response] = await ttsClient.synthesizeSpeech(request);

        if (response.audioContent instanceof Uint8Array) {
            const audioBase64 = Buffer.from(response.audioContent).toString('base64');
            appLogger.info(`[generateTtsAction] Successfully generated TTS audio for lang: ${mappedCode}`);
            return { audioContent: audioBase64, error: null };
        } else {
            appLogger.error("[generateTtsAction] TTS response did not contain valid audio content.", response);
            return { audioContent: null, error: "TTS generation failed: Invalid audio content received." };
        }
    } catch (error: any) {
        appLogger.error('[generateTtsAction] Google TTS API Error:', error);
        // Attempt to provide a more specific error message if available
        const errorMessage = error.details || error.message || 'Unknown API error';
        return { audioContent: null, error: `TTS generation failed: ${errorMessage}` };
    }
}
/**
 * Generates TTS audio for the given text.
 * 
 * @param {Object} params - TTS generation parameters
 * @param {string} params.text - Text to convert to speech
 * @param {string} params.language - Language code for TTS (e.g., 'en-US')
 * @param {string} [params.voice] - Optional voice ID to use
 * @returns {Promise<ArrayBuffer>} The generated audio data
 * @throws {Error} If TTS generation fails or parameters are invalid
 */
export async function generateTTS({
  text,
  language,
  voice,
}: {
  text: string;
  language: string;
  voice?: string;
}): Promise<ArrayBuffer> {
  const result = await generateTtsAction(
    text,
    language,
    voice ? undefined : google.cloud.texttospeech.v1.SsmlVoiceGender.NEUTRAL,
    voice || null
  );
  
  if (result.error || !result.audioContent) {
    throw new Error(result.error || 'Failed to generate TTS audio');
  }
  
  // Convert base64 string to ArrayBuffer
  const buffer = Buffer.from(result.audioContent, 'base64');
  return buffer.buffer.slice(
    buffer.byteOffset,
    buffer.byteOffset + buffer.byteLength
  );
}

```

### File: lib/actions/types.ts

```
/**
 * Defines common types used across server actions.
 */

/**
 * Represents the outcome of a server action.
 * 
 * @template T The type of the data returned on success.
 */
export interface ActionResult<T> {
    data: T | null;
    error: string | null; // Consistent error type (string message)
} 
```

## Directory: lib/schema

### File: lib/schema/card.schema.ts

```
import { z } from 'zod';

// Schema representing the specific fields on the 'cards' table that can be updated
// during a study session progress update.
export const cardUpdateFieldsSchema = z.object({
  srs_level: z.number().int().min(0).describe("New SRS level (0 for learning/relearning, >=1 for review)"),
  easiness_factor: z.number().describe("New easiness factor (float)"),
  interval_days: z.number().describe("New interval until next review (float, in days, can be fractional for minutes/hours)"),
  next_review_due: z.string().datetime({ offset: true }).describe("Timestamp for next review (ISO 8601 string)"),
  learning_state: z.enum(['learning', 'relearning']).nullable().describe("The new learning phase ('learning', 'relearning', or null)"),
  learning_step_index: z.number().int().min(0).nullable().describe("The index of the current step in learning/relearning phase"),
  failed_attempts_in_learn: z.number().int().min(0).describe("Counter for 'Again' grades during initial learning"),
  hard_attempts_in_learn: z.number().int().min(0).describe("Counter for 'Hard' grades during initial learning"),
  // Include general stats if the hook updates them
  attempt_count: z.number().int().min(0).optional().describe("Total number of attempts on this card"),
  correct_count: z.number().int().min(0).optional().describe("Total number of correct (Grade >= 2) reviews"),
  incorrect_count: z.number().int().min(0).optional().describe("Total number of incorrect (Grade 1) reviews"),
});

// Represents the full input expected by the updateCardProgress server action
export const updateCardProgressSchema = z.object({
  cardId: z.string().uuid("Invalid Card ID format"),
  grade: z.union([
    z.literal(1),
    z.literal(2),
    z.literal(3),
    z.literal(4)
  ]).describe("User review grade (1=Again, 2=Hard, 3=Good, 4=Easy)"),
  updatedFields: cardUpdateFieldsSchema.describe("Object containing all card fields to be updated"),
}); 
```

### File: lib/schema/deckSchemas.ts

```
// lib/schema/deckSchemas.ts
import { z } from 'zod';

// Schema for creating a deck
export const createDeckSchema = z.object({
    name: z.string().trim().min(1, 'Deck name is required').max(100),
    primary_language: z.string().optional().nullable(),
    secondary_language: z.string().optional().nullable(),
    is_bilingual: z.boolean().optional().default(false),
    // user_id will be added from the authenticated user in the action
});
export type CreateDeckInput = z.infer<typeof createDeckSchema>;

// Schema for updating a deck (all fields optional)
export const updateDeckSchema = createDeckSchema.partial();
export type UpdateDeckInput = z.infer<typeof updateDeckSchema>;

```

### File: lib/schema/study-query.schema.ts

```
// lib/schema/study-query.schema.ts
import { z } from 'zod';

// --- Shared Schemas for Date Filter Values ---
const dateStringSchema = z.string().datetime({ offset: true })
  .describe("Date or timestamp in ISO 8601 format (e.g., '2024-07-31T00:00:00+00:00')");
const dateRangeSchema = z.tuple([dateStringSchema, dateStringSchema])
  .describe("A tuple containing two non-null date/time strings in ISO 8601 format for start and end");
const numberOfDaysSchema = z.string().regex(/^\d+$/, "Value must be a whole number of days represented as a string")
  .describe("Number of days, represented as a string (e.g., '7')");

// --- Specific Schemas for Different Date Filter Types using discriminatedUnion ---
const newerThanDaysFilterSchema = z.object({
  operator: z.literal('newerThanDays'),
  value: numberOfDaysSchema, // Value is a string representing a number
});
const olderThanDaysFilterSchema = z.object({
  operator: z.literal('olderThanDays'),
  value: numberOfDaysSchema, // Value is a string representing a number
});
const onDateFilterSchema = z.object({
  operator: z.literal('onDate'),
  value: dateStringSchema,
});
const betweenDatesFilterSchema = z.object({
  operator: z.literal('betweenDates'),
  value: dateRangeSchema,
});
const neverFilterSchema = z.object({
  operator: z.literal('never'),
  value: z.undefined().optional(),
});
const isDueFilterSchema = z.object({
  operator: z.literal('isDue'),
  value: z.undefined().optional(),
});

const CreatedUpdatedDateFilterSchema = z.discriminatedUnion("operator", [
  newerThanDaysFilterSchema,
  olderThanDaysFilterSchema,
  onDateFilterSchema,
  betweenDatesFilterSchema,
]);
const LastReviewedDateFilterSchema = z.discriminatedUnion("operator", [
  newerThanDaysFilterSchema,
  olderThanDaysFilterSchema,
  onDateFilterSchema,
  betweenDatesFilterSchema,
  neverFilterSchema,
]);
const NextReviewDueDateFilterSchema = z.discriminatedUnion("operator", [
  newerThanDaysFilterSchema,
  olderThanDaysFilterSchema,
  onDateFilterSchema,
  betweenDatesFilterSchema,
  neverFilterSchema,
  isDueFilterSchema,
]);

// --- Main Study Query Criteria Schema (Updated) ---
export const StudyQueryCriteriaSchema = z.object({
  // Core Filters
  deckIds: z.array(z.string().uuid("Invalid Deck ID format")).optional() // Changed from deckId to deckIds (array)
    .describe("Optional array of Deck UUIDs to filter by"),
  allCards: z.boolean().optional()
    .describe("If true, fetch all cards for the user, overriding most other filters except possibly user-level ones"),
  includeTags: z.array(z.string().uuid("Invalid Tag ID format")).optional()
    .describe("Optional array of Tag UUIDs (deck tags) to include"),
  excludeTags: z.array(z.string().uuid("Invalid Tag ID format")).optional()
    .describe("Optional array of Tag UUIDs (deck tags) to exclude"),
  tagLogic: z.enum(['ANY', 'ALL']).optional().default('ANY')
    .describe("Logic for 'includeTags': ANY (default) or ALL"),
  includeLearning: z.boolean().optional()
    .describe("If true, includes cards primarily for initial learning (srs_level = 0 and learning_state is null or 'learning')"),

  // NEW Language Filter
  containsLanguage: z.string().length(2, "Language code must be 2 characters").optional() // e.g., "en", "fr"
    .describe("Optional 2-letter ISO language code. Filters cards where this language is primary OR (if deck is bilingual) secondary."),

  // Date Filters
  createdDate: CreatedUpdatedDateFilterSchema.optional(),
  updatedDate: CreatedUpdatedDateFilterSchema.optional(),
  lastReviewed: LastReviewedDateFilterSchema.optional(),
  nextReviewDue: NextReviewDueDateFilterSchema.optional(),

  // NEW SRS Stage Filter (replaces old srsLevel numeric filter)
  srsStages: z.array(z.enum(['new', 'learning', 'relearning', 'young', 'mature'])).optional()
    .describe("Optional array of SRS stage names to include cards from."),

  // REMOVED: srsLevel: srsLevelFilterSchema.optional()
})
.describe("Schema defining the criteria for selecting cards for a study session");

export type StudyQueryCriteria = z.infer<typeof StudyQueryCriteriaSchema>;
export type ResolvedCardId = { card_id: string };

// Alias for backward compatibility if needed (though direct export is fine)
export const studyQueryCriteriaSchema = StudyQueryCriteriaSchema;
```

### File: lib/schema/study-set.schema.ts

```
import { z } from 'zod';
import { StudyQueryCriteriaSchema } from '@/lib/schema/study-query.schema';

// Zod schema for validating the input when creating or fully updating study sets
export const studySetInputSchema = z.object({
    name: z.string().trim().min(1, 'Study set name is required').max(100)
        .describe("The name of the study set (1-100 characters)"),
    description: z.string().trim().max(500).optional().nullable()
        .describe("Optional description for the study set (max 500 characters)"),
    // Use the imported schema to validate the nested criteria object
    criteria: StudyQueryCriteriaSchema
        .describe("The query criteria object defining the cards included in this set"),
});

// Zod schema for validating partial updates to study sets
// Allows any subset of the fields defined in studySetInputSchema to be provided
export const partialStudySetInputSchema = studySetInputSchema.partial()
    .describe("Schema for partially updating a study set; allows any subset of fields.");

// Infer TypeScript types from the schemas
export type StudySetInput = z.infer<typeof studySetInputSchema>;
export type PartialStudySetInput = z.infer<typeof partialStudySetInputSchema>; 
```

## Directory: lib/study

### File: lib/study/card-state-handlers.ts

```
// lib/study/card-state-handlers.ts
/**
 * Pure functions to handle card state transitions based on review grades and study settings.
 * These functions determine the next database state, internal session state, and queue action
 * for a card after it has been answered.
 */

import type { Tables } from '@/types/database';
import type { Settings } from '@/providers/settings-provider';
import type {
    InternalCardState,
    CardStateUpdateOutcome // This type should define the queueInstruction literals correctly
} from '@/types/study'; // Assuming types are in types/study.ts
import {
    ReviewGrade,
    calculateSm2State,
    calculateNextStandardLearnStep,
    calculateNextRelearningStep,
    createGraduationPayload,
    createRelearningGraduationPayload,
    Sm2InputCardState
} from '@/lib/srs';
import { addMinutes, addDays, parseISO } from 'date-fns'; // Added parseISO

type DbCard = Tables<'cards'>;

export function handleInitialLearningAnswer(
    card: DbCard,
    internalState: InternalCardState,
    grade: ReviewGrade,
    settings: Settings
): CardStateUpdateOutcome {
    console.log(`[CardStateHandler] Handling initial learning answer for card ${card.id}, grade: ${grade}, algorithm: ${settings.studyAlgorithm}`);

    const dbUpdatePayload: Partial<DbCard> = {
        last_reviewed_at: new Date().toISOString(),
        last_review_grade: grade,
        attempt_count: (card.attempt_count ?? 0) + 1,
        correct_count: grade >= 3 ? (card.correct_count ?? 0) + 1 : card.correct_count ?? 0,
        incorrect_count: grade === 1 ? (card.incorrect_count ?? 0) + 1 : card.incorrect_count ?? 0,
    };
    let nextInternalState = { ...internalState };
    let queueInstruction: CardStateUpdateOutcome['queueInstruction'] = 'set-timed-step'; // CORRECTED
    let sessionResultCategory: CardStateUpdateOutcome['sessionResultCategory'] | undefined = undefined;
    let reinsertAfterNJobs: CardStateUpdateOutcome['reinsertAfterNJobs'] | undefined = undefined;

    if (grade === 1) dbUpdatePayload.failed_attempts_in_learn = (card.failed_attempts_in_learn ?? 0) + 1;
    if (grade === 2) dbUpdatePayload.hard_attempts_in_learn = (card.hard_attempts_in_learn ?? 0) + 1;
    nextInternalState.failedAttemptsInLearnSession = grade === 1 ? nextInternalState.failedAttemptsInLearnSession + 1 : nextInternalState.failedAttemptsInLearnSession;
    nextInternalState.hardAttemptsInLearnSession = grade === 2 ? nextInternalState.hardAttemptsInLearnSession + 1 : nextInternalState.hardAttemptsInLearnSession;

    if (settings.studyAlgorithm === 'dedicated-learn' || settings.enableDedicatedLearnMode) {
        let newStreak = internalState.streak;
        if (grade === 1) newStreak = 0;
        else if (grade === 2) newStreak = Math.max(0, newStreak);
        else if (grade >= 3) newStreak++;

        nextInternalState.streak = newStreak;
        nextInternalState.justSeenInSession = true;

        if (newStreak >= settings.masteryThreshold || grade === 4) {
            console.log(`[CardStateHandler] Card ${card.id} graduating from Dedicated Learn.`);
            sessionResultCategory = 'graduatedLearn';
            queueInstruction = 'remove';

            const graduationPayload = createGraduationPayload(
                grade,
                dbUpdatePayload.failed_attempts_in_learn ?? 0,
                dbUpdatePayload.hard_attempts_in_learn ?? 0,
                settings
            );
            dbUpdatePayload.srs_level = graduationPayload.srsLevel;
            dbUpdatePayload.learning_state = null;
            dbUpdatePayload.learning_step_index = null;
            dbUpdatePayload.easiness_factor = graduationPayload.easinessFactor;
            dbUpdatePayload.interval_days = graduationPayload.intervalDays;
            dbUpdatePayload.next_review_due = graduationPayload.nextReviewDue?.toISOString();
            dbUpdatePayload.failed_attempts_in_learn = 0;
            dbUpdatePayload.hard_attempts_in_learn = 0;
            nextInternalState.learningStepIndex = null;
        } else {
            console.log(`[CardStateHandler] Card ${card.id} continues in Dedicated Learn (Streak: ${newStreak}).`);
            if (grade === 1 || grade === 2) {
                queueInstruction = 're-queue-soon'; // CORRECTED
                reinsertAfterNJobs = settings.customLearnRequeueGap;
            } else {
                queueInstruction = 're-queue-later';
            }
            nextInternalState.dueTime = new Date();
            dbUpdatePayload.learning_state = 'learning';
            dbUpdatePayload.learning_step_index = nextInternalState.learningStepIndex ?? 0;
        }
    } else {
        const currentStep = internalState.learningStepIndex ?? 0;
        const stepResult = calculateNextStandardLearnStep(currentStep, grade, settings);

        if (stepResult.nextStepIndex === 'graduated') {
            console.log(`[CardStateHandler] Card ${card.id} graduating from Standard Learn.`);
            sessionResultCategory = 'graduatedLearn';
            queueInstruction = 'remove';

            const graduationPayload = createGraduationPayload(
                grade,
                dbUpdatePayload.failed_attempts_in_learn ?? 0,
                dbUpdatePayload.hard_attempts_in_learn ?? 0,
                settings
            );
            dbUpdatePayload.srs_level = graduationPayload.srsLevel;
            dbUpdatePayload.learning_state = null;
            dbUpdatePayload.learning_step_index = null;
            dbUpdatePayload.easiness_factor = graduationPayload.easinessFactor;
            dbUpdatePayload.interval_days = graduationPayload.intervalDays;
            dbUpdatePayload.next_review_due = graduationPayload.nextReviewDue?.toISOString();
            dbUpdatePayload.failed_attempts_in_learn = 0;
            dbUpdatePayload.hard_attempts_in_learn = 0;
            nextInternalState.learningStepIndex = null;
        } else {
            console.log(`[CardStateHandler] Card ${card.id} continues in Standard Learn step ${stepResult.nextStepIndex}.`);
            queueInstruction = 'set-timed-step'; // CORRECTED
            nextInternalState.learningStepIndex = stepResult.nextStepIndex;
            nextInternalState.dueTime = stepResult.nextDueTime;

            dbUpdatePayload.learning_state = 'learning';
            dbUpdatePayload.learning_step_index = nextInternalState.learningStepIndex;
            dbUpdatePayload.next_review_due = nextInternalState.dueTime.toISOString();
        }
    }
    return { dbUpdatePayload, nextInternalState, queueInstruction, sessionResultCategory, reinsertAfterNJobs };
}

export function handleRelearningAnswer(
    card: DbCard,
    internalState: InternalCardState,
    grade: ReviewGrade,
    settings: Settings
): CardStateUpdateOutcome {
    console.log(`[CardStateHandler] Handling relearning answer for card ${card.id}, grade: ${grade}`);
    const dbUpdatePayload: Partial<DbCard> = {
        last_reviewed_at: new Date().toISOString(),
        last_review_grade: grade,
        attempt_count: (card.attempt_count ?? 0) + 1,
        correct_count: grade >= 3 ? (card.correct_count ?? 0) + 1 : card.correct_count ?? 0,
        incorrect_count: grade === 1 ? (card.incorrect_count ?? 0) + 1 : card.incorrect_count ?? 0,
    };
    let nextInternalState = { ...internalState };
    let queueInstruction: CardStateUpdateOutcome['queueInstruction'] = 'set-timed-step'; // CORRECTED
    let sessionResultCategory: CardStateUpdateOutcome['sessionResultCategory'] | undefined = undefined;

    const currentStep = internalState.learningStepIndex ?? 0;
    const stepResult = calculateNextRelearningStep(currentStep, grade, settings);

    if (stepResult.nextStepIndex === 'graduatedFromRelearning') {
        console.log(`[CardStateHandler] Card ${card.id} graduating from Relearning.`);
        sessionResultCategory = 'graduatedRelearn';
        queueInstruction = 'remove';

        const relearnGraduationPayload = createRelearningGraduationPayload(
            grade,
            card.easiness_factor ?? settings.defaultEasinessFactor,
            // internalState.originalSrsLevelOnLoad, // REMOVED - not used by current srs.ts function
            settings
        );
        dbUpdatePayload.srs_level = relearnGraduationPayload.srsLevel;
        dbUpdatePayload.learning_state = null;
        dbUpdatePayload.learning_step_index = null;
        dbUpdatePayload.easiness_factor = relearnGraduationPayload.easinessFactor;
        dbUpdatePayload.interval_days = relearnGraduationPayload.intervalDays;
        dbUpdatePayload.next_review_due = relearnGraduationPayload.nextReviewDue?.toISOString();
        nextInternalState.learningStepIndex = null;
    } else {
        console.log(`[CardStateHandler] Card ${card.id} continues in Relearning step ${stepResult.nextStepIndex}.`);
        queueInstruction = 'set-timed-step'; // CORRECTED
        nextInternalState.learningStepIndex = stepResult.nextStepIndex;
        nextInternalState.dueTime = stepResult.nextDueTime;
        dbUpdatePayload.learning_state = 'relearning';
        dbUpdatePayload.learning_step_index = nextInternalState.learningStepIndex;
        dbUpdatePayload.next_review_due = nextInternalState.dueTime.toISOString();
    }
    return { dbUpdatePayload, nextInternalState, queueInstruction, sessionResultCategory };
}

export function handleReviewAnswer(
    card: DbCard,
    internalState: InternalCardState,
    grade: ReviewGrade,
    settings: Settings
): CardStateUpdateOutcome {
    console.log(`[CardStateHandler] Handling review answer for card ${card.id}, grade: ${grade}`);
    const dbUpdatePayload: Partial<DbCard> = {
        last_reviewed_at: new Date().toISOString(),
        last_review_grade: grade,
        attempt_count: (card.attempt_count ?? 0) + 1,
        correct_count: grade >= 2 ? (card.correct_count ?? 0) + 1 : card.correct_count ?? 0,
        incorrect_count: grade === 1 ? (card.incorrect_count ?? 0) + 1 : card.incorrect_count ?? 0,
    };
    let nextInternalState = { ...internalState };
    let queueInstruction: CardStateUpdateOutcome['queueInstruction'] = 'remove';
    let sessionResultCategory: CardStateUpdateOutcome['sessionResultCategory'] | undefined = undefined;

    const sm2Input: Sm2InputCardState = {
        srsLevel: card.srs_level,
        easinessFactor: card.easiness_factor ?? settings.defaultEasinessFactor,
        intervalDays: card.interval_days ?? 0,
        learningState: null, // In review, these are null
        learningStepIndex: null, // In review, these are null
        nextReviewDue: card.next_review_due ? parseISO(card.next_review_due) : null // CORRECTED IMPORT
    };

    const sm2Result = calculateSm2State(sm2Input, grade, settings);

    dbUpdatePayload.srs_level = sm2Result.srsLevel;
    dbUpdatePayload.easiness_factor = sm2Result.easinessFactor;
    dbUpdatePayload.interval_days = sm2Result.intervalDays;
    dbUpdatePayload.next_review_due = sm2Result.nextReviewDue?.toISOString();
    dbUpdatePayload.learning_state = sm2Result.learningState;
    dbUpdatePayload.learning_step_index = sm2Result.learningStepIndex;

    if (sm2Result.learningState === 'relearning') {
        console.log(`[CardStateHandler] Card ${card.id} lapsed to Relearning.`);
        sessionResultCategory = 'lapsed';
        nextInternalState.learningStepIndex = 0;
        nextInternalState.dueTime = sm2Result.nextReviewDue || new Date();
        // If relearning steps are very short and should happen in the same session:
        // queueInstruction = 'set-timed-step'; // This would keep it in the queue
    } else {
        console.log(`[CardStateHandler] Card ${card.id} successful in Review. Next due: ${dbUpdatePayload.next_review_due}`);
    }
    return { dbUpdatePayload, nextInternalState, queueInstruction, sessionResultCategory };
}
```

### File: lib/study/session-queue-manager.ts

```
// lib/study/session-queue-manager.ts
/**
 * Utility functions for managing the study session queue.
 * These functions are pure and operate on the queue data structure,
 * facilitating its initialization, updates, and card selection.
 */

import type { Tables } from '@/types/database';
import type { Settings } from '@/providers/settings-provider';
import type {
    SessionCard,
    InternalCardState,
    SessionType,
    CardAnswerResult, // Not directly used here, but its components are used in updateQueueAfterAnswer
    StudyCardDb,
    CardStateUpdateOutcome
} from '@/types/study';
import { parseISO, isValid as isValidDate } from 'date-fns'; // Renamed isValid to avoid conflict

// Type alias for card data from DB
type DbCard = Tables<'cards'>;

/**
 * Initializes the session queue from a list of fetched database cards.
 * - Filters cards based on the sessionType.
 * - For 'unified' mode, prioritizes 'new' and 'learning' cards.
 * - Initializes InternalCardState for each card.
 * - Sorts the queue.
 *
 * @param fetchedCards Array of cards fetched from the database.
 * @param sessionType The type of session being started ('learn-only', 'review-only', 'unified').
 * @param settings User's application settings.
 * @returns An array of SessionCard objects ready for the study session.
 */
export function initializeQueue(
    fetchedCards: StudyCardDb[],
    sessionType: SessionType,
    settings: Settings
): SessionCard[] {
    console.log(`[QueueManager] Initializing queue. Type: ${sessionType}, Fetched cards: ${fetchedCards.length}`);
    const now = new Date();
    let eligibleCards: StudyCardDb[] = [];

    // 1. Filter cards based on sessionType and their current state
    if (sessionType === 'learn-only') {
        eligibleCards = fetchedCards.filter(card =>
            card.srs_level === 0 && card.learning_state !== 'relearning'
        );
        console.log(`[QueueManager] Filtered for 'learn-only': ${eligibleCards.length} cards.`);
    } else if (sessionType === 'review-only') {
        eligibleCards = fetchedCards.filter(card => {
            const isReviewState = card.srs_level !== null && card.srs_level >= 1 && card.learning_state === null;
            const isRelearningState = card.srs_level === 0 && card.learning_state === 'relearning';
            const isDue = card.next_review_due && isValidDate(parseISO(card.next_review_due)) && parseISO(card.next_review_due) <= now;
            return (isReviewState || isRelearningState) && isDue;
        });
        console.log(`[QueueManager] Filtered for 'review-only' (due): ${eligibleCards.length} cards.`);
    } else { // 'unified' session
        // For unified, we take all cards and will prioritize them later.
        // We still need to ensure they are generally eligible for either learn or review.
        eligibleCards = fetchedCards.filter(card => {
            const isLearnEligible = card.srs_level === 0 && card.learning_state !== 'relearning';
            const isReviewEligible = (
                (card.srs_level !== null && card.srs_level >= 1 && card.learning_state === null) ||
                (card.srs_level === 0 && card.learning_state === 'relearning')
            ) && card.next_review_due && isValidDate(parseISO(card.next_review_due)) && parseISO(card.next_review_due) <= now;
            return isLearnEligible || isReviewEligible;
        });
        console.log(`[QueueManager] Filtered for 'unified' (learn or due review): ${eligibleCards.length} cards.`);
    }

    if (eligibleCards.length === 0) {
        return [];
    }

    // 2. Map to SessionCard and initialize InternalCardState
    const sessionCards: SessionCard[] = eligibleCards.map(dbCard => {
        const card = { ...dbCard }; // Create a mutable copy for the session
        let initialLearningStepIndex = card.learning_step_index;

        // For truly new cards entering a learn or unified session, set their initial learning state
        if ((sessionType === 'learn-only' || sessionType === 'unified') && card.srs_level === 0 && card.learning_state === null) {
            // Note: The actual DB update for learning_state='learning' will happen after the first answer.
            // Here, we prepare the internal session state.
            initialLearningStepIndex = 0; // Start at step 0 for session internal state
        }

        const internalState: InternalCardState = {
            streak: 0,
            learningStepIndex: initialLearningStepIndex,
            // For review cards, dueTime is their actual DB due time.
            // For new/learning cards in learn/unified, they are due now unless steps dictate otherwise.
            dueTime: (card.srs_level !== null && card.srs_level >= 1 && card.next_review_due && isValidDate(parseISO(card.next_review_due)))
                        ? parseISO(card.next_review_due)
                        : now,
            failedAttemptsInLearnSession: 0,
            hardAttemptsInLearnSession: 0,
            justSeenInSession: false,
            originalSrsLevelOnLoad: card.srs_level, // Store original level
        };
        return { card, internalState };
    });

    // 3. Sort the queue
    return sortSessionQueue(sessionCards, sessionType);
}

/**
 * Sorts the session queue.
 * For 'unified' mode, learning cards (srs_level 0, not relearning) are prioritized first,
 * then all cards are sorted by their dueTime.
 * For 'learn-only' and 'review-only', sorts primarily by dueTime.
 */
function sortSessionQueue(queue: SessionCard[], sessionType: SessionType): SessionCard[] {
    return [...queue].sort((a, b) => {
        if (sessionType === 'unified') {
            const aIsLearning = a.card.srs_level === 0 && a.card.learning_state !== 'relearning';
            const bIsLearning = b.card.srs_level === 0 && b.card.learning_state !== 'relearning';

            if (aIsLearning && !bIsLearning) return -1; // a (learning) comes before b (review)
            if (!aIsLearning && bIsLearning) return 1;  // b (learning) comes before a (review)
            // If both are learning or both are review, sort by dueTime
        }
        // Default sort by dueTime for all other cases or when types are same in unified
        return a.internalState.dueTime.getTime() - b.internalState.dueTime.getTime();
    });
}

/**
 * Finds the index of the next card to study in the queue.
 * Returns the index of the first card where internalState.dueTime <= now.
 * If no card is due, returns queue.length (indicating a waiting state).
 *
 * @param queue The current session queue.
 * @returns The index of the next due card, or queue.length.
 */
export function findNextCardIndex(queue: SessionCard[]): number {
    if (!queue || queue.length === 0) return 0; // Or queue.length, but 0 is fine for empty

    const now = new Date();
    const nextIndex = queue.findIndex(item => item.internalState.dueTime <= now);

    return nextIndex !== -1 ? nextIndex : queue.length;
}

/**
 * Updates the session queue after a card has been answered.
 *
 * @param currentQueue The current session queue.
 * @param answeredCardId The ID of the card that was just answered.
 * @param answerOutcome The result from card-state-handlers, containing updated states and queue instruction.
 * @param settings User settings, for `customLearnRequeueGap`.
 * @returns The new session queue, sorted.
 */
export function updateQueueAfterAnswer(
    currentQueue: SessionCard[],
    answeredCardId: string,
    answerOutcome: CardStateUpdateOutcome, // This is the outcome from card-state-handlers
    settings: Settings
): SessionCard[] {
    const { nextInternalState, queueInstruction, reinsertAfterNJobs } = answerOutcome;

    let newQueue = [...currentQueue];
    const answeredItemIndex = newQueue.findIndex(item => item.card.id === answeredCardId);

    if (answeredItemIndex === -1) {
        console.error(`[QueueManager] Could not find answered card ${answeredCardId} in queue to update.`);
        return currentQueue; // Return original queue if card not found
    }

    // Get the card data from the item that was answered (it might have been updated by the handler)
    // The `answerOutcome.dbUpdatePayload` contains the new DB state, but for the queue, we need the SessionCard structure.
    // The `nextInternalState` is the critical piece for the queue.
    // The card's DB-relevant fields within SessionCard.card should also reflect `answerOutcome.dbUpdatePayload`.
    const originalAnsweredItem = newQueue[answeredItemIndex];
    const updatedAnsweredCardData = { ...originalAnsweredItem.card, ...answerOutcome.dbUpdatePayload };

    // Remove the answered card first
    newQueue.splice(answeredItemIndex, 1);

    if (queueInstruction === 'remove') {
        // Card is removed permanently from this session (graduated or completed review)
        console.log(`[QueueManager] Card ${answeredCardId} removed from queue.`);
    } else {
        const itemToReinsert: SessionCard = {
            card: updatedAnsweredCardData as StudyCardDb, // Assert as StudyCardDb after merging
            internalState: nextInternalState,
        };

        if (queueInstruction === 're-queue-soon' && reinsertAfterNJobs !== undefined) {
            const insertPos = Math.min(answeredItemIndex + reinsertAfterNJobs, newQueue.length);
            newQueue.splice(insertPos, 0, itemToReinsert);
            console.log(`[QueueManager] Card ${answeredCardId} re-queued sooner at index ${insertPos}.`);
        } else if (queueInstruction === 're-queue-later') {
            newQueue.push(itemToReinsert); // Add to the end
            console.log(`[QueueManager] Card ${answeredCardId} re-queued later (end of current due items).`);
        } else if (queueInstruction === 'set-timed-step') {
            // Card stays in queue, its dueTime in nextInternalState determines its new position
            newQueue.push(itemToReinsert); // Add it back, sort will place it
            console.log(`[QueueManager] Card ${answeredCardId} updated for timed step. Due: ${nextInternalState.dueTime}`);
        }
    }

    // Always re-sort the queue as dueTimes or item order might have changed
    // The sort function used here might need to be aware of the overall sessionType if unified prioritization is complex.
    // For now, a simple dueTime sort after initial prioritization should work.
    return newQueue.sort((a, b) => a.internalState.dueTime.getTime() - b.internalState.dueTime.getTime());
}


/**
 * Determines the delay for the next due check timer.
 *
 * @param queue The current session queue.
 * @returns The delay in milliseconds, or null if no timer is needed.
 */
export function getNextDueCheckDelay(queue: SessionCard[]): number | null {
    if (queue.length === 0) return null;

    const now = new Date();
    let soonestFutureDueTime: Date | null = null;

    // Queue should already be sorted by dueTime by updateQueueAfterAnswer or initializeQueue
    for (const item of queue) {
        if (item.internalState.dueTime > now) {
            soonestFutureDueTime = item.internalState.dueTime;
            break;
        }
    }

    if (soonestFutureDueTime) {
        const delay = soonestFutureDueTime.getTime() - now.getTime();
        return Math.max(delay + 100, 100); // Add buffer, min 100ms
    }

    return null; // No future due cards, no timer needed immediately
}
```

## Directory: lib/supabase

### File: lib/supabase/server.ts

```
import { createServerClient as createSSRClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'
import { type Database } from '@/types/database'
import { appLogger, statusLogger } from '@/lib/logger'

/**
 * Creates a Supabase client for use in Server Components.
 * The cookie handler is fully async-compatible with dynamic routes.
 */
export function createServerClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  
  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase environment variables')
  }
  
  return createSSRClient<Database>(supabaseUrl, supabaseAnonKey, {
    cookies: {
      async get(name: string) {
        // Use a try-catch to handle any potential errors with cookie access
        try {
          // For dynamic routes, we need to await the cookies() function itself
          const cookieStore = await cookies()
          return cookieStore.get(name)?.value
        } catch (error) {
          appLogger.error(`Error accessing cookie ${name}:`, error)
          return undefined
        }
      },
      async set(name: string, value: string, options: CookieOptions) {
        try {
          const cookieStore = await cookies()
          cookieStore.set({ name, value, ...options })
        } catch (error) {
          // This happens in read-only contexts like middleware or edge functions
          appLogger.info(`Cookie ${name} not set - read-only context`)
        }
      },
      async remove(name: string, options: CookieOptions) {
        try {
          const cookieStore = await cookies()
          cookieStore.set({ name, value: '', ...options })
        } catch (error) {
          // This happens in read-only contexts like middleware or edge functions
          appLogger.info(`Cookie ${name} not removed - read-only context`)
        }
      },
    },
  })
}

/**
 * Creates a Supabase client for use in Server Actions and Route Handlers.
 * The cookie handler is fully async-compatible with dynamic routes.
 */
export function createActionClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  
  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase environment variables')
  }
  
  return createSSRClient<Database>(supabaseUrl, supabaseAnonKey, {
    cookies: {
      async get(name: string) {
        try {
          // Await the cookies() function itself
          const cookieStore = await cookies()
          return cookieStore.get(name)?.value
        } catch (error) {
          appLogger.error(`Error accessing cookie ${name}:`, error)
          return undefined
        }
      },
      async set(name: string, value: string, options: CookieOptions) {
        try {
          const cookieStore = await cookies()
          cookieStore.set({ name, value, ...options })
        } catch (error) {
          // This happens in read-only contexts
          appLogger.info(`Cookie ${name} not set - read-only context`)
        }
      },
      async remove(name: string, options: CookieOptions) {
        try {
          const cookieStore = await cookies()
          cookieStore.set({ name, value: '', ...options })
        } catch (error) {
          // This happens in read-only contexts
          appLogger.info(`Cookie ${name} not removed - read-only context`)
        }
      },
    },
  })
}

/**
 * For backward compatibility with existing code.
 * The cookie handler is fully async-compatible with dynamic routes.
 */
export function createDynamicRouteClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  
  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase environment variables')
  }
  
  return createSSRClient<Database>(supabaseUrl, supabaseAnonKey, {
    cookies: {
      async get(name: string) {
        try {
          // Await the cookies() function itself
          const cookieStore = await cookies()
          return cookieStore.get(name)?.value
        } catch (error) {
          appLogger.error(`Error accessing cookie ${name}:`, error)
          return undefined
        }
      },
      async set(name: string, value: string, options: CookieOptions) {
        try {
          const cookieStore = await cookies()
          cookieStore.set({ name, value, ...options })
        } catch (error) {
          appLogger.info(`Cookie ${name} not set - read-only context`)
        }
      },
      async remove(name: string, options: CookieOptions) {
        try {
          const cookieStore = await cookies()
          cookieStore.set({ name, value: '', ...options })
        } catch (error) {
          appLogger.info(`Cookie ${name} not removed - read-only context`)
        }
      },
    },
  })
}

/**
 * Creates a client without authentication (for public data)
 */
export function createAnonymousClient() {
  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  
  if (!supabaseUrl || !supabaseAnonKey) {
    throw new Error('Missing Supabase environment variables')
  }
  
  // For anonymous access, we don't need cookie handling
  return createSSRClient<Database>(supabaseUrl, supabaseAnonKey, {
    cookies: {
      get: () => undefined,
      set: () => {},
      remove: () => {},
    },
  })
} 
```

## Directory: node_modules/@google-cloud

## Directory: node_modules/@hookform

## Directory: node_modules/@next

## Directory: node_modules/@radix-ui

## Directory: node_modules/@supabase

## Directory: node_modules/@testing-library

## Directory: node_modules/@types

## Directory: node_modules/@typescript-eslint

## Directory: node_modules/@vercel

## Directory: providers

### File: providers/settings-provider.tsx

```
"use client";

import React, { createContext, useContext, useState, useEffect, useCallback } from "react";
import { useAuth } from "@/hooks/use-auth";
import { getUserSettings, updateUserSettings } from "@/lib/actions/settingsActions";
import { toast } from "sonner";
import type { Database, Tables, Json } from "@/types/database"; // Ensure this is updated
import type { ActionResult } from '@/lib/actions/types'; // Ensure path is correct
// --- Import Palette types and defaults ---
import {
    DEFAULT_PALETTE_CONFIG,
    // DEFAULT_WORD_COLORS // No longer needed here if palettes cover defaults
} from "@/lib/palettes"; // Adjust path if needed
import { appLogger, statusLogger } from '@/lib/logger';
// -----------------------------------------


// Debug flag
const DEBUG = true;

// Debug logging function
const debug = (...args: any[]) => {
  if (DEBUG && process.env.NODE_ENV !== 'production') {
    appLogger.info('[Settings Provider Debug]:', ...args); // Use debug instead of warn
  }
};

// Define types
export type ThemePreference = "light" | "dark" | "system";
export type FontOption = "default" | "opendyslexic" | "atkinson";

// --- Updated Settings Interface ---
export interface Settings {
  appLanguage: string;
  cardFont: FontOption;
  showDifficulty: boolean;
  ttsEnabled: boolean;
  removeMasteredCards?: boolean;
  languageDialects: { // Non-nullable
    en: string;
    nl: string;
    fr: string;
    de: string;
    es: string;
    it: string;
  };
  enableBasicColorCoding: boolean;
  enableAdvancedColorCoding: boolean;
  wordPaletteConfig: Record<string, Record<string, string>>; // Stores Palette IDs
  colorOnlyNonNative: boolean;
  showDeckProgress: boolean;
  themePreference: ThemePreference;

  // --- NEW Study Algorithm Fields ---
  studyAlgorithm: 'dedicated-learn' | 'standard-sm2';
  enableDedicatedLearnMode: boolean;
  masteryThreshold: number;
  customLearnRequeueGap: number;
  graduatingIntervalDays: number;
  easyIntervalDays: number;
  relearningStepsMinutes: number[];
  initialLearningStepsMinutes: number[];
  lapsedEfPenalty: number;
  learnAgainPenalty: number;
    learnHardPenalty: number;
  minEasinessFactor: number;
  defaultEasinessFactor: number;
}

// Re-declare DB Type Alias to potentially help TS
type DbSettings = Tables<'settings'>;

interface SettingsContextType {
  settings: Settings | null;
  updateSettings: (updates: Partial<Settings>) => Promise<ActionResult<DbSettings | null>>;
  loading: boolean;
}

// --- Updated Default Settings ---
export const DEFAULT_SETTINGS: Settings = {
  appLanguage: "en",
  cardFont: "default",
  showDifficulty: true,
  ttsEnabled: true,
  removeMasteredCards: false,
  languageDialects: {
    en: "en-GB", nl: "nl-NL", fr: "fr-FR", de: "de-DE", es: "es-ES", it: "it-IT",
  },
  enableBasicColorCoding: true,
  enableAdvancedColorCoding: false,
  wordPaletteConfig: DEFAULT_PALETTE_CONFIG,
  colorOnlyNonNative: true,
  showDeckProgress: true,
  themePreference: 'system',

  // --- NEW Study Algorithm Defaults ---
  studyAlgorithm: 'dedicated-learn',
  enableDedicatedLearnMode: true,
  masteryThreshold: 3,
  customLearnRequeueGap: 3,
  graduatingIntervalDays: 1,
  easyIntervalDays: 4,
  relearningStepsMinutes: [10, 1440],
  initialLearningStepsMinutes: [1, 10],
  lapsedEfPenalty: 0.2,
  learnAgainPenalty: 0.2,
  learnHardPenalty: 0.05,
  minEasinessFactor: 1.3,
  defaultEasinessFactor: 2.5,
};

// --- Updated Transformation Function ---
const transformDbSettingsToSettings = (dbSettings: DbSettings | null): Settings => {
    if (!dbSettings) {
        debug('transformDbSettingsToSettings: No DB settings provided, returning default.');
        return { ...DEFAULT_SETTINGS }; // Return a copy
    }
    try {
        debug('transformDbSettingsToSettings: Transforming DB settings:', dbSettings);
        const cardFontValue = dbSettings.card_font as FontOption | null;
        const isValidFont = ['default', 'opendyslexic', 'atkinson'].includes(cardFontValue ?? '');
        const cardFontFinal = isValidFont && cardFontValue ? cardFontValue : DEFAULT_SETTINGS.cardFont;

        const dbDialects = dbSettings.language_dialects as Record<string, string> | null;
        const languageDialectsFinal = { ...(DEFAULT_SETTINGS.languageDialects), ...(dbDialects ?? {}) };

        // --- Handle Palette Config ---
        // Read the new snake_case column from the DB type
        const dbPaletteConfig = dbSettings.word_palette_config as Record<string, Record<string, string>> | null;
        // Merge DB config over the imported defaults
        const wordPaletteConfigFinal = dbPaletteConfig ? { ...DEFAULT_PALETTE_CONFIG, ...dbPaletteConfig } : { ...DEFAULT_PALETTE_CONFIG };
        // --------------------------

        // Determine studyAlgorithm based on enable_dedicated_learn_mode for simplicity
        // You might want a dedicated 'study_algorithm' column in the DB later
        const studyAlgorithmFinal = (dbSettings.enable_dedicated_learn_mode ?? DEFAULT_SETTINGS.enableDedicatedLearnMode)
            ? 'dedicated-learn'
            : 'standard-sm2';

        const transformed: Settings = {
            appLanguage: dbSettings.app_language ?? DEFAULT_SETTINGS.appLanguage,
            languageDialects: languageDialectsFinal,
            ttsEnabled: dbSettings.tts_enabled ?? DEFAULT_SETTINGS.ttsEnabled,
            showDifficulty: dbSettings.show_difficulty ?? DEFAULT_SETTINGS.showDifficulty,
            cardFont: cardFontFinal,
            enableBasicColorCoding: dbSettings.enable_basic_color_coding ?? DEFAULT_SETTINGS.enableBasicColorCoding,
            enableAdvancedColorCoding: dbSettings.enable_advanced_color_coding ?? DEFAULT_SETTINGS.enableAdvancedColorCoding,
            wordPaletteConfig: wordPaletteConfigFinal,
            colorOnlyNonNative: dbSettings.color_only_non_native ?? DEFAULT_SETTINGS.colorOnlyNonNative,
            showDeckProgress: dbSettings.show_deck_progress ?? DEFAULT_SETTINGS.showDeckProgress,
            themePreference: (dbSettings.theme_light_dark_mode ?? DEFAULT_SETTINGS.themePreference) as ThemePreference,

            // --- NEW Study Algorithm Mappings ---
            studyAlgorithm: studyAlgorithmFinal,
            enableDedicatedLearnMode: dbSettings.enable_dedicated_learn_mode ?? DEFAULT_SETTINGS.enableDedicatedLearnMode,
            masteryThreshold: dbSettings.mastery_threshold ?? DEFAULT_SETTINGS.masteryThreshold,
            customLearnRequeueGap: dbSettings.custom_learn_requeue_gap ?? DEFAULT_SETTINGS.customLearnRequeueGap,
            graduatingIntervalDays: dbSettings.graduating_interval_days ?? DEFAULT_SETTINGS.graduatingIntervalDays,
            easyIntervalDays: dbSettings.easy_interval_days ?? DEFAULT_SETTINGS.easyIntervalDays,
            // Ensure arrays are handled correctly, provide default if null/invalid
            relearningStepsMinutes: Array.isArray(dbSettings.relearning_steps_minutes) ? dbSettings.relearning_steps_minutes : DEFAULT_SETTINGS.relearningStepsMinutes,
            initialLearningStepsMinutes: Array.isArray(dbSettings.initial_learning_steps_minutes) ? dbSettings.initial_learning_steps_minutes : DEFAULT_SETTINGS.initialLearningStepsMinutes,
            // Ensure numbers are handled correctly
            lapsedEfPenalty: typeof dbSettings.lapsed_ef_penalty === 'number' ? dbSettings.lapsed_ef_penalty : DEFAULT_SETTINGS.lapsedEfPenalty,
            learnAgainPenalty: typeof dbSettings.learn_again_penalty === 'number' ? dbSettings.learn_again_penalty : DEFAULT_SETTINGS.learnAgainPenalty,
            learnHardPenalty: typeof dbSettings.learn_hard_penalty === 'number' ? dbSettings.learn_hard_penalty : DEFAULT_SETTINGS.learnHardPenalty,
            minEasinessFactor: typeof dbSettings.min_easiness_factor === 'number' ? dbSettings.min_easiness_factor : DEFAULT_SETTINGS.minEasinessFactor,
            defaultEasinessFactor: typeof dbSettings.default_easiness_factor === 'number' ? dbSettings.default_easiness_factor : DEFAULT_SETTINGS.defaultEasinessFactor,
        };
        debug('transformDbSettingsToSettings: Transformation result:', transformed);
        return transformed;
    } catch (e) {
        appLogger.error("Error transforming DbSettings:", e);
        debug('transformDbSettingsToSettings: Error during transformation, returning default.');
        return { ...DEFAULT_SETTINGS }; // Return copy on error
    }
};

// Context Definition (Unchanged)
export const SettingsContext = createContext<SettingsContextType>({
  settings: null,
  updateSettings: async () => ({ data: null, error: "Context not initialized" }),
  loading: true,
});

// SettingsProvider Component (Logic unchanged, uses updated types/defaults)
export function SettingsProvider({ children }: { children: React.ReactNode }) {
  debug('SettingsProvider initializing');
  const { user } = useAuth();
  const [settings, setSettings] = useState<Settings | null>(null);
  const [loading, setLoading] = useState(true);

  // Fetch Settings Effect (Unchanged)
  useEffect(() => {
    debug('Settings load effect triggered', { userId: user?.id });
    if (!user) {
      debug('No user, setting settings to null and loading to false');
      setSettings(null);
      setLoading(false);
      return;
    }
    let isMounted = true;
    const loadSettings = async () => {
      debug('Setting loading true');
      if (isMounted) setLoading(true);
      try {
        debug('Loading settings via action for user', user.id);
        const { data: dbSettings, error } = await getUserSettings();
        if (!isMounted) { debug("Component unmounted during settings load"); return; }

        if (error) {
          appLogger.error("Failed to load settings:", error);
          debug('Error loading settings, using defaults', DEFAULT_SETTINGS);
          toast.error("Failed to load settings", { description: error || "Using default settings." });
          setSettings({ ...DEFAULT_SETTINGS });
        } else {
          const finalSettings = transformDbSettingsToSettings(dbSettings); // Uses updated transform
          debug('Setting user settings state', finalSettings);
          setSettings(finalSettings);
        }
      } catch (unexpectedError) {
        appLogger.error("Unexpected error during settings load:", unexpectedError);
        debug('Unexpected error, using defaults', DEFAULT_SETTINGS);
        toast.error("Error", { description: "An unexpected error occurred while loading settings. Using default values." });
        if (isMounted) setSettings({ ...DEFAULT_SETTINGS });
      } finally {
        debug('Setting loading false');
        if (isMounted) setLoading(false);
      }
    };
    loadSettings();
    return () => { isMounted = false; debug("Settings load effect cleanup"); };
  }, [user]);

  // Update Settings Callback (Unchanged)
  const updateSettings = useCallback(async (
    updates: Partial<Settings> // Accepts Partial<Settings> with wordPaletteConfig
  ): Promise<ActionResult<DbSettings | null>> => {
    debug('updateSettings called', { current: settings, updates });
    if (!user) {
         debug('Cannot update settings - no user');
         toast.warning("Cannot save settings", { description: "You must be logged in." });
         return { data: null, error: "Not authenticated" };
    }
    if (!settings) {
        debug('Cannot update settings - current settings are null/not loaded');
        toast.warning("Cannot save settings", { description: "Settings not loaded yet." });
        return { data: null, error: "Settings not loaded" };
    }

    const previousSettings = { ...settings };
    debug('Applying optimistic update');
    setSettings(prev => prev ? { ...prev, ...updates } : null);

    try {
      debug('Calling updateUserSettings action with updates:', updates);
      // Action needs to handle mapping wordPaletteConfig -> word_palette_config
      const { data, error } = await updateUserSettings({ updates: updates });

      if (error) {
        appLogger.error("Failed to update settings via action:", error);
        debug('Settings action update failed, reverting optimistic update', { error });
        toast.error("Error Saving Settings", { description: error || "Could not save settings." });
        setSettings(previousSettings);
        return { data: null, error: error };
      } else {
        debug('Settings action update successful, optimistic update confirmed', data);
        // OPTIONAL: Re-transform DB data if needed
        // setSettings(transformDbSettingsToSettings(data));
        return { data, error: null };
      }
    } catch (unexpectedError) {
      appLogger.error("Unexpected error during settings action call:", unexpectedError);
      debug('Unexpected settings update error, reverting optimistic update');
      const errorMsg = unexpectedError instanceof Error ? unexpectedError.message : "An unexpected error occurred.";
      toast.error("Error Saving Settings", { description: errorMsg });
      setSettings(previousSettings);
      return { data: null, error: errorMsg };
    }
  }, [settings, user]); // Dependencies

  // Log state changes (Unchanged)
  useEffect(() => { debug('Settings state changed', { settings, loading }); }, [settings, loading]);

  return (
    <SettingsContext.Provider value={{ settings, updateSettings, loading }}>
      {children}
    </SettingsContext.Provider>
  );
}

// useSettings Hook (Unchanged)
export function useSettings() {
  const context = useContext(SettingsContext);
  if (context === undefined) {
    throw new Error("useSettings must be used within a SettingsProvider");
  }
  return context;
}
```

## Directory: scripts

### File: scripts/export_codebase.sh

```
#!/usr/bin/env bash
# scripts/export_codebase.sh
# Generates a Markdown overview of your codebase, excluding specified files & dirs.

set -euo pipefail

OUTPUT="codebase_overview.md"

# 1) Start fresh with a title
printf "# Project Codebase Overview\n\n" > "$OUTPUT"

# 2) Print an indentation-only tree, skipping unwanted dirs/files
tree -i -f \
  -I '.*|logs|node_modules|public|*.yaml|*.txt|*.pdf|*.md|.DS_Store|.env.local|tsconfig.tsbuildinfo' \
  >> "$OUTPUT"

printf "\n\n" >> "$OUTPUT"

# 3) Walk each directory, then dump files
find . -type d \
  ! -path '*/.*' \
  ! -path './logs' \
  ! -path './node_modules' \
  ! -path './public' \
  ! -path './public/*' \
| sort \
| while read -r dir; do
  DIR_NAME=${dir#./}; [[ -z "$DIR_NAME" ]] && DIR_NAME="Root"
  printf "## Directory: %s\n\n" "$DIR_NAME" >> "$OUTPUT"

  find "$dir" -maxdepth 1 -type f \
    ! -name "*.yaml" \
    ! -name "*.txt" \
    ! -name "*.pdf" \
    ! -name "*.md" \
    ! -name ".DS_Store" \
    ! -name ".env.local" \
    ! -name "tsconfig.tsbuildinfo" \
    ! -name "$OUTPUT" \
  | sort \
  | while read -r file; do
    REL=${file#./}
    printf "### File: %s\n\n" "$REL" >> "$OUTPUT"
    printf '```\n' >> "$OUTPUT"
    sed '' "$file" >> "$OUTPUT"
    printf '\n```\n\n' >> "$OUTPUT"
  done
done
```

## Directory: store

### File: store/studySessionStore.ts

```
// store/studySessionStore.ts
import { create } from 'zustand';
// Import the centralized types from types/study.ts
import type { StudySessionInput, SessionType } from '@/types/study';
import { appLogger } from '@/lib/logger'; // Assuming logger is correctly set up

interface StudySessionState {
  currentInput: StudySessionInput | null;
  currentSessionType: SessionType | null; // Changed from currentMode to currentSessionType
  setStudyParameters: (input: StudySessionInput, sessionType: SessionType) => void; // Parameter changed
  clearStudyParameters: () => void;
}

/**
 * Zustand store to manage the parameters for the current or upcoming study session.
 * It now stores SessionType ('learn-only', 'review-only', 'unified') instead of the simpler StudyMode.
 */
export const useStudySessionStore = create<StudySessionState>((set) => ({
  currentInput: null,
  currentSessionType: null, // Initialize currentSessionType
  setStudyParameters: (input, sessionType) => {
      appLogger.info("[StudySessionStore] Setting parameters:", { input, sessionType });
      set({ currentInput: input, currentSessionType: sessionType }); // Store sessionType
  },
  clearStudyParameters: () => {
      appLogger.info("[StudySessionStore] Clearing parameters.");
      set({ currentInput: null, currentSessionType: null }); // Clear sessionType
  },
}));
```

## Directory: supabase

### File: supabase/.gitignore

```
# Supabase
.branches
.temp

# dotenvx
.env.keys
.env.local
.env.*.local

```

### File: supabase/config.toml

```
# For detailed configuration reference documentation, visit:
# https://supabase.com/docs/guides/local-development/cli/config
# A string used to distinguish different Supabase projects on the same host. Defaults to the
# working directory name when running `supabase init`.
project_id = "flashcards"

[api]
enabled = true
# Port to use for the API URL.
port = 54321
# Schemas to expose in your API. Tables, views and stored procedures in this schema will get API
# endpoints. `public` and `graphql_public` schemas are included by default.
schemas = ["public", "graphql_public"]
# Extra schemas to add to the search_path of every request.
extra_search_path = ["public", "extensions"]
# The maximum number of rows returns from a view, table, or stored procedure. Limits payload size
# for accidental or malicious requests.
max_rows = 1000

[api.tls]
# Enable HTTPS endpoints locally using a self-signed certificate.
enabled = false

[db]
# Port to use for the local database URL.
port = 54322
# Port used by db diff command to initialize the shadow database.
shadow_port = 54320
# The database major version to use. This has to be the same as your remote database's. Run `SHOW
# server_version;` on the remote database to check.
major_version = 15

[db.pooler]
enabled = false
# Port to use for the local connection pooler.
port = 54329
# Specifies when a server connection can be reused by other clients.
# Configure one of the supported pooler modes: `transaction`, `session`.
pool_mode = "transaction"
# How many server connections to allow per user/database pair.
default_pool_size = 20
# Maximum number of client connections allowed.
max_client_conn = 100

# [db.vault]
# secret_key = "env(SECRET_VALUE)"

[db.migrations]
# Specifies an ordered list of schema files that describe your database.
# Supports glob patterns relative to supabase directory: "./schemas/*.sql"
schema_paths = []

[db.seed]
# If enabled, seeds the database after migrations during a db reset.
enabled = true
# Specifies an ordered list of seed files to load during db reset.
# Supports glob patterns relative to supabase directory: "./seeds/*.sql"
sql_paths = ["./seed.sql"]

[realtime]
enabled = true
# Bind realtime via either IPv4 or IPv6. (default: IPv4)
# ip_version = "IPv6"
# The maximum length in bytes of HTTP request headers. (default: 4096)
# max_header_length = 4096

[studio]
enabled = true
# Port to use for Supabase Studio.
port = 54323
# External URL of the API server that frontend connects to.
api_url = "http://127.0.0.1"
# OpenAI API Key to use for Supabase AI in the Supabase Studio.
openai_api_key = "env(OPENAI_API_KEY)"

# Email testing server. Emails sent with the local dev setup are not actually sent - rather, they
# are monitored, and you can view the emails that would have been sent from the web interface.
[inbucket]
enabled = true
# Port to use for the email testing server web interface.
port = 54324
# Uncomment to expose additional ports for testing user applications that send emails.
# smtp_port = 54325
# pop3_port = 54326
# admin_email = "admin@email.com"
# sender_name = "Admin"

[storage]
enabled = true
# The maximum file size allowed (e.g. "5MB", "500KB").
file_size_limit = "50MiB"

# Image transformation API is available to Supabase Pro plan.
# [storage.image_transformation]
# enabled = true

# Uncomment to configure local storage buckets
# [storage.buckets.images]
# public = false
# file_size_limit = "50MiB"
# allowed_mime_types = ["image/png", "image/jpeg"]
# objects_path = "./images"

[auth]
enabled = true
# The base URL of your website. Used as an allow-list for redirects and for constructing URLs used
# in emails.
site_url = "http://127.0.0.1:3000"
# A list of *exact* URLs that auth providers are permitted to redirect to post authentication.
additional_redirect_urls = ["https://127.0.0.1:3000"]
# How long tokens are valid for, in seconds. Defaults to 3600 (1 hour), maximum 604,800 (1 week).
jwt_expiry = 3600
# If disabled, the refresh token will never expire.
enable_refresh_token_rotation = true
# Allows refresh tokens to be reused after expiry, up to the specified interval in seconds.
# Requires enable_refresh_token_rotation = true.
refresh_token_reuse_interval = 10
# Allow/disallow new user signups to your project.
enable_signup = true
# Allow/disallow anonymous sign-ins to your project.
enable_anonymous_sign_ins = false
# Allow/disallow testing manual linking of accounts
enable_manual_linking = false
# Passwords shorter than this value will be rejected as weak. Minimum 6, recommended 8 or more.
minimum_password_length = 6
# Passwords that do not meet the following requirements will be rejected as weak. Supported values
# are: `letters_digits`, `lower_upper_letters_digits`, `lower_upper_letters_digits_symbols`
password_requirements = ""

[auth.rate_limit]
# Number of emails that can be sent per hour. Requires auth.email.smtp to be enabled.
email_sent = 2
# Number of SMS messages that can be sent per hour. Requires auth.sms to be enabled.
sms_sent = 30
# Number of anonymous sign-ins that can be made per hour per IP address. Requires enable_anonymous_sign_ins = true.
anonymous_users = 30
# Number of sessions that can be refreshed in a 5 minute interval per IP address.
token_refresh = 150
# Number of sign up and sign-in requests that can be made in a 5 minute interval per IP address (excludes anonymous users).
sign_in_sign_ups = 30
# Number of OTP / Magic link verifications that can be made in a 5 minute interval per IP address.
token_verifications = 30

# Configure one of the supported captcha providers: `hcaptcha`, `turnstile`.
# [auth.captcha]
# enabled = true
# provider = "hcaptcha"
# secret = ""

[auth.email]
# Allow/disallow new user signups via email to your project.
enable_signup = true
# If enabled, a user will be required to confirm any email change on both the old, and new email
# addresses. If disabled, only the new email is required to confirm.
double_confirm_changes = true
# If enabled, users need to confirm their email address before signing in.
enable_confirmations = false
# If enabled, users will need to reauthenticate or have logged in recently to change their password.
secure_password_change = false
# Controls the minimum amount of time that must pass before sending another signup confirmation or password reset email.
max_frequency = "1s"
# Number of characters used in the email OTP.
otp_length = 6
# Number of seconds before the email OTP expires (defaults to 1 hour).
otp_expiry = 3600

# Use a production-ready SMTP server
# [auth.email.smtp]
# enabled = true
# host = "smtp.sendgrid.net"
# port = 587
# user = "apikey"
# pass = "env(SENDGRID_API_KEY)"
# admin_email = "admin@email.com"
# sender_name = "Admin"

# Uncomment to customize email template
# [auth.email.template.invite]
# subject = "You have been invited"
# content_path = "./supabase/templates/invite.html"

[auth.sms]
# Allow/disallow new user signups via SMS to your project.
enable_signup = false
# If enabled, users need to confirm their phone number before signing in.
enable_confirmations = false
# Template for sending OTP to users
template = "Your code is {{ .Code }}"
# Controls the minimum amount of time that must pass before sending another sms otp.
max_frequency = "5s"

# Use pre-defined map of phone number to OTP for testing.
# [auth.sms.test_otp]
# 4152127777 = "123456"

# Configure logged in session timeouts.
# [auth.sessions]
# Force log out after the specified duration.
# timebox = "24h"
# Force log out if the user has been inactive longer than the specified duration.
# inactivity_timeout = "8h"

# This hook runs before a token is issued and allows you to add additional claims based on the authentication method used.
# [auth.hook.custom_access_token]
# enabled = true
# uri = "pg-functions://<database>/<schema>/<hook_name>"

# Configure one of the supported SMS providers: `twilio`, `twilio_verify`, `messagebird`, `textlocal`, `vonage`.
[auth.sms.twilio]
enabled = false
account_sid = ""
message_service_sid = ""
# DO NOT commit your Twilio auth token to git. Use environment variable substitution instead:
auth_token = "env(SUPABASE_AUTH_SMS_TWILIO_AUTH_TOKEN)"

# Multi-factor-authentication is available to Supabase Pro plan.
[auth.mfa]
# Control how many MFA factors can be enrolled at once per user.
max_enrolled_factors = 10

# Control MFA via App Authenticator (TOTP)
[auth.mfa.totp]
enroll_enabled = false
verify_enabled = false

# Configure MFA via Phone Messaging
[auth.mfa.phone]
enroll_enabled = false
verify_enabled = false
otp_length = 6
template = "Your code is {{ .Code }}"
max_frequency = "5s"

# Configure MFA via WebAuthn
# [auth.mfa.web_authn]
# enroll_enabled = true
# verify_enabled = true

# Use an external OAuth provider. The full list of providers are: `apple`, `azure`, `bitbucket`,
# `discord`, `facebook`, `github`, `gitlab`, `google`, `keycloak`, `linkedin_oidc`, `notion`, `twitch`,
# `twitter`, `slack`, `spotify`, `workos`, `zoom`.
[auth.external.apple]
enabled = false
client_id = ""
# DO NOT commit your OAuth provider secret to git. Use environment variable substitution instead:
secret = "env(SUPABASE_AUTH_EXTERNAL_APPLE_SECRET)"
# Overrides the default auth redirectUrl.
redirect_uri = ""
# Overrides the default auth provider URL. Used to support self-hosted gitlab, single-tenant Azure,
# or any other third-party OIDC providers.
url = ""
# If enabled, the nonce check will be skipped. Required for local sign in with Google auth.
skip_nonce_check = false

# Use Firebase Auth as a third-party provider alongside Supabase Auth.
[auth.third_party.firebase]
enabled = false
# project_id = "my-firebase-project"

# Use Auth0 as a third-party provider alongside Supabase Auth.
[auth.third_party.auth0]
enabled = false
# tenant = "my-auth0-tenant"
# tenant_region = "us"

# Use AWS Cognito (Amplify) as a third-party provider alongside Supabase Auth.
[auth.third_party.aws_cognito]
enabled = false
# user_pool_id = "my-user-pool-id"
# user_pool_region = "us-east-1"

# Use Clerk as a third-party provider alongside Supabase Auth.
[auth.third_party.clerk]
enabled = false
# Obtain from https://clerk.com/setup/supabase
# domain = "example.clerk.accounts.dev"

[edge_runtime]
enabled = true
# Configure one of the supported request policies: `oneshot`, `per_worker`.
# Use `oneshot` for hot reload, or `per_worker` for load testing.
policy = "oneshot"
# Port to attach the Chrome inspector for debugging edge functions.
inspector_port = 8083
# The Deno major version to use.
deno_version = 1

# [edge_runtime.secrets]
# secret_key = "env(SECRET_VALUE)"

[analytics]
enabled = true
port = 54327
# Configure one of the supported backends: `postgres`, `bigquery`.
backend = "postgres"

# Experimental features may be deprecated any time
[experimental]
# Configures Postgres storage engine to use OrioleDB (S3)
orioledb_version = ""
# Configures S3 bucket URL, eg. <bucket_name>.s3-<region>.amazonaws.com
s3_host = "env(S3_HOST)"
# Configures S3 bucket region, eg. us-east-1
s3_region = "env(S3_REGION)"
# Configures AWS_ACCESS_KEY_ID for S3 bucket
s3_access_key = "env(S3_ACCESS_KEY)"
# Configures AWS_SECRET_ACCESS_KEY for S3 bucket
s3_secret_key = "env(S3_SECRET_KEY)"

```

## Directory: supabase/migrations

### File: supabase/migrations/20250426200000_add_ai_uploads_storage_policies.sql

```
-- supabase/migrations/add_ai_uploads_storage_policies.sql
-- Migration to add Row Level Security (RLS) policies for the 'ai-uploads' storage bucket.
-- These policies restrict access based on authenticated user ID matching the first part of the file path.
-- Uses DROP IF EXISTS / CREATE to ensure idempotency on older PostgreSQL versions.

-- 1. Policy: Allow authenticated users to upload (INSERT) files into their own folder.
DROP POLICY IF EXISTS "Allow authenticated uploads to own folder" ON storage.objects;
CREATE POLICY "Allow authenticated uploads to own folder" 
ON storage.objects FOR INSERT 
TO authenticated 
WITH CHECK (
  bucket_id = 'ai-uploads' AND 
  auth.uid() = ((storage.foldername(name))[1])::uuid -- Cast text folder name to uuid
);

-- 2. Policy: Allow authenticated users to download/view (SELECT) files from their own folder.
DROP POLICY IF EXISTS "Allow authenticated selects from own folder" ON storage.objects;
CREATE POLICY "Allow authenticated selects from own folder" 
ON storage.objects FOR SELECT 
TO authenticated 
USING (
  bucket_id = 'ai-uploads' AND 
  auth.uid() = ((storage.foldername(name))[1])::uuid -- Cast text folder name to uuid
);

-- 3. Policy: Allow authenticated users to delete (DELETE) files from their own folder.
DROP POLICY IF EXISTS "Allow authenticated deletes from own folder" ON storage.objects;
CREATE POLICY "Allow authenticated deletes from own folder" 
ON storage.objects FOR DELETE 
TO authenticated 
USING (
  bucket_id = 'ai-uploads' AND 
  auth.uid() = ((storage.foldername(name))[1])::uuid -- Cast text folder name to uuid
);

-- 4. Policy: Allow authenticated users to update (UPDATE) files in their own folder.
DROP POLICY IF EXISTS "Allow authenticated updates in own folder" ON storage.objects;
CREATE POLICY "Allow authenticated updates in own folder" 
ON storage.objects FOR UPDATE 
TO authenticated 
USING (
  bucket_id = 'ai-uploads' AND 
  auth.uid() = ((storage.foldername(name))[1])::uuid -- Cast text folder name to uuid
);

-- Optional: Log the creation of policies (informational)
-- INSERT INTO supabase_migrations.schema_migrations (version) VALUES ('add_ai_uploads_storage_policies');
-- Note: Supabase CLI handles migration versioning automatically. 
```

### File: supabase/migrations/20250427092434_remote_schema.sql

```

```

### File: supabase/migrations/20250427092656_remote_schema.sql

```
create type "public"."font_option" as enum ('default', 'opendyslexic', 'atkinson');

create table "public"."cards" (
    "id" uuid not null default uuid_generate_v4(),
    "deck_id" uuid not null,
    "question" text not null,
    "answer" text not null,
    "correct_count" integer default 0,
    "incorrect_count" integer default 0,
    "last_studied" timestamp with time zone,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now()),
    "attempt_count" integer default 0,
    "difficulty_score" double precision default 0,
    "user_id" uuid,
    "last_reviewed_at" timestamp with time zone,
    "next_review_due" timestamp with time zone,
    "srs_level" integer not null default 0,
    "easiness_factor" double precision default 2.5,
    "interval_days" integer default 0,
    "stability" double precision,
    "difficulty" double precision,
    "last_review_grade" integer,
    "question_part_of_speech" text default 'N/A'::text,
    "question_gender" text default 'N/A'::text,
    "answer_part_of_speech" text default 'N/A'::text,
    "answer_gender" text default 'N/A'::text
);


alter table "public"."cards" enable row level security;

create table "public"."deck_tags" (
    "deck_id" uuid not null,
    "tag_id" uuid not null,
    "user_id" uuid not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."deck_tags" enable row level security;

create table "public"."decks" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "name" text not null,
    "progress" jsonb not null default '{"streak": 0, "correct": 0, "incorrect": 0, "lastStudied": null}'::jsonb,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now()),
    "is_bilingual" boolean not null default false,
    "primary_language" text not null default 'en'::text,
    "secondary_language" text not null default 'en'::text
);


alter table "public"."decks" enable row level security;

create table "public"."settings" (
    "id" uuid not null default gen_random_uuid(),
    "user_id" uuid not null,
    "app_language" text not null default 'english'::text,
    "preferred_voices" jsonb not null default '{"dutch": null, "french": null, "english": null}'::jsonb,
    "created_at" timestamp with time zone default timezone('utc'::text, now()),
    "updated_at" timestamp with time zone default timezone('utc'::text, now()),
    "language_dialects" jsonb default jsonb_build_object('en', 'en-GB', 'nl', 'nl-NL', 'fr', 'fr-FR', 'de', 'de-DE', 'es', 'es-ES', 'it', 'it-IT'),
    "tts_enabled" boolean default true,
    "show_difficulty" boolean default true,
    "mastery_threshold" integer default 3,
    "card_font" character varying(20) default 'default'::character varying,
    "enable_word_color_coding" boolean default false,
    "enable_basic_color_coding" boolean default true,
    "enable_advanced_color_coding" boolean default false,
    "word_palette_config" jsonb,
    "color_only_non_native" boolean default true
);


alter table "public"."settings" enable row level security;

create table "public"."study_sets" (
    "id" uuid not null default uuid_generate_v4(),
    "user_id" uuid not null,
    "name" text not null,
    "description" text,
    "query_criteria" jsonb not null,
    "created_at" timestamp with time zone not null default now(),
    "updated_at" timestamp with time zone not null default now()
);


alter table "public"."study_sets" enable row level security;

create table "public"."tags" (
    "id" uuid not null default uuid_generate_v4(),
    "user_id" uuid not null,
    "name" text not null,
    "created_at" timestamp with time zone not null default now()
);


alter table "public"."tags" enable row level security;

CREATE UNIQUE INDEX cards_pkey ON public.cards USING btree (id);

CREATE UNIQUE INDEX deck_tags_pkey ON public.deck_tags USING btree (deck_id, tag_id);

CREATE UNIQUE INDEX decks_pkey ON public.decks USING btree (id);

CREATE INDEX idx_cards_deck_id ON public.cards USING btree (deck_id);

CREATE INDEX idx_cards_user_id_next_review_due ON public.cards USING btree (user_id, next_review_due);

CREATE INDEX idx_deck_tags_deck_id ON public.deck_tags USING btree (deck_id);

CREATE INDEX idx_deck_tags_tag_id ON public.deck_tags USING btree (tag_id);

CREATE INDEX idx_deck_tags_user_id ON public.deck_tags USING btree (user_id);

CREATE INDEX idx_decks_user_id ON public.decks USING btree (user_id);

CREATE INDEX idx_settings_user_id ON public.settings USING btree (user_id);

CREATE UNIQUE INDEX settings_pkey ON public.settings USING btree (id);

CREATE UNIQUE INDEX study_sets_pkey ON public.study_sets USING btree (id);

CREATE UNIQUE INDEX tags_pkey ON public.tags USING btree (id);

CREATE UNIQUE INDEX tags_user_id_name_key ON public.tags USING btree (user_id, name);

CREATE UNIQUE INDEX unique_user_settings ON public.settings USING btree (user_id);

alter table "public"."cards" add constraint "cards_pkey" PRIMARY KEY using index "cards_pkey";

alter table "public"."deck_tags" add constraint "deck_tags_pkey" PRIMARY KEY using index "deck_tags_pkey";

alter table "public"."decks" add constraint "decks_pkey" PRIMARY KEY using index "decks_pkey";

alter table "public"."settings" add constraint "settings_pkey" PRIMARY KEY using index "settings_pkey";

alter table "public"."study_sets" add constraint "study_sets_pkey" PRIMARY KEY using index "study_sets_pkey";

alter table "public"."tags" add constraint "tags_pkey" PRIMARY KEY using index "tags_pkey";

alter table "public"."cards" add constraint "cards_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."cards" validate constraint "cards_user_id_fkey";

alter table "public"."cards" add constraint "fk_deck" FOREIGN KEY (deck_id) REFERENCES decks(id) ON DELETE CASCADE not valid;

alter table "public"."cards" validate constraint "fk_deck";

alter table "public"."deck_tags" add constraint "deck_tags_deck_id_fkey" FOREIGN KEY (deck_id) REFERENCES decks(id) ON DELETE CASCADE not valid;

alter table "public"."deck_tags" validate constraint "deck_tags_deck_id_fkey";

alter table "public"."deck_tags" add constraint "deck_tags_tag_id_fkey" FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE not valid;

alter table "public"."deck_tags" validate constraint "deck_tags_tag_id_fkey";

alter table "public"."deck_tags" add constraint "deck_tags_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."deck_tags" validate constraint "deck_tags_user_id_fkey";

alter table "public"."decks" add constraint "fk_user" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."decks" validate constraint "fk_user";

alter table "public"."settings" add constraint "settings_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."settings" validate constraint "settings_user_id_fkey";

alter table "public"."settings" add constraint "unique_user_settings" UNIQUE using index "unique_user_settings";

alter table "public"."study_sets" add constraint "study_sets_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."study_sets" validate constraint "study_sets_user_id_fkey";

alter table "public"."tags" add constraint "tags_user_id_fkey" FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE not valid;

alter table "public"."tags" validate constraint "tags_user_id_fkey";

alter table "public"."tags" add constraint "tags_user_id_name_key" UNIQUE using index "tags_user_id_name_key";

set check_function_bodies = off;

CREATE OR REPLACE FUNCTION public.resolve_study_query(p_user_id uuid, p_query_criteria jsonb, p_order_by_field text DEFAULT 'created_at'::text, p_order_by_direction text DEFAULT 'DESC'::text)
 RETURNS TABLE(card_id uuid)
 LANGUAGE plpgsql
AS $function$DECLARE
    v_sql                  TEXT;
    v_from_clause          TEXT := 'FROM cards c';
    v_where_clauses        TEXT[] := ARRAY[]::TEXT[];
    v_params               TEXT[] := ARRAY[]::TEXT[];
    v_param_index          INTEGER := 0;

    -- Parsed criteria variables
    v_deck_id              UUID;
    v_all_cards            BOOLEAN;
    v_include_tags         UUID[];
    v_exclude_tags         UUID[];
    v_tag_logic            TEXT;
    v_deck_title_contains  TEXT;
    v_deck_languages_raw   JSONB;
    v_deck_languages       TEXT[];
    v_created_date_filter  JSONB;
    v_updated_date_filter  JSONB;
    v_last_reviewed_filter JSONB;
    v_next_review_due_filter JSONB;
    v_srs_level_filter     JSONB;
    v_date_operator        TEXT;
    v_date_value_days      INTEGER;
    v_date_value_start     TEXT;
    v_date_value_end       TEXT;
    v_srs_operator         TEXT;
    v_srs_value            INTEGER;
    v_include_difficult    BOOLEAN; -- **[ADDED]**

    -- Ordering variables
    v_order_by_clause      TEXT;
    v_valid_order_field    TEXT;
    v_valid_order_direction TEXT;
    -- ** Use current schema column names, not front_content/back_content **
    v_allowed_order_fields TEXT[] := ARRAY[
        'created_at','updated_at','question','answer', -- Updated field names
        'last_reviewed_at','next_review_due','srs_level',
        'easiness_factor','interval_days','stability','difficulty'
    ];
    v_allowed_directions   TEXT[] := ARRAY['ASC','DESC'];
BEGIN
    RAISE NOTICE '[DEBUG resolve_study_query V4+Diff] START - User: %, Criteria: %', p_user_id, p_query_criteria;

    -- 0. Mandatory user_id filter
    v_where_clauses := array_append(
        v_where_clauses,
        format('c.user_id = %L::uuid', p_user_id)
    );
    RAISE NOTICE '[DEBUG V4+Diff] Added user_id clause';

    -- 1. allCards flag
    v_all_cards := (p_query_criteria->>'allCards')::BOOLEAN;
    IF v_all_cards IS TRUE THEN
        RAISE NOTICE '[DEBUG V4+Diff] allCards = true, skipping filters';
    ELSE
        RAISE NOTICE '[DEBUG V4+Diff] allCards = false, applying filters';

        -- 2. Deck filter (Literal embedding - unchanged from V4)
        v_deck_id := (p_query_criteria->>'deckId')::UUID;
        IF v_deck_id IS NOT NULL THEN
            v_where_clauses := array_append(
                v_where_clauses,
                format('c.deck_id = %L::uuid', v_deck_id)
            );
            RAISE NOTICE '[DEBUG V4+Diff] Added deck_id clause (%)', v_deck_id;
        END IF;

        -- 3. Deck Title / Language Filters (JOIN needed, unchanged from V4)
        v_deck_title_contains := p_query_criteria->>'deckTitleContains';
        v_deck_languages_raw  := p_query_criteria->'deckLanguages';
        IF v_deck_title_contains IS NOT NULL
           OR (v_deck_languages_raw IS NOT NULL
               AND jsonb_typeof(v_deck_languages_raw) = 'array'
               AND jsonb_array_length(v_deck_languages_raw) > 0) THEN
            RAISE NOTICE '[DEBUG V4+Diff] Adding JOIN decks';
            v_from_clause := v_from_clause || ' JOIN decks d ON c.deck_id = d.id';
            IF v_deck_title_contains IS NOT NULL THEN
                v_param_index := v_param_index + 1;
                v_where_clauses := array_append(v_where_clauses, format('d.title ILIKE $%s', v_param_index));
                v_params := array_append(v_params, ('%' || v_deck_title_contains || '%')::TEXT);
                RAISE NOTICE '[DEBUG V4+Diff] Added param $%: deckTitleContains', v_param_index;
            END IF;
            IF v_deck_languages_raw IS NOT NULL AND jsonb_typeof(v_deck_languages_raw) = 'array' AND jsonb_array_length(v_deck_languages_raw) > 0 THEN
                SELECT array_agg(elem::TEXT) INTO v_deck_languages FROM jsonb_array_elements_text(v_deck_languages_raw) AS elem;
                v_param_index := v_param_index + 1;
                v_where_clauses := array_append(v_where_clauses, format('(d.primary_language = ANY($%s::text[]) OR d.secondary_language = ANY($%s::text[]))', v_param_index, v_param_index));
                v_params := array_append(v_params, v_deck_languages::TEXT);
                RAISE NOTICE '[DEBUG V4+Diff] Added param $%: deckLanguages', v_param_index;
            END IF;
        END IF;

        -- 4. Tag filtering (Refactored for deck_tags)
        v_tag_logic := COALESCE(p_query_criteria->>'tagLogic','ANY'); -- 'ANY' or 'ALL'

        -- Include Tags Logic
        IF (p_query_criteria->'includeTags') IS NOT NULL AND jsonb_typeof(p_query_criteria->'includeTags') = 'array' AND jsonb_array_length(p_query_criteria->'includeTags') > 0 THEN
            SELECT array_agg(elem::TEXT::UUID) INTO v_include_tags FROM jsonb_array_elements_text(p_query_criteria->'includeTags') AS elem;
            v_param_index := v_param_index + 1;
            RAISE NOTICE '[DEBUG V4+Diff] includeTags (Deck Level) param index $%', v_param_index;

            IF v_tag_logic = 'ALL' THEN
                 -- Deck must have ALL the specified tags
                 v_where_clauses := array_append(v_where_clauses, format(
                    'c.deck_id IN (SELECT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L::uuid AND dt.tag_id = ANY($%s::uuid[]) GROUP BY dt.deck_id HAVING count(DISTINCT dt.tag_id) = %s)',
                    p_user_id,
                    v_param_index,
                    array_length(v_include_tags,1)
                 ));
                 RAISE NOTICE '[DEBUG V4+Diff] Added deck_tags includeTags (ALL) clause';
            ELSE -- ANY (Default)
                -- Deck must have AT LEAST ONE of the specified tags
                v_where_clauses := array_append(v_where_clauses, format(
                    'c.deck_id IN (SELECT DISTINCT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L::uuid AND dt.tag_id = ANY($%s::uuid[]))',
                    p_user_id,
                    v_param_index
                ));
                 RAISE NOTICE '[DEBUG V4+Diff] Added deck_tags includeTags (ANY) clause';
            END IF;

            v_params := array_append(v_params, v_include_tags::TEXT); -- Pass UUID array as text for parameter binding
            RAISE NOTICE '[DEBUG V4+Diff] Added includeTags param $% value: %', v_param_index, v_include_tags;
        END IF;

        -- Exclude Tags Logic
        IF (p_query_criteria->'excludeTags') IS NOT NULL AND jsonb_typeof(p_query_criteria->'excludeTags') = 'array' AND jsonb_array_length(p_query_criteria->'excludeTags') > 0 THEN
            SELECT array_agg(elem::TEXT::UUID) INTO v_exclude_tags FROM jsonb_array_elements_text(p_query_criteria->'excludeTags') AS elem;
            v_param_index := v_param_index + 1;
            RAISE NOTICE '[DEBUG V4+Diff] excludeTags (Deck Level) param index $%', v_param_index;

            -- Deck must NOT have ANY of the specified tags
            v_where_clauses := array_append(v_where_clauses, format(
                'c.deck_id NOT IN (SELECT DISTINCT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L::uuid AND dt.tag_id = ANY($%s::uuid[]))',
                 p_user_id,
                 v_param_index
            ));
            v_params := array_append(v_params, v_exclude_tags::TEXT); -- Pass UUID array as text
            RAISE NOTICE '[DEBUG V4+Diff] Added excludeTags param $% value: %', v_param_index, v_exclude_tags;
        END IF;
        -- End Refactored Tag Filtering

        -- 5. Date/Timestamp Filters (Partial logic from V4 - assumes other dates were similar)
        v_created_date_filter := p_query_criteria->'createdDate';
        IF v_created_date_filter IS NOT NULL AND jsonb_typeof(v_created_date_filter) = 'object' THEN
            v_date_operator := v_created_date_filter->>'operator';
            RAISE NOTICE '[DEBUG V4+Diff] Processing createdDate filter, operator: %', v_date_operator;
            IF v_date_operator = 'newerThanDays' THEN v_date_value_days := (v_created_date_filter->>'value')::INT; v_where_clauses := array_append(v_where_clauses, format('c.created_at >= (NOW() - interval ''%s day'')', v_date_value_days));
            ELSIF v_date_operator = 'olderThanDays' THEN v_date_value_days := (v_created_date_filter->>'value')::INT; v_where_clauses := array_append(v_where_clauses, format('c.created_at < (NOW() - interval ''%s day'')', v_date_value_days));
            ELSIF v_date_operator = 'onDate' THEN v_date_value_start := v_created_date_filter->>'value'; v_param_index := v_param_index + 1; v_where_clauses := array_append(v_where_clauses, format('c.created_at::date = $%s::date', v_param_index)); v_params := array_append(v_params, v_date_value_start);
            ELSIF v_date_operator = 'betweenDates' THEN v_date_value_start := v_created_date_filter->'value'->>0; v_date_value_end := v_created_date_filter->'value'->>1; IF v_date_value_start IS NOT NULL AND v_date_value_end IS NOT NULL THEN v_param_index := v_param_index + 1; v_where_clauses := array_append(v_where_clauses, format('c.created_at >= $%s::timestamptz', v_param_index)); v_params := array_append(v_params, v_date_value_start); v_param_index := v_param_index + 1; v_where_clauses := array_append(v_where_clauses, format('c.created_at <= $%s::timestamptz', v_param_index)); v_params := array_append(v_params, v_date_value_end); END IF;
            END IF;
        END IF;
        -- *** Add similar IF blocks here for updatedDate, lastReviewed, nextReviewDue ***
        -- *** based on your original V4 code if they existed and used parameters ***

        -- 6. SRS level filter (Unchanged from V4)
        v_srs_level_filter := p_query_criteria->'srsLevel';
        IF v_srs_level_filter IS NOT NULL AND jsonb_typeof(v_srs_level_filter) = 'object' THEN
            v_srs_operator := v_srs_level_filter->>'operator';
            v_srs_value    := (v_srs_level_filter->>'value')::INT;
            RAISE NOTICE '[DEBUG V4+Diff] Processing srsLevel filter, op: %, val: %', v_srs_operator, v_srs_value;
            IF v_srs_value IS NOT NULL THEN
                IF v_srs_operator = 'equals' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level = %s', v_srs_value));
                ELSIF v_srs_operator = 'lessThan' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level < %s', v_srs_value));
                ELSIF v_srs_operator = 'greaterThan' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level > %s', v_srs_value));
                END IF;
                 RAISE NOTICE '[DEBUG V4+Diff] Added srsLevel clause';
            END IF;
        END IF;

        -- 7. Difficult Filter **[NEW LOGIC ADDED HERE]**
        v_include_difficult := (p_query_criteria ->> 'includeDifficult')::boolean;
        IF v_include_difficult IS TRUE THEN
             RAISE NOTICE '[DEBUG V4+Diff] includeDifficult=true, adding clause';
             -- This clause uses only literals, no parameters, so safe to add
             v_where_clauses := array_append(v_where_clauses, '(c.srs_level < 3 OR c.last_review_grade IS NULL OR c.last_review_grade <= 2)');
        END IF;
        -- **[END NEW LOGIC]**

    END IF;  -- END allCards

    -- 8. Build ORDER BY (Unchanged from V4, but using updated allowed fields)
    v_valid_order_field     := COALESCE(p_order_by_field,'created_at');
    v_valid_order_direction := UPPER(COALESCE(p_order_by_direction,'DESC'));
    IF NOT v_valid_order_field = ANY(v_allowed_order_fields) THEN v_valid_order_field := 'created_at'; END IF;
    IF NOT v_valid_order_direction = ANY(v_allowed_directions) THEN v_valid_order_direction := 'DESC'; END IF;
    v_order_by_clause := format('ORDER BY c.%I %s NULLS LAST', v_valid_order_field, v_valid_order_direction);
    RAISE NOTICE '[DEBUG V4+Diff] Order By Clause: %', v_order_by_clause;

    -- 9. Final SQL & execution
    v_sql := 'SELECT c.id ' || v_from_clause || ' WHERE ' ||
             -- Handle case where only user_id filter exists
             (CASE WHEN array_length(v_where_clauses, 1) > 0 THEN array_to_string(v_where_clauses,' AND ') ELSE 'TRUE' END)
             || ' ' || v_order_by_clause;

    RAISE NOTICE '[FINAL V4+Diff] SQL: %', v_sql;
    RAISE NOTICE '[FINAL V4+Diff] PARAMS: %', v_params;

    -- Execute using original USING syntax, passing the params array
    RETURN QUERY EXECUTE v_sql USING v_params;

EXCEPTION
    WHEN others THEN
        RAISE WARNING '[ERROR V4+Diff] SQLSTATE: %, MSG: %', SQLSTATE, SQLERRM;
        RAISE WARNING '[FAILED SQL V4+Diff] %', v_sql;
        RAISE WARNING '[FAILED PARAMS V4+Diff] %', v_params;
        RETURN;
END;$function$
;

CREATE OR REPLACE FUNCTION public.update_updated_at_column()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$function$
;

grant delete on table "public"."cards" to "anon";

grant insert on table "public"."cards" to "anon";

grant references on table "public"."cards" to "anon";

grant select on table "public"."cards" to "anon";

grant trigger on table "public"."cards" to "anon";

grant truncate on table "public"."cards" to "anon";

grant update on table "public"."cards" to "anon";

grant delete on table "public"."cards" to "authenticated";

grant insert on table "public"."cards" to "authenticated";

grant references on table "public"."cards" to "authenticated";

grant select on table "public"."cards" to "authenticated";

grant trigger on table "public"."cards" to "authenticated";

grant truncate on table "public"."cards" to "authenticated";

grant update on table "public"."cards" to "authenticated";

grant delete on table "public"."cards" to "service_role";

grant insert on table "public"."cards" to "service_role";

grant references on table "public"."cards" to "service_role";

grant select on table "public"."cards" to "service_role";

grant trigger on table "public"."cards" to "service_role";

grant truncate on table "public"."cards" to "service_role";

grant update on table "public"."cards" to "service_role";

grant delete on table "public"."deck_tags" to "anon";

grant insert on table "public"."deck_tags" to "anon";

grant references on table "public"."deck_tags" to "anon";

grant select on table "public"."deck_tags" to "anon";

grant trigger on table "public"."deck_tags" to "anon";

grant truncate on table "public"."deck_tags" to "anon";

grant update on table "public"."deck_tags" to "anon";

grant delete on table "public"."deck_tags" to "authenticated";

grant insert on table "public"."deck_tags" to "authenticated";

grant references on table "public"."deck_tags" to "authenticated";

grant select on table "public"."deck_tags" to "authenticated";

grant trigger on table "public"."deck_tags" to "authenticated";

grant truncate on table "public"."deck_tags" to "authenticated";

grant update on table "public"."deck_tags" to "authenticated";

grant delete on table "public"."deck_tags" to "service_role";

grant insert on table "public"."deck_tags" to "service_role";

grant references on table "public"."deck_tags" to "service_role";

grant select on table "public"."deck_tags" to "service_role";

grant trigger on table "public"."deck_tags" to "service_role";

grant truncate on table "public"."deck_tags" to "service_role";

grant update on table "public"."deck_tags" to "service_role";

grant delete on table "public"."decks" to "anon";

grant insert on table "public"."decks" to "anon";

grant references on table "public"."decks" to "anon";

grant select on table "public"."decks" to "anon";

grant trigger on table "public"."decks" to "anon";

grant truncate on table "public"."decks" to "anon";

grant update on table "public"."decks" to "anon";

grant delete on table "public"."decks" to "authenticated";

grant insert on table "public"."decks" to "authenticated";

grant references on table "public"."decks" to "authenticated";

grant select on table "public"."decks" to "authenticated";

grant trigger on table "public"."decks" to "authenticated";

grant truncate on table "public"."decks" to "authenticated";

grant update on table "public"."decks" to "authenticated";

grant delete on table "public"."decks" to "service_role";

grant insert on table "public"."decks" to "service_role";

grant references on table "public"."decks" to "service_role";

grant select on table "public"."decks" to "service_role";

grant trigger on table "public"."decks" to "service_role";

grant truncate on table "public"."decks" to "service_role";

grant update on table "public"."decks" to "service_role";

grant delete on table "public"."settings" to "anon";

grant insert on table "public"."settings" to "anon";

grant references on table "public"."settings" to "anon";

grant select on table "public"."settings" to "anon";

grant trigger on table "public"."settings" to "anon";

grant truncate on table "public"."settings" to "anon";

grant update on table "public"."settings" to "anon";

grant delete on table "public"."settings" to "authenticated";

grant insert on table "public"."settings" to "authenticated";

grant references on table "public"."settings" to "authenticated";

grant select on table "public"."settings" to "authenticated";

grant trigger on table "public"."settings" to "authenticated";

grant truncate on table "public"."settings" to "authenticated";

grant update on table "public"."settings" to "authenticated";

grant delete on table "public"."settings" to "service_role";

grant insert on table "public"."settings" to "service_role";

grant references on table "public"."settings" to "service_role";

grant select on table "public"."settings" to "service_role";

grant trigger on table "public"."settings" to "service_role";

grant truncate on table "public"."settings" to "service_role";

grant update on table "public"."settings" to "service_role";

grant delete on table "public"."study_sets" to "anon";

grant insert on table "public"."study_sets" to "anon";

grant references on table "public"."study_sets" to "anon";

grant select on table "public"."study_sets" to "anon";

grant trigger on table "public"."study_sets" to "anon";

grant truncate on table "public"."study_sets" to "anon";

grant update on table "public"."study_sets" to "anon";

grant delete on table "public"."study_sets" to "authenticated";

grant insert on table "public"."study_sets" to "authenticated";

grant references on table "public"."study_sets" to "authenticated";

grant select on table "public"."study_sets" to "authenticated";

grant trigger on table "public"."study_sets" to "authenticated";

grant truncate on table "public"."study_sets" to "authenticated";

grant update on table "public"."study_sets" to "authenticated";

grant delete on table "public"."study_sets" to "service_role";

grant insert on table "public"."study_sets" to "service_role";

grant references on table "public"."study_sets" to "service_role";

grant select on table "public"."study_sets" to "service_role";

grant trigger on table "public"."study_sets" to "service_role";

grant truncate on table "public"."study_sets" to "service_role";

grant update on table "public"."study_sets" to "service_role";

grant delete on table "public"."tags" to "anon";

grant insert on table "public"."tags" to "anon";

grant references on table "public"."tags" to "anon";

grant select on table "public"."tags" to "anon";

grant trigger on table "public"."tags" to "anon";

grant truncate on table "public"."tags" to "anon";

grant update on table "public"."tags" to "anon";

grant delete on table "public"."tags" to "authenticated";

grant insert on table "public"."tags" to "authenticated";

grant references on table "public"."tags" to "authenticated";

grant select on table "public"."tags" to "authenticated";

grant trigger on table "public"."tags" to "authenticated";

grant truncate on table "public"."tags" to "authenticated";

grant update on table "public"."tags" to "authenticated";

grant delete on table "public"."tags" to "service_role";

grant insert on table "public"."tags" to "service_role";

grant references on table "public"."tags" to "service_role";

grant select on table "public"."tags" to "service_role";

grant trigger on table "public"."tags" to "service_role";

grant truncate on table "public"."tags" to "service_role";

grant update on table "public"."tags" to "service_role";

create policy "Users can only access cards in their decks"
on "public"."cards"
as permissive
for all
to public
using ((EXISTS ( SELECT 1
   FROM decks
  WHERE ((decks.id = cards.deck_id) AND (decks.user_id = auth.uid())))));


create policy "Allow users to DELETE their own deck_tags"
on "public"."deck_tags"
as permissive
for delete
to public
using ((auth.uid() = user_id));


create policy "Allow users to INSERT deck_tags for their own decks"
on "public"."deck_tags"
as permissive
for insert
to public
with check (((auth.uid() = user_id) AND (EXISTS ( SELECT 1
   FROM decks
  WHERE ((decks.id = deck_tags.deck_id) AND (decks.user_id = auth.uid())))) AND (EXISTS ( SELECT 1
   FROM tags
  WHERE ((tags.id = deck_tags.tag_id) AND (tags.user_id = auth.uid()))))));


create policy "Allow users to SELECT their own deck_tags"
on "public"."deck_tags"
as permissive
for select
to public
using ((auth.uid() = user_id));


create policy "Users can only access their own decks"
on "public"."decks"
as permissive
for all
to public
using ((auth.uid() = user_id));

create policy "Users can only access their own settings"
on "public"."settings"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Allow individual user access to their study_sets"
on "public"."study_sets"
as permissive
for all
to public
using ((auth.uid() = user_id));


create policy "Allow individual user access to their tags"
on "public"."tags"
as permissive
for all
to public
using ((auth.uid() = user_id));


CREATE TRIGGER set_cards_updated_at BEFORE UPDATE ON public.cards FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_settings_updated_at BEFORE UPDATE ON public.settings FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER set_study_sets_updated_at BEFORE UPDATE ON public.study_sets FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();



```

### File: supabase/migrations/20250427171814_create_cards_with_difficulty_view.sql

```
-- introduce new column 'mature_interval_threshold' to settings table
ALTER TABLE public.settings
ADD COLUMN mature_interval_threshold INTEGER DEFAULT 21 NOT NULL;

COMMENT ON COLUMN public.settings.mature_interval_threshold IS 'SRS interval (days) threshold for a card to be considered mature (default: 21).';


-- Drop the previous view if it exists
DROP VIEW IF EXISTS public.cards_with_difficulty;

-- Create the new view joining cards and settings to catch the mature_threshold_days parameter which is 21 by default
CREATE VIEW public.cards_with_srs_stage AS
SELECT
    c.*, -- Select all columns from cards
    COALESCE(s.mature_interval_threshold, 21) AS card_mature_threshold_days, -- Include the threshold used for debugging/info
    CASE
        WHEN c.last_reviewed_at IS NULL THEN 'new'::text -- We haven’t seen this card before. It’s waiting for its first turn.
        WHEN COALESCE(c.interval_days, 0) = 0 OR c.last_review_grade = 1 THEN 'learning'::text -- This card is still tricky, so we look at it a lot to help it stick.
        WHEN COALESCE(c.interval_days, 0) < COALESCE(s.mature_interval_threshold, 21) THEN 'young'::text -- We remember this card pretty well, but we still check it every so often to keep it fresh.
        ELSE 'mature'::text -- We know this card really well, so we only peek at it now and then to stay sharp.
    END AS srs_stage
FROM
    public.cards c
    -- Left join settings on user_id to get the threshold
    LEFT JOIN public.settings s ON c.user_id = s.user_id;

-- Add comment
COMMENT ON VIEW public.cards_with_srs_stage IS 'Extends cards with calculated SRS stage (new, learning, young, mature) based on SRS state and user settings.';

-- to improve performance of the view, we create a composite btree index on the user_id and mature_interval_threshold columns
-- create the composite btree index
CREATE INDEX IF NOT EXISTS settings_userid_maturethreshold_idx
    ON public.settings
    USING btree (user_id, mature_interval_threshold);



-- IMPORTANT: Ensure RLS is already enabled and correctly configured on the base table 'public.cards'
--            (e.g., checking auth.uid() = user_id)
--            No separate RLS enablement or policies are needed DIRECTLY on the view here.


```

### File: supabase/migrations/20250428000000_create_deck_srs_counts_function.sql

```
-- Migration: Create function to get deck list with SRS stage counts

-- Drop function if it exists (optional, for idempotency during development)
DROP FUNCTION IF EXISTS public.get_deck_list_with_srs_counts(uuid);

-- Create the function
CREATE OR REPLACE FUNCTION public.get_deck_list_with_srs_counts(
    p_user_id uuid
)
RETURNS TABLE (
    id uuid,
    name text,
    primary_language text,
    secondary_language text,
    is_bilingual boolean,
    updated_at timestamptz,
    new_count bigint,       -- Use bigint for counts
    learning_count bigint,
    young_count bigint,
    mature_count bigint
)
LANGUAGE sql
STABLE -- Function does not modify the database
SECURITY DEFINER -- To bypass RLS within the function if needed, ensure function owner has appropriate base table permissions
AS $$
WITH deck_base AS (
    -- First query only the user's decks to reduce data processed
    SELECT
        d.id,
        d.name,
        d.primary_language,
        d.secondary_language,
        d.is_bilingual,
        d.updated_at
    FROM
        public.decks d
    WHERE
        d.user_id = p_user_id
),
srs_counts AS (
    -- Calculate counts separately with optimized classification logic
    SELECT
        c.deck_id,
        COUNT(*) FILTER (WHERE c.last_reviewed_at IS NULL) AS new_count,
        COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND 
                        (COALESCE(c.interval_days, 0) = 0 OR c.last_review_grade = 1)) AS learning_count,
        COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND
                        COALESCE(c.interval_days, 0) > 0 AND 
                        c.last_review_grade != 1 AND
                        COALESCE(c.interval_days, 0) < COALESCE(
                            (SELECT mature_interval_threshold FROM public.settings WHERE user_id = p_user_id), 
                            21)) AS young_count,
        COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND
                        COALESCE(c.interval_days, 0) > 0 AND 
                        c.last_review_grade != 1 AND
                        COALESCE(c.interval_days, 0) >= COALESCE(
                            (SELECT mature_interval_threshold FROM public.settings WHERE user_id = p_user_id), 
                            21)) AS mature_count
    FROM
        public.cards c
    WHERE
        -- Only count cards for this user
        c.user_id = p_user_id
        -- Only include decks for this user (redundant with RLS but helps optimizer)
        AND c.deck_id IN (SELECT id FROM deck_base)
    GROUP BY
        c.deck_id
)
-- Join the base decks with the counts
SELECT
    d.id,
    d.name,
    d.primary_language,
    d.secondary_language,
    d.is_bilingual,
    d.updated_at,
    COALESCE(s.new_count, 0) AS new_count,
    COALESCE(s.learning_count, 0) AS learning_count,
    COALESCE(s.young_count, 0) AS young_count,
    COALESCE(s.mature_count, 0) AS mature_count
FROM
    deck_base d
LEFT JOIN
    srs_counts s ON d.id = s.deck_id
ORDER BY
    d.name ASC;
$$;

-- Add comment to the function
COMMENT ON FUNCTION public.get_deck_list_with_srs_counts(uuid)
IS 'Retrieves all decks for a user along with counts of cards in each SRS stage (new, learning, young, mature). Optimized version that avoids using the full view.';

-- Grant execution rights to the authenticated role
-- Important: Ensure the 'authenticated' role exists and RLS on base tables (decks, cards) is correctly configured.
GRANT EXECUTE ON FUNCTION public.get_deck_list_with_srs_counts(uuid) TO authenticated;

-- Create an index to optimize the query
CREATE INDEX IF NOT EXISTS idx_cards_user_deck_reviewed 
ON public.cards(user_id, deck_id, last_reviewed_at, interval_days, last_review_grade);

-- Optional: Grant to service_role if called from backend bypassing RLS
-- GRANT EXECUTE ON FUNCTION public.get_deck_list_with_srs_counts(uuid) TO service_role; 
```

### File: supabase/migrations/20250428010000_add_show_deck_progress_setting.sql

```
-- Migration: Add show_deck_progress setting

ALTER TABLE public.settings
ADD COLUMN IF NOT EXISTS show_deck_progress BOOLEAN NOT NULL DEFAULT true;

COMMENT ON COLUMN public.settings.show_deck_progress IS 'Whether to display the SRS stage progress bar on deck list items.'; 
```

### File: supabase/migrations/20250428020000_add_theme_preference_setting.sql

```
-- Migration: Add theme_light_dark_mode setting

ALTER TABLE public.settings
ADD COLUMN IF NOT EXISTS theme_light_dark_mode TEXT NOT NULL DEFAULT 'system';
-- Optional: Add a check constraint
-- ALTER TABLE public.settings
-- ADD CONSTRAINT valid_theme_light_dark_mode CHECK (theme_light_dark_mode IN ('light', 'dark', 'system'));

COMMENT ON COLUMN public.settings.theme_light_dark_mode IS 'User preferred theme (light, dark, system).'; 
```

### File: supabase/migrations/20250430214258_update_resolve_study_query.sql

```
-- Migration file: YYYYMMDDHHMMSS_update_resolve_study_query_difficult_logic_v3.sql
-- Description: Updates the resolve_study_query function to use cards_with_srs_stage 
--              for the includeDifficult flag, filtering for 'learning' stage.
--              Restores original deck_tags filtering logic.
--              Uses TEXT variables for date values.

-- Drop the existing function if it exists
DROP FUNCTION IF EXISTS resolve_study_query(jsonb, uuid);

-- Recreate the function with updated logic
CREATE OR REPLACE FUNCTION resolve_study_query(
    p_query_criteria jsonb,
    p_user_id uuid
    -- Assuming original function did not have p_order_by parameters, add if needed
    -- p_order_by_field TEXT DEFAULT 'created_at',
    -- p_order_by_direction TEXT DEFAULT 'DESC'
)
RETURNS TABLE(card_id uuid)
LANGUAGE plpgsql
STABLE 
SECURITY INVOKER 
AS $$
DECLARE
    v_sql                  TEXT;
    v_from_clause          TEXT := 'FROM cards c';
    v_join_clauses         TEXT := ''; -- For joins needed by filters
    v_where_clauses        TEXT[] := ARRAY[]::TEXT[];
    -- Use original's parameter approach if preferred, otherwise format() can work
    -- v_params               TEXT[] := ARRAY[]::TEXT[]; 
    -- v_param_index          INTEGER := 0;

    -- Parsed criteria variables
    v_deck_id              UUID;
    v_include_tags         UUID[];
    v_exclude_tags         UUID[];
    v_tag_logic            TEXT;
    v_srs_level_op         TEXT;
    v_srs_level_value      INT;
    v_include_difficult    BOOLEAN; -- Flag we are changing logic for
    
    -- Date related variables (using TEXT like corrected proposal)
    v_created_op           TEXT;
    v_created_value        TEXT; 
    v_updated_op           TEXT;
    v_updated_value        TEXT; 
    v_last_reviewed_op     TEXT;
    v_last_reviewed_value  TEXT; 
    v_next_due_op          TEXT;
    v_next_due_value       TEXT; 
    v_date_range_value     TEXT[]; -- Specific for 'betweenDates'

    -- Ordering variables (if needed, adapt from original)
    -- v_order_by_clause      TEXT;
    -- v_valid_order_field    TEXT;
    -- v_valid_order_direction TEXT;
    -- v_allowed_order_fields TEXT[] := ARRAY[...]; -- Use updated field names
    -- v_allowed_directions   TEXT[] := ARRAY['ASC','DESC'];

BEGIN
    -- Add mandatory user filter (using format %L for safety)
    v_where_clauses := array_append(v_where_clauses, format('c.user_id = %L', p_user_id));

    -- Extract criteria
    v_deck_id := p_query_criteria->>'deckId';
    v_tag_logic := COALESCE(p_query_criteria->>'tagLogic', 'ANY');
    v_include_difficult := (p_query_criteria->>'includeDifficult')::BOOLEAN;

    SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'includeTags')) INTO v_include_tags;
    SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'excludeTags')) INTO v_exclude_tags;
    v_include_tags := COALESCE(v_include_tags, ARRAY[]::UUID[]);
    v_exclude_tags := COALESCE(v_exclude_tags, ARRAY[]::UUID[]);

    -- --- Filter by Deck ---
    IF v_deck_id IS NOT NULL THEN
        v_where_clauses := array_append(v_where_clauses, format('c.deck_id = %L', v_deck_id));
    END IF;

    -- --- Filter by Tags (Restored Original Deck Tag Logic) ---
    -- Include Tags Logic
    IF array_length(v_include_tags, 1) > 0 THEN
        IF v_tag_logic = 'ALL' THEN
             -- Deck must have ALL the specified tags
             v_where_clauses := array_append(v_where_clauses, format(
                'c.deck_id IN (SELECT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L AND dt.tag_id = ANY(%L::uuid[]) GROUP BY dt.deck_id HAVING count(DISTINCT dt.tag_id) = %s)',
                p_user_id,
                v_include_tags, -- Embed UUID array directly with ::uuid[] cast
                array_length(v_include_tags,1)
             ));
        ELSE -- ANY (Default)
            -- Deck must have AT LEAST ONE of the specified tags
            v_where_clauses := array_append(v_where_clauses, format(
                'c.deck_id IN (SELECT DISTINCT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L AND dt.tag_id = ANY(%L::uuid[]))',
                p_user_id,
                v_include_tags -- Embed UUID array directly with ::uuid[] cast
            ));
        END IF;
    END IF;

    -- Exclude Tags Logic
    IF array_length(v_exclude_tags, 1) > 0 THEN
        -- Deck must NOT have ANY of the specified tags
        v_where_clauses := array_append(v_where_clauses, format(
            'c.deck_id NOT IN (SELECT DISTINCT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L AND dt.tag_id = ANY(%L::uuid[]))',
             p_user_id,
             v_exclude_tags -- Embed UUID array directly with ::uuid[] cast
        ));
    END IF;
    -- --- End Restored Tag Logic ---

    -- --- Filter by 'includeDifficult' flag (NEW LOGIC) ---
    IF v_include_difficult IS TRUE THEN
        -- Join with the view is required
        v_join_clauses := v_join_clauses || ' INNER JOIN cards_with_srs_stage cws ON c.id = cws.id';
        -- Add the condition to filter for 'learning' stage
        v_where_clauses := array_append(v_where_clauses, 'cws.srs_stage = ''learning''');
    END IF;
    -- --- End New Difficult Logic ---

    -- --- Filter by SRS Level (manual filter - simplified embedding) ---
    v_srs_level_op := p_query_criteria->'srsLevel'->>'operator';
    IF p_query_criteria->'srsLevel'->>'value' IS NOT NULL THEN
       v_srs_level_value := (p_query_criteria->'srsLevel'->>'value')::INT;
    ELSE
       v_srs_level_value := NULL;
    END IF;
    IF v_srs_level_op IS NOT NULL AND v_srs_level_value IS NOT NULL THEN
        CASE v_srs_level_op
            WHEN 'equals' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level = %s', v_srs_level_value));
            WHEN 'lessThan' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level < %s', v_srs_level_value));
            WHEN 'greaterThan' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level > %s', v_srs_level_value));
        END CASE;
    END IF;

    -- --- Date Filters (Using TEXT variables, requires full implementation) ---
    -- Example for 'createdDate' - Apply pattern to others
    v_created_op := p_query_criteria->'createdDate'->>'operator';
    IF v_created_op IS NOT NULL THEN
        v_created_value := p_query_criteria->'createdDate'->>'value'; 
        IF v_created_value IS NOT NULL THEN 
            IF v_created_op = 'newerThanDays' OR v_created_op = 'olderThanDays' THEN
                 v_where_clauses := array_append(v_where_clauses, format('c.created_at %s now() - interval %L', CASE v_created_op WHEN 'newerThanDays' THEN '>' ELSE '<' END, v_created_value || ' days'));
            ELSIF v_created_op = 'onDate' THEN
                 v_where_clauses := array_append(v_where_clauses, format('c.created_at::date = %L::date', v_created_value));
            -- >>> ADD 'betweenDates' logic here <<<
            END IF;
        -- >>> Handle operators without values ('never', 'isDue') here <<<
        END IF;
    END IF;
    -- >>> REPEAT for updatedDate, lastReviewed, nextReviewDue <<<

    -- --- Construct Final SQL ---
    v_sql := 'SELECT DISTINCT c.id ' || v_from_clause || ' ' || v_join_clauses;
    IF array_length(v_where_clauses, 1) > 0 THEN
        v_sql := v_sql || ' WHERE ' || array_to_string(v_where_clauses, ' AND ');
    END IF;

    -- Add Ordering (adapt from original if needed)
    -- v_sql := v_sql || ' ORDER BY c.created_at DESC NULLS LAST'; -- Example default

    RAISE LOG 'Executing SQL (v3): %', v_sql;

    -- Execute (using EXECUTE without USING as values are embedded via format)
    RETURN QUERY EXECUTE v_sql;

EXCEPTION WHEN others THEN
    RAISE LOG 'Error in resolve_study_query (v3): %', SQLERRM;
    RETURN QUERY SELECT uuid_nil(); 
END;
$$;

GRANT EXECUTE ON FUNCTION resolve_study_query(jsonb, uuid) TO authenticated;

COMMENT ON FUNCTION resolve_study_query(jsonb, uuid) IS 
'Resolves study query criteria JSON into a list of matching card IDs. v3: Uses cards_with_srs_stage for includeDifficult flag, keeps original deck_tags logic.';

```

### File: supabase/migrations/20250501153215_update_resolve_study_query_difficult_logic_v3.sql.sql

```
-- resolve_study_query function definition

CREATE OR REPLACE FUNCTION public.resolve_study_query(
    p_user_id uuid,
    p_query_criteria jsonb
)
RETURNS SETOF uuid -- Return a set of card IDs
LANGUAGE plpgsql
STABLE -- Function does not modify the database
SECURITY DEFINER -- Important for accessing tables with RLS based on p_user_id
AS $$
DECLARE
    v_sql                  TEXT;
    v_from_clause          TEXT := 'FROM cards c';
    v_join_clauses         TEXT := ''; -- For joins needed by filters
    v_where_clauses        TEXT[] := ARRAY[]::TEXT[];

    -- Parsed criteria variables
    v_deck_id              UUID;
    v_include_tags         UUID[];
    v_exclude_tags         UUID[];
    v_tag_logic            TEXT;
    v_srs_level_op         TEXT;
    v_srs_level_value      INT;
    v_include_difficult    BOOLEAN;

    -- Date related variables (using TEXT as in provided code)
    v_created_op           TEXT;
    v_created_value        TEXT;
    v_updated_op           TEXT;
    v_updated_value        TEXT;
    v_last_reviewed_op     TEXT;
    v_last_reviewed_value  TEXT;
    v_next_due_op          TEXT;
    v_next_due_value       TEXT;
    v_date_range_value     TEXT[]; -- Specific for 'betweenDates'
BEGIN
    -- Add mandatory user filter
    v_where_clauses := array_append(v_where_clauses, format('c.user_id = %L', p_user_id));

    -- Extract criteria
    v_deck_id := p_query_criteria->>'deckId';
    v_tag_logic := COALESCE(p_query_criteria->>'tagLogic', 'ANY');
    -- Ensure boolean conversion handles JSON null properly -> defaults to FALSE if null or not 'true'
    v_include_difficult := COALESCE((p_query_criteria->>'includeDifficult')::BOOLEAN, FALSE);

    -- Extract UUID arrays safely, checking for array type
    SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'includeTags') WHERE jsonb_typeof(p_query_criteria->'includeTags') = 'array') INTO v_include_tags;
    SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'excludeTags') WHERE jsonb_typeof(p_query_criteria->'excludeTags') = 'array') INTO v_exclude_tags;
    v_include_tags := COALESCE(v_include_tags, ARRAY[]::UUID[]);
    v_exclude_tags := COALESCE(v_exclude_tags, ARRAY[]::UUID[]);


    -- --- Filter by Deck ---
    IF v_deck_id IS NOT NULL THEN
        v_where_clauses := array_append(v_where_clauses, format('c.deck_id = %L', v_deck_id));
    END IF;

    -- --- Filter by Tags (Deck Tag Logic - Restored as per original) ---
    -- Assumes deck_tags table exists with deck_id, tag_id, user_id
    IF array_length(v_include_tags, 1) > 0 THEN
        IF v_tag_logic = 'ALL' THEN
             v_where_clauses := array_append(v_where_clauses, format(
                'c.deck_id IN (SELECT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L AND dt.tag_id = ANY(%L::uuid[]) GROUP BY dt.deck_id HAVING count(DISTINCT dt.tag_id) = %s)',
                p_user_id, v_include_tags, array_length(v_include_tags,1) ));
        ELSE -- ANY
            v_where_clauses := array_append(v_where_clauses, format(
                'c.deck_id IN (SELECT DISTINCT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L AND dt.tag_id = ANY(%L::uuid[]))',
                p_user_id, v_include_tags ));
        END IF;
    END IF;
    IF array_length(v_exclude_tags, 1) > 0 THEN
        v_where_clauses := array_append(v_where_clauses, format(
            'c.deck_id NOT IN (SELECT DISTINCT dt.deck_id FROM deck_tags dt WHERE dt.user_id = %L AND dt.tag_id = ANY(%L::uuid[]))',
             p_user_id, v_exclude_tags ));
    END IF;

    -- --- Filter by 'includeDifficult' flag (Uses cards_with_srs_stage) ---
    -- Keep this logic AS IS from the provided code.
    -- Assumes cards_with_srs_stage view exists and includes srs_stage='learning' for difficult cards.
    IF v_include_difficult IS TRUE THEN
        -- No need to join if already done for other filters, but simpler to just add it if flag is true
        -- Avoid duplicate joins if possible in more complex scenarios
        IF v_join_clauses NOT LIKE '%cards_with_srs_stage%' THEN
             v_join_clauses := v_join_clauses || ' INNER JOIN public.cards_with_srs_stage cws ON c.id = cws.id';
        END IF;
        -- This filter means srs_stage = 'learning' based on your current view/code.
        v_where_clauses := array_append(v_where_clauses, 'cws.srs_stage = ''learning''');
    END IF;

    -- --- Filter by SRS Level (manual filter) ---
    v_srs_level_op := p_query_criteria->'srsLevel'->>'operator';
    -- Check if the value field exists and is a valid number before casting
    IF p_query_criteria->'srsLevel'->>'value' IS NOT NULL AND p_query_criteria->'srsLevel'->>'value' ~ '^\d+$' THEN
       v_srs_level_value := (p_query_criteria->'srsLevel'->>'value')::INT;
    ELSE v_srs_level_value := NULL; END IF;

    IF v_srs_level_op IS NOT NULL AND v_srs_level_value IS NOT NULL THEN
        CASE v_srs_level_op
            WHEN 'equals' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level = %s', v_srs_level_value));
            WHEN 'lessThan' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level < %s', v_srs_level_value));
            WHEN 'greaterThan' THEN v_where_clauses := array_append(v_where_clauses, format('c.srs_level > %s', v_srs_level_value));
            -- Add default or error handling?
            ELSE -- Invalid operator
                 RAISE WARNING 'resolve_study_query: Invalid srsLevel operator: %', v_srs_level_op;
            -- Consider adding a WHERE 1=0 clause here if invalid operator should return no results
        END CASE;
    END IF;

    -- --- Date Filters (COMPLETE THE LOGIC FOR ALL 4 FIELDS) ---
    -- Filter by createdDate
    v_created_op := p_query_criteria->'createdDate'->>'operator';
    IF v_created_op IS NOT NULL THEN
        -- Value for createdDate can be number of days (string) or date string
        v_created_value := p_query_criteria->'createdDate'->>'value';
        -- Value for betweenDates is always an array
        SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'createdDate'->'value') WHERE jsonb_typeof(p_query_criteria->'createdDate'->'value') = 'array') INTO v_date_range_value;

        CASE v_created_op
            WHEN 'newerThanDays' OR 'olderThanDays' THEN
                 IF v_created_value IS NOT NULL AND v_created_value ~ '^\d+$' THEN -- Check if value is number of days
                    v_where_clauses := array_append(v_where_clauses, format('c.created_at %s now() - interval %L', CASE v_created_op WHEN 'newerThanDays' THEN '>=' ELSE '<=' END, v_created_value || ' days'));
                 END IF;
            WHEN 'onDate' THEN
                 IF v_created_value IS NOT NULL THEN -- Check if value is a date string
                    -- Use date comparison to ignore time part
                    v_where_clauses := array_append(v_where_clauses, format('c.created_at::date = %L::date', v_created_value));
                 END IF;
            WHEN 'betweenDates' THEN
                 IF array_length(v_date_range_value, 1) = 2 AND v_date_range_value[1] IS NOT NULL AND v_date_range_value[2] IS NOT NULL THEN
                      -- Include both start and end date by comparing dates
                      v_where_clauses := array_append(v_where_clauses, format('c.created_at::date >= %L::date', v_date_range_value[1]));
                      v_where_clauses := array_append(v_where_clauses, format('c.created_at::date <= %L::date', v_date_range_value[2]));
                 END IF;
             ELSE -- Invalid operator
                  RAISE WARNING 'resolve_study_query: Invalid createdDate operator: %', v_created_op;
             -- Consider adding a WHERE 1=0 clause here
        END CASE;
    END IF;

    -- Filter by updatedDate
     v_updated_op := p_query_criteria->'updatedDate'->>'operator';
    IF v_updated_op IS NOT NULL THEN
        v_updated_value := p_query_criteria->'updatedDate'->>'value';
        SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'updatedDate'->'value') WHERE jsonb_typeof(p_query_criteria->'updatedDate'->'value') = 'array') INTO v_date_range_value;

        CASE v_updated_op
             WHEN 'newerThanDays' OR 'olderThanDays' THEN
                 IF v_updated_value IS NOT NULL AND v_updated_value ~ '^\d+$' THEN
                     v_where_clauses := array_append(v_where_clauses, format('c.updated_at %s now() - interval %L', CASE v_updated_op WHEN 'newerThanDays' THEN '>=' ELSE '<=' END, v_updated_value || ' days'));
                 END IF;
             WHEN 'onDate' THEN
                 IF v_updated_value IS NOT NULL THEN
                     v_where_clauses := array_append(v_where_clauses, format('c.updated_at::date = %L::date', v_updated_value));
                 END IF;
             WHEN 'betweenDates' THEN
                 IF array_length(v_date_range_value, 1) = 2 AND v_date_range_value[1] IS NOT NULL AND v_date_range_value[2] IS NOT NULL THEN
                      v_where_clauses := array_append(v_where_clauses, format('c.updated_at::date >= %L::date', v_date_range_value[1]));
                      v_where_clauses := array_append(v_where_clauses, format('c.updated_at::date <= %L::date', v_date_range_value[2]));
                 END IF;
             ELSE -- Invalid operator
                  RAISE WARNING 'resolve_study_query: Invalid updatedDate operator: %', v_updated_op;
        END CASE;
    END IF;

    -- Filter by lastReviewed
     v_last_reviewed_op := p_query_criteria->'lastReviewed'->>'operator';
    IF v_last_reviewed_op IS NOT NULL THEN
        v_last_reviewed_value := p_query_criteria->'lastReviewed'->>'value';
        SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'lastReviewed'->'value') WHERE jsonb_typeof(p_query_criteria->'lastReviewed'->'value') = 'array') INTO v_date_range_value;

        CASE v_last_reviewed_op
             WHEN 'newerThanDays' OR 'olderThanDays' THEN
                 IF v_last_reviewed_value IS NOT NULL AND v_last_reviewed_value ~ '^\d+$' THEN
                     -- Apply IS NOT NULL check for reviewed dates
                     v_where_clauses := array_append(v_where_clauses, format('c.last_reviewed_at IS NOT NULL AND c.last_reviewed_at %s now() - interval %L', CASE v_last_reviewed_op WHEN 'newerThanDays' THEN '>=' ELSE '<=' END, v_last_reviewed_value || ' days'));
                 END IF;
             WHEN 'onDate' THEN
                 IF v_last_reviewed_value IS NOT NULL THEN
                      v_where_clauses := array_append(v_where_clauses, format('c.last_reviewed_at IS NOT NULL AND c.last_reviewed_at::date = %L::date', v_last_reviewed_value));
                 END IF;
             WHEN 'betweenDates' THEN
                 IF array_length(v_date_range_value, 1) = 2 AND v_date_range_value[1] IS NOT NULL AND v_date_range_value[2] IS NOT NULL THEN
                      v_where_clauses := array_append(v_where_clauses, format('c.last_reviewed_at IS NOT NULL AND c.last_reviewed_at::date >= %L::date', v_date_range_value[1]));
                      v_where_clauses := array_append(v_where_clauses, format('c.last_reviewed_at::date <= %L::date', v_date_range_value[2]));
                 END IF;
             WHEN 'never' THEN
                 v_where_clauses := array_append(v_where_clauses, 'c.last_reviewed_at IS NULL');
             ELSE -- Invalid operator
                  RAISE WARNING 'resolve_study_query: Invalid lastReviewed operator: %', v_last_reviewed_op;
        END CASE;
    END IF;

    -- Filter by nextReviewDue
     v_next_due_op := p_query_criteria->'nextReviewDue'->>'operator';
    IF v_next_due_op IS NOT NULL THEN
        v_next_due_value := p_query_criteria->'nextReviewDue'->>'value';
        SELECT ARRAY(SELECT jsonb_array_elements_text(p_query_criteria->'nextReviewDue'->'value') WHERE jsonb_typeof(p_query_criteria->'nextReviewDue'->'value') = 'array') INTO v_date_range_value;

        CASE v_next_due_op
            WHEN 'newerThanDays' OR 'olderThanDays' THEN
                -- Note: 'newerThanDays' for next_review_due means FURTHER in the future (>= now() - interval)
                -- Note: 'olderThanDays' for next_review_due means CLOSER to now (or past) (<= now() - interval)
                 IF v_next_due_value IS NOT NULL AND v_next_due_value ~ '^\d+$' THEN
                     v_where_clauses := array_append(v_where_clauses, format('c.next_review_due IS NOT NULL AND c.next_review_due %s now() - interval %L', CASE v_next_due_op WHEN 'newerThanDays' THEN '>=' ELSE '<=' END, v_next_due_value || ' days')); -- Fixed operators here
                 END IF;
            WHEN 'onDate' THEN
                 IF v_next_due_value IS NOT NULL THEN
                     v_where_clauses := array_append(v_where_clauses, format('c.next_review_due IS NOT NULL AND c.next_review_due::date = %L::date', v_next_due_value));
                 END IF;
            WHEN 'betweenDates' THEN
                 IF array_length(v_date_range_value, 1) = 2 AND v_date_range_value[1] IS NOT NULL AND v_date_range_value[2] IS NOT NULL THEN
                      v_where_clauses := array_append(v_where_clauses, format('c.next_review_due IS NOT NULL AND c.next_review_due::date >= %L::date', v_date_range_value[1]));
                      v_where_clauses := array_append(v_where_clauses, format('c.next_review_due::date <= %L::date', v_date_range_value[2]));
                 END IF;
            WHEN 'never' THEN
                 v_where_clauses := array_append(v_where_clauses, 'c.next_review_due IS NULL');
            WHEN 'isDue' THEN
                 -- Cards are due if next_review_due is NULL (never scheduled) OR in the past/present.
                 v_where_clauses := array_append(v_where_clauses, '(c.next_review_due IS NULL OR c.next_review_due <= NOW())');
            ELSE -- Invalid operator
                 RAISE WARNING 'resolve_study_query: Invalid nextReviewDue operator: %', v_next_due_op;
        END CASE;
    END IF;


    -- --- Construct Final SQL ---
    v_sql := 'SELECT DISTINCT c.id ' || v_from_clause || ' ' || v_join_clauses;
    IF array_length(v_where_clauses, 1) > 0 THEN
        v_sql := v_sql || ' WHERE ' || array_to_string(v_where_clauses, ' AND ');
    END IF;

    RAISE LOG '[resolve_study_query] User: %, Criteria: %, SQL: %', p_user_id, p_query_criteria, v_sql;

    RETURN QUERY EXECUTE v_sql;

EXCEPTION WHEN others THEN
    -- Log the error and return empty set on error
    RAISE WARNING '[resolve_study_query] Error building or executing query for User: %, Criteria: %. Error: %', p_user_id, p_query_criteria, SQLERRM;
    RETURN; -- Returns empty table
END;
$$;

COMMENT ON FUNCTION public.resolve_study_query(uuid, jsonb) IS
'Resolves study query criteria JSON into a list of matching card IDs. v6: Uses deck_tags for tag filtering, maps `includeDifficult` to ''learning'' stage, completes all date filter logic.';
```

### File: supabase/migrations/20250501154500_add_missing_study_fields.sql

```
-- migrate:up
-- UP Migration: Add study-related columns and index
-- Add new columns to the cards table for tracking learning/relearning state
ALTER TABLE public.cards
ADD COLUMN IF NOT EXISTS learning_state text NULL,
ADD COLUMN IF NOT EXISTS learning_step_index integer NULL,
ADD COLUMN IF NOT EXISTS failed_attempts_in_learn integer NOT NULL DEFAULT 0,
ADD COLUMN IF NOT EXISTS hard_attempts_in_learn integer NOT NULL DEFAULT 0;

-- Add comments for the new cards columns
COMMENT ON COLUMN public.cards.learning_state IS 'Tracks if a card is in initial learning (''learning'') or relearning (''relearning'') state.';
COMMENT ON COLUMN public.cards.learning_step_index IS 'Tracks the current step index within the learning or relearning phase.';
COMMENT ON COLUMN public.cards.failed_attempts_in_learn IS 'Counts ''Again'' (Grade 1) answers during initial learning for EF calculation.';
COMMENT ON COLUMN public.cards.hard_attempts_in_learn IS 'Counts ''Hard'' (Grade 2) answers during initial learning for EF calculation.';

-- Drop the dependent view before altering the column type
DROP VIEW IF EXISTS public.cards_with_srs_stage;

-- Change interval_days type to float to support fractional intervals for learning steps
ALTER TABLE public.cards
ALTER COLUMN interval_days TYPE float USING interval_days::float;
-- Note: The NOT NULL DEFAULT 0 constraint is preserved by ALTER TYPE

-- Set easiness_factor to NOT NULL as it should always have a value (default 2.5)
ALTER TABLE public.cards
ALTER COLUMN easiness_factor SET NOT NULL;

-- Add new columns to the settings table for study algorithm parameters
ALTER TABLE public.settings
ADD COLUMN IF NOT EXISTS enable_dedicated_learn_mode boolean NOT NULL DEFAULT TRUE,
ADD COLUMN IF NOT EXISTS mastery_threshold integer NOT NULL DEFAULT 3,
ADD COLUMN IF NOT EXISTS custom_learn_requeue_gap integer NOT NULL DEFAULT 3,
ADD COLUMN IF NOT EXISTS graduating_interval_days integer NOT NULL DEFAULT 1,
ADD COLUMN IF NOT EXISTS easy_interval_days integer NOT NULL DEFAULT 4,
ADD COLUMN IF NOT EXISTS relearning_steps_minutes integer[] NOT NULL DEFAULT '{}'::integer[],
ADD COLUMN IF NOT EXISTS initial_learning_steps_minutes integer[] NOT NULL DEFAULT '{}'::integer[],
ADD COLUMN IF NOT EXISTS lapsed_ef_penalty numeric NOT NULL DEFAULT 0.2,
ADD COLUMN IF NOT EXISTS learn_again_penalty numeric NOT NULL DEFAULT 0.2,
ADD COLUMN IF NOT EXISTS learn_hard_penalty numeric NOT NULL DEFAULT 0.05,
ADD COLUMN IF NOT EXISTS min_easiness_factor numeric NOT NULL DEFAULT 1.3,
ADD COLUMN IF NOT EXISTS default_easiness_factor numeric NOT NULL DEFAULT 2.5;

-- Add comments for the new settings columns
COMMENT ON COLUMN public.settings.enable_dedicated_learn_mode IS 'Flag to use the dedicated streak-based learning mode (vs standard SM2 steps).';
COMMENT ON COLUMN public.settings.mastery_threshold IS 'Required streak/success count to graduate from dedicated learn mode.';
COMMENT ON COLUMN public.settings.custom_learn_requeue_gap IS 'Number of other cards to show before re-queueing a failed card in dedicated learn mode.';
COMMENT ON COLUMN public.settings.graduating_interval_days IS 'Initial interval (days) assigned when a card graduates from learning/relearning.';
COMMENT ON COLUMN public.settings.easy_interval_days IS 'Interval (days) assigned when graduating with ''Easy'' (Grade 4).';
COMMENT ON COLUMN public.settings.relearning_steps_minutes IS 'Intervals (in minutes) for steps during relearning phase (e.g., {10, 1440} for 10m, 1d).';
COMMENT ON COLUMN public.settings.initial_learning_steps_minutes IS 'Intervals (in minutes) for steps during initial learning phase (standard SM2 algorithm; e.g., {1, 10}).';
COMMENT ON COLUMN public.settings.lapsed_ef_penalty IS 'Amount subtracted from easiness factor when a card lapses.';
COMMENT ON COLUMN public.settings.learn_again_penalty IS 'Penalty subtracted from initial EF per ''Again'' (Grade 1) in dedicated learn.';
COMMENT ON COLUMN public.settings.learn_hard_penalty IS 'Penalty subtracted from initial EF per ''Hard'' (Grade 2) in dedicated learn.';
COMMENT ON COLUMN public.settings.min_easiness_factor IS 'Minimum allowed easiness factor.';
COMMENT ON COLUMN public.settings.default_easiness_factor IS 'Default starting easiness factor for new cards.';

-- Recreate the view after altering the base table
CREATE OR REPLACE VIEW public.cards_with_srs_stage AS
SELECT
    c.*, -- Select all columns from cards
    COALESCE(s.mature_interval_threshold, 21) AS card_mature_threshold_days, -- Include the threshold used for debugging/info
    CASE
        WHEN c.last_reviewed_at IS NULL THEN 'new'::text -- We haven't seen this card before. It's waiting for its first turn.
        WHEN COALESCE(c.interval_days, 0) = 0 OR c.last_review_grade = 1 THEN 'learning'::text -- This card is still tricky, so we look at it a lot to help it stick.
        WHEN COALESCE(c.interval_days, 0) < COALESCE(s.mature_interval_threshold, 21) THEN 'young'::text -- We remember this card pretty well, but we still check it every so often to keep it fresh.
        ELSE 'mature'::text -- We know this card really well, so we only peek at it now and then to stay sharp.
    END AS srs_stage
FROM
    public.cards c
    -- Left join settings on user_id to get the threshold
    LEFT JOIN public.settings s ON c.user_id = s.user_id;

-- Add an index to optimize queries filtering by user and SRS state
CREATE INDEX IF NOT EXISTS cards_user_id_srs_state_idx ON public.cards (user_id, srs_level, learning_state);


```

### File: supabase/migrations/20250510000000_optimize_deck_listing_performance.sql

```
-- migrate:up
-- Fix function signature to match how it's called by the application

-- Drop the problematic function
DROP FUNCTION IF EXISTS public.get_deck_list_with_srs_counts(uuid);

CREATE OR REPLACE FUNCTION public.get_deck_list_with_srs_counts(
  p_user_id uuid
)
RETURNS TABLE (
  id uuid,
  name text,
  primary_language text,
  secondary_language text,
  is_bilingual boolean,
  updated_at timestamptz,
  new_count bigint,
  learning_count bigint,
  young_count bigint,
  mature_count bigint
)
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
WITH deck_base AS (
  SELECT
    d.id,
    d.name,
    d.primary_language,
    d.secondary_language,
    d.is_bilingual,
    d.updated_at
  FROM
    public.decks d
  WHERE
    d.user_id = p_user_id
),
srs_counts AS (
  SELECT
    c.deck_id,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NULL) AS new_count,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND 
                    (COALESCE(c.interval_days, 0) = 0 OR c.last_review_grade = 1)) AS learning_count,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND
                    COALESCE(c.interval_days, 0) > 0 AND 
                    c.last_review_grade != 1 AND
                    COALESCE(c.interval_days, 0) < COALESCE(
                        (SELECT mature_interval_threshold FROM public.settings WHERE user_id = p_user_id), 
                        21)) AS young_count,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND
                    COALESCE(c.interval_days, 0) > 0 AND 
                    c.last_review_grade != 1 AND
                    COALESCE(c.interval_days, 0) >= COALESCE(
                        (SELECT mature_interval_threshold FROM public.settings WHERE user_id = p_user_id), 
                        21)) AS mature_count
  FROM
    public.cards c
  WHERE
    c.user_id = p_user_id
    AND c.deck_id IN (SELECT id FROM deck_base)
  GROUP BY
    c.deck_id
)
SELECT
  d.id,
  d.name,
  d.primary_language,
  d.secondary_language,
  d.is_bilingual,
  d.updated_at,
  COALESCE(s.new_count, 0) AS new_count,
  COALESCE(s.learning_count, 0) AS learning_count,
  COALESCE(s.young_count, 0) AS young_count,
  COALESCE(s.mature_count, 0) AS mature_count
FROM
  deck_base d
LEFT JOIN
  srs_counts s ON d.id = s.deck_id
ORDER BY
  d.name ASC;
$$;

COMMENT ON FUNCTION public.get_deck_list_with_srs_counts(uuid)
IS 'Retrieves all decks for a user along with counts of cards in each SRS stage (new, learning, young, mature). Optimized version that avoids using the full view.';

GRANT EXECUTE ON FUNCTION public.get_deck_list_with_srs_counts(uuid) TO authenticated;
```

### File: supabase/migrations/20250510010000_optimize_rls_performance.sql

```
-- migrate:up
-- Optimize RLS policy performance by reducing function calls
-- Based on Supabase Performance Advisor recommendations

-- First drop all existing policies
DROP POLICY IF EXISTS "Users can only access cards in their decks" ON public.cards;
DROP POLICY IF EXISTS "Allow users to DELETE their own deck_tags" ON public.deck_tags;
DROP POLICY IF EXISTS "Allow users to INSERT deck_tags for their own decks" ON public.deck_tags;
DROP POLICY IF EXISTS "Allow users to SELECT their own deck_tags" ON public.deck_tags;
DROP POLICY IF EXISTS "Users can only access their own decks" ON public.decks;
DROP POLICY IF EXISTS "Allow individual user access to their settings" ON public.settings;
DROP POLICY IF EXISTS "Users can only access their own settings" ON public.settings;
DROP POLICY IF EXISTS "Allow individual user access to their study_sets" ON public.study_sets;
DROP POLICY IF EXISTS "Allow individual user access to their tags" ON public.tags;

-- Recreate policies with optimized (SELECT auth.uid() AS uid) form
CREATE POLICY "Users can only access cards in their decks" 
ON public.cards 
FOR ALL
TO public
USING (
    EXISTS (
        SELECT 1
        FROM decks
        WHERE decks.id = cards.deck_id 
        AND decks.user_id = (SELECT auth.uid() AS uid)
    )
);

CREATE POLICY "Allow users to DELETE their own deck_tags"
ON public.deck_tags
FOR DELETE
TO public
USING (user_id = (SELECT auth.uid() AS uid));

CREATE POLICY "Allow users to INSERT deck_tags for their own decks"
ON public.deck_tags
FOR INSERT
TO public
WITH CHECK (
    (user_id = (SELECT auth.uid() AS uid)) AND 
    (EXISTS (
        SELECT 1
        FROM decks
        WHERE decks.id = deck_tags.deck_id 
        AND decks.user_id = (SELECT auth.uid() AS uid)
    )) AND 
    (EXISTS (
        SELECT 1
        FROM tags
        WHERE tags.id = deck_tags.tag_id 
        AND tags.user_id = (SELECT auth.uid() AS uid)
    ))
);

CREATE POLICY "Allow users to SELECT their own deck_tags"
ON public.deck_tags
FOR SELECT
TO public
USING (user_id = (SELECT auth.uid() AS uid));

CREATE POLICY "Users can only access their own decks" 
ON public.decks 
FOR ALL
TO public
USING (user_id = (SELECT auth.uid() AS uid));

CREATE POLICY "Allow individual user access to their settings" 
ON public.settings 
FOR ALL
TO public
USING (user_id = (SELECT auth.uid() AS uid));

CREATE POLICY "Users can only access their own settings" 
ON public.settings 
FOR ALL
TO public
USING (user_id = (SELECT auth.uid() AS uid));

CREATE POLICY "Allow individual user access to their study_sets" 
ON public.study_sets 
FOR ALL
TO public
USING (user_id = (SELECT auth.uid() AS uid));

CREATE POLICY "Allow individual user access to their tags" 
ON public.tags 
FOR ALL
TO public
USING (user_id = (SELECT auth.uid() AS uid));

-- migrate:down
-- Revert to original policies
DROP POLICY IF EXISTS "Users can only access cards in their decks" ON public.cards;
DROP POLICY IF EXISTS "Allow users to DELETE their own deck_tags" ON public.deck_tags;
DROP POLICY IF EXISTS "Allow users to INSERT deck_tags for their own decks" ON public.deck_tags;
DROP POLICY IF EXISTS "Allow users to SELECT their own deck_tags" ON public.deck_tags;
DROP POLICY IF EXISTS "Users can only access their own decks" ON public.decks;
DROP POLICY IF EXISTS "Allow individual user access to their settings" ON public.settings;
DROP POLICY IF EXISTS "Users can only access their own settings" ON public.settings;
DROP POLICY IF EXISTS "Allow individual user access to their study_sets" ON public.study_sets;
DROP POLICY IF EXISTS "Allow individual user access to their tags" ON public.tags;

-- Restore original cards policy
CREATE POLICY "Users can only access cards in their decks"
ON public.cards
FOR ALL
TO public
USING (
    EXISTS (
        SELECT 1
        FROM decks
        WHERE decks.id = cards.deck_id 
        AND decks.user_id = auth.uid()
    )
);

-- Restore original deck_tags policies
CREATE POLICY "Allow users to DELETE their own deck_tags"
ON public.deck_tags
FOR DELETE
TO public
USING (auth.uid() = user_id);

CREATE POLICY "Allow users to INSERT deck_tags for their own decks"
ON public.deck_tags
FOR INSERT
TO public
WITH CHECK (
    (auth.uid() = user_id) AND 
    (EXISTS (
        SELECT 1
        FROM decks
        WHERE decks.id = deck_tags.deck_id 
        AND decks.user_id = auth.uid()
    )) AND 
    (EXISTS (
        SELECT 1
        FROM tags
        WHERE tags.id = deck_tags.tag_id 
        AND tags.user_id = auth.uid()
    ))
);

CREATE POLICY "Allow users to SELECT their own deck_tags"
ON public.deck_tags
FOR SELECT
TO public
USING (auth.uid() = user_id);

-- Restore original decks policy
CREATE POLICY "Users can only access their own decks"
ON public.decks
FOR ALL
TO public
USING (auth.uid() = user_id);

-- Restore original settings policies
CREATE POLICY "Allow individual user access to their settings"
ON public.settings
FOR ALL
TO public
USING (auth.uid() = user_id);

CREATE POLICY "Users can only access their own settings"
ON public.settings
FOR ALL
TO public
USING (auth.uid() = user_id);

-- Restore original study_sets policy
CREATE POLICY "Allow individual user access to their study_sets"
ON public.study_sets
FOR ALL
TO public
USING (auth.uid() = user_id);

-- Restore original tags policy
CREATE POLICY "Allow individual user access to their tags"
ON public.tags
FOR ALL
TO public
USING (auth.uid() = user_id); 
```

### File: supabase/migrations/20250510020000_add_complete_srs_counts_function.sql

```
-- Add database function to fetch decks with complete SRS counts in one query

CREATE OR REPLACE FUNCTION public.get_decks_with_complete_srs_counts(
  p_user_id uuid
)
RETURNS TABLE (
  id uuid,
  name text,
  primary_language text,
  secondary_language text,
  is_bilingual boolean,
  updated_at timestamptz,
  new_count bigint,           -- Standard SRS stage counts
  learning_count bigint,
  young_count bigint,
  mature_count bigint,
  learn_eligible_count bigint, -- New Learn button count
  review_eligible_count bigint -- New Review button count
)
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
WITH 
deck_base AS (
  SELECT
    d.id,
    d.name,
    d.primary_language,
    d.secondary_language,
    d.is_bilingual,
    d.updated_at
  FROM
    public.decks d
  WHERE
    d.user_id = p_user_id
),
-- Calculate standard SRS stages
srs_counts AS (
  SELECT
    c.deck_id,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NULL) AS new_count,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND 
                    (COALESCE(c.interval_days, 0) = 0 OR c.last_review_grade = 1)) AS learning_count,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND
                    COALESCE(c.interval_days, 0) > 0 AND 
                    c.last_review_grade != 1 AND
                    COALESCE(c.interval_days, 0) < COALESCE(
                        (SELECT mature_interval_threshold FROM public.settings WHERE user_id = p_user_id), 
                        21)) AS young_count,
    COUNT(*) FILTER (WHERE c.last_reviewed_at IS NOT NULL AND
                    COALESCE(c.interval_days, 0) > 0 AND 
                    c.last_review_grade != 1 AND
                    COALESCE(c.interval_days, 0) >= COALESCE(
                        (SELECT mature_interval_threshold FROM public.settings WHERE user_id = p_user_id), 
                        21)) AS mature_count,
    -- Learn Mode eligibility: srs_level=0, learning_state=null or 'learning'
    COUNT(*) FILTER (WHERE c.srs_level = 0 AND 
                    (c.learning_state IS NULL OR c.learning_state = 'learning')) AS learn_eligible_count,
    -- Review Mode eligibility
    COUNT(*) FILTER (WHERE 
                    -- graduated or relearning
                    ((c.srs_level >= 1) OR (c.srs_level = 0 AND c.learning_state = 'relearning'))
                    -- and due for review
                    AND c.next_review_due <= CURRENT_TIMESTAMP) AS review_eligible_count
  FROM
    public.cards c
  WHERE
    c.user_id = p_user_id
    AND c.deck_id IN (SELECT id FROM deck_base)
  GROUP BY
    c.deck_id
)
-- Combine the data
SELECT
  d.id,
  d.name,
  d.primary_language,
  d.secondary_language,
  d.is_bilingual,
  d.updated_at,
  COALESCE(s.new_count, 0) AS new_count,
  COALESCE(s.learning_count, 0) AS learning_count,
  COALESCE(s.young_count, 0) AS young_count,
  COALESCE(s.mature_count, 0) AS mature_count,
  COALESCE(s.learn_eligible_count, 0) AS learn_eligible_count,
  COALESCE(s.review_eligible_count, 0) AS review_eligible_count
FROM
  deck_base d
LEFT JOIN
  srs_counts s ON d.id = s.deck_id
ORDER BY
  d.name ASC;
$$;

COMMENT ON FUNCTION public.get_decks_with_complete_srs_counts(uuid)
IS 'Retrieves all decks for a user with complete SRS information in a single query. Includes standard SRS stage counts and eligible counts for learn/review modes.';

GRANT EXECUTE ON FUNCTION public.get_decks_with_complete_srs_counts(uuid) TO authenticated;
```

### File: supabase/migrations/20250518095041_update_cards_with_srs_stage_v2.sql

```
-- Migration: Update cards_with_srs_stage view to use srs_level and learning_state
-- Version: 2
-- Description: This migration updates the public.cards_with_srs_stage view
--              to classify cards based on their srs_level and learning_state,
--              aligning with the application's core SRS state model.
--              It introduces 'relearning' as a distinct stage visible in the view.

-- Drop the existing view if it exists to ensure a clean re-creation
DROP VIEW IF EXISTS public.cards_with_srs_stage;

-- Create the new view with updated logic
CREATE OR REPLACE VIEW public.cards_with_srs_stage AS
SELECT
    c.id,
    c.deck_id,
    c.user_id,
    c.question,
    c.answer,
    c.created_at,
    c.updated_at,
    c.last_reviewed_at,
    c.next_review_due,
    c.srs_level,
    c.easiness_factor,
    c.interval_days,
    c.learning_state,
    c.learning_step_index,
    c.failed_attempts_in_learn,
    c.hard_attempts_in_learn,
    c.stability,
    c.difficulty,
    c.last_review_grade,
    c.correct_count,
    c.incorrect_count,
    c.attempt_count,
    c.question_part_of_speech,
    c.question_gender,
    c.answer_part_of_speech,
    c.answer_gender,
    s.mature_interval_threshold, -- Include for reference or potential future use
    CASE
        -- Card is 'new' if it has srs_level 0 and no learning_state (never started learning)
        WHEN c.srs_level = 0 AND c.learning_state IS NULL THEN 'new'::text
        -- Card is 'learning' if srs_level 0 and in 'learning' state (initial learning steps)
        WHEN c.srs_level = 0 AND c.learning_state = 'learning' THEN 'learning'::text
        -- Card is 'relearning' if srs_level 0 and in 'relearning' state (lapsed and in relearning steps)
        WHEN c.srs_level = 0 AND c.learning_state = 'relearning' THEN 'relearning'::text
        -- Card is 'young' if it's in review (srs_level >= 1), has a positive interval,
        -- and its interval is less than the mature_interval_threshold from user settings.
        WHEN c.srs_level >= 1 AND c.interval_days > 0 AND c.interval_days < COALESCE(s.mature_interval_threshold, 21) THEN 'young'::text
        -- Card is 'mature' if it's in review (srs_level >= 1), has a positive interval,
        -- and its interval is greater than or equal to the mature_interval_threshold.
        WHEN c.srs_level >= 1 AND c.interval_days >= COALESCE(s.mature_interval_threshold, 21) THEN 'mature'::text
        -- Fallback for any other unexpected state (should ideally not be hit if data is consistent)
        ELSE 'unknown'::text
    END AS srs_stage
FROM
    public.cards c
    -- LEFT JOIN settings on user_id to get the mature_interval_threshold.
    -- Using LEFT JOIN ensures cards are still included even if a user has no settings row (though unlikely).
    LEFT JOIN public.settings s ON c.user_id = s.user_id;

-- Add comment to the updated view
COMMENT ON VIEW public.cards_with_srs_stage IS 'Extends cards with calculated SRS stage (new, learning, relearning, young, mature) based on srs_level, learning_state, interval_days, and user settings. Version 2.';

-- RLS: Row Level Security for this view will be inherited from the underlying 'public.cards' table.
-- Ensure 'public.cards' RLS policies correctly restrict access based on auth.uid() = cards.user_id.
-- Ensure 'public.settings' RLS policies correctly restrict access based on auth.uid() = settings.user_id if the view is not SECURITY DEFINER.
-- If direct access to settings by any user querying the view is a concern and SECURITY INVOKER is used,
-- ensure appropriate RLS on 'settings' table or consider making the view SECURITY DEFINER if necessary and safe.
-- For now, assuming SECURITY INVOKER and that RLS on underlying tables is sufficient.

-- No separate GRANT statements are typically needed for views if the user has permissions on the underlying tables,
-- unless specific view-level permissions are desired.
```

### File: supabase/migrations/20250518100551_deprecate_get_deck_list_with_srs_counts_function.sql.sql

```
-- Migration: Deprecate and remove the old get_deck_list_with_srs_counts function
-- Version: 1
-- Description: This migration removes the public.get_deck_list_with_srs_counts(uuid)
--              function as its functionality is superseded by
--              public.get_decks_with_complete_srs_counts(uuid), which provides
--              more comprehensive SRS stage and eligibility counts.

DROP FUNCTION IF EXISTS public.get_deck_list_with_srs_counts(uuid);

-- Optional: Add a comment if you want to record the deprecation reason in a more permanent way,
-- though the migration file itself serves this purpose.
-- COMMENT ON FUNCTION public.get_deck_list_with_srs_counts(uuid) IS 'DEPRECATED: Replaced by get_decks_with_complete_srs_counts(uuid) as of YYYY-MM-DD.';
```

### File: supabase/migrations/20250518102853_refine_resolve_study_query_srs_filters_v8.sql.sql

```
-- Migration: Update resolve_study_query for new filters (language, multi-deck, SRS stages)
-- Version: 10
-- Description: This migration updates public.resolve_study_query(uuid, jsonb) to:
--              1. Support filtering by an array of deck_ids.
--              2. Add filtering by 'containsLanguage' (checks deck's primary or secondary language).
--              3. Replace numeric SRS level filter with filtering by an array of 'srsStages'
--                 (requires joining with cards_with_srs_stage view).
--              4. Retains existing filters (user, tags, includeLearning, dates).

DROP FUNCTION IF EXISTS public.resolve_study_query(uuid, jsonb);

CREATE OR REPLACE FUNCTION public.resolve_study_query(
    p_user_id uuid,
    p_query_criteria jsonb
)
RETURNS SETOF uuid
LANGUAGE plpgsql
STABLE
SECURITY DEFINER
AS $$
DECLARE
    v_sql                  TEXT;
    v_from_clause          TEXT := 'FROM public.cards c';
    v_join_clauses         TEXT := '';
    v_where_clauses        TEXT[] := ARRAY[]::TEXT[];

    -- Parsed criteria variables
    v_deck_ids             UUID[]; -- Changed from v_deck_id
    v_include_tags         UUID[];
    v_exclude_tags         UUID[];
    v_tag_logic            TEXT;
    v_include_learning     BOOLEAN;
    v_contains_language    TEXT;   -- NEW
    v_srs_stages           TEXT[]; -- NEW (replaces srs_level_op/value)

    -- Date related variables (same as v8/v9)
    v_date_field_key       TEXT;
    v_date_field_keys      TEXT[] := ARRAY['createdDate', 'updatedDate', 'lastReviewed', 'nextReviewDue'];
    v_db_column            TEXT;
    v_date_op_json         TEXT;
    v_date_val_json        TEXT;
    v_date_range_json      JSONB;
    v_start_date           TEXT;
    v_end_date             TEXT;
    v_current_date_clauses TEXT[];
BEGIN
    RAISE LOG '[resolve_study_query_v10] User: %, Criteria: %', p_user_id, p_query_criteria;

    v_where_clauses := array_append(v_where_clauses, format('c.user_id = %L', p_user_id));

    -- Extract criteria
    IF jsonb_typeof(p_query_criteria->'deckIds') = 'array' THEN
        SELECT array_agg(elem::uuid) INTO v_deck_ids FROM jsonb_array_elements_text(p_query_criteria->'deckIds') elem;
    END IF;
    v_deck_ids := COALESCE(v_deck_ids, ARRAY[]::UUID[]);

    v_tag_logic := COALESCE(p_query_criteria->>'tagLogic', 'ANY');
    v_include_learning := COALESCE((p_query_criteria->>'includeLearning')::BOOLEAN, FALSE);
    v_contains_language := p_query_criteria->>'containsLanguage'; -- Will be null if not present

    IF jsonb_typeof(p_query_criteria->'srsStages') = 'array' THEN
        SELECT array_agg(elem::text) INTO v_srs_stages FROM jsonb_array_elements_text(p_query_criteria->'srsStages') elem;
    END IF;
    v_srs_stages := COALESCE(v_srs_stages, ARRAY[]::TEXT[]);

    -- Tag arrays (same as before)
    IF jsonb_typeof(p_query_criteria->'includeTags') = 'array' THEN
        SELECT array_agg(elem::uuid) INTO v_include_tags FROM jsonb_array_elements_text(p_query_criteria->'includeTags') elem;
    END IF;
    v_include_tags := COALESCE(v_include_tags, ARRAY[]::UUID[]);
    IF jsonb_typeof(p_query_criteria->'excludeTags') = 'array' THEN
        SELECT array_agg(elem::uuid) INTO v_exclude_tags FROM jsonb_array_elements_text(p_query_criteria->'excludeTags') elem;
    END IF;
    v_exclude_tags := COALESCE(v_exclude_tags, ARRAY[]::UUID[]);


    -- Deck filter (multiple IDs)
    IF array_length(v_deck_ids, 1) > 0 THEN
        v_where_clauses := array_append(v_where_clauses, format('c.deck_id = ANY(%L::uuid[])', v_deck_ids));
    END IF;

    -- Tag filtering (same as before)
    IF array_length(v_include_tags, 1) > 0 THEN
        IF v_join_clauses !~ 'JOIN public.deck_tags' THEN -- Add join only if needed
            v_join_clauses := v_join_clauses || ' JOIN public.decks d_tags ON c.deck_id = d_tags.id LEFT JOIN public.deck_tags dt ON d_tags.id = dt.deck_id';
        END IF;
        IF v_tag_logic = 'ALL' THEN
             v_where_clauses := array_append(v_where_clauses, format(
                'EXISTS (SELECT 1 FROM public.deck_tags d_all_tags WHERE d_all_tags.deck_id = c.deck_id AND d_all_tags.tag_id = ANY(%L::uuid[]) GROUP BY d_all_tags.deck_id HAVING COUNT(DISTINCT d_all_tags.tag_id) = %s)',
                v_include_tags, array_length(v_include_tags,1) ));
        ELSE -- ANY
            v_where_clauses := array_append(v_where_clauses, format(
                'EXISTS (SELECT 1 FROM public.deck_tags d_any_tags WHERE d_any_tags.deck_id = c.deck_id AND d_any_tags.tag_id = ANY(%L::uuid[]))',
                v_include_tags ));
        END IF;
    END IF;
    IF array_length(v_exclude_tags, 1) > 0 THEN
         IF v_join_clauses !~ 'JOIN public.deck_tags' AND v_join_clauses !~ 'LEFT JOIN public.deck_tags' THEN
            v_join_clauses := v_join_clauses || ' LEFT JOIN public.deck_tags dt_exclude ON c.deck_id = dt_exclude.deck_id AND dt_exclude.tag_id = ANY(%L::uuid[])';
            v_where_clauses := array_append(v_where_clauses, 'dt_exclude.tag_id IS NULL');
        ELSE
             v_where_clauses := array_append(v_where_clauses, format(
                'NOT EXISTS (SELECT 1 FROM public.deck_tags d_none_tags WHERE d_none_tags.deck_id = c.deck_id AND d_none_tags.tag_id = ANY(%L::uuid[]))',
                 v_exclude_tags ));
        END IF;
    END IF;

    -- 'includeLearning' filter (same as before)
    IF v_include_learning IS TRUE THEN
        v_where_clauses := array_append(v_where_clauses, '(c.srs_level = 0 AND (c.learning_state IS NULL OR c.learning_state = ''learning''))');
    END IF;

    -- NEW Language Filter
    IF v_contains_language IS NOT NULL AND char_length(v_contains_language) = 2 THEN
        IF v_join_clauses !~ 'JOIN public.decks d_lang' THEN -- Add join only if needed by language or other deck property filters
            v_join_clauses := v_join_clauses || ' JOIN public.decks d_lang ON c.deck_id = d_lang.id';
        END IF;
        v_where_clauses := array_append(v_where_clauses,
            format('(d_lang.primary_language = %L OR (d_lang.is_bilingual IS TRUE AND d_lang.secondary_language = %L))',
                   v_contains_language, v_contains_language)
        );
        RAISE LOG '[resolve_study_query_v10] Applied containsLanguage filter: %', v_contains_language;
    END IF;

    -- NEW SRS Stage Filter
    IF array_length(v_srs_stages, 1) > 0 THEN
        IF v_join_clauses !~ 'JOIN public.cards_with_srs_stage cws' THEN -- Add join only if needed
            v_join_clauses := v_join_clauses || ' JOIN public.cards_with_srs_stage cws ON c.id = cws.id';
        END IF;
        v_where_clauses := array_append(v_where_clauses, format('cws.srs_stage = ANY(%L::text[])', v_srs_stages));
        RAISE LOG '[resolve_study_query_v10] Applied srsStages filter: %', v_srs_stages;
    END IF;

    -- Date Filters (same logic as v9)
    FOREACH v_date_field_key IN ARRAY v_date_field_keys LOOP
        v_current_date_clauses := ARRAY[]::TEXT[];
        v_db_column := CASE v_date_field_key /* ... same mapping ... */
                         WHEN 'createdDate' THEN 'c.created_at'
                         WHEN 'updatedDate' THEN 'c.updated_at'
                         WHEN 'lastReviewed' THEN 'c.last_reviewed_at'
                         WHEN 'nextReviewDue' THEN 'c.next_review_due'
                         ELSE '' END;
        v_date_op_json := p_query_criteria->v_date_field_key->>'operator';
        v_date_val_json := p_query_criteria->v_date_field_key->>'value';
        v_date_range_json := p_query_criteria->v_date_field_key->'value';

        IF v_date_op_json IS NOT NULL AND v_date_op_json <> 'any' THEN
            IF v_date_op_json = 'newerThanDays' AND v_date_val_json IS NOT NULL AND v_date_val_json ~ '^\d+$' THEN
                v_current_date_clauses := array_append(v_current_date_clauses, format('%s >= (NOW() - interval ''1 day'' * (%L::integer))', v_db_column, v_date_val_json));
            ELSIF v_date_op_json = 'olderThanDays' AND v_date_val_json IS NOT NULL AND v_date_val_json ~ '^\d+$' THEN
                v_current_date_clauses := array_append(v_current_date_clauses, format('%s < (NOW() - interval ''1 day'' * (%L::integer))', v_db_column, v_date_val_json));
            ELSIF v_date_op_json = 'onDate' AND v_date_val_json IS NOT NULL THEN
                v_current_date_clauses := array_append(v_current_date_clauses, format('%s::date = %L::date', v_db_column, v_date_val_json));
            ELSIF v_date_op_json = 'betweenDates' AND jsonb_typeof(v_date_range_json) = 'array' AND jsonb_array_length(v_date_range_json) = 2 THEN
                v_start_date := v_date_range_json->>0; v_end_date := v_date_range_json->>1;
                IF v_start_date IS NOT NULL AND v_start_date <> 'null' THEN v_current_date_clauses := array_append(v_current_date_clauses, format('%s::date >= %L::date', v_db_column, v_start_date)); END IF;
                IF v_end_date IS NOT NULL AND v_end_date <> 'null' THEN v_current_date_clauses := array_append(v_current_date_clauses, format('%s::date <= %L::date', v_db_column, v_end_date)); END IF;
            ELSIF v_date_op_json = 'never' AND (v_date_field_key = 'lastReviewed' OR v_date_field_key = 'nextReviewDue') THEN
                v_current_date_clauses := array_append(v_current_date_clauses, format('%s IS NULL', v_db_column));
            ELSIF v_date_op_json = 'isDue' AND v_date_field_key = 'nextReviewDue' THEN
                v_current_date_clauses := array_append(v_current_date_clauses, format('(%s IS NULL OR %s <= NOW())', v_db_column, v_db_column));
            ELSE RAISE WARNING '[resolve_study_query_v10] Invalid date op: "%" for %, User %. Ignored.', v_date_op_json, v_db_column, p_user_id; END IF;

            IF (v_date_op_json IN ('newerThanDays', 'olderThanDays', 'onDate', 'betweenDates')) AND
               (v_date_field_key = 'lastReviewed' OR v_date_field_key = 'nextReviewDue') AND
               array_length(v_current_date_clauses, 1) > 0 THEN
                v_current_date_clauses := array_prepend(format('%s IS NOT NULL', v_db_column), v_current_date_clauses);
            END IF;
            IF array_length(v_current_date_clauses, 1) > 0 THEN v_where_clauses := array_append(v_where_clauses, '(' || array_to_string(v_current_date_clauses, ' AND ') || ')'); END IF;
        END IF;
    END LOOP;

    v_sql := 'SELECT c.id ' || v_from_clause || v_join_clauses; -- Added v_join_clauses
    IF array_length(v_where_clauses, 1) > 0 THEN
        v_sql := v_sql || ' WHERE ' || array_to_string(v_where_clauses, ' AND ');
    END IF;
    v_sql := v_sql || ' ORDER BY c.created_at DESC, c.id DESC NULLS LAST';

    RAISE LOG '[resolve_study_query_v10] Final SQL: %', v_sql;
    RETURN QUERY EXECUTE v_sql;

EXCEPTION WHEN others THEN
    RAISE WARNING '[resolve_study_query_v10] Error for User: %, Criteria: %. Error: %', p_user_id, p_query_criteria, SQLERRM;
    RETURN;
END;
$$;

GRANT EXECUTE ON FUNCTION public.resolve_study_query(uuid, jsonb) TO authenticated;

COMMENT ON FUNCTION public.resolve_study_query(uuid, jsonb) IS
'Resolves study query criteria into card IDs. v10: Multi-deck, language filter, SRS stage filter, date filter completion.';
```

## Directory: types

### File: types/database.ts

```
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      cards: {
        Row: {
          answer: string
          answer_gender: string | null
          answer_part_of_speech: string | null
          attempt_count: number | null
          correct_count: number | null
          created_at: string | null
          deck_id: string
          difficulty: number | null
          difficulty_score: number | null
          easiness_factor: number | null
          failed_attempts_in_learn: number
          hard_attempts_in_learn: number
          id: string
          incorrect_count: number | null
          interval_days: number | null
          last_review_grade: number | null
          last_reviewed_at: string | null
          last_studied: string | null
          learning_state: string | null
          learning_step_index: number | null
          next_review_due: string | null
          question: string
          question_gender: string | null
          question_part_of_speech: string | null
          srs_level: number
          stability: number | null
          updated_at: string | null
          user_id: string | null
        }
        Insert: {
          answer: string
          answer_gender?: string | null
          answer_part_of_speech?: string | null
          attempt_count?: number | null
          correct_count?: number | null
          created_at?: string | null
          deck_id: string
          difficulty?: number | null
          difficulty_score?: number | null
          easiness_factor?: number | null
          failed_attempts_in_learn?: number
          hard_attempts_in_learn?: number
          id?: string
          incorrect_count?: number | null
          interval_days?: number | null
          last_review_grade?: number | null
          last_reviewed_at?: string | null
          last_studied?: string | null
          learning_state?: string | null
          learning_step_index?: number | null
          next_review_due?: string | null
          question: string
          question_gender?: string | null
          question_part_of_speech?: string | null
          srs_level?: number
          stability?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Update: {
          answer?: string
          answer_gender?: string | null
          answer_part_of_speech?: string | null
          attempt_count?: number | null
          correct_count?: number | null
          created_at?: string | null
          deck_id?: string
          difficulty?: number | null
          difficulty_score?: number | null
          easiness_factor?: number | null
          failed_attempts_in_learn?: number
          hard_attempts_in_learn?: number
          id?: string
          incorrect_count?: number | null
          interval_days?: number | null
          last_review_grade?: number | null
          last_reviewed_at?: string | null
          last_studied?: string | null
          learning_state?: string | null
          learning_step_index?: number | null
          next_review_due?: string | null
          question?: string
          question_gender?: string | null
          question_part_of_speech?: string | null
          srs_level?: number
          stability?: number | null
          updated_at?: string | null
          user_id?: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_deck"
            columns: ["deck_id"]
            isOneToOne: false
            referencedRelation: "decks"
            referencedColumns: ["id"]
          },
        ]
      }
      deck_tags: {
        Row: {
          created_at: string
          deck_id: string
          tag_id: string
          user_id: string
        }
        Insert: {
          created_at?: string
          deck_id: string
          tag_id: string
          user_id: string
        }
        Update: {
          created_at?: string
          deck_id?: string
          tag_id?: string
          user_id?: string
        }
        Relationships: [
          {
            foreignKeyName: "deck_tags_deck_id_fkey"
            columns: ["deck_id"]
            isOneToOne: false
            referencedRelation: "decks"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "deck_tags_tag_id_fkey"
            columns: ["tag_id"]
            isOneToOne: false
            referencedRelation: "tags"
            referencedColumns: ["id"]
          },
        ]
      }
      decks: {
        Row: {
          created_at: string | null
          id: string
          is_bilingual: boolean
          name: string
          primary_language: string
          progress: Json
          secondary_language: string
          updated_at: string | null
          user_id: string
        }
        Insert: {
          created_at?: string | null
          id?: string
          is_bilingual?: boolean
          name: string
          primary_language?: string
          progress?: Json
          secondary_language?: string
          updated_at?: string | null
          user_id: string
        }
        Update: {
          created_at?: string | null
          id?: string
          is_bilingual?: boolean
          name?: string
          primary_language?: string
          progress?: Json
          secondary_language?: string
          updated_at?: string | null
          user_id?: string
        }
        Relationships: []
      }
      settings: {
        Row: {
          app_language: string
          card_font: string | null
          color_only_non_native: boolean | null
          created_at: string | null
          custom_learn_requeue_gap: number
          default_easiness_factor: number
          easy_interval_days: number
          enable_advanced_color_coding: boolean | null
          enable_basic_color_coding: boolean | null
          enable_dedicated_learn_mode: boolean
          enable_word_color_coding: boolean | null
          graduating_interval_days: number
          id: string
          initial_learning_steps_minutes: number[]
          language_dialects: Json | null
          lapsed_ef_penalty: number
          learn_again_penalty: number
          learn_hard_penalty: number
          mastery_threshold: number | null
          mature_interval_threshold: number
          min_easiness_factor: number
          preferred_voices: Json
          relearning_steps_minutes: number[]
          show_deck_progress: boolean
          show_difficulty: boolean | null
          theme_light_dark_mode: string
          tts_enabled: boolean | null
          updated_at: string | null
          user_id: string
          word_palette_config: Json | null
        }
        Insert: {
          app_language?: string
          card_font?: string | null
          color_only_non_native?: boolean | null
          created_at?: string | null
          custom_learn_requeue_gap?: number
          default_easiness_factor?: number
          easy_interval_days?: number
          enable_advanced_color_coding?: boolean | null
          enable_basic_color_coding?: boolean | null
          enable_dedicated_learn_mode?: boolean
          enable_word_color_coding?: boolean | null
          graduating_interval_days?: number
          id?: string
          initial_learning_steps_minutes?: number[]
          language_dialects?: Json | null
          lapsed_ef_penalty?: number
          learn_again_penalty?: number
          learn_hard_penalty?: number
          mastery_threshold?: number | null
          mature_interval_threshold?: number
          min_easiness_factor?: number
          preferred_voices?: Json
          relearning_steps_minutes?: number[]
          show_deck_progress?: boolean
          show_difficulty?: boolean | null
          theme_light_dark_mode?: string
          tts_enabled?: boolean | null
          updated_at?: string | null
          user_id: string
          word_palette_config?: Json | null
        }
        Update: {
          app_language?: string
          card_font?: string | null
          color_only_non_native?: boolean | null
          created_at?: string | null
          custom_learn_requeue_gap?: number
          default_easiness_factor?: number
          easy_interval_days?: number
          enable_advanced_color_coding?: boolean | null
          enable_basic_color_coding?: boolean | null
          enable_dedicated_learn_mode?: boolean
          enable_word_color_coding?: boolean | null
          graduating_interval_days?: number
          id?: string
          initial_learning_steps_minutes?: number[]
          language_dialects?: Json | null
          lapsed_ef_penalty?: number
          learn_again_penalty?: number
          learn_hard_penalty?: number
          mastery_threshold?: number | null
          mature_interval_threshold?: number
          min_easiness_factor?: number
          preferred_voices?: Json
          relearning_steps_minutes?: number[]
          show_deck_progress?: boolean
          show_difficulty?: boolean | null
          theme_light_dark_mode?: string
          tts_enabled?: boolean | null
          updated_at?: string | null
          user_id?: string
          word_palette_config?: Json | null
        }
        Relationships: []
      }
      study_sets: {
        Row: {
          created_at: string
          description: string | null
          id: string
          name: string
          query_criteria: Json
          updated_at: string
          user_id: string
        }
        Insert: {
          created_at?: string
          description?: string | null
          id?: string
          name: string
          query_criteria: Json
          updated_at?: string
          user_id: string
        }
        Update: {
          created_at?: string
          description?: string | null
          id?: string
          name?: string
          query_criteria?: Json
          updated_at?: string
          user_id?: string
        }
        Relationships: []
      }
      tags: {
        Row: {
          created_at: string
          id: string
          name: string
          user_id: string
        }
        Insert: {
          created_at?: string
          id?: string
          name: string
          user_id: string
        }
        Update: {
          created_at?: string
          id?: string
          name?: string
          user_id?: string
        }
        Relationships: []
      }
    }
    Views: {
      cards_with_srs_stage: {
        Row: {
          answer: string | null
          answer_gender: string | null
          answer_part_of_speech: string | null
          attempt_count: number | null
          correct_count: number | null
          created_at: string | null
          deck_id: string | null
          difficulty: number | null
          easiness_factor: number | null
          failed_attempts_in_learn: number | null
          hard_attempts_in_learn: number | null
          id: string | null
          incorrect_count: number | null
          interval_days: number | null
          last_review_grade: number | null
          last_reviewed_at: string | null
          learning_state: string | null
          learning_step_index: number | null
          mature_interval_threshold: number | null
          next_review_due: string | null
          question: string | null
          question_gender: string | null
          question_part_of_speech: string | null
          srs_level: number | null
          srs_stage: string | null
          stability: number | null
          updated_at: string | null
          user_id: string | null
        }
        Relationships: [
          {
            foreignKeyName: "fk_deck"
            columns: ["deck_id"]
            isOneToOne: false
            referencedRelation: "decks"
            referencedColumns: ["id"]
          },
        ]
      }
    }
    Functions: {
      get_decks_with_complete_srs_counts: {
        Args: { p_user_id: string }
        Returns: {
          id: string
          name: string
          primary_language: string
          secondary_language: string
          is_bilingual: boolean
          updated_at: string
          new_count: number
          learning_count: number
          young_count: number
          mature_count: number
          learn_eligible_count: number
          review_eligible_count: number
        }[]
      }
      resolve_study_query: {
        Args: { p_user_id: string; p_query_criteria: Json }
        Returns: string[]
      }
    }
    Enums: {
      font_option: "default" | "opendyslexic" | "atkinson"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type DefaultSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  DefaultSchemaTableNameOrOptions extends
    | keyof (DefaultSchema["Tables"] & DefaultSchema["Views"])
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
        Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? (Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"] &
      Database[DefaultSchemaTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : DefaultSchemaTableNameOrOptions extends keyof (DefaultSchema["Tables"] &
        DefaultSchema["Views"])
    ? (DefaultSchema["Tables"] &
        DefaultSchema["Views"])[DefaultSchemaTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  DefaultSchemaTableNameOrOptions extends
    | keyof DefaultSchema["Tables"]
    | { schema: keyof Database },
  TableName extends DefaultSchemaTableNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = DefaultSchemaTableNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : DefaultSchemaTableNameOrOptions extends keyof DefaultSchema["Tables"]
    ? DefaultSchema["Tables"][DefaultSchemaTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  DefaultSchemaEnumNameOrOptions extends
    | keyof DefaultSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends DefaultSchemaEnumNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = DefaultSchemaEnumNameOrOptions extends { schema: keyof Database }
  ? Database[DefaultSchemaEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : DefaultSchemaEnumNameOrOptions extends keyof DefaultSchema["Enums"]
    ? DefaultSchema["Enums"][DefaultSchemaEnumNameOrOptions]
    : never

export type CompositeTypes<
  PublicCompositeTypeNameOrOptions extends
    | keyof DefaultSchema["CompositeTypes"]
    | { schema: keyof Database },
  CompositeTypeName extends PublicCompositeTypeNameOrOptions extends {
    schema: keyof Database
  }
    ? keyof Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"]
    : never = never,
> = PublicCompositeTypeNameOrOptions extends { schema: keyof Database }
  ? Database[PublicCompositeTypeNameOrOptions["schema"]]["CompositeTypes"][CompositeTypeName]
  : PublicCompositeTypeNameOrOptions extends keyof DefaultSchema["CompositeTypes"]
    ? DefaultSchema["CompositeTypes"][PublicCompositeTypeNameOrOptions]
    : never

export const Constants = {
  public: {
    Enums: {
      font_option: ["default", "opendyslexic", "atkinson"],
    },
  },
} as const

```

### File: types/pdf-parse.d.ts

```
declare module 'pdf-parse' {
  interface PDFData {
    text: string;
    numpages: number;
    info: Record<string, any>;
    metadata: Record<string, any>;
    version: string;
  }

  interface PDFOptions {
    max?: number;
    pagerender?: (pageData: any) => Promise<string>;
    [key: string]: any;
  }

  function pdfParse(dataBuffer: Buffer | ArrayBuffer, options?: PDFOptions): Promise<PDFData>;

  export = pdfParse;
} 
```

### File: types/study.ts

```
// types/study.ts

import type { Tables } from '@/types/database';
// Import the authoritative StudyQueryCriteria type from its Zod schema definition
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
// Note: ReviewGrade should be imported from '@/lib/srs' where used, not redefined here.

// Type for the card data as fetched from the database, including potential deck relations
// This should align with what getCardsByIds action returns.
export type StudyCardDb = Tables<'cards'> & {
  decks?: { // Optional decks relation for language info
    primary_language: string;
    secondary_language: string;
  } | null;
};

/**
 * Represents the internal, session-specific state of a card being studied.
 * This state is managed by the study session hook and is not directly persisted
 * as-is to the database (though its components might inform DB updates).
 */
export interface InternalCardState {
  /** For 'dedicated-learn' algorithm: tracks consecutive correct answers in the current session. */
  streak: number;
  /** For 'standard-sm2' (learn/relearn): current step index in the learning/relearning steps array. */
  learningStepIndex: number | null;
  /** When this card is next due *within the current study session*. (e.g., for timed steps or re-queueing) */
  dueTime: Date;
  /** For 'dedicated-learn': tracks 'Again' (Grade 1) responses during the initial learning phase of this session. */
  failedAttemptsInLearnSession: number;
  /** For 'dedicated-learn': tracks 'Hard' (Grade 2) responses during the initial learning phase of this session. */
  hardAttemptsInLearnSession: number;
  /** Flag to indicate if this card has just been seen in the current session pass (for custom re-queue logic) */
  justSeenInSession?: boolean;
  /** Original srs_level when the card was loaded into the session (for relearning graduation reference) */
  originalSrsLevelOnLoad?: number;
}

/**
 * Represents a card item within the active study session queue.
 * It combines the persistent card data with its transient session state.
 */
export interface SessionCard {
  /** The full card data object from the database. */
  card: StudyCardDb;
  /** The internal state of this card specific to the current study session. */
  internalState: InternalCardState;
}

/**
 * Defines the type of study session being conducted.
 * - 'learn-only': Focuses only on new cards (srs_level 0, not relearning).
 * - 'review-only': Focuses only on cards due for review (srs_level >= 1 or relearning, and due).
 * - 'unified': A combined session that prioritizes learning cards first, then due review cards.
 */
export type SessionType = 'learn-only' | 'review-only' | 'unified';

/**
 * Represents the aggregated results and statistics for the current study session.
 */
export interface SessionResults {
  totalAnswered: number;
  correctCount: number; // Grade >= 3 (Good or Easy)
  hardCount: number;    // Grade 2
  incorrectCount: number; // Grade 1 (Again)
  graduatedFromLearnCount: number;
  graduatedFromRelearnCount: number;
  lapsedToRelearnCount: number;
}

/**
 * Describes the outcome of answering a card, providing necessary data
 * for updating the card's DB state and the session queue.
 * This type is used by card-state-handlers.ts
 */
export type CardStateUpdateOutcome = {
    dbUpdatePayload: Partial<Tables<'cards'>>;
    nextInternalState: InternalCardState;
    queueInstruction: 'remove' | 're-queue-soon' | 're-queue-later' | 'set-timed-step'; // Aligned with handler logic
    reinsertAfterNJobs?: number; // For 'dedicated-learn' requeue gap
    sessionResultCategory?: 'graduatedLearn' | 'graduatedRelearn' | 'lapsed';
};


/**
 * Input parameters to initialize a study session, typically stored in Zustand
 * or passed as props to the useStudySession hook.
 */
export type StudySessionInput =
  | { criteria: StudyQueryCriteria; studySetId?: undefined; deckId?: undefined } // Uses the Zod-derived StudyQueryCriteria
  | { criteria?: undefined; studySetId: string; deckId?: undefined }
  | { criteria?: undefined; studySetId?: undefined; deckId: string };

/**
 * Study mode, typically stored in Zustand along with StudySessionInput.
 * This determines the high-level intent (learn new things vs. review existing).
 * The `SessionType` (used internally by the hook) might be derived from this
 * for more specific queue handling (e.g., a 'unified' SessionType).
 */
export type StudySessionMode = 'learn' | 'review';


// REMOVED: SrsProgression - Not directly used by the core session types, can be app-specific if needed elsewhere.
// REMOVED: studyQueryCriteriaSchema and StudyQueryCriteria - These are authoritatively defined in lib/schema/study-query.schema.ts
// REMOVED: Redefinition of CardAnswerResult - It was identical to CardStateUpdateOutcome. Consolidating to CardStateUpdateOutcome.
// REMOVED: ReviewGrade - Should be imported from lib/srs.ts by consuming files.
```

