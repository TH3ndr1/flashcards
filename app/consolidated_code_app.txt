=== settings/page.tsx ===
// File: /app/settings/page.tsx
"use client";

import React, { useEffect, useState, useCallback, useRef } from "react"; // Keep imports from working version
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Label } from "@/components/ui/label";
import { ArrowLeft, Palette, RotateCcw } from "lucide-react";
import { useAuth } from "@/hooks/use-auth";
// --- Adjust imports for Palette ---
import { useSettings, DEFAULT_SETTINGS as PROVIDER_DEFAULT_SETTINGS } from "@/providers/settings-provider";
import type { Settings, FontOption, ThemePreference } from "@/providers/settings-provider"; // Now includes wordPaletteConfig
import { PREDEFINED_PALETTES, DEFAULT_PALETTE_CONFIG } from "@/lib/palettes"; // Import palette data
import type { Palette as PaletteType } from "@/lib/palettes"; // Import Palette type
// ---------------------------------
import { toast } from "sonner";
import { Switch } from "@/components/ui/switch";
import { Input } from "@/components/ui/input";
import { FONT_OPTIONS } from "@/lib/fonts";
import { Separator } from "@/components/ui/separator";
import { useTheme } from "next-themes"; // Import useTheme
// Debounce likely not needed for Selects, removing for simplicity unless proven necessary
// import { debounce } from "@/lib/utils";

// Constants (Keep all from previous working version)
const POS_OPTIONS: ReadonlyArray<string> = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other'] as const;
const GENDER_OPTIONS_LABELS: ReadonlyArray<string> = ['Male', 'Female', 'Neutral / Other'] as const; // Use refined label
const GENDER_KEYS: ReadonlyArray<string> = ['Male', 'Female', 'Default'] as const;
const GENDERED_POS: ReadonlyArray<string> = ['Noun', 'Adjective', 'Pronoun'] as const;
const BASIC_POS: ReadonlyArray<string> = ['Noun', 'Verb'] as const;
const ADVANCED_POS: ReadonlyArray<string> = ['Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other'] as const;

// Use local defaults based on provider defaults (now includes palette config)
const LOCAL_DEFAULT_SETTINGS: Settings = {
    ...PROVIDER_DEFAULT_SETTINGS, // Should have correct enable flags
    wordPaletteConfig: DEFAULT_PALETTE_CONFIG, // Use palette default
};


export default function SettingsPage() {
  // Hooks and State
  const { user, loading: authLoading } = useAuth();
  const router = useRouter();
  const { settings, updateSettings, loading: settingsLoading } = useSettings();
  const { setTheme } = useTheme(); // Get setTheme function

  // State initialization (Keep all existing state variables)
  const [appLanguage, setAppLanguage] = useState<string>(LOCAL_DEFAULT_SETTINGS.appLanguage);
  const [cardFont, setCardFont] = useState<FontOption>(LOCAL_DEFAULT_SETTINGS.cardFont);
  const [masteryThreshold, setMasteryThreshold] = useState<number>(LOCAL_DEFAULT_SETTINGS.masteryThreshold);
  const [languageDialects, setLanguageDialects] = useState<NonNullable<Settings['languageDialects']>>(
      LOCAL_DEFAULT_SETTINGS.languageDialects
  );
  const [showDifficulty, setShowDifficulty] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.showDifficulty);
  const [ttsEnabled, setTtsEnabled] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.ttsEnabled);
  const [colorOnlyNonNative, setColorOnlyNonNative] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.colorOnlyNonNative);
  const [enableBasicColorCoding, setEnableBasicColorCoding] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.enableBasicColorCoding);
  const [enableAdvancedColorCoding, setEnableAdvancedColorCoding] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.enableAdvancedColorCoding);
  // --- State uses Palette Config ---
  const [wordPaletteConfig, setWordPaletteConfig] = useState<NonNullable<Settings['wordPaletteConfig']>>(
      LOCAL_DEFAULT_SETTINGS.wordPaletteConfig
  );
  // --- Add state for new setting ---
  const [showDeckProgress, setShowDeckProgress] = useState<boolean>(LOCAL_DEFAULT_SETTINGS.showDeckProgress);
  const [themePreference, setThemePreference] = useState<ThemePreference>(LOCAL_DEFAULT_SETTINGS.themePreference);
  // --------------------------------

  // Effects (Keep original logic)
  useEffect(() => { /* Redirect */
    if (!authLoading && !user) {
        const callbackUrl = encodeURIComponent('/settings');
        router.push(`/login?callbackUrl=${callbackUrl}`);
    }
   }, [authLoading, user, router]);

  useEffect(() => { /* Load Settings */
     if (!settingsLoading && user) {
         const currentSettings = settings ?? LOCAL_DEFAULT_SETTINGS;
         setAppLanguage(currentSettings.appLanguage);
         setCardFont(currentSettings.cardFont);
         setMasteryThreshold(currentSettings.masteryThreshold);
         setShowDifficulty(currentSettings.showDifficulty);
         setTtsEnabled(currentSettings.ttsEnabled);
         setLanguageDialects(currentSettings.languageDialects);
         setColorOnlyNonNative(currentSettings.colorOnlyNonNative);
         setEnableBasicColorCoding(currentSettings.enableBasicColorCoding);
         setEnableAdvancedColorCoding(currentSettings.enableAdvancedColorCoding);
         // --- Load Palette Config ---
         setWordPaletteConfig({ ...DEFAULT_PALETTE_CONFIG, ...(currentSettings.wordPaletteConfig ?? {}) });
         // --- Load new setting ---
         setShowDeckProgress(currentSettings.showDeckProgress);
         setThemePreference(currentSettings.themePreference); // Load theme preference
         // --------------------------
     }
  }, [settings, settingsLoading, user]);

  // Handlers (Keep original useCallback structure)
  const handleSettingChange = useCallback(async (updates: Partial<Settings>) => {
    if (!user) { toast.error("Authentication Error"); return; }
    try {
        await updateSettings(updates);
        // toast.success("Settings updated"); // Only toast on explicit saves/resets perhaps
    } catch (error) {
        console.error("Failed to save settings:", error);
        toast.error("Error saving settings");
    }
   }, [user, updateSettings]); // Keep dependencies

  // Keep simple handlers wrapped in useCallback
  const handleLanguageChange = useCallback(async (value: string) => { setAppLanguage(value); await handleSettingChange({ appLanguage: value }); }, [handleSettingChange]);
  const handleFontChange = useCallback(async (value: FontOption) => { setCardFont(value); await handleSettingChange({ cardFont: value }); }, [handleSettingChange]);
  const handleMasteryThresholdChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
      const value = parseInt(e.target.value);
      if (!isNaN(value) && value >= 1 && value <= 10) {
          setMasteryThreshold(value);
          handleSettingChange({ masteryThreshold: value });
      } else if (e.target.value === '') {
          setMasteryThreshold(LOCAL_DEFAULT_SETTINGS.masteryThreshold);
      }
   }, [handleSettingChange]);
  const handleShowDifficultyChange = useCallback(async (checked: boolean) => { setShowDifficulty(checked); await handleSettingChange({ showDifficulty: checked }); }, [handleSettingChange]);
  const handleTtsEnabledChange = useCallback(async (checked: boolean) => { setTtsEnabled(checked); await handleSettingChange({ ttsEnabled: checked }); }, [handleSettingChange]);
  const handleDialectChange = useCallback((key: keyof NonNullable<Settings['languageDialects']>) => async (value: string) => {
      setLanguageDialects(prevDialects => {
          const newDialects = { ...prevDialects, [key]: value };
          handleSettingChange({ languageDialects: newDialects });
          return newDialects;
      });
   }, [handleSettingChange]);
  
   const handleColorOnlyNonNativeChange = useCallback(async (checked: boolean) => {
    setColorOnlyNonNative(checked);
    await handleSettingChange({ colorOnlyNonNative: checked });
  }, [handleSettingChange]);

  const handleEnableBasicChange = useCallback(async (checked: boolean) => { setEnableBasicColorCoding(checked); await handleSettingChange({ enableBasicColorCoding: checked }); }, [handleSettingChange]);
  const handleEnableAdvancedChange = useCallback(async (checked: boolean) => { setEnableAdvancedColorCoding(checked); await handleSettingChange({ enableAdvancedColorCoding: checked }); }, [handleSettingChange]);

  // --- NEW Palette Change Handler (Replaces handleColorChange, no debounce needed) ---
  const handlePaletteChange = useCallback((pos: string, genderKey: string) => async (selectedPaletteId: string) => {
      setWordPaletteConfig(prevConfig => {
           const currentConfig = prevConfig ?? DEFAULT_PALETTE_CONFIG;
           // Deep copy might be safer if config structure gets complex
           const newConfig = JSON.parse(JSON.stringify(currentConfig));
           if (!newConfig[pos]) newConfig[pos] = {};
           newConfig[pos][genderKey] = selectedPaletteId;
           // Save immediately
           handleSettingChange({ wordPaletteConfig: newConfig });
           return newConfig;
      });
      // Optional feedback toast
      // toast.info(`${pos} (${genderKey}) palette set to ${selectedPaletteId}`);
  }, [handleSettingChange]);
  // ---------------------------------------------------------------------------------

  // --- UPDATED Reset Handler ---
  const handleResetColors = useCallback(async () => {
      const defaultPalettes = { ...DEFAULT_PALETTE_CONFIG };
      setWordPaletteConfig(defaultPalettes); // Reset local state
      await handleSettingChange({ wordPaletteConfig: defaultPalettes }); // Save defaults
      toast.info("Color palette settings reset to default.");
  }, [handleSettingChange]);
  // ---------------------------

  // --- Add handler for new setting ---
  const handleShowDeckProgressChange = useCallback(async (checked: boolean) => {
      setShowDeckProgress(checked);
      await handleSettingChange({ showDeckProgress: checked });
  }, [handleSettingChange]);
  // -----------------------------------

  // --- Updated handler for new theme setting ---
  const handleThemeChange = useCallback(async (value: ThemePreference) => {
      // 1. Update local state
      setThemePreference(value);
      // 2. Apply theme using next-themes
      setTheme(value);
      // 3. Save preference to database
      await handleSettingChange({ themePreference: value });
      // 4. Notify user
      toast.info(`Theme set to ${value}.`);
  }, [handleSettingChange, setTheme]); // Added setTheme to dependencies
  // --------------------------------------

  // Loading/User checks
  if (settingsLoading || authLoading) { return <div className="container mx-auto p-8">Loading Settings...</div>; }
  if (!user) { return <div className="container mx-auto p-8">Redirecting to login...</div>; }

  // --- Render ---
  return (
    <div className="container mx-auto py-8"> {/* Keep Original Container */}
      <div className="flex items-center justify-between mb-8"> {/* Keep Original Header */}
        <h1 className="text-3xl font-bold">Settings</h1>
        <Button variant="outline" onClick={() => router.back()}> <ArrowLeft className="mr-2 h-4 w-4" /> Back </Button>
      </div>
      <div className="grid gap-6"> {/* Keep Original Grid */}

        {/* --- Card Settings Card (Renamed) --- */}
        <Card>
            <CardHeader>
                <CardTitle>Card Settings</CardTitle> {/* Renamed Title */}
                <CardDescription>Configure card appearance and learning behavior</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                <div className="grid gap-4">
                    {/* Language */}
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="appLanguage" className="text-right">Native Language</Label>
                        <Select value={appLanguage} onValueChange={handleLanguageChange}>
                            <SelectTrigger id="appLanguage" className="col-span-3"><SelectValue placeholder="Select language" /></SelectTrigger>
                            <SelectContent>
                                <SelectItem value="en">English</SelectItem>
                                <SelectItem value="nl">Dutch</SelectItem>
                                <SelectItem value="fr">French</SelectItem>
                                <SelectItem value="de">German</SelectItem>
                                <SelectItem value="es">Spanish</SelectItem>
                                <SelectItem value="it">Italian</SelectItem>
                            </SelectContent>
                        </Select>
                    </div>
                    {/* Font Selection */}
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="cardFont" className="text-right">Card Font</Label>
                        <Select value={cardFont} onValueChange={handleFontChange}>
                            <SelectTrigger id="cardFont" className="col-span-3"><SelectValue placeholder="Select font" /></SelectTrigger>
                            <SelectContent>
                                {(Object.entries(FONT_OPTIONS) as [FontOption, { name: string; [key: string]: any }][]).map(([key, font]) => (
                                <SelectItem key={key} value={key} style={{ fontFamily: key === 'default' ? 'var(--font-sans)' : key === 'opendyslexic' ? "'OpenDyslexic', system-ui, sans-serif" : "'Atkinson Hyperlegible', system-ui, sans-serif" }} > {font.name} </SelectItem>
                                ))}
                            </SelectContent>
                        </Select>
                    </div>
                    {/* Mastery Threshold */}
                    <div className="grid grid-cols-4 items-center gap-4">
                        <Label htmlFor="masteryThreshold" className="text-right">Mastery Threshold</Label>
                        <div className="col-span-3 flex items-center gap-4">
                        <Input id="masteryThreshold" type="number" min={1} max={10} value={masteryThreshold} onChange={handleMasteryThresholdChange} className="w-24" />
                        <span className="text-sm text-muted-foreground">Correct answers needed to master (1-10)</span>
                        </div>
                    </div>
                </div>
                {/* Show Rating Buttons */}
                <div className="flex items-center justify-between p-4 border rounded-lg">
                    <div>
                        <h3 className="font-medium">Show Rating Buttons</h3>
                        <p className="text-sm text-muted-foreground">Display Again/Hard/Good/Easy buttons</p>
                    </div>
                    <Switch checked={showDifficulty} onCheckedChange={handleShowDifficultyChange} />
                </div>
            </CardContent>
        </Card>
        {/* --- End Card Settings Card --- */}

        {/* --- Appearance Settings Card (New) --- */}
        <Card>
            <CardHeader>
                <CardTitle>Appearance Settings</CardTitle>
                <CardDescription>Adjust the look and feel of the application</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                {/* Theme Preference */}
                <div className="grid grid-cols-4 items-center gap-4">
                    <Label htmlFor="themePreference" className="text-right">Theme</Label>
                    <Select value={themePreference} onValueChange={handleThemeChange}>
                        <SelectTrigger id="themePreference" className="col-span-3">
                            <SelectValue placeholder="Select theme..." />
                        </SelectTrigger>
                        <SelectContent>
                            <SelectItem value="light">Light</SelectItem>
                            <SelectItem value="dark">Dark</SelectItem>
                            <SelectItem value="system">System Default</SelectItem>
                        </SelectContent>
                    </Select>
                </div>
                <Separator />
                {/* Show Deck Progress Toggle (Moved) */}
                <div className="flex items-center justify-between">
                    <div>
                        <h3 className="font-medium">Show Deck Progress</h3>
                        <p className="text-sm text-muted-foreground">Display progress bars on deck cards</p>
                    </div>
                    <Switch checked={showDeckProgress} onCheckedChange={handleShowDeckProgressChange} />
                </div>
            </CardContent>
        </Card>

        {/* --- Speech Settings Card - RESTORED FULL CONTENT --- */}
        <Card>
            <CardHeader>
                <CardTitle>Speech Settings</CardTitle>
                <CardDescription>Configure text-to-speech and language preferences</CardDescription>
            </CardHeader>
            <CardContent className="space-y-6">
                {/* TTS Toggle */}
                <div className="flex items-center justify-between p-4 border rounded-lg">
                    <div>
                        <h3 className="font-medium">Text-to-Speech</h3>
                        <p className="text-sm text-muted-foreground">Enable audio playback for cards</p>
                    </div>
                    <Switch checked={ttsEnabled} onCheckedChange={handleTtsEnabledChange}/>
                </div>
                {/* Dialect Selectors */}
                {ttsEnabled && (
                <>
                    <Separator />
                    <div className="grid gap-4 pt-4">
                        {(Object.keys(languageDialects) as Array<keyof typeof languageDialects>).map((langKey) => (
                        <div key={langKey} className="grid grid-cols-4 items-center gap-4">
                            <Label htmlFor={`dialect-${langKey}`} className="text-right capitalize">{ { en: 'English', nl: 'Dutch', fr: 'French', de: 'German', es: 'Spanish', it: 'Italian' }[langKey] ?? langKey }</Label>
                            <Select value={languageDialects[langKey] ?? ''} onValueChange={handleDialectChange(langKey)}>
                                <SelectTrigger id={`dialect-${langKey}`} className="col-span-3"><SelectValue /></SelectTrigger>
                                <SelectContent>
                                    {langKey === 'en' && <> <SelectItem value="en-GB">English (UK)</SelectItem> <SelectItem value="en-US">English (US)</SelectItem> </>}
                                    {langKey === 'nl' && <> <SelectItem value="nl-NL">Dutch (NL)</SelectItem> <SelectItem value="nl-BE">Dutch (BE)</SelectItem> </>}
                                    {langKey === 'fr' && <> <SelectItem value="fr-FR">French (FR)</SelectItem> <SelectItem value="fr-BE">French (BE)</SelectItem> <SelectItem value="fr-CH">French (CH)</SelectItem> </>}
                                    {langKey === 'de' && <> <SelectItem value="de-DE">German (DE)</SelectItem> <SelectItem value="de-AT">German (AT)</SelectItem> <SelectItem value="de-CH">German (CH)</SelectItem> </>}
                                    {langKey === 'es' && <> <SelectItem value="es-ES">Spanish (ES)</SelectItem> </>}
                                    {langKey === 'it' && <> <SelectItem value="it-IT">Italian (IT)</SelectItem> <SelectItem value="it-CH">Italian (CH)</SelectItem> </>}
                                </SelectContent>
                            </Select>
                        </div>
                        ))}
                    </div>
                </>
                )}
            </CardContent>
        </Card>
        {/* --- End Speech Settings Card --- */}

        {/* --- Word Color Coding Card (MODIFIED Content) --- */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2"><Palette className="h-5 w-5" /> Word Color Coding</CardTitle>
            <CardDescription>Assign pre-defined color palettes to words based on grammar.</CardDescription>
          </CardHeader>
          <CardContent className="space-y-6">
            
             {/* Section 1: Basic */}
             <div className="border rounded-lg p-4 space-y-4">
                <div className="flex items-center justify-between">
                     <div> <h3 className="font-medium">Basic Color Coding (Nouns & Verbs)</h3> <p className="text-sm text-muted-foreground">Highlight common word types.</p> </div>
                     <Switch checked={enableBasicColorCoding} onCheckedChange={handleEnableBasicChange}/>
                </div>
                {enableBasicColorCoding && (
                    <div className="pl-2 space-y-4">
                        {BASIC_POS.map(pos => (
                            <div key={pos}>
                                <Label className="font-semibold text-base mb-3 block">{pos}</Label>
                                <div className={`grid grid-cols-1 ${pos === 'Noun' ? 'md:grid-cols-3' : 'md:grid-cols-1'} gap-x-6 gap-y-4 items-center`}>
                                    {(pos === 'Noun' ? GENDER_KEYS : ['Default']).map((genderKey, index) => (
                                        <div key={genderKey} className="flex flex-col sm:flex-row sm:items-center gap-2">
                                            <Label htmlFor={`palette-${pos}-${genderKey}`} className="text-sm w-full sm:w-24 text-left sm:text-right flex-shrink-0">
                                                {pos === 'Noun' ? GENDER_OPTIONS_LABELS[index] : 'Default Color'}
                                            </Label>
                                            {/* === Select for Palettes === */}
                                            <Select
                                                value={wordPaletteConfig?.[pos]?.[genderKey] ?? 'default'}
                                                onValueChange={handlePaletteChange(pos, genderKey)}
                                            >
                                                <SelectTrigger id={`palette-${pos}-${genderKey}`} className="flex-grow">
                                                    <SelectValue placeholder="Select palette..." />
                                                </SelectTrigger>
                                                <SelectContent>
                                                    {PREDEFINED_PALETTES.map((palette) => (
                                                        <SelectItem key={palette.id} value={palette.id}>
                                                            <div className="flex items-center gap-2">
                                                                <span style={{ backgroundColor: palette.light.background, border: '1px solid #ccc' }} className="inline-block w-4 h-4 rounded-sm flex-shrink-0"></span>
                                                                {palette.name}
                                                            </div>
                                                        </SelectItem>
                                                    ))}
                                                </SelectContent>
                                            </Select>
                                            {/* ============================ */}
                                        </div>
                                    ))}
                                </div>
                            </div>
                        ))}
                    </div>
                )}
             </div>

             {/* Section 2: Advanced */}
             <div className="border rounded-lg p-4 space-y-4">
                 <div className="flex items-center justify-between">
                    <div> <h3 className="font-medium">Advanced Color Coding</h3> <p className="text-sm text-muted-foreground">Configure colors for other word types.</p> </div>
                    <Switch checked={enableAdvancedColorCoding} onCheckedChange={handleEnableAdvancedChange}/>
                 </div>
                 {enableAdvancedColorCoding && (
                     <div className="pl-2 space-y-4">
                        {ADVANCED_POS.map(pos => {
                            const isGendered = GENDERED_POS.includes(pos);
                            const relevantGenders = isGendered ? GENDER_KEYS : ['Default'];
                            const relevantLabels = isGendered ? GENDER_OPTIONS_LABELS : ['Neutral / Other'];
                            return (
                                <div key={pos}>
                                    <Label className="font-semibold text-base mb-3 block">{pos}</Label>
                                    <div className={`grid grid-cols-1 ${isGendered ? 'md:grid-cols-3' : 'md:grid-cols-1'} gap-x-6 gap-y-4 items-center`}>
                                        {relevantGenders.map((genderKey, index) => (
                                            <div key={genderKey} className="flex flex-col sm:flex-row sm:items-center gap-2">
                                                <Label htmlFor={`palette-${pos}-${genderKey}`} className="text-sm w-full sm:w-24 text-left sm:text-right flex-shrink-0">
                                                    {relevantLabels[index]}
                                                </Label>
                                                 {/* === Select for Palettes === */}
                                                <Select
                                                    value={wordPaletteConfig?.[pos]?.[genderKey] ?? 'default'}
                                                    onValueChange={handlePaletteChange(pos, genderKey)}
                                                >
                                                    <SelectTrigger id={`palette-${pos}-${genderKey}`} className="flex-grow">
                                                        <SelectValue placeholder="Select palette..." />
                                                    </SelectTrigger>
                                                    <SelectContent>
                                                        {PREDEFINED_PALETTES.map((palette) => (
                                                            <SelectItem key={palette.id} value={palette.id}>
                                                                 <div className="flex items-center gap-2">
                                                                    <span style={{ backgroundColor: palette.light.background, border: '1px solid #ccc' }} className="inline-block w-4 h-4 rounded-sm flex-shrink-0"></span>
                                                                    {palette.name}
                                                                </div>
                                                            </SelectItem>
                                                        ))}
                                                    </SelectContent>
                                                </Select>
                                                 {/* ============================ */}
                                            </div>
                                        ))}
                                    </div>
                                </div>
                            );
                        })}
                     </div>
                 )}
             </div>
                
              {/* Reset Button */}
             <div className="flex justify-end pt-4">
                 <Button variant="outline" size="sm" onClick={handleResetColors}>
                     <RotateCcw className="h-4 w-4 mr-2" />
                     Reset Palette Defaults
                 </Button>
             </div>
             {/* --- NEW Toggle --- */}
            <div className="flex items-center justify-between p-4 border rounded-lg">
                          <div>
                              <h3 className="font-medium">Apply Only to Non-Native Language</h3>
                              <p className="text-sm text-muted-foreground">
                                  Only color words not matching your app language ('{settings?.appLanguage || 'N/A'}').
                              </p>
                          </div>
                          <Switch
                              checked={colorOnlyNonNative}
                              onCheckedChange={handleColorOnlyNonNativeChange}
                              aria-labelledby="color-non-native-label"
                          />
                            <span id="color-non-native-label" className="sr-only">Apply color coding only to non-native language words</span>
                      </div>
                      {/* ---------------- */}
          </CardContent>
        </Card>
        {/* --- End Word Color Coding Card --- */}

      </div> {/* End main grid */}
    </div> // End container
  );
}
=== study/sets/[studySetId]/edit/page.tsx ===
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { StudySetBuilder } from '@/components/study/StudySetBuilder'; // Adjust path if needed
import { getStudySet, updateStudySet, deleteStudySet } from '@/lib/actions/studySetActions'; // Import actions
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import type { Tables } from '@/types/database'; // Import Tables
import { toast } from 'sonner';
import { Button } from '@/components/ui/button';
import Link from 'next/link';
import { Loader2 as IconLoader, AlertTriangle, Trash2 } from 'lucide-react';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
  AlertDialogTrigger,
} from "@/components/ui/alert-dialog";

// Define the DbStudySet type using Tables
type DbStudySet = Tables<'study_sets'>;

// Define the type for the data passed to the onSave callback
interface StudySetSaveData {
    name: string;
    description: string | null;
    criteria: StudyQueryCriteria;
}

export default function EditStudySetPage() {
    const router = useRouter();
    const params = useParams();
    const studySetId = params.studySetId as string; // Get ID from route params

    const [initialData, setInitialData] = useState<DbStudySet | null>(null);
    const [isLoading, setIsLoading] = useState(true); // Loading initial data
    const [isSaving, setIsSaving] = useState(false); // Saving updates
    const [isDeleting, setIsDeleting] = useState(false); // Added deleting state
    const [error, setError] = useState<string | null>(null);

    // Fetch initial study set data
    useEffect(() => {
        if (!studySetId) {
            setError("Study Set ID not found in URL.");
            setIsLoading(false);
            return;
        }

        const fetchSetData = async () => {
            setIsLoading(true);
            setError(null);
            console.log(`[EditStudySetPage] Fetching data for set ID: ${studySetId}`);
            try {
                const result = await getStudySet(studySetId);
                if (result.error) {
                    setError(result.error);
                    toast.error("Failed to load study set", { description: result.error });
                    // Optionally redirect if not found/authorized
                    // router.replace('/study/sets'); 
                } else if (result.data) {
                    setInitialData(result.data);
                    console.log("[EditStudySetPage] Initial data loaded:", result.data);
                } else {
                     // Handle case where data is null but no specific error (e.g., not found)
                     setError("Study set not found or you do not have permission to edit it.");
                     toast.error("Study set not found.");
                     // Optionally redirect
                     // router.replace('/study/sets');
                }
            } catch (err) {
                console.error(`[EditStudySetPage] Unexpected error fetching study set:`, err);
                const message = err instanceof Error ? err.message : "An unexpected error occurred.";
                setError(message);
                toast.error("Error loading study set", { description: message });
            } finally {
                setIsLoading(false);
            }
        };

        fetchSetData();
    }, [studySetId]); // Removed router dependency as it doesn't change

    // Handle saving updates
    const handleUpdateStudySet = useCallback(async (data: StudySetSaveData) => {
        if (!studySetId) {
            toast.error("Cannot save: Study Set ID is missing.");
            return;
        }
        setIsSaving(true);
        console.log(`[EditStudySetPage] Updating study set ${studySetId}:`, data);
        try {
            const result = await updateStudySet(studySetId, data); // Pass ID and updated data
            if (result.error) {
                toast.error("Failed to update study set", { description: result.error });
            } else {
                toast.success(`Study Set "${result.data?.name}" updated successfully!`);
                // Optionally navigate back or refresh data
                router.push('/study/sets'); // Navigate back to list on success
                 // Or maybe just refresh initial data if staying on page:
                 // setInitialData(result.data); // Update local state with saved data
            }
        } catch (err) {
            console.error(`[EditStudySetPage] Unexpected error updating study set:`, err);
            toast.error("An unexpected error occurred while saving.");
        } finally {
            setIsSaving(false);
        }
    }, [studySetId, router]);

    // Added handleDelete function
    const handleDelete = useCallback(async () => {
        if (!studySetId || !initialData) {
            toast.error("Cannot delete: Study Set data missing.");
            return;
        }
        setIsDeleting(true);
        const setName = initialData.name;
        console.log(`[EditStudySetPage] Deleting study set: ${setName} (${studySetId})`);
        try {
            const result = await deleteStudySet(studySetId);
            if (result.error) {
                toast.error(`Failed to delete "${setName}"`, { description: result.error });
            } else {
                toast.success(`Study Set "${setName}" deleted.`);
                router.push('/study/sets'); // Navigate back to list on success
            }
        } catch (err) {
            console.error(`[EditStudySetPage] Unexpected error deleting study set:`, err);
            toast.error("An unexpected error occurred while deleting.");
        } finally {
            setIsDeleting(false); // Ensure state is reset even on error
        }
    }, [studySetId, initialData, router]);

    // --- Render Logic ---

    if (isLoading) {
        return (
            <div className="flex justify-center items-center h-screen">
                <IconLoader className="h-8 w-8 animate-spin mr-2" /> Loading study set...
            </div>
        );
    }

    if (error) {
         return (
            <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen">
                <Alert variant="destructive" className="max-w-md">
                  <AlertTriangle className="h-4 w-4" />
                  <AlertTitle>Error Loading Study Set</AlertTitle>
                  <AlertDescription>{error}</AlertDescription>
                </Alert>
                <Button onClick={() => router.push('/study/sets')} className="mt-4" variant="outline">
                    Back to Playlists
                </Button>
            </div>
        );
    }

    if (!initialData) {
        // Should ideally be covered by error state, but acts as a final fallback
        return <div className="container mx-auto p-4">Study set data could not be loaded.</div>;
    }

    return (
        <div className="py-4 px-4 md:p-6 max-w-4xl mx-auto">
             <div className="flex justify-between items-center mb-6">
                <h1 className="text-2xl font-bold">Edit Smart Playlist</h1>
                <Button variant="outline" asChild>
                    <Link href="/study/sets">Cancel</Link>
                </Button>
             </div>

            <StudySetBuilder
                // Pass the fetched data, ensuring criteria is included
                initialData={{
                    id: initialData.id,
                    name: initialData.name,
                    description: initialData.description,
                    criteria: initialData.query_criteria as StudyQueryCriteria, // Cast criteria
                }}
                onSave={handleUpdateStudySet}
                isSaving={isSaving}
            />

            {/* Added Delete Section */}
            <div className="mt-8 pt-6 border-t border-dashed border-destructive/50">
                <h3 className="text-lg font-semibold text-destructive mb-2">Danger Zone</h3>
                <p className="text-sm text-muted-foreground mb-4">Deleting this playlist cannot be undone.</p>
                <AlertDialog>
                  <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isDeleting || isSaving}>
                       <Trash2 className="mr-2 h-4 w-4" /> Delete Playlist
                    </Button>
                  </AlertDialogTrigger>
                  <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Delete "{initialData.name}"?</AlertDialogTitle>
                        <AlertDialogDescription>This action cannot be undone. This will permanently delete the smart playlist definition, but will not delete any actual cards.</AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                       <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
                       <AlertDialogAction onClick={handleDelete} disabled={isDeleting} className="bg-destructive hover:bg-destructive/90">
                            {isDeleting ? <IconLoader className="h-4 w-4 animate-spin mr-2"/> : null} Delete
                       </AlertDialogAction>
                     </AlertDialogFooter>
                   </AlertDialogContent>
                </AlertDialog>
            </div>
        </div>
    );
} 
=== study/sets/new/page.tsx ===
'use client';

import React, { useState, useCallback } from 'react';
import { useRouter } from 'next/navigation';
import { StudySetBuilder } from '@/components/study/StudySetBuilder'; // Adjust path if needed
import { createStudySet } from '@/lib/actions/studySetActions'; // Import the create action
import type { StudyQueryCriteria } from '@/lib/schema/study-query.schema';
import { toast } from 'sonner';
import { Button } from '@/components/ui/button'; // For potential cancel button
import Link from 'next/link'; // For linking back

export default function NewStudySetPage() {
  const router = useRouter();
  const [isSaving, setIsSaving] = useState(false);

  const handleSaveStudySet = useCallback(async (data: {
    name: string;
    description: string | null;
    criteria: StudyQueryCriteria;
  }) => {
    setIsSaving(true);
    console.log("[NewStudySetPage] Saving new study set:", data);
    try {
      const result = await createStudySet(data);
      if (result.error) {
        toast.error("Failed to create study set", { description: result.error });
      } else {
        toast.success(`Study Set "${result.data?.name}" created successfully!`);
        // Navigate back to the list page (adjust path if different)
        router.push('/study/sets'); 
        // Optional: revalidate list page path if needed, though action might handle it
        // revalidatePath('/study/sets'); 
      }
    } catch (err) {
      console.error("[NewStudySetPage] Unexpected error saving study set:", err);
      toast.error("An unexpected error occurred while saving.");
    } finally {
      setIsSaving(false);
    }
  }, [router]);

  return (
    <div className="container mx-auto p-4 md:p-6 max-w-4xl">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Create New Smart Playlist</h1>
        <Button variant="outline" asChild>
          <Link href="/study/sets">Cancel</Link>
        </Button>
      </div>

      <StudySetBuilder 
        onSave={handleSaveStudySet} 
        isSaving={isSaving} 
        // No initialData is passed for creating a new set
      />
    </div>
  );
} 
=== study/sets/page.tsx ===
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getUserStudySets } from '@/lib/actions/studySetActions';
import { StudySetListClient } from '../../../components/study/StudySetListClient';

/**
 * Study Sets listing page (Smart Playlists).
 * 
 * This is a Server Component that pre-fetches all study sets server-side
 * before rendering the page, eliminating client-side data fetching delays.
 * 
 * @returns {Promise<JSX.Element>} The Study Sets page with pre-fetched data
 */
export default async function ListStudySetsPage() {
  // Check authentication server-side
  const supabase = createServerClient();
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  if (!session || authError) {
    redirect('/login');
  }

  // Pre-fetch all study sets in a single server-side request
  const { data: studySets, error: fetchError } = await getUserStudySets();

  const hasErrors = Boolean(fetchError);

  return (
    <div className="py-4 px-4 md:p-6">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Your Smart Playlists</h1>
        <Button asChild>
          <Link href="/study/sets/new">Create New Playlist</Link>
        </Button>
      </div>
      <StudySetListClient initialData={studySets || []} />
    </div>
  );
} 
=== study/select/page.tsx ===
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getDecks } from '@/lib/actions/deckActions';
import { getUserStudySets } from '@/lib/actions/studySetActions';
import { PageHeading } from '@/components/ui/page-heading';
import { StudySelectClient } from '../../../components/study/StudySelectClient';
import type { Tables } from '@/types/database';

/**
 * Study Selection Page
 * 
 * This is a Server Component that pre-fetches both decks and study sets data
 * server-side before rendering the page, eliminating client-side data fetching delays.
 * 
 * @returns {Promise<JSX.Element>} The Study Selection page with pre-fetched data
 */
export default async function StudySelectPage() {
  // Check authentication server-side
  const supabase = createServerClient();
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  if (!session) {
    redirect("/login");
  }

  // Pre-fetch both decks and study sets in parallel server-side
  const [decksResult, studySetsResult] = await Promise.all([
    getDecks(),
    getUserStudySets()
  ]);

  const hasErrors = Boolean(decksResult.error || studySetsResult.error);

  // Type for Deck with SRS counts from StudySelectClient
  type DeckWithCounts = Tables<'decks'> & {
    new_count: number;
    learning_count: number;
    young_count: number;
    mature_count: number;
  };

  return (
    <div className="container py-6">
      <PageHeading 
        title="Choose Study Material"
        description="Select what you want to review" 
        backHref="/"
      />
      <StudySelectClient 
        initialDecks={(decksResult.data || []) as unknown as DeckWithCounts[]} 
        initialStudySets={studySetsResult.data || []}
        hasErrors={hasErrors}
      />
    </div>
  );
} 
=== study/session/page.tsx ===
// app/study/session/page.tsx
'use client';

import React, { useEffect, useState, useMemo, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { useStudySessionStore } from '@/store/studySessionStore'; // Import store
import { useStudySession } from '@/hooks/useStudySession'; // Import the main hook
import { StudyFlashcardView } from '@/components/study-flashcard-view'; // Use named import for StudyFlashcardView
import { Loader2 as IconLoader } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Progress } from "@/components/ui/progress"; // For progress display
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert"
import { Terminal } from "lucide-react"
import { toast } from 'sonner'; // Added toast import
import { useSettings } from '@/providers/settings-provider'; // Import useSettings
import { useTTS } from "@/hooks/use-tts"; // Import useTTS here
import type { Tables } from '@/types/database'; // Import Tables type

// Add proper type for the card including joined deck data
type StudyCard = Tables<'cards'> & {
  decks?: {
    primary_language: string;
    secondary_language: string;
  } | null;
};

// Assuming ReviewGrade is defined or imported elsewhere
type ReviewGrade = 1 | 2 | 3 | 4;

const FLIP_DURATION_MS = 300; // Match CSS animation duration (adjust if needed)

// Add TypeScript declaration for window property
declare global {
  interface Window {
    ttsErrorShown?: boolean;
  }
}

export default function StudySessionPage() {
  const router = useRouter();
  
  const currentInput = useStudySessionStore((state) => state.currentInput);
  const currentMode = useStudySessionStore((state) => state.currentMode);

  const [isInitialized, setIsInitialized] = useState(false);

  const { settings, loading: isLoadingSettings } = useSettings(); 

  // Get flip state and action FROM the hook
  const { 
    currentCard, isInitializing, error, studyMode, 
    isComplete, totalCardsInSession, currentCardNumber, initialSelectionCount, 
    answerCard, sessionResults, isProcessingAnswer, 
    isFlipped, onFlip // Use state/action from hook
  } = useStudySession({ initialInput: currentInput, initialMode: currentMode });

  // Still need local transition state for visual flip animation disabling
  const [isTransitioningVisual, setIsTransitioningVisual] = useState(false);

  const { speak, ttsState } = useTTS({});
  const isLoadingPage = isInitializing || isLoadingSettings || !isInitialized;
  const prevCardIdRef = useRef<string | undefined | null>(null);

  // Redirect if parameters aren't set after initial client-side check
  useEffect(() => {
    if (!isInitialized) {
        setIsInitialized(true);
        return; // Wait for initialization before checking
    }
    // Add short delay to allow store state to potentially propagate on fast refreshes
    const checkTimer = setTimeout(() => {
        if (!currentInput || !currentMode) {
          console.warn("Study parameters not set, redirecting.");
          toast.warning("No study session active.", { description: "Redirecting to selection..."});
          router.replace('/study/select'); // Redirect to selection page
        }
    }, 50); // 50ms delay
    return () => clearTimeout(checkTimer);
  }, [isInitialized, currentInput, currentMode, router]);

  // Reset VISUAL transition state when card changes
  useEffect(() => {
    if (currentCard?.id) {
      setIsTransitioningVisual(false);
    }
    // Keep ref update here, it runs before TTS effect
    prevCardIdRef.current = currentCard?.id;
  }, [currentCard?.id]);

  // --- TTS Trigger Effect (Refined Logic) --- 
  useEffect(() => {
      if (!currentCard || ttsState === 'loading' || !settings?.ttsEnabled || isLoadingPage) return;

      const cardIdHasChanged = prevCardIdRef.current !== currentCard.id;
      prevCardIdRef.current = currentCard.id;
      
      // Debug language dialects in settings
      console.log('[Study Session] Language dialects in settings:', settings?.languageDialects);
      
      let textToSpeak: string | null | undefined = null;
      let langToUse: string | null = null;

      // Safe casting of currentCard to StudyCard type
      const studyCard = currentCard as StudyCard;

      // Determine what to speak based on change or flip state
      if (cardIdHasChanged || !isFlipped) { 
          textToSpeak = studyCard.question;
          // Safely access deck properties
          langToUse = studyCard.decks?.primary_language ?? 'en-US';
          console.log('[Study Session] Speaking question, original language:', langToUse);
      } else if (isFlipped) { 
          textToSpeak = studyCard.answer;
          // Safely access deck properties
          langToUse = studyCard.decks?.secondary_language ?? 
                      studyCard.decks?.primary_language ?? 
                      'en-US';
          console.log('[Study Session] Speaking answer, original language:', langToUse);
      }

      // Ensure we have a proper language code with dialect - direct fix
      if (textToSpeak && langToUse) {
          // Map language code directly at the point of use
          // This ensures the correct language code is used even if the hook has issues
          console.log(`[Study Session] Calling speak() with language: ${langToUse}`);
          
          speak(textToSpeak, langToUse).catch(error => {
              console.error("Failed to speak text:", error);
              // Only show TTS errors once per session to avoid repeated notifications
              if (!window.ttsErrorShown) {
                  toast.error("Text-to-speech error", { 
                      description: "TTS functionality is unavailable. Check your settings.",
                      duration: 5000
                  });
                  window.ttsErrorShown = true;
              }
          });
      }
       
  // Minimal dependencies: card ID, flip state, TTS enabled setting, and session loading state.
  }, [currentCard?.id, isFlipped, settings?.ttsEnabled, isLoadingPage, speak]); 

  // --- Callbacks ---
  const handleFlip = useCallback(() => {
    if (isTransitioningVisual) return; // Prevent double-click during animation
    setIsTransitioningVisual(true);
    onFlip(); // Call the hook's flip action
    const timer = setTimeout(() => {
      setIsTransitioningVisual(false);
    }, FLIP_DURATION_MS);
    return () => clearTimeout(timer);
  }, [isTransitioningVisual, onFlip]); // Depend on local state and hook action

  // --- Render Logic ---

  // Use isLoadingPage for the main spinner
  if (isLoadingPage) { 
     return (
        <div className="flex flex-col justify-center items-center min-h-screen">
            <IconLoader className="h-10 w-10 animate-spin mb-4" /> 
            <p className="text-muted-foreground">Loading session...</p> 
        </div>
    );
  }

  // Error State
  if (error) {
     return (
        <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen">
            <Alert variant="destructive" className="max-w-md">
              <Terminal className="h-4 w-4" />
              <AlertTitle>Error Loading Session</AlertTitle>
              <AlertDescription>
                {error}
              </AlertDescription>
            </Alert>
            <Button onClick={() => router.push('/study/select')} className="mt-4">Go Back</Button>
        </div>
    );
  }

  // Completion State - Updated with Results
  if (isComplete) {
     const noCardsFoundInitially = initialSelectionCount === 0;
     const sessionHadCards = initialSelectionCount > 0;

     let title = "Session Complete!";
     let description = "Well done!"; 

     if (noCardsFoundInitially) {
         title = "No Cards Found";
         description = "There were no cards matching your selection criteria.";
     } else if (sessionHadCards) { 
         // Extract results
         const { correct = 0, incorrect = 0, completedInSession = 0 } = sessionResults ?? {};
         const totalAnswered = correct + incorrect;
         const accuracy = totalAnswered > 0 ? Math.round((correct / totalAnswered) * 100) : 0;

         if (studyMode === 'review') {
             title = " Review Complete! ";
             // initialSelectionCount might differ from completedInSession if user stops early?
             // Use completedInSession for number reviewed in this specific session.
             description = `You reviewed ${completedInSession} card${completedInSession === 1 ? '' : 's'}. Correct: ${correct}, Incorrect: ${incorrect} (${accuracy}% accuracy).`;
         } else { // Learn mode complete
             title = " Learn Session Complete! ";
             description = `You learned ${completedInSession} card${completedInSession === 1 ? '' : 's'} in this session! Correct: ${correct}, Incorrect: ${incorrect}. Great work!`;
         }
     } // Handle initialSelectionCount === -1 (init error) if needed
     
     return (
        <div className="container mx-auto p-4 flex flex-col items-center justify-center min-h-screen text-center">
            <h1 className="text-3xl font-bold mb-4">{title}</h1>
            <p className="text-lg text-muted-foreground mb-6">{description}</p>
             <Button onClick={() => router.push('/study/select')} className="mt-4">Start New Session</Button>
        </div>
    );
  }

  // Check if currentCard is ready (it might be null briefly even if not loading/complete)
  if (!currentCard) {
    return (
        <div className="flex flex-col justify-center items-center min-h-screen">
            <p className="text-muted-foreground">Error: Could not load current card.</p>
            <Button onClick={() => router.push('/study/select')} className="mt-4">Go Back</Button>
        </div>
    );
  }

  // Active Study State
  const progressValue = totalCardsInSession > 0 ? (currentCardNumber / totalCardsInSession) * 100 : 0;
  const progressText = `Card ${currentCardNumber} / ${totalCardsInSession}`;

  return (
    <div className="container mx-auto p-4 md:p-6 flex flex-col min-h-screen">
      {/* Header with Mode and Progress */}
      <div className="mb-4">
        <h1 className="text-xl font-semibold capitalize">Study Mode: {studyMode}</h1>
        {totalCardsInSession > 0 && (
            <div className="flex items-center gap-2 mt-2">
                <Progress value={progressValue} className="w-full h-2" />
                <span className="text-sm text-muted-foreground whitespace-nowrap">
                    {progressText}
                </span>
            </div>
        )}
      </div>

      {/* Main Study View Area */}
      <div className="flex-grow flex items-center justify-center">
          {/* Render StudyFlashcardView only if currentCard is valid */}
          <StudyFlashcardView
            card={currentCard} // Pass DbCard directly
            onAnswer={answerCard}
            // Pass real settings and flip state/handler
            settings={settings}
            isFlipped={isFlipped}
            onFlip={handleFlip}
            // Pass derived progress text
            progressText={progressText}
            // Pass the transition state
            isTransitioning={isTransitioningVisual || isProcessingAnswer} // Disable buttons during visual flip OR background processing
         />
      </div>

       {/* Add footer or controls if needed */}
    </div>
  );
}
=== prepare/ai-generate/AiGenerateInputCard.tsx ===
// app/prepare/ai-generate/AiGenerateInputCard.tsx
"use client";

import React from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Loader2, BotMessageSquare, FileText } from 'lucide-react';
import { MediaCaptureTabs } from '@/components/media-capture-tabs';

// Constants defined here or imported from a central constants file
const SUPPORTED_FILE_TYPES = "PDF, JPG, JPEG, PNG, GIF, BMP, WEBP, HEIC, HEIF";
const SUPPORTED_EXTENSIONS = [".pdf", ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp", ".heic", ".heif"];
const MAX_FILE_SIZE = 25; // 25MB
const MAX_IMAGES = 10; // Example limit

interface AiGenerateInputCardProps {
    files: File[];
    isLoading: boolean;
    error: string | null;
    onFilesSelected: (selectedFiles: File[]) => void;
    onSubmit: (e: React.FormEvent) => Promise<void>; // Make onSubmit async if needed
    onClearAll: () => void;
    // Add props for any other display elements needed, e.g., results exist to show clear button
    hasResults: boolean;
}

export function AiGenerateInputCard({
    files,
    isLoading,
    error,
    onFilesSelected,
    onSubmit,
    onClearAll,
    hasResults
}: AiGenerateInputCardProps) {
    return (
        <Card className="sticky top-4"> {/* Make input card sticky */}
            <CardHeader className="px-4 sm:px-6 py-4">
                <CardTitle className="flex items-center gap-2"><FileText className="h-5 w-5" /> 1. Upload Source</CardTitle>
                <CardDescription> Upload PDF/Image files or use camera. </CardDescription>
            </CardHeader>
            <CardContent className="px-4 sm:px-6 pb-4">
                {/* Pass onSubmit directly to the form */}
                <form onSubmit={onSubmit}>
                    <div className="mb-4">
                        <MediaCaptureTabs
                            onFilesSelected={onFilesSelected} // Pass down the handler
                            supportedFileTypes={SUPPORTED_FILE_TYPES}
                            supportedExtensions={SUPPORTED_EXTENSIONS}
                            maxFileSize={MAX_FILE_SIZE}
                            maxImages={MAX_IMAGES}
                            // Pass current files ONLY if MediaCaptureTabs needs to display them
                            // initialFiles={files}
                        />
                        {/* Display error specific to input/validation */}
                        {error && <p className="text-sm text-red-500 mt-2">{error}</p>}
                    </div>
                    <div className="flex flex-col sm:flex-row gap-2">
                        <Button type="submit" disabled={isLoading || !files || files.length === 0} className="flex-1">
                            {isLoading ? <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Processing...</> : <><BotMessageSquare className="mr-2 h-4 w-4" /> Generate Flashcards</>}
                        </Button>
                        {/* Show Clear button if files selected OR results exist */}
                        {(files.length > 0 || hasResults) && !isLoading && (
                            <Button type="button" variant="outline" onClick={onClearAll}> Clear All </Button>
                        )}
                    </div>
                </form>
            </CardContent>
        </Card>
    );
}
=== prepare/ai-generate/useAiGenerate.ts ===
// app/prepare/ai-generate/useAiGenerate.ts
"use client";

import { useState, useCallback, useRef, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { toast } from 'sonner';
import { useSupabase } from '@/hooks/use-supabase'; // For storage uploads
import { useAuth } from '@/hooks/use-auth'; // For user ID
import { v4 as uuidv4 } from 'uuid';
// Ensure ApiFlashcard is imported and reflects the latest structure with classification fields
import type { ApiFlashcard } from '@/app/api/extract-pdf/types';
import { swapCardFields } from '@/lib/utils';
// Import specific types needed
import type { InitialGenerationResult, GeminiFlashcardClassification } from '@/app/api/extract-pdf/flashcardGeneratorService';
// --- Import SupportedFileType --- 
import type { SupportedFileType } from '@/app/api/extract-pdf/fileUtils'; 

// Use consistent type alias within this file
type FinalFlashcardData = ApiFlashcard; // Represents the final card with classification
// Export this type so other modules can import it
export type BasicFlashcardData = { question: string; answer: string; source?: string; fileType?: SupportedFileType; }; // Basic card structure
type ClassificationData = GeminiFlashcardClassification;

// Constants (remain unchanged)
const SUPPORTED_EXTENSIONS = [".pdf", ".jpg", ".jpeg", ".png", ".gif", ".bmp", ".webp"];
const MAX_FILE_SIZE = 25; // 25MB
const DIRECT_UPLOAD_LIMIT = 4; // 4MB
const COMBINED_SIZE_LIMIT = 4; // 4MB
const UPLOAD_BUCKET = 'ai-uploads';

// Language Name -> Code Mapping (remain unchanged)
const languageNameToCodeMap: Record<string, string> = {
    'english': 'en', 'dutch': 'nl', 'french': 'fr',
    'german': 'de',
    'spanish': 'es', 'italian': 'it', 'portuguese': 'pt',
    // Add more as needed
};
const getLanguageCode = (name: string | undefined): string => {
    if (!name) return 'en'; // Default to English if undefined
    const code = languageNameToCodeMap[name.toLowerCase().trim()];
    return code || 'en'; // Default to English if mapping not found
};

// Helper function (remain unchanged)

export function useAiGenerate() {
    // --- State ---
    const [files, setFiles] = useState<File[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [isProcessingStep2, setIsProcessingStep2] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [basicFlashcardsBySource, setBasicFlashcardsBySource] = useState<Record<string, BasicFlashcardData[]>>({});
    const [initialModeBySource, setInitialModeBySource] = useState<Record<string, 'translation' | 'knowledge'>>({});
    const [finalFlashcards, setFinalFlashcards] = useState<FinalFlashcardData[]>([]);
    const [serverExtractedTextMap, setServerExtractedTextMap] = useState<Record<string, string>>({});
    const [needsModeConfirmationSource, setNeedsModeConfirmationSource] = useState<string | null>(null);
    const [extractedTextPreview, setExtractedTextPreview] = useState<string | null>(null);
    const [processingSummary, setProcessingSummary] = useState<string | null>(null);
    const [deckName, setDeckName] = useState<string>("");
    const [isSavingDeck, setIsSavingDeck] = useState(false);
    const [savedDeckId, setSavedDeckId] = useState<string | null>(null);
    const [detectedLanguageNames, setDetectedLanguageNames] = useState<{ qName: string | undefined, aName: string | undefined, b: boolean }>({ qName: undefined, aName: undefined, b: false });

    // --- Hooks and Refs ---
    const { supabase } = useSupabase();
    const { user } = useAuth();
    const router = useRouter();
    const progressTimerRef = useRef<NodeJS.Timeout | null>(null);
    const currentFileIndexRef = useRef<number>(0);

    // --- Memoized Derived State --- 
    const allBasicFlashcards = useMemo(() => Object.values(basicFlashcardsBySource).flat(), [basicFlashcardsBySource]);
    const displayFlashcards: (BasicFlashcardData | FinalFlashcardData)[] = useMemo(() => {
        return needsModeConfirmationSource ? allBasicFlashcards : finalFlashcards;
    }, [needsModeConfirmationSource, allBasicFlashcards, finalFlashcards]);

    // --- Internal Helper Functions ---

    // startProgressIndicator (remain unchanged)
    const startProgressIndicator = (toastId: string, fileNames: string[]) => {
        const totalFiles = fileNames.length;
        const averageTimePerFile = Math.max(1500, Math.min(5000, 90000 / (totalFiles + 1)));
        if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        toast.loading(`Processing file 1/${totalFiles}: ${fileNames[0]}`, { id: toastId });
        currentFileIndexRef.current = 0;
        progressTimerRef.current = setInterval(() => {
            currentFileIndexRef.current++;
            if (currentFileIndexRef.current >= totalFiles) {
                if (progressTimerRef.current) clearInterval(progressTimerRef.current);
                progressTimerRef.current = null;
                toast.loading(`Finalizing processing of ${totalFiles} files...`, { id: toastId });
                return;
            }
            const currentFile = fileNames[currentFileIndexRef.current];
            toast.loading(`Processing file ${currentFileIndexRef.current + 1}/${totalFiles}: ${currentFile}`, { id: toastId });
        }, averageTimePerFile);
    };

    // Reset state function
    const resetGenerationState = useCallback(() => {
        setError(null);
        setBasicFlashcardsBySource({});
        setInitialModeBySource({});
        setFinalFlashcards([]);
        setServerExtractedTextMap({});
        setNeedsModeConfirmationSource(null);
        setExtractedTextPreview(null);
        setProcessingSummary(null);
        setDeckName("");
        setSavedDeckId(null);
        setDetectedLanguageNames({ qName: undefined, aName: undefined, b: false });
        setIsProcessingStep2(false);
        setIsSavingDeck(false);
    }, []);

    // --- ADDED BACK: handleFilesSelected ---
    const handleFilesSelected = useCallback((selectedFiles: File[]) => {
        console.log(`[useAiGenerate] handleFilesSelected: ${selectedFiles.length} files`);
        setFiles(Array.isArray(selectedFiles) ? [...selectedFiles] : []);
        // Reset relevant state when new files are selected
        resetGenerationState();
    }, [resetGenerationState]);
    // -------------------------------------

    // --- UPDATED: handleApiResponse for Step 1 ---
    const handleStep1ApiResponse = (data: any, totalFilesSubmitted: number) => {
        // --- ADD LOG to see the received code ---
        console.log(`[useAiGenerate] handleStep1ApiResponse received data.code: ${data?.code}`);
        // ---------------------------------------
        
        // --- Explicitly handle PAGE_LIMIT_EXCEEDED error from API --- 
        if (data?.success === false && data?.code === 'PAGE_LIMIT_EXCEEDED') {
            console.warn(`[useAiGenerate] Handling PAGE_LIMIT_EXCEEDED error: ${data.message}`);
            setError(data.message); // Set the specific error message for display
            const skippedInfo = data.skippedFiles && data.skippedFiles[0] ? `- ${data.skippedFiles[0].filename}: Skipped (${data.skippedFiles[0].reason})` : "File skipped due to page limit.";
            setProcessingSummary(skippedInfo);
            toast.error("Processing Failed", { description: data.message });
            console.log("[useAiGenerate] Page limit error handled, returning from handleStep1ApiResponse.");
            return; // Stop further processing in this handler
        }
        // --- ELSE: Check for other errors or invalid structure ---
        else if (!data?.success || !Array.isArray(data.initialResults)) {
            // Throw error for other unsuccessful responses or invalid structure
            throw new Error(data?.message || "Invalid response structure from initial generation API.");
        }
        // ----------------------------------------------------------
        
        // --- Capture Server-Extracted Text --- 
        const extractedTextsFromServer: { filename: string; extractedText: string }[] = data.extractedTexts || [];
        const newServerExtractedTextMap: Record<string, string> = {};
        extractedTextsFromServer.forEach(item => {
            newServerExtractedTextMap[item.filename] = item.extractedText;
        });
        setServerExtractedTextMap(newServerExtractedTextMap); // Store server text
        // ------------------------------------

        const initialResults: InitialGenerationResult[] = data.initialResults;
        const skippedFiles: Array<{ filename: string; reason: string }> = data?.skippedFiles || [];
        const successfullyProcessedCount = data?.fileInfo?.files || 0;
        
        const newBasicFlashcardsBySource: Record<string, BasicFlashcardData[]> = {};
        const newInitialModeBySource: Record<string, 'translation' | 'knowledge'> = {};
        let firstTranslationSource: string | null = null; // Track first source needing confirmation
        let firstCard: BasicFlashcardData | null = null; // Track first card overall for naming
        let firstCardLangs: { qName: string | undefined, aName: string | undefined } = { qName: undefined, aName: undefined };

        initialResults.forEach((result, index) => {
            // Find the source filename - assumes initialResults matches files processed order
            const sourceFilename = data.fileInfo?.metadata?.sources?.[index]?.filename || `Unknown Source ${index + 1}`;
            const sourceFileType = data.fileInfo?.metadata?.sources?.[index]?.type as SupportedFileType | undefined || undefined;

            const processedCards = result.basicFlashcards.map(card => ({ 
                ...card, // question, answer
                source: sourceFilename, // Add source
                fileType: sourceFileType // Add file type
            }));
            
            newBasicFlashcardsBySource[sourceFilename] = processedCards;
            newInitialModeBySource[sourceFilename] = result.mode;

            if (!firstCard && processedCards.length > 0) {
                firstCard = processedCards[0];
                firstCardLangs = { qName: result.detectedQuestionLanguage || undefined, aName: result.detectedAnswerLanguage || undefined };
            }

            if (result.mode === 'translation' && processedCards.length > 0 && !firstTranslationSource) {
                firstTranslationSource = sourceFilename;
            }
        });

        setBasicFlashcardsBySource(newBasicFlashcardsBySource);
        setInitialModeBySource(newInitialModeBySource);
        const initialFinalCards: FinalFlashcardData[] = Object.values(newBasicFlashcardsBySource).flat().map(bc => ({
            question: bc.question,
            answer: bc.answer,
            questionLanguage: getLanguageCode(firstCardLangs.qName),
            answerLanguage: getLanguageCode(firstCardLangs.aName),
            isBilingual: !!firstCardLangs.qName && !!firstCardLangs.aName && firstCardLangs.qName !== firstCardLangs.aName,
            questionPartOfSpeech: 'N/A',
            questionGender: 'N/A',
            answerPartOfSpeech: 'N/A',
            answerGender: 'N/A',
            source: bc.source,
            fileType: bc.fileType
        }));
        setFinalFlashcards(initialFinalCards);
        setExtractedTextPreview(data?.extractedTextPreview || null);

        // --- Handle Mode Confirmation ---
        setNeedsModeConfirmationSource(firstTranslationSource);
        if (firstTranslationSource) {
            console.log(`[useAiGenerate] Mode confirmation needed for source: ${firstTranslationSource}`);
            toast.info("Mode Confirmation Needed", { description: "Please confirm or change the detected mode for one or more files." });
        } else {
             console.log("[useAiGenerate] No mode confirmation needed.");
        }
        // -------------------------------

        // Update summary and languages based on the FIRST card found
        let summaryLines: string[] = [];
        Object.entries(newBasicFlashcardsBySource).forEach(([filename, cards]) => {
            summaryLines.push(`- ${filename}: ${cards.length} card${cards.length !== 1 ? 's' : ''} generated (Mode: ${newInitialModeBySource[filename]})`);
        });
        skippedFiles.forEach(skipped => summaryLines.push(`- ${skipped.filename}: Skipped (${skipped.reason})`));
        setProcessingSummary(summaryLines.length > 0 ? summaryLines.join('\n') : "Processing complete.");

        if (firstCard) {
            const qLangName = firstCardLangs.qName;
            const aLangName = firstCardLangs.aName;
            const isBilingual = !!qLangName && !!aLangName && qLangName !== aLangName;
            setDetectedLanguageNames({ qName: qLangName, aName: aLangName, b: isBilingual });
            const basicFirstCard = firstCard as BasicFlashcardData;
            const suggestedName = basicFirstCard.source
                ? basicFirstCard.source.substring(0, basicFirstCard.source.lastIndexOf('.')) || basicFirstCard.source
                : "Generated Deck";
            setDeckName(suggestedName);
        } else {
            setDetectedLanguageNames({ qName: undefined, aName: undefined, b: false });
            setDeckName("Generated Deck");
        }

        // Toast logic 
        const totalGenerated = Object.values(newBasicFlashcardsBySource).reduce((sum, cards) => sum + cards.length, 0);
        if (totalGenerated > 0) {
            toast.success(`Generated ${totalGenerated} initial flashcards!`, {
                description: skippedFiles.length > 0 ? `(${skippedFiles.length} file(s) skipped)` : `Processed ${successfullyProcessedCount} file(s).`,
            });
        } else if (successfullyProcessedCount > 0 && skippedFiles.length === 0) {
            toast.info(`No flashcards generated from ${successfullyProcessedCount} file(s).`, { description: "Check file content." });
        } else if (skippedFiles.length > 0) {
            toast.warning(`No flashcards generated. ${skippedFiles.length} file(s) skipped.`, { description: "Check summary." });
        } else {
            toast.error("Processing failed.", { description: "No files processed." });
        }
    };

    // --- UPDATED: handleSubmit --- 
    const handleSubmit = useCallback(async () => {
        // Set loading true IMMEDIATELY
        setIsLoading(true);
        
        console.log("[useAiGenerate] handleSubmit triggered for Step 1");
        const currentFiles = files;
        if (!currentFiles || currentFiles.length === 0) {
            setError('Please select file(s)');
            setIsLoading(false); // Reset loading if no files
            return;
        }
        if (!supabase || !user) {
            setError('Auth or DB connection error.');
            setIsLoading(false); // Reset loading on auth error
            return;
        }

        // Now reset other state, isLoading is already true
        resetGenerationState();

        const loadingToastId = `loading-${Date.now()}`;
        currentFileIndexRef.current = 0;
        if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        const safetyTimeout = setTimeout(() => { /* ... */ }, 90000);
        toast.loading(`Preparing ${currentFiles.length} file(s)...`, { id: loadingToastId });

        try {
            // --- File Validation ---
            let totalSizeMB = 0;
            let isAnyFileLarge = false;
            for (const file of currentFiles) {
                const fileSizeMB = file.size / (1024 * 1024);
                totalSizeMB += fileSizeMB;
                const fileExtension = file.name.slice(file.name.lastIndexOf('.')).toLowerCase();

                if (!SUPPORTED_EXTENSIONS.includes(fileExtension)) {
                    throw new Error(`Unsupported file type: ${file.name}`);
                }
                if (fileSizeMB > MAX_FILE_SIZE) {
                    throw new Error(`File too large: ${file.name} (${fileSizeMB.toFixed(2)}MB > ${MAX_FILE_SIZE}MB)`);
                }
                if (fileSizeMB > DIRECT_UPLOAD_LIMIT) {
                    isAnyFileLarge = true;
                }
            }
            console.log(`[useAiGenerate] Validation passed. isAnyFileLarge: ${isAnyFileLarge}, totalSizeMB: ${totalSizeMB.toFixed(2)}`);


            // --- Determine Upload Strategy & Prepare API Payload ---
            let apiPayload: FormData | string; // Can be FormData or JSON string
            let fetchOptions: RequestInit = { method: 'POST', credentials: 'same-origin' }; // Default method

            if (isAnyFileLarge || totalSizeMB > COMBINED_SIZE_LIMIT) {
                // Storage Upload Flow (Restored Logic)
                toast.loading(`Uploading to storage...`, { id: loadingToastId });
                let currentUploadIndex = 0;
                const uploadPromises = currentFiles.map(async (file, index) => {
                    // Ensure user object and id exist before using them
                    if (!user?.id) throw new Error("User not authenticated for storage upload."); 
                    const storagePath = `${user.id}/${uuidv4()}${file.name.slice(file.name.lastIndexOf('.'))}`; // Preserve original extension
                    try {
                        currentUploadIndex = index + 1;
                        toast.loading(`Uploading ${currentUploadIndex}/${currentFiles.length}: ${file.name}`, { id: loadingToastId });
                        // Ensure supabase client exists
                        if (!supabase) throw new Error("Supabase client not available for storage upload."); 
                        const { data: uploadData, error: uploadError } = await supabase.storage.from(UPLOAD_BUCKET).upload(storagePath, file, { upsert: false });
                        if (uploadError) throw new Error(`Storage upload failed for ${file.name}: ${uploadError.message}`);
                        // Check if uploadData and path exist
                        if (!uploadData?.path) throw new Error(`Storage upload succeeded for ${file.name} but returned no path.`); 
                        toast.success(`Uploaded: ${file.name}`, { id: `upload-${file.name}-${index}` });
                        return { filename: file.name, filePath: uploadData.path };
                    } catch (err: any) {
                        console.error(`Upload Error ${file.name}:`, err);
                        toast.error(`Failed to upload: ${file.name}`, { id: `upload-${file.name}-${index}`, description: err.message });
                        return null;
                    }
                });
                const uploadResults = await Promise.all(uploadPromises);
                const successfulUploads = uploadResults.filter(
                    (result): result is { filename: string; filePath: string } => result !== null
                );
                if (successfulUploads.length === 0) throw new Error('All storage uploads failed.');
                if (successfulUploads.length < currentFiles.length) toast.warning(`${currentFiles.length - successfulUploads.length} file(s) failed to upload. Continuing with successful ones.`);
                
                // Prepare JSON payload with file paths
                apiPayload = JSON.stringify({ files: successfulUploads }); 
                fetchOptions.headers = { 'Content-Type': 'application/json' };
                console.log("[useAiGenerate] Using Storage Upload Flow. Payload:", apiPayload);

            } else {
                // Direct Upload Flow (Unchanged)
                const formData = new FormData();
                currentFiles.forEach(file => formData.append('file', file));
                apiPayload = formData;
                // No specific Content-Type header needed for FormData; browser sets it
                console.log("[useAiGenerate] Using Direct Upload Flow.");
            }
            // Assign body AFTER the if/else
            fetchOptions.body = apiPayload; 
            // ---------------------------------------------------------

            // --- API Call to Step 1 endpoint --- 
            const filesToProcess = currentFiles.map(f => f.name);
            startProgressIndicator(loadingToastId, filesToProcess); // Update toast for processing phase
            console.log("[useAiGenerate] Calling POST /api/extract-pdf (Step 1)");
            const response = await fetch('/api/extract-pdf', fetchOptions);
            // ---------------------------------

            // --- Handle API Response (Step 1) --- 
            if (!response) throw new Error("No response from initial generation server.");
            let data;
            try { data = await response.json(); }
            catch (jsonError) { throw new Error(`Server returned invalid response (${response.status}).`); }
            finally { clearTimeout(safetyTimeout); toast.dismiss(loadingToastId); }
            
            // Use the dedicated handler for Step 1 results
            handleStep1ApiResponse(data, currentFiles.length); 
            // ------------------------------------

        } catch (err: any) {
            console.log("[useAiGenerate] Caught error in handleSubmit try block.");
            console.error('[useAiGenerate] Error during file processing (Step 1):', err);
            clearTimeout(safetyTimeout); toast.dismiss(loadingToastId);
            // --- Only set generic error if a specific one wasn't already set (Corrected Syntax) --- 
            if (!error) {
                setError(err.message || 'An error occurred during initial processing.');
            }
            // -----------------------------------------------------------------------------------
            toast.error('Initial Processing Error', { description: err.message || 'An unknown error occurred.' });
            // Remove this - we want to keep the error state to display it
            // resetGenerationState(); \n        } finally {\n            setIsLoading(false); // Step 1 loading finished\n            if (progressTimerRef.current) clearInterval(progressTimerRef.current);\n        }
        } finally {
            console.log("[useAiGenerate] Entering handleSubmit finally block.");
            setIsLoading(false); // Step 1 loading finished
            if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        }
    }, [files, supabase, user, resetGenerationState, handleStep1ApiResponse, startProgressIndicator]);


    // --- NEW: handleConfirmTranslation (Step 2 - Classify) --- 
    const handleConfirmTranslation = useCallback(async () => {
        if (!needsModeConfirmationSource) return;
        const sourceFilename = needsModeConfirmationSource;
        const basicCards = basicFlashcardsBySource[sourceFilename];
        if (!basicCards || basicCards.length === 0) {
            toast.error("Cannot classify: No basic flashcards found for this source.");
            setNeedsModeConfirmationSource(null); // Clear flag even on error
            return;
        }

        setIsProcessingStep2(true);
        const toastId = toast.loading(`Classifying ${basicCards.length} flashcards for ${sourceFilename}...`);

        try {
            const payload = {
                action: 'classify',
                filename: sourceFilename,
                basicFlashcards: basicCards.map(({ question, answer }) => ({ question, answer })) // Send only Q/A
            };

            console.log(`[useAiGenerate] Calling POST /api/process-ai-step2 (Action: classify) for ${sourceFilename}`);
            const response = await fetch('/api/process-ai-step2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            if (!response) throw new Error("No response from classification server.");
            const result = await response.json();
            if (!result.success) throw new Error(result.message || "Classification API returned an error.");

            const classifications: ClassificationData[] = result.data;

            // Merge classifications with basic cards
            setFinalFlashcards(prevFinal => {
                return prevFinal.map(card => {
                    if (card.source === sourceFilename) {
                        // Find corresponding basic card index (less efficient, consider map if needed)
                        const basicIndex = basicCards.findIndex(bc => bc.question === card.question && bc.answer === card.answer);
                        const classification = (basicIndex !== -1 && basicIndex < classifications.length) ? classifications[basicIndex] : null;
                        return {
                            ...card,
                            questionPartOfSpeech: classification?.questionPartOfSpeech?.trim() || 'N/A',
                            questionGender: classification?.questionGender?.trim() || 'N/A',
                            answerPartOfSpeech: classification?.answerPartOfSpeech?.trim() || 'N/A',
                            answerGender: classification?.answerGender?.trim() || 'N/A',
                        };
                    }
                    return card;
                });
            });

            toast.success(`Classification complete for ${sourceFilename}!`, { id: toastId });
            setNeedsModeConfirmationSource(null); // Clear confirmation flag

        } catch (error: any) {
            console.error('[useAiGenerate] Error during classification (Step 2):', error);
            toast.error(`Classification Failed for ${sourceFilename}`, { 
                id: toastId, 
                description: error.message || 'An unknown error occurred.'
            });
             // Optionally revert finalFlashcards back to basic? Or leave as is?
             // For now, leave as basic, user might retry.
        } finally {
            setIsProcessingStep2(false);
        }
    }, [needsModeConfirmationSource, basicFlashcardsBySource]);


    // --- NEW: handleForceKnowledge (Step 2 - Regenerate) --- 
    const handleForceKnowledge = useCallback(async () => {
        if (!needsModeConfirmationSource) return;
        const sourceFilename = needsModeConfirmationSource;
        // Retrieve text from the map holding SERVER-extracted text
        const serverExtractedText = serverExtractedTextMap[sourceFilename];
        // Explicitly type currentFileType
        const currentFileType: SupportedFileType | undefined = basicFlashcardsBySource[sourceFilename]?.[0]?.fileType;
        if (!serverExtractedText) { // Check the correct variable
            toast.error(`Cannot regenerate: Server-extracted text for ${sourceFilename} not found.`);
            setNeedsModeConfirmationSource(null); // Clear flag
            return;
        }

        setIsProcessingStep2(true);
        const toastId = toast.loading(`Regenerating flashcards in Knowledge Mode for ${sourceFilename}...`);

        try {
            const payload = {
                action: 'force_knowledge',
                filename: sourceFilename,
                originalText: serverExtractedText // Send the correct text
            };

            console.log(`[useAiGenerate] Calling POST /api/process-ai-step2 (Action: force_knowledge) for ${sourceFilename}`);
            const response = await fetch('/api/process-ai-step2', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload),
            });

            if (!response) throw new Error("No response from knowledge regeneration server.");
            const result = await response.json();
            if (!result.success || !result.data) throw new Error(result.message || "Knowledge regeneration API returned an error or invalid data.");

            const regeneratedData = result.data as { detectedQuestionLanguage: string; detectedAnswerLanguage: string; basicFlashcards: BasicFlashcardData[] };
            const regeneratedCards: FinalFlashcardData[] = regeneratedData.basicFlashcards.map(card => ({
                ...card,
                questionLanguage: regeneratedData.detectedQuestionLanguage,
                answerLanguage: regeneratedData.detectedAnswerLanguage,
                isBilingual: false, // Knowledge mode is never bilingual
                questionPartOfSpeech: 'N/A',
                questionGender: 'N/A',
                answerPartOfSpeech: 'N/A',
                answerGender: 'N/A',
                source: sourceFilename, // Re-add source
                fileType: currentFileType // Assign the potentially undefined SupportedFileType
            }));

            // Update the final flashcards state, replacing cards from this source
            setFinalFlashcards(prevFinal => {
                const otherSourceCards = prevFinal.filter(card => card.source !== sourceFilename);
                return [...otherSourceCards, ...regeneratedCards];
            });
            
            // Update detected languages if this is the first source processed
            if (Object.keys(basicFlashcardsBySource).length === 1) { // Or check if it was the source used for initial detection
                setDetectedLanguageNames({ qName: regeneratedData.detectedQuestionLanguage, aName: regeneratedData.detectedAnswerLanguage, b: false });
            }

            // Update the summary for this source
            setProcessingSummary(prev => {
                 if (!prev) return `Regenerated ${regeneratedCards.length} cards for ${sourceFilename} (Knowledge Mode).`;
                 const lines = prev.split('\n');
                 const existingIndex = lines.findIndex(line => line.includes(sourceFilename));
                 const newLine = `- ${sourceFilename}: ${regeneratedCards.length} card${regeneratedCards.length !== 1 ? 's' : ''} generated (Knowledge Mode - Regenerated)`;
                 if (existingIndex !== -1) {
                     lines[existingIndex] = newLine;
                     return lines.join('\n');
                 } else {
                     return prev + '\n' + newLine;
                 }
            });

            toast.success(`Regeneration complete for ${sourceFilename}!`, { id: toastId });
            setNeedsModeConfirmationSource(null); // Clear confirmation flag

        } catch (error: any) {
            console.error('[useAiGenerate] Error during knowledge regeneration (Step 2):', error);
            toast.error(`Regeneration Failed for ${sourceFilename}`, { 
                id: toastId, 
                description: error.message || 'An unknown error occurred.'
            });
        } finally {
            setIsProcessingStep2(false);
        }
    }, [needsModeConfirmationSource, serverExtractedTextMap, basicFlashcardsBySource]);

    // --- handleSaveDeck (Cleaned up error handling comments) --- 
    const handleSaveDeck = useCallback(async () => {
        const cardsToSave = finalFlashcards; 
        if (!cardsToSave || cardsToSave.length === 0) { 
            toast.error("No flashcards to save."); 
            return; 
        }
        if (needsModeConfirmationSource) {
             toast.error("Please resolve the mode confirmation before saving.");
             return;
        }
        if (!deckName.trim()) {
            toast.error("Please enter a deck name.");
            return;
        }

        setIsSavingDeck(true);
        const toastId = toast.loading("Saving deck...");

        try {
            const firstCard = cardsToSave[0]; 
            const qLangCode = getLanguageCode(firstCard?.questionLanguage);
            const aLangCode = getLanguageCode(firstCard?.answerLanguage);
            const isBilingualFlag = !!firstCard?.isBilingual;
            const payload = { name: deckName.trim(), questionLanguage: qLangCode, answerLanguage: aLangCode, isBilingual: isBilingualFlag, flashcards: cardsToSave };

            const response = await fetch('/api/decks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
            
            // --- Cleaned up response handling --- 
            let result;
            const contentType = response.headers.get("content-type"); 
            if (contentType && contentType.includes("application/json")) {
                 result = await response.json(); 
            } else {
                 const textResponse = await response.text();
                 throw new Error(`Server returned non-JSON response (${response.status}): ${textResponse.substring(0,150)}...`);
            }
             
            if (!response.ok || !result.success) { 
                 throw new Error(result.message || `Failed to save deck (Status: ${response.status})`); 
            }
            // ----------------------------------

            setSavedDeckId(result.deckId); 
            toast.success(result.message || `Deck "${deckName.trim()}" saved!`, { id: toastId, action: { label: "View Deck", onClick: () => router.push(`/edit/${result.deckId}`) } }); 

        } catch (error: any) {
            console.error("[useAiGenerate] Error saving deck:", error);
            toast.error("Failed to save deck", { id: toastId, description: error.message || "An unknown error occurred." });
            setSavedDeckId(null); 
        } finally {
            setIsSavingDeck(false);
        }
    }, [deckName, finalFlashcards, router, needsModeConfirmationSource]); 


    // handleClearAll (Needs to reset new state)
    const handleClearAll = useCallback(() => {
        setFiles([]);
        setIsLoading(false);
        resetGenerationState(); // Use the reset helper
        if (progressTimerRef.current) clearInterval(progressTimerRef.current);
        currentFileIndexRef.current = 0;
        toast.info("Inputs and results cleared.");
    }, [resetGenerationState]);


    // handleSaveFlashcards (JSON download - Should download FINAL cards)
    const handleSaveFlashcards = useCallback(() => {
        const cardsToDownload = finalFlashcards;
        if (cardsToDownload.length === 0) {
            toast.error("No flashcards to download.");
            return;
        }
        // ... rest of download logic remains the same ...
        const jsonString = `data:text/json;charset=utf-8,${encodeURIComponent(
            JSON.stringify(cardsToDownload, null, 2)
        )}`;
        const link = document.createElement("a");
        link.href = jsonString;
        link.download = `${deckName || 'flashcards'}.json`;
        link.click();
        toast.success("Final flashcard data downloaded as JSON.");
    }, [finalFlashcards, deckName]);


    // handleDeckNameChange (remain unchanged)
    const handleDeckNameChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
        setDeckName(e.target.value);
    }, []);


    // handleSwapSourceCards (updated)
    const handleSwapSourceCards = useCallback((sourceToSwap: string) => {
        console.log(`[useAiGenerate] Swapping Q/A for source: ${sourceToSwap}`);
        
        setFinalFlashcards(currentFlashcards => 
            currentFlashcards.map(card => {
                if (card.source === sourceToSwap) {
                    const swappedBase = swapCardFields({ question: card.question, answer: card.answer });
                    return { 
                        ...card, 
                        question: swappedBase.question,
                        answer: swappedBase.answer,
                        questionLanguage: card.answerLanguage, // Swap languages
                        answerLanguage: card.questionLanguage,
                     } as FinalFlashcardData;
                }
                return card; 
            })
        );

        // Update basic cards state too
        setBasicFlashcardsBySource(prevBasic => {
             if (!prevBasic[sourceToSwap]) return prevBasic;
             const currentBasic = prevBasic[sourceToSwap];
             const newBasic = currentBasic.map(card => {
                 const swapped = swapCardFields({question: card.question, answer: card.answer});
                 // Re-apply source/type
                 return { ...swapped, source: card.source, fileType: card.fileType };
             }) as BasicFlashcardData[];
             return { ...prevBasic, [sourceToSwap]: newBasic };
         });

        // Update detected languages display state
        const firstSource = Object.keys(basicFlashcardsBySource)[0];
        if (sourceToSwap === firstSource) {
             setDetectedLanguageNames(prev => ({ qName: prev.aName, aName: prev.qName, b: prev.b }));
        }

        toast.info(`Question & Answer swapped for "${sourceToSwap}" (preview only). Save deck to persist.`);
    }, [basicFlashcardsBySource]); // Removed setFinalFlashcards as direct dependency


    // --- Return Values --- 
    return {
        // State
        files, 
        isLoading, // Step 1 loading
        isProcessingStep2, // Step 2 loading
        error, 
        displayFlashcards, // Use this for rendering the list
        extractedTextPreview, 
        processingSummary,
        deckName, 
        isSavingDeck, 
        savedDeckId,
        needsModeConfirmationSource, // Filename needing confirmation, or null
        // Actions / Handlers
        handleFilesSelected, 
        handleSubmit, // Renamed Step 1 trigger
        handleConfirmTranslation, // New Step 2 handler
        handleForceKnowledge, // New Step 2 handler
        handleSaveDeck, 
        handleClearAll,
        handleSaveFlashcards, 
        handleDeckNameChange, 
        handleSwapSourceCards,
    };
}
=== prepare/ai-generate/AiGenerateResultsCard.tsx ===
// app/prepare/ai-generate/AiGenerateResultsCard.tsx
"use client";

import React from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Download, Eye, Languages, Repeat, Tag, Loader2, AlertTriangle, HelpCircle, Sparkles, BookOpen } from 'lucide-react'; // Updated Icons
import type { ApiFlashcard } from '@/app/api/extract-pdf/types';
// Import the basic type as well
import type { BasicFlashcardData } from './useAiGenerate';

// Use a union type for the flashcards prop
type FlashcardData = ApiFlashcard | BasicFlashcardData;

interface AiGenerateResultsCardProps {
    flashcards: FlashcardData[]; // Use the union type
    extractedTextPreview: string | null;
    processingSummary: string | null;
    deckName: string;
    savedDeckId: string | null;
    needsModeConfirmationSource: string | null; // New prop
    isProcessingStep2: boolean; // New prop
    onSaveJson: () => void;
    onSwapSource: (source: string) => void;
    onConfirmTranslation: () => void; // New prop
    onForceKnowledge: () => void; // New prop
}

// Helper to group cards (needs to handle union type)
const getFlashcardsBySource = (cards: FlashcardData[]) => {
    const grouped: Record<string, FlashcardData[]> = {};
    cards.forEach(card => {
        const source = card.source || 'Unknown Source';
        if (!grouped[source]) grouped[source] = [];
        grouped[source].push(card);
    });
    return grouped;
};

export function AiGenerateResultsCard({
    flashcards,
    extractedTextPreview,
    processingSummary,
    deckName,
    savedDeckId,
    needsModeConfirmationSource,
    isProcessingStep2,
    onSaveJson,
    onSwapSource,
    onConfirmTranslation,
    onForceKnowledge
}: AiGenerateResultsCardProps) {
    const hasFlashcards = flashcards.length > 0;
    // Disable JSON download if confirmation is needed
    const showJsonDownload = hasFlashcards && !savedDeckId && !needsModeConfirmationSource;

    // Helper to display classification info (check for existence of properties)
    const renderClassification = (
        card: FlashcardData,
        prefix: string = "",
        fieldPrefix: 'question' | 'answer'
    ) => {
        // Check if the card is ApiFlashcard type before accessing classification fields
        const pos = (card as ApiFlashcard)?. [`${fieldPrefix}PartOfSpeech`];
        const gender = (card as ApiFlashcard)?. [`${fieldPrefix}Gender`];

        const posText = (pos && pos !== 'N/A') ? pos : null;
        const genderText = (gender && gender !== 'N/A') ? gender : null;

        if (!posText && !genderText) {
            return null; // Don't render anything if both are N/A or undefined
        }

        return (
            <span className="flex items-center gap-1 text-xs text-muted-foreground ml-1">
                {prefix && <span className="font-medium">{prefix}:</span>}
                {posText && <Badge variant="outline" className="px-1.5 py-0 text-xs">{posText}</Badge>}
                {genderText && <Badge variant="outline" className="px-1.5 py-0 text-xs">{genderText}</Badge>}
            </span>
        );
    };

    // Confirmation UI Component
    const renderConfirmationPrompt = (source: string) => {
        return (
            <div className="border-l-4 border-blue-500 dark:border-blue-400 bg-blue-50 dark:bg-blue-900/20 p-4 rounded-md mb-4">
                <div className="flex items-center mb-2">
                    <HelpCircle className="h-5 w-5 text-blue-600 dark:text-blue-400 mr-2" />
                    <h4 className="font-semibold text-blue-800 dark:text-blue-200">We detected this as a 'Translation' list. How would you like to proceed?</h4>
                </div>
                <p className="text-sm text-blue-700 dark:text-blue-300 mb-3">
                    Mode Confirmation for '{source}'
                </p>
                <div className="flex flex-col sm:flex-row gap-2">
                    <Button 
                        onClick={onConfirmTranslation}
                        disabled={isProcessingStep2}
                        size="sm"
                        variant="default"
                        className="bg-blue-600 hover:bg-blue-700 dark:bg-blue-500 dark:hover:bg-blue-600 dark:text-white w-full"
                    >
                        {isProcessingStep2 ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Sparkles className="mr-2 h-4 w-4"/>}
                        Add Grammar Details
                    </Button>
                    <Button 
                        onClick={onForceKnowledge}
                        disabled={isProcessingStep2}
                        size="sm"
                        variant="outline"
                        className="dark:text-gray-300 dark:border-gray-600 dark:hover:bg-gray-700 dark:hover:text-white w-full"
                    >
                        {isProcessingStep2 ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <BookOpen className="mr-2 h-4 w-4"/>}
                        Change to Knowledge Mode
                    </Button>
                </div>
            </div>
        );
    };

    return (
        <Card className="min-h-[300px] flex flex-col">
            <CardHeader className="px-4 sm:px-6 py-4">
                 <CardTitle className="flex items-center gap-2"><Eye className="h-5 w-5" /> 2. Review Results</CardTitle>
                 <CardDescription className="mt-1 !mb-0">
                    Review generated flashcards and processing summary.
                 </CardDescription>
                 {/* Processing Summary Display */}
                 {processingSummary && (
                    <div className="text-xs space-y-1 mt-3 border-t pt-3">
                        <p className="font-medium mb-1 text-foreground">Processing Summary:</p>
                        {processingSummary.split('\n').map((line, index) => (
                        <p key={index} className="flex items-start">
                            <span className={`flex-shrink-0 w-4 ${line.includes('Skipped') ? 'text-orange-500' : 'text-green-500'}`}>{line.includes('Skipped') ? '' : ''}</span>
                            <span className={`ml-1 whitespace-pre-wrap ${line.includes('Skipped') ? 'text-muted-foreground' : 'text-foreground'}`}>{line.replace(/^- /, '')}</span>
                        </p>
                        ))}
                    </div>
                 )}
            </CardHeader>
            <CardContent className="flex-grow overflow-auto px-4 sm:px-6 pb-4">
                {!hasFlashcards && !extractedTextPreview && !processingSummary ? (
                    // Placeholder
                    <div className="text-center py-6 text-muted-foreground flex flex-col items-center justify-center h-full">
                        <p>Results will appear here after processing.</p>
                    </div>
                ) : hasFlashcards ? (
                    // Grouped Flashcard Display
                    <div className="space-y-6 pr-2">
                        {/* Render Confirmation Prompt if needed */}
                        {needsModeConfirmationSource && renderConfirmationPrompt(needsModeConfirmationSource)}

                        {Object.entries(getFlashcardsBySource(flashcards)).map(([source, cards]) => {
                            const firstCard = cards[0]; // Use first card for group info
                            // Check if properties exist before accessing for languages
                            const docLangs = {
                                qName: (firstCard as ApiFlashcard)?.questionLanguage,
                                aName: (firstCard as ApiFlashcard)?.answerLanguage,
                                b: (firstCard as ApiFlashcard)?.isBilingual
                             };
                            const showALang = docLangs.aName && docLangs.qName !== docLangs.aName;
                            return (
                            <div key={source}>
                                <div className="flex flex-wrap items-center justify-between gap-2 mb-3 pb-2 border-b">
                                    <h3 className="text-sm font-semibold truncate" title={source}>Source: {source}</h3>
                                    <div className="flex items-center gap-1 flex-wrap">
                                        {firstCard?.fileType && <Badge variant="outline" className="text-xs">{firstCard.fileType}</Badge>}
                                        {docLangs.qName && <Badge variant="secondary" className="text-xs capitalize"><Languages className="inline h-3 w-3 mr-1"/>Q: {docLangs.qName}</Badge>}
                                        {showALang && <Badge variant="secondary" className="text-xs capitalize"><Languages className="inline h-3 w-3 mr-1"/>A: {docLangs.aName}</Badge>}
                                        <Badge variant="outline" className="text-xs">{cards.length} cards</Badge>
                                    </div>
                                </div>
                                <div className="mb-3 -mt-2 flex justify-end">
                                    {/* Disable swap button if confirmation needed */}
                                    <Button variant="outline" size="sm" onClick={() => onSwapSource(source)} disabled={!!needsModeConfirmationSource}>
                                        <Repeat className="h-4 w-4 mr-2"/>
                                        Swap Q/A for this Source
                                    </Button>
                                </div>
                                <div className="space-y-3">
                                    {cards.map((card, index) => (
                                        <div key={`${source}-${index}-${card.question?.substring(0, 5)}`} className="border rounded-md p-3 text-sm bg-background shadow-sm">
                                            {/* Question and optional classification */}
                                            <div className="flex flex-wrap items-center gap-x-2 mb-1">
                                                <p className="font-medium break-words">{card.question}</p>
                                                {renderClassification(card, "", 'question')}
                                            </div>
                                            {/* Answer and optional classification */}
                                            <div className="flex flex-wrap items-center gap-x-2">
                                                <p className="text-muted-foreground whitespace-pre-line break-words">{card.answer}</p>
                                                {renderClassification(card, "", 'answer')}
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                            );
                        })}
                    </div>
                ) : extractedTextPreview ? (
                     // Text Preview Display
                    <div>
                        <h3 className="text-sm font-medium mb-2">Extracted Text Preview:</h3>
                        <div className="bg-muted p-3 rounded-md max-h-[40vh] overflow-y-auto text-xs border">
                            <pre className="whitespace-pre-wrap font-mono">{extractedTextPreview.substring(0, 1000)}{extractedTextPreview.length > 1000 && '...'}</pre>
                        </div>
                    </div>
                ) : (
                     // Fallback
                     <div className="text-center py-6 text-muted-foreground flex flex-col items-center justify-center h-full">
                         <p>Processing complete. Check summary above.</p>
                     </div>
                )}
            </CardContent>
             {/* Optional Footer for JSON Download */}
             {showJsonDownload && (
                <CardFooter className="border-t px-4 sm:px-6 py-3 mt-auto">
                    <Button variant="secondary" size="sm" className="w-full" onClick={onSaveJson}>
                        <Download className="mr-2 h-4 w-4" />
                        Download Flashcards as JSON
                    </Button>
                </CardFooter>
             )}
        </Card>
    );
}
=== prepare/ai-generate/AiGenerateSaveDeckCard.tsx ===
// app/prepare/ai-generate/AiGenerateSaveDeckCard.tsx
"use client";

import React from 'react'; // Import React for ChangeEvent type
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Loader2, FilePlus, CheckCircle, ArrowRight } from 'lucide-react';
// Import both types
import type { ApiFlashcard } from '@/app/api/extract-pdf/types';
import type { BasicFlashcardData } from './useAiGenerate';

// Define the union type locally or import if defined elsewhere
type FlashcardData = ApiFlashcard | BasicFlashcardData;

interface AiGenerateSaveDeckCardProps {
    flashcards: FlashcardData[]; // Use the union type
    deckName: string;
    isSavingDeck: boolean;
    savedDeckId: string | null;
    onDeckNameChange: (e: React.ChangeEvent<HTMLInputElement>) => void;
    onSaveDeck: () => Promise<void>;
}

export function AiGenerateSaveDeckCard({
    flashcards,
    deckName,
    isSavingDeck,
    savedDeckId,
    onDeckNameChange,
    onSaveDeck
}: AiGenerateSaveDeckCardProps) {

    // Don't render this card if there are no flashcards to save
    if (flashcards.length === 0) {
        return null;
    }

    return (
        <Card className="mt-6">
            <CardHeader>
                <CardTitle className="flex items-center gap-2">
                    {savedDeckId ? <CheckCircle className="h-5 w-5 text-green-600" /> : <FilePlus className="h-5 w-5" />}
                    {savedDeckId ? "Deck Created" : "3. Save as New Deck"}
                </CardTitle>
                <CardDescription>
                    {savedDeckId ? "Your new deck is ready!" : "Save these flashcards as a new deck in your collection."}
                </CardDescription>
            </CardHeader>
            <CardContent>
                {savedDeckId ? (
                    // Success Message & Link
                    <div className="flex items-center justify-between p-4 bg-green-50 dark:bg-green-900/30 rounded-md border border-green-200 dark:border-green-800">
                        <p className="text-sm font-medium text-green-800 dark:text-green-200">
                            Deck "{deckName}" created! {/* Show name used for saving */}
                        </p>
                        <Button variant="default" size="sm" asChild>
                            <Link href={`/edit/${savedDeckId}`}>
                                View Deck <ArrowRight className="ml-2 h-4 w-4" />
                            </Link>
                        </Button>
                    </div>
                ) : (
                    // Input and Save Button
                    <div className="flex flex-col sm:flex-row gap-3 items-end">
                        <div className="flex-1 w-full sm:w-auto">
                            <Label htmlFor="deckNameInput" className="mb-1 block text-sm font-medium">Deck Name</Label>
                            <Input
                                id="deckNameInput" // Use unique ID if needed elsewhere
                                value={deckName}
                                onChange={onDeckNameChange} // Pass handler down
                                placeholder="Enter deck name (e.g., Biology Ch. 5)"
                                disabled={isSavingDeck}
                                required
                                aria-required="true"
                            />
                        </div>
                        <Button
                            disabled={isSavingDeck || !deckName.trim()}
                            onClick={onSaveDeck} // Pass handler down
                            className="w-full sm:w-auto"
                        >
                            {isSavingDeck ? <><Loader2 className="mr-2 h-4 w-4 animate-spin" /> Saving...</> : "Save Deck"}
                        </Button>
                    </div>
                )}
            </CardContent>
        </Card>
    );
}
=== prepare/ai-generate/page.tsx ===
// app/prepare/ai-generate/page.tsx
'use client';

import React from 'react'; // Import React if using JSX type React.FormEvent
// Import the hook and new components
import { useAiGenerate } from './useAiGenerate';
import { AiGenerateInputCard } from './AiGenerateInputCard';
import { AiGenerateResultsCard } from './AiGenerateResultsCard';
import { AiGenerateSaveDeckCard } from './AiGenerateSaveDeckCard';

/**
 * Main page component for the AI Flashcard Generator.
 * Orchestrates the UI by using the useAiGenerate hook and rendering
 * specialized child components for input, results, and saving.
 */
export default function AiGeneratePage() {
    // Get all state and handlers from the custom hook
    const {
        files,
        isLoading,
        isProcessingStep2,
        error,
        displayFlashcards,
        extractedTextPreview,
        processingSummary,
        deckName,
        isSavingDeck,
        savedDeckId,
        needsModeConfirmationSource,
        handleFilesSelected,
        handleSubmit, // This is now the async function to call
        handleConfirmTranslation,
        handleForceKnowledge,
        handleSaveDeck,
        handleClearAll,
        handleSaveFlashcards, // For JSON download
        handleDeckNameChange,
        handleSwapSourceCards,
    } = useAiGenerate();

    // --- FIX: Create an async wrapper for the form onSubmit ---
    const handleFormSubmit = async (e: React.FormEvent) => {
        e.preventDefault(); // Prevent default form submission
        await handleSubmit(); // Call the async handler from the hook
    };
    // -------------------------------------------------------

    return (
        <div className="container mx-auto px-3 sm:px-4 py-4 sm:py-8">
            <h1 className="text-2xl sm:text-3xl font-bold mb-4 sm:mb-6">AI Flashcard Generator</h1>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 sm:gap-6">

                {/* Input Column */}
                <div>
                    <AiGenerateInputCard
                        files={files}
                        isLoading={isLoading}
                        error={error}
                        onFilesSelected={handleFilesSelected}
                        onSubmit={handleFormSubmit} // Use the async wrapper here
                        onClearAll={handleClearAll}
                        hasResults={displayFlashcards.length > 0 || !!extractedTextPreview || !!processingSummary}
                    />
                </div>

                {/* Results & Save Column */}
                <div className="space-y-6">
                    <AiGenerateResultsCard
                        flashcards={displayFlashcards}
                        extractedTextPreview={extractedTextPreview}
                        processingSummary={processingSummary}
                        deckName={deckName}
                        savedDeckId={savedDeckId}
                        needsModeConfirmationSource={needsModeConfirmationSource}
                        isProcessingStep2={isProcessingStep2}
                        onSaveJson={handleSaveFlashcards}
                        onSwapSource={handleSwapSourceCards}
                        onConfirmTranslation={handleConfirmTranslation}
                        onForceKnowledge={handleForceKnowledge}
                    />

                    <AiGenerateSaveDeckCard
                        flashcards={displayFlashcards}
                        deckName={deckName}
                        isSavingDeck={isSavingDeck}
                        savedDeckId={savedDeckId}
                        onDeckNameChange={handleDeckNameChange}
                        onSaveDeck={handleSaveDeck}
                    />
                </div>

            </div>
        </div> // End container
    );
}
=== auth/callback/route.ts ===
import { NextResponse } from 'next/server'
import { createServerClient } from '@/lib/supabase/server'

/**
 * Handles the GET request for the authentication callback.
 * This route is hit when the user clicks the email confirmation link sent by Supabase.
 * It exchanges the provided code for a user session.
 * 
 * @param {Request} request The incoming request object.
 * @returns {Promise<NextResponse>} A response object, typically a redirect.
 */
export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  // The `next` parameter might be used if you want to redirect to a specific page after login
  // const next = searchParams.get('next') ?? '/'

  if (code) {
    const supabase = createServerClient()
    try {
      const { error, data } = await supabase.auth.exchangeCodeForSession(code)
      
      if (!error && data.session) {
        // Email confirmed, session created successfully.
        // Redirect to the main application page or a specified 'next' page.
        console.log('Auth callback successful, redirecting to /');
        return NextResponse.redirect(`${origin}/`) // Redirect to home page
      } else {
        // Handle errors during code exchange
        console.error('Auth callback error during code exchange:', error?.message);

        // Check for common errors indicating the link was already used, expired, or invalid
        const isInvalidGrantError = error?.message?.toLowerCase().includes('invalid grant') || 
                                  error?.message?.toLowerCase().includes('invalid or expired') ||
                                  error?.message?.toLowerCase().includes('already confirmed');

        if (isInvalidGrantError) {
          // Redirect to login with a message indicating the issue (already confirmed, expired link, etc.)
          return NextResponse.redirect(`${origin}/login?message=email_already_confirmed_or_link_invalid`);
        } else {
           // Redirect to login page with a generic error for other issues
          return NextResponse.redirect(`${origin}/login?error=confirmation_failed`);
        }
      }
    } catch (e) {
      // Catch unexpected errors during the process
      console.error('Auth callback unexpected error:', e);
      return NextResponse.redirect(`${origin}/login?error=confirmation_failed`);
    }
  }

  // If no code is present in the URL, redirect to login with an error
  console.warn('Auth callback called without a code.');
  return NextResponse.redirect(`${origin}/login?error=missing_confirmation_code`);
} 
=== signup/page.tsx ===
"use client"

import type React from "react"
import { useState, useEffect, Suspense } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useAuth } from "@/hooks/use-auth"
import { toast } from "sonner"
import type { AuthError } from '@supabase/supabase-js'

/**
 * Sign-up Page component.
 *
 * This component acts as the entry point for the sign-up route.
 * It wraps the main `SignupContent` component in a React Suspense
 * boundary to correctly handle client-side hooks like `useSearchParams`.
 *
 * @returns {JSX.Element} The Sign-up Page UI wrapped in Suspense.
 */
export default function SignupPage() {
  // The main export wraps SignupContent in Suspense
  return (
    <Suspense fallback={<div className="flex items-center justify-center min-h-screen">Loading Page...</div>}>
      <SignupContent />
    </Suspense>
  )
}

/**
 * Renders the sign-up form and manages the sign-up process.
 *
 * This client component handles user input for email and password,
 * performs client-side validation (password match, length),
 * interacts with the `useAuth` hook to call the `signUp` function,
 * displays loading states and feedback messages (success/error) using toasts,
 * handles redirection based on authentication state or server feedback
 * (e.g., after email confirmation request), and prevents access if the user
 * is already logged in.
 *
 * @returns {JSX.Element} The Sign-up form UI or a loading spinner.
 */
// --- Define the inner component containing the client logic ---
function SignupContent() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [confirmPassword, setConfirmPassword] = useState("")
  const [isLoading, setIsLoading] = useState(false)
  const { signUp, user, loading: authLoading } = useAuth()
  const router = useRouter()
  const searchParams = useSearchParams()

  useEffect(() => {
    if (!authLoading && user) {
      router.push("/")
    }
  }, [user, authLoading, router])

  useEffect(() => {
    const message = searchParams.get('message')
    const error = searchParams.get('error')
    if (message === 'confirmation_email_sent') {
      toast.success("Confirmation Email Sent", {
        description: "Please check your email to confirm your account."
      })
    }
    if (error) {
      toast.error("Signup Error", { description: error })
    }
    if (message || error) {
      router.replace('/signup', { scroll: false })
    }
  }, [searchParams, router])

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!email || !password || !confirmPassword) {
      toast.error("Missing Information", {
        description: "Please fill in all fields."
      })
      return
    }

    if (password !== confirmPassword) {
      toast.error("Password Mismatch", {
        description: "The passwords entered do not match."
      })
      return
    }

    if (password.length < 6) {
      toast.error("Password Too Short", {
        description: "Password must be at least 6 characters long."
      })
      return
    }

    setIsLoading(true)

    try {
      const { data, error } = await signUp(email, password)

      if (error) {
        console.error("Sign up error:", error)
        if (error instanceof Error) {
          toast.error(error.message || "An unexpected error occurred during sign up.")
        } else {
          toast.error((error as any).message || "Sign up failed. Please try again.")
        }
      } else if (data?.user) {
        if (data.user.identities && data.user.identities.length > 0 && !data.user.email_confirmed_at) {
          toast.info("Sign up successful! Please check your email to confirm your account.")
          router.push("/login?message=check_email")
        } else {
          toast.success("Sign up successful! Redirecting...")
          router.push("/")
        }
      } else {
        toast.error("An unexpected issue occurred during sign up. Please try again.")
      }
    } catch (err) {
      console.error("Signup submit error:", err)
      toast.error("Sign Up Failed", {
        description: "An unexpected error occurred. Please try again later."
      })
    } finally {
      setIsLoading(false)
    }
  }

  if (authLoading || user) {
    return (
      <div className="flex items-center justify-center min-h-screen bg-background">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
      </div>
    )
  }

  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl text-center">Create an account</CardTitle>
          <CardDescription className="text-center">Enter your email and password to sign up</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="m@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="password">Password</Label>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="confirmPassword">Confirm Password</Label>
              <Input
                id="confirmPassword"
                type="password"
                value={confirmPassword}
                onChange={(e) => setConfirmPassword(e.target.value)}
                required
                disabled={isLoading}
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={isLoading}>
              {isLoading ? "Creating account..." : "Sign up"}
            </Button>
          </CardFooter>
        </form>
        <CardFooter className="flex flex-col items-center justify-center space-y-2">
          <div className="text-sm text-muted-foreground">
            Already have an account?{" "}
            <Link href="/login" className="text-primary hover:underline">
              Sign in
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  )
}
// --- End of SignupContent component ---


=== layout-script.tsx ===
"use client"

import { useEffect } from "react"

export default function LayoutScript() {
  useEffect(() => {
    // Only register service worker in production and when in a browser context
    // that supports service workers
    if (typeof window !== "undefined" && "serviceWorker" in navigator) {
      // Check if we're in a development/preview environment
      const isPreviewEnvironment =
        window.location.hostname.includes("vusercontent.net") ||
        window.location.hostname.includes("vercel.app") ||
        window.location.hostname === "localhost" ||
        window.location.hostname === "127.0.0.1"

      if (isPreviewEnvironment) {
        console.log("Service Worker registration skipped in preview/development environment")
        return
      }

      // Only register in production environments
      window.addEventListener("load", () => {
        navigator.serviceWorker
          .register("/sw.js")
          .then((registration) => {
            console.log("Service Worker registered with scope:", registration.scope)
          })
          .catch((error) => {
            console.error("Service Worker registration failed:", error)
            // Continue app execution even if service worker fails
          })
      })
    }
  }, [])

  return null
}


=== tags/page.tsx ===
import React from 'react';
import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { ArrowLeft } from 'lucide-react';
import { cookies } from 'next/headers';
import { createServerClient } from '@/lib/supabase/server';
import { redirect } from 'next/navigation';
import { getTags } from '@/lib/actions/tagActions';
import { TagManagerClient } from '../../components/tags/TagManagerClient';

/**
 * Tags Management Page
 * 
 * This is a Server Component that pre-fetches all tags server-side
 * before rendering the page, eliminating client-side data fetching delays.
 * 
 * @returns {Promise<JSX.Element>} The Tags page with pre-fetched data
 */
export default async function ManageTagsPage() {
  // Check authentication server-side
  const supabase = createServerClient();
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  if (!session || authError) {
    redirect('/login');
  }

  // Pre-fetch all tags in a single server-side request
  const { data: tags, error: fetchError } = await getTags();

  return (
    <div className="container py-6">
      <div className="mb-6 flex items-center">
        <Button asChild variant="ghost" size="icon" className="mr-2">
          <Link href="/">
            <ArrowLeft className="h-4 w-4" />
          </Link>
        </Button>
        <h1 className="text-2xl font-bold">Manage Tags</h1>
      </div>
      
      <TagManagerClient initialTags={tags || []} />
    </div>
  );
} 
=== decks/create-choice/page.tsx ===
// app/decks/create-choice/page.tsx
"use client";

import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { ArrowLeft, FilePlus, BotMessageSquare, PencilLine } from 'lucide-react'; // Added PencilLine
import { useRouter } from 'next/navigation';

export default function CreateChoicePage() {
    const router = useRouter();

    return (
        <div className="container mx-auto max-w-lg px-4 py-8">
            <Button variant="outline" size="sm" onClick={() => router.back()} className="mb-6">
                 <ArrowLeft className="mr-2 h-4 w-4" />
                 Back
            </Button>

            <h1 className="text-2xl font-bold mb-6 text-center">How would you like to create a deck?</h1>

            <div className="grid grid-cols-1 gap-6">
                {/* Option 1: Manual Creation */}
                <Link href="/decks/new" legacyBehavior>
                    <a className="block hover:no-underline">
                        <Card className="hover:border-primary hover:shadow-md transition-all cursor-pointer">
                            <CardHeader className="flex flex-row items-center gap-4 pb-2">
                                <PencilLine className="h-8 w-8 text-primary" />
                                <div>
                                    <CardTitle>Create Manually</CardTitle>
                                    <CardDescription>Enter deck details and add cards yourself.</CardDescription>
                                </div>
                            </CardHeader>
                        </Card>
                    </a>
                </Link>

                {/* Option 2: AI from File/Image */}
                <Link href="/prepare/ai-generate" legacyBehavior>
                     <a className="block hover:no-underline">
                        <Card className="hover:border-primary hover:shadow-md transition-all cursor-pointer">
                             <CardHeader className="flex flex-row items-center gap-4 pb-2">
                                <BotMessageSquare className="h-8 w-8 text-primary" /> {/* Using Bot icon */}
                                <div>
                                    <CardTitle>Generate from File / Image (AI)</CardTitle>
                                    <CardDescription>Upload documents or photos to automatically create flashcards.</CardDescription>
                                </div>
                             </CardHeader>
                         </Card>
                     </a>
                </Link>

                {/* Add more options here in the future */}
                {/* Example:
                <Card className="opacity-50 cursor-not-allowed">
                    <CardHeader className="flex flex-row items-center gap-4 pb-2">
                        <LinkIcon className="h-8 w-8 text-muted-foreground" />
                        <div>
                            <CardTitle>Create from URL (Coming Soon)</CardTitle>
                            <CardDescription>Paste a web link to generate cards.</CardDescription>
                        </div>
                    </CardHeader>
                </Card>
                */}
            </div>
        </div>
    );
}
=== decks/new/page.tsx ===
// app/decks/new/page.tsx
"use client";

import type React from "react"; // Import React type if needed for specific typings
import { useState, useEffect, useCallback } from "react";
import { useRouter } from "next/navigation";
import { useSettings } from "@/providers/settings-provider"; // To get default language
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Switch } from "@/components/ui/switch";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { toast } from "sonner";
import { ArrowLeft, Loader2 as IconLoader } from "lucide-react"; // For loading state

/**
 * Page component for manually creating a new deck's metadata.
 * Collects name, language(s), and bilingual status, then calls the API
 * to create the deck shell before redirecting to the edit page.
 */
export default function NewDeckPage() {
    const router = useRouter();
    const { settings } = useSettings();

    // State for form inputs
    const [name, setName] = useState("");
    const [isBilingual, setIsBilingual] = useState(false);
    const [primaryLanguage, setPrimaryLanguage] = useState(""); // Renamed for clarity
    const [secondaryLanguage, setSecondaryLanguage] = useState(""); // Renamed for clarity
    const [loading, setLoading] = useState(false);

    // Set default languages based on user settings when component mounts
    useEffect(() => {
        if (settings?.appLanguage) {
            console.log("[NewDeckPage] Setting default language from settings:", settings.appLanguage);
            setPrimaryLanguage(settings.appLanguage);
            setSecondaryLanguage(settings.appLanguage); // Default secondary to same as primary
        } else {
            // Fallback if settings not loaded or no language set
             console.log("[NewDeckPage] No default language in settings, using 'en'.");
             setPrimaryLanguage("en");
             setSecondaryLanguage("en");
        }
    }, [settings]); // Re-run if settings change

    // Handler for language change when NOT bilingual
    const handleSingleLanguageChange = (value: string) => {
        setPrimaryLanguage(value);
        setSecondaryLanguage(value); // Keep them synced
    };

    // Form submission handler
    const handleSubmit = async (e: React.FormEvent) => {
        e.preventDefault(); // Prevent default form submission

        // Basic Validation
        if (!name.trim()) {
            toast.error("Deck name is required.");
            return;
        }
        if (!primaryLanguage) {
            toast.error("Primary language is required.");
            return;
        }
        if (isBilingual && !secondaryLanguage) {
             toast.error("Secondary language is required for bilingual decks.");
             return;
        }

        setLoading(true); // Indicate loading state
        const toastId = toast.loading("Creating deck...");

        // Prepare the payload for the API
        const payload = {
            name: name.trim(),
            questionLanguage: primaryLanguage, // Map state to API expected field name
            answerLanguage: isBilingual ? secondaryLanguage : primaryLanguage, // Use primary if not bilingual
            isBilingual: isBilingual,
            flashcards: [] // Send empty array for manual creation
        };

        console.log("[NewDeckPage] Sending payload to POST /api/decks:", payload);

        try {
            const response = await fetch('/api/decks', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            const result = await response.json();

            if (!response.ok) {
                // Handle API errors (like validation errors, auth errors, db errors)
                throw new Error(result.message || `HTTP error! status: ${response.status}`);
            }

            // Success!
            toast.success(`Deck "${payload.name}" created! Redirecting...`, { id: toastId });
            console.log("[NewDeckPage] Deck created successfully, API response:", result);

            // Redirect to the edit page for the new deck
            if (result.deckId) {
                router.push(`/edit/${result.deckId}`);
            } else {
                 // Should not happen if API returns correctly, but handle defensively
                 throw new Error("API succeeded but did not return a deck ID.");
            }

        } catch (error: any) {
            console.error("[NewDeckPage] Error creating deck:", error);
            toast.error("Failed to create deck", {
                id: toastId,
                description: error.message || "An unexpected error occurred.",
            });
            setLoading(false); // Stop loading on error
        }
        // No finally block needed for setLoading(false) because we navigate away on success
    };

    return (
        <div className="container mx-auto max-w-2xl px-4 py-8">
             <Button variant="outline" size="sm" onClick={() => router.back()} className="mb-4">
                 <ArrowLeft className="mr-2 h-4 w-4" />
                 Back
            </Button>

            <Card>
                <form onSubmit={handleSubmit}>
                    <CardHeader>
                        <CardTitle>Create New Deck</CardTitle>
                        <CardDescription>Enter the basic details for your new deck. You can add cards on the next screen.</CardDescription>
                    </CardHeader>
                    <CardContent className="grid gap-6">
                        {/* Deck Name */}
                        <div className="grid gap-2">
                            <Label htmlFor="name">Deck Name</Label>
                            <Input
                                id="name"
                                value={name}
                                onChange={(e) => setName(e.target.value)}
                                placeholder="e.g., French Vocabulary Chapter 1"
                                required
                                disabled={loading}
                            />
                        </div>

                        {/* Bilingual Switch */}
                        <div className="flex items-center space-x-2 rounded-lg border p-4">
                             <Switch
                                id="bilingual"
                                checked={isBilingual}
                                onCheckedChange={setIsBilingual}
                                disabled={loading}
                            />
                            <div className="flex-1">
                                <Label htmlFor="bilingual" className="font-medium">
                                    Bilingual Deck
                                </Label>
                                <p className="text-xs text-muted-foreground">
                                    Use different languages for questions (front) and answers (back).
                                </p>
                            </div>
                        </div>

                        {/* Language Selects */}
                        {isBilingual ? (
                            <div className="grid sm:grid-cols-2 gap-4">
                                <div className="grid gap-2">
                                    <Label htmlFor="primaryLanguage">Question Language (Front)</Label>
                                    <Select value={primaryLanguage} onValueChange={setPrimaryLanguage} required disabled={loading}>
                                        <SelectTrigger id="primaryLanguage">
                                            <SelectValue placeholder="Select language..." />
                                        </SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="en">English</SelectItem>
                                            <SelectItem value="nl">Dutch</SelectItem>
                                            <SelectItem value="fr">French</SelectItem>
                                            <SelectItem value="de">German</SelectItem>
                                            <SelectItem value="es">Spanish</SelectItem>
                                            <SelectItem value="it">Italian</SelectItem>
                                            {/* Add more languages as needed */}
                                        </SelectContent>
                                    </Select>
                                </div>
                                <div className="grid gap-2">
                                    <Label htmlFor="secondaryLanguage">Answer Language (Back)</Label>
                                    <Select value={secondaryLanguage} onValueChange={setSecondaryLanguage} required disabled={loading}>
                                        <SelectTrigger id="secondaryLanguage">
                                            <SelectValue placeholder="Select language..." />
                                        </SelectTrigger>
                                        <SelectContent>
                                            <SelectItem value="en">English</SelectItem>
                                            <SelectItem value="nl">Dutch</SelectItem>
                                            <SelectItem value="fr">French</SelectItem>
                                            <SelectItem value="de">German</SelectItem>
                                            <SelectItem value="es">Spanish</SelectItem>
                                            <SelectItem value="it">Italian</SelectItem>
                                            {/* Add more languages as needed */}
                                        </SelectContent>
                                    </Select>
                                </div>
                            </div>
                        ) : (
                            <div className="grid gap-2">
                                <Label htmlFor="language">Deck Language</Label>
                                <Select value={primaryLanguage} onValueChange={handleSingleLanguageChange} required disabled={loading}>
                                    <SelectTrigger id="language">
                                        <SelectValue placeholder="Select language..." />
                                    </SelectTrigger>
                                    <SelectContent>
                                        <SelectItem value="en">English</SelectItem>
                                        <SelectItem value="nl">Dutch</SelectItem>
                                        <SelectItem value="fr">French</SelectItem>
                                        <SelectItem value="de">German</SelectItem>
                                        <SelectItem value="es">Spanish</SelectItem>
                                        <SelectItem value="it">Italian</SelectItem>
                                        {/* Add more languages as needed */}
                                    </SelectContent>
                                </Select>
                            </div>
                        )}
                    </CardContent>
                    <CardFooter>
                        <Button type="submit" disabled={loading} className="w-full">
                            {loading ? <IconLoader className="mr-2 h-4 w-4 animate-spin" /> : null}
                            {loading ? "Creating..." : "Create Deck & Add Cards"}
                        </Button>
                    </CardFooter>
                </form>
            </Card>
        </div>
    );
}
=== edit/[deckId]/DeckDangerZone.tsx ===
// app/edit/[deckId]/DeckDangerZone.tsx
"use client";

import { memo } from 'react';
import { Button } from "@/components/ui/button";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
    AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { Trash2, Loader2 as IconLoader } from "lucide-react";

interface DeckDangerZoneProps {
    deckName: string;
    onDelete: () => Promise<void>; // The confirmed delete action
    isDeleting: boolean; // Loading state for delete button
}

export const DeckDangerZone = memo(({
    deckName,
    onDelete,
    isDeleting
}: DeckDangerZoneProps) => {

    return (
        <div className="mt-8 pt-6 border-t border-dashed border-destructive/50">
            <h3 className="text-lg font-semibold text-destructive mb-2">Danger Zone</h3>
            <p className="text-sm text-muted-foreground mb-4">Deleting this deck and all its cards cannot be undone.</p>
            <AlertDialog>
                <AlertDialogTrigger asChild>
                    <Button variant="destructive" disabled={isDeleting}>
                        {isDeleting ? <IconLoader className="mr-2 h-4 w-4 animate-spin" /> : <Trash2 className="mr-2 h-4 w-4" />}
                         Delete Deck
                    </Button>
                </AlertDialogTrigger>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        {/* Use template literal for dynamic title */}
                        <AlertDialogTitle>Delete "{deckName}"?</AlertDialogTitle>
                        <AlertDialogDescription>This action cannot be undone. This will permanently delete the deck and all associated cards.</AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel disabled={isDeleting}>Cancel</AlertDialogCancel>
                        {/* Call the onDelete prop when confirmed */}
                        <AlertDialogAction onClick={onDelete} disabled={isDeleting} className="bg-destructive hover:bg-destructive/90">
                            {isDeleting ? <IconLoader className="h-4 w-4 animate-spin mr-2" /> : null} Delete
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>
        </div>
    );
});

DeckDangerZone.displayName = 'DeckDangerZone';
=== edit/[deckId]/CardViewTabContent.tsx ===
// app/edit/[deckId]/CardViewTabContent.tsx
"use client";

import { memo } from 'react';
import { CardEditor } from "@/components/card-editor";
import { Button } from "@/components/ui/button";
import { Card as UICard, CardContent } from "@/components/ui/card"; // Alias Card component
import { Plus } from "lucide-react";
import type { Tables } from "@/types/database";

// --- Add Constants ---
const POS_OPTIONS: ReadonlyArray<string> = ['Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other', 'N/A'];
const GENDER_OPTIONS = [
    { value: 'Male', label: 'Male'},
    { value: 'Female', label: 'Female'},
    { value: 'Default', label: 'Neutral / Other'}
]; // Use 'Default' as the key for N/A/Neutral
const GENDER_KEYS: ReadonlyArray<string> = ['Male', 'Female', 'Default'] as const; // Keys matching GENDER_OPTIONS values
const GENDERED_POS: ReadonlyArray<string> = ['Noun', 'Adjective', 'Pronoun'] as const; // PoS types where gender selection is relevant
// ---------------------

type DbCard = Tables<'cards'>;
// --- Define input types matching useEditDeck handlers ---
type CreateCardInput = Pick<DbCard, 'question' | 'answer' | 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>;
type UpdateCardInput = Partial<CreateCardInput>;
// -------------------------------------------------------

interface CardViewTabContentProps {
    cards: Array<Partial<DbCard>>; // Can include new placeholders
    // --- Update callback signatures to match useEditDeck handlers ---
    onCreateCard: (data: CreateCardInput) => Promise<string | null>;
    onUpdateCard: (cardId: string, data: UpdateCardInput) => void;
    // -----------------------------------------------------------
    onDeleteCard: (cardId: string) => void;
    onAddNewCardClick: () => void; // Trigger adding a new placeholder
}

export const CardViewTabContent = memo(({
    cards,
    onCreateCard,
    onUpdateCard,
    onDeleteCard,
    onAddNewCardClick
}: CardViewTabContentProps) => {

    return (
        <div className="mt-6">
            {cards.length === 0 ? (
                <UICard>
                    <CardContent className="flex flex-col items-center justify-center p-6 h-40">
                        <p className="text-muted-foreground text-center mb-4">No cards in this deck yet</p>
                        <Button onClick={onAddNewCardClick}>
                            <Plus className="mr-2 h-4 w-4" />
                            Add Your First Card
                        </Button>
                    </CardContent>
                </UICard>
            ) : (
                <div className="space-y-4">
                    {cards.map((cardData, index) => (
                        <CardEditor
                            // Use temporary ID for new cards or real ID for existing
                            key={cardData.id || `new-${index}`}
                            card={cardData}
                            // --- Pass down the action handlers directly --- They now have the correct signature
                            onUpdate={onUpdateCard}
                            onDelete={onDeleteCard}
                            onCreate={!cardData.id || cardData.id.startsWith('new-') ? onCreateCard : undefined} // Pass onCreate if it's a placeholder
                            // -------------------------------------------
                        />
                    ))}
                </div>
            )}

            {/* Always show Add Card button at the bottom if needed */}
            {cards.length >= 0 && ( // Show even if empty to allow first add
                <div className="flex justify-center mt-6">
                    <Button onClick={onAddNewCardClick}>
                        <Plus className="mr-2 h-4 w-4" />
                        Add Card
                    </Button>
                </div>
            )}
        </div>
    );
});

CardViewTabContent.displayName = 'CardViewTabContent';
=== edit/[deckId]/DeckMetadataEditor.tsx ===
// app/edit/[deckId]/DeckMetadataEditor.tsx
"use client";

import { memo } from 'react';
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import type { Tables, Json } from "@/types/database"; // Make sure Json is imported if needed, though not directly used here

type DbDeck = Tables<'decks'>;

interface DeckMetadataEditorProps {
    name: string;
    // Allow null from the parent state
    primaryLanguage: string | null;
    secondaryLanguage: string | null;
    isBilingual: boolean;
    // The callback expects Partial<Pick<...>> which implies undefined for optional fields
    onChange: (updates: Partial<Pick<DbDeck, 'name' | 'primary_language' | 'secondary_language' | 'is_bilingual'>>) => void;
    isSaving?: boolean;
}

export const DeckMetadataEditor = memo(({
    name,
    primaryLanguage,
    secondaryLanguage,
    isBilingual,
    onChange,
    isSaving
}: DeckMetadataEditorProps) => {

    const handleBilingualChange = (checked: boolean) => {
        // --- FIX: Convert null to undefined when updating ---
        const secondaryUpdate = !checked
            ? { secondary_language: primaryLanguage ?? undefined } // Convert null to undefined
            : {}; // No change to secondary if turning bilingual ON

        onChange({
            is_bilingual: checked,
            ...secondaryUpdate
        });
    };

    const handlePrimaryLangChange = (value: string) => {
        // --- FIX: Convert null to undefined when updating ---
        const secondaryUpdate = !isBilingual
            ? { secondary_language: value ?? undefined } // Update secondary if not bilingual (value won't be null here, but good practice)
            : {};

        onChange({
            primary_language: value ?? undefined, // Ensure primary is also undefined if needed, although Select usually gives string
            ...secondaryUpdate
        });
    };

     const handleSecondaryLangChange = (value: string) => {
         // Secondary change only matters if bilingual is on
         if (isBilingual) {
            onChange({
                secondary_language: value ?? undefined // Convert null to undefined if Select somehow returns it
            });
         }
    };


    return (
        <div className="space-y-6">
            {/* Deck Name Input */}
            <div>
                <Label htmlFor="deckNameInput">Deck Name</Label>
                <Input
                    id="deckNameInput"
                    value={name}
                    onChange={(e) => onChange({ name: e.target.value })}
                    className="mt-1"
                    placeholder="Enter deck name"
                    disabled={isSaving}
                />
                 {isSaving && <p className="text-sm text-muted-foreground mt-1">Saving...</p>}
            </div>

            {/* Language Settings Section */}
            <div className="p-4 border rounded-lg space-y-4">
                <div className="flex items-center justify-between">
                    <div>
                        <h3 className="font-medium">Bilingual Mode</h3>
                        <p className="text-sm text-muted-foreground">
                            Enable different languages for front and back
                        </p>
                    </div>
                    <Switch
                        checked={isBilingual}
                        onCheckedChange={handleBilingualChange}
                        disabled={isSaving}
                    />
                </div>

                {isBilingual ? (
                    <div className="grid gap-4 sm:grid-cols-2 pt-4 border-t">
                        <div>
                            <Label htmlFor="primaryLanguage">Front/Primary Language</Label>
                            <Select
                                value={primaryLanguage ?? undefined} // Pass undefined to Select if null
                                onValueChange={handlePrimaryLangChange}
                                disabled={isSaving}
                            >
                                <SelectTrigger id="primaryLanguage"><SelectValue placeholder="Select language" /></SelectTrigger>
                                <SelectContent> <SelectItem value="en">English</SelectItem> <SelectItem value="nl">Dutch</SelectItem> <SelectItem value="fr">French</SelectItem> <SelectItem value="de">German</SelectItem> <SelectItem value="es">Spanish</SelectItem> <SelectItem value="it">Italian</SelectItem> </SelectContent>
                            </Select>
                        </div>
                        <div>
                            <Label htmlFor="secondaryLanguage">Back/Secondary Language</Label>
                            <Select
                                value={secondaryLanguage ?? undefined} // Pass undefined to Select if null
                                onValueChange={handleSecondaryLangChange} // Use dedicated handler
                                disabled={isSaving}
                            >
                                <SelectTrigger id="secondaryLanguage"><SelectValue placeholder="Select language" /></SelectTrigger>
                                <SelectContent> <SelectItem value="en">English</SelectItem> <SelectItem value="nl">Dutch</SelectItem> <SelectItem value="fr">French</SelectItem> <SelectItem value="de">German</SelectItem> <SelectItem value="es">Spanish</SelectItem> <SelectItem value="it">Italian</SelectItem> </SelectContent>
                            </Select>
                        </div>
                    </div>
                ) : (
                    <div className="pt-4 border-t">
                        <Label htmlFor="language">Language</Label>
                        <Select
                            value={primaryLanguage ?? undefined} // Pass undefined to Select if null
                            onValueChange={handlePrimaryLangChange} // This handler updates both if not bilingual
                            disabled={isSaving}
                        >
                            <SelectTrigger id="language"><SelectValue placeholder="Select language" /></SelectTrigger>
                            <SelectContent> <SelectItem value="en">English</SelectItem> <SelectItem value="nl">Dutch</SelectItem> <SelectItem value="fr">French</SelectItem> <SelectItem value="de">German</SelectItem> <SelectItem value="es">Spanish</SelectItem> <SelectItem value="it">Italian</SelectItem> </SelectContent>
                        </Select>
                    </div>
                )}
            </div>
        </div>
    );
});

DeckMetadataEditor.displayName = 'DeckMetadataEditor';
=== edit/[deckId]/TableViewTabContent.tsx ===
// app/edit/[deckId]/TableViewTabContent.tsx
"use client";

import { memo } from 'react';
import { EditableCardTable } from "@/components/deck/EditableCardTable"; // Assuming this component exists and works
import { Button } from "@/components/ui/button";
import { Card as UICard, CardContent } from "@/components/ui/card"; // Alias Card component
import { Plus } from "lucide-react";
import type { Tables } from "@/types/database";

type DbCard = Tables<'cards'>;

interface TableViewTabContentProps {
    // Expects only cards with actual IDs for the table view
    cards: Array<DbCard>;
    deckId: string;
    // Callback when the table signals an update (e.g., after inline edit save)
    onCardUpdated: (updatedCard: DbCard) => void; // Or maybe just refetch? Depends on EditableCardTable
    // Trigger adding a new placeholder/row (might need separate handling than card view)
    onAddNewCardClick: () => void;
}

export const TableViewTabContent = memo(({
    cards,
    deckId,
    onCardUpdated,
    onAddNewCardClick
}: TableViewTabContentProps) => {

    return (
        <div className="mt-6">
            {cards.length > 0 ? (
                <EditableCardTable
                    initialCards={cards}
                    deckId={deckId}
                    onCardUpdated={onCardUpdated} // Pass handler down
                     // Consider if EditableCardTable needs other props like delete handlers
                />
            ) : (
                <UICard>
                    <CardContent className="flex flex-col items-center justify-center p-6 h-40">
                        <p className="text-muted-foreground text-center mb-4">No cards to display in table view.</p>
                        {/* Optionally show Add button here too */}
                    </CardContent>
                </UICard>
            )}
            {/* Add Button Below Table */}
            <div className="flex justify-center mt-6">
                <Button onClick={onAddNewCardClick}>
                    <Plus className="mr-2 h-4 w-4" />
                    Add Card
                </Button>
            </div>
        </div>
    );
});

TableViewTabContent.displayName = 'TableViewTabContent';
=== edit/[deckId]/useEditDeck.ts ===
// app/edit/[deckId]/useEditDeck.ts
"use client";

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
// Assuming useDecks provides getDeck, updateDeck, deleteDeck and their loading state
import { useDecks } from "@/hooks/use-decks";
// Assuming card actions exist and follow ActionResult pattern
import { createCard as createCardAction, updateCard as updateCardAction, deleteCard as deleteCardAction } from "@/lib/actions/cardActions";
// Import your DB types generated by Supabase
import type { Tables, Json } from "@/types/database";
// Assuming useDecks defines this type for its updateDeck action payload
import type { UpdateDeckParams } from "@/hooks/use-decks";
// For user feedback
import { toast } from "sonner";
// For debouncing saves
import { debounce } from "@/lib/utils";
// --- Import NEW Deck Tag actions --- 
import { addTagToDeck, removeTagFromDeck } from '@/lib/actions/tagActions';
// --- Update state type to include tags --- 
// Use the DeckWithCardsAndTags type which includes the tags array
// Assuming useDecks.getDeck returns this structure now
import type { DeckWithCardsAndTags } from "@/hooks/use-decks"; // Import the combined type

// Type aliases for better readability
type DbDeck = Tables<'decks'>;
type DbCard = Tables<'cards'>;
type DbTag = Tables<'tags'>; // Added Tag type alias

// Define the input type for creating a card (matches server action expectation)
// Add the new classification fields here
type CreateCardInput = Pick<DbCard, 'question' | 'answer' | 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>;

// Define the input type for updating a card (matches server action expectation)
// All fields are optional
type UpdateCardInput = Partial<CreateCardInput>;

// Define the state type managed by this hook
// Base it on the imported type but explicitly allow partial cards in the state
export type DeckEditState = (Omit<DeckWithCardsAndTags, 'cards'> & { cards: Array<Partial<DbCard>> }) | null;

// Debounce time for auto-saving metadata (in milliseconds)
const DECK_UPDATE_DEBOUNCE_MS = 1500;

// Interface for storing previous/initial metadata state for comparison logic
interface MetadataState {
    name?: string | null;
    primary_language?: string | null;
    secondary_language?: string | null;
    is_bilingual?: boolean | null;
}

/**
 * Custom hook to manage the state and logic for editing a deck.
 *
 * @param deckId The ID of the deck to edit (from route params), or undefined if creating/invalid.
 * @returns An object containing the deck state, loading/error status, and action handlers.
 */
export function useEditDeck(deckId: string | undefined) {
    const router = useRouter();
    // Get deck-related actions and loading state from the dedicated useDecks hook
    const { getDeck, updateDeck, deleteDeck, loading: useDecksLoading } = useDecks();

    // --- State Definitions ---
    const [deck, setDeck] = useState<DeckEditState>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isSavingMetadata, setIsSavingMetadata] = useState(false);
    const [isDeletingDeck, setIsDeletingDeck] = useState(false);

    // --- Refs for Internal Logic ---
    const isMountedRef = useRef(false); // Track initial load completion
    // Ref to store the last *successfully saved* or initially loaded metadata state
    const previousSavedMetadataRef = useRef<MetadataState>({});


    // --- Data Fetching Logic ---
    const loadDeckData = useCallback(async (id: string) => {
        console.log(`[useEditDeck] Loading deck data for ID: ${id}`);
        setLoading(true); setError(null);
        isMountedRef.current = false; // Reset load flag
        previousSavedMetadataRef.current = {}; // Reset saved state ref
        try {
            const result = await getDeck(id);
            if (result.error) throw new Error(result.error);
            if (result.data) {
                // Store in the state with cards explicitly as Partial<DbCard>[]
                const fetchedDeckForState: DeckEditState = {
                    ...result.data,
                    cards: (result.data.cards || []) as Array<Partial<DbCard>> // Cast to partial for state
                };
                console.log("[useEditDeck] Fetched Deck Data for State:", fetchedDeckForState);
                setDeck(fetchedDeckForState); 
                // Null check before accessing properties
                if (fetchedDeckForState) { 
                    previousSavedMetadataRef.current = {
                        name: fetchedDeckForState.name,
                        primary_language: fetchedDeckForState.primary_language,
                        secondary_language: fetchedDeckForState.secondary_language,
                        is_bilingual: fetchedDeckForState.is_bilingual,
                    };
                    isMountedRef.current = true;
                    console.log("[useEditDeck] Initial deck loaded. Metadata ref set.", previousSavedMetadataRef.current);
                } else {
                     isMountedRef.current = false;
                     console.warn("[useEditDeck] Fetched deck data was unexpectedly null after check.");
                }
            } else {
                // Deck not found case
                setDeck(null); // Ensure deck state is null
                setError("Deck not found or access denied."); // Set error message
                isMountedRef.current = false; 
                console.log("[useEditDeck] Deck not found or access denied, setting state to null.");
            }
        } catch (err: any) {
             console.error("[useEditDeck] Error loading deck:", err);
              setError(err.message || "Failed to load deck.");
              setDeck(null);
              isMountedRef.current = false;
        } finally {
            setLoading(false);
        }
    }, [getDeck]);

    // Initial load effect
    useEffect(() => {
        isMountedRef.current = false; // Reset on ID change
        previousSavedMetadataRef.current = {};
        if (deckId && !useDecksLoading) {
            loadDeckData(deckId);
        } else if (!deckId) {
            setError("No Deck ID provided."); setLoading(false);
        } else if (useDecksLoading) {
            console.log("[useEditDeck] Waiting for useDecks hook to finish loading...");
            setLoading(true);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [deckId, useDecksLoading]);


    // --- Deck Metadata Updates ---

    // Debounced function responsible for calling the actual update action
    const debouncedSaveMetadata = useCallback(
        debounce(async (deckIdToSave: string, payloadToSave: UpdateDeckParams) => {
            if (!isMountedRef.current) {
                console.warn("[useEditDeck] Debounced save skipped: Initial load not complete.");
                return;
            }

            console.log("[useEditDeck] Debounced Save Metadata EXECUTION for ID:", deckIdToSave, "Payload:", payloadToSave);
            setIsSavingMetadata(true);
            try {
                const result = await updateDeck(deckIdToSave, payloadToSave);

                if (result.error) {
                    toast.error("Deck settings auto-save failed", { description: result.error });
                } else {
                    console.log("[useEditDeck] Deck settings auto-saved successfully to DB.");
                    // Update the ref ONLY after successful save
                    if (result.data) {
                         previousSavedMetadataRef.current = {
                            name: result.data.name,
                            primary_language: result.data.primary_language,
                            secondary_language: result.data.secondary_language,
                            is_bilingual: result.data.is_bilingual,
                         };
                         console.log("[useEditDeck] Updated previousSavedMetadataRef after successful save.");
                    }
                     // *** NO setDeck() call here ***
                }
            } catch (error: any) {
                console.error("[useEditDeck] Error during debouncedSaveMetadata execution:", error);
                toast.error("Deck settings auto-save failed", { description: error.message || "Unknown error" });
            } finally {
                setIsSavingMetadata(false);
            }
        }, DECK_UPDATE_DEBOUNCE_MS),
        [updateDeck] // Stable dependency
    );

    // Handler called by the DeckMetadataEditor component when user input changes
    const handleDeckMetadataChange = useCallback((updates: Partial<DbDeck>) => {
        console.log('[DEBUG] handleDeckMetadataChange called with updates:', updates);
        // --- Use DeckEditState type for callback param and return --- 
        setDeck((prevDeckState: DeckEditState): DeckEditState => {
            if (!prevDeckState) return null;
            // Ensure cards remain Array<Partial<DbCard>>
            return { ...prevDeckState, ...updates }; 
        });
        // --- Trigger debounce after state update --- 
        if (isMountedRef.current && deck?.id && previousSavedMetadataRef.current) {
            const currentMetadataPayload: MetadataState = {
               name: updates.name ?? deck.name,
               primary_language: updates.primary_language ?? deck.primary_language,
               secondary_language: updates.secondary_language ?? deck.secondary_language,
               is_bilingual: updates.is_bilingual ?? deck.is_bilingual,
            };

            let changed = false;
            if (currentMetadataPayload.name !== previousSavedMetadataRef.current.name) changed = true;
            if (currentMetadataPayload.primary_language !== previousSavedMetadataRef.current.primary_language) changed = true;
            if (currentMetadataPayload.secondary_language !== previousSavedMetadataRef.current.secondary_language) changed = true;
            if (currentMetadataPayload.is_bilingual !== previousSavedMetadataRef.current.is_bilingual) changed = true;

            if (changed) {
                console.log("[DEBUG] Change detected from initial/last save. Queuing debounced metadata save.");
                const payloadToSave: UpdateDeckParams = {
                    name: currentMetadataPayload.name ?? undefined,
                    primary_language: currentMetadataPayload.primary_language ?? undefined,
                    secondary_language: currentMetadataPayload.secondary_language ?? undefined,
                    is_bilingual: currentMetadataPayload.is_bilingual ?? undefined,
                };
                debouncedSaveMetadata(deck.id, payloadToSave);
            } else {
                console.log("[DEBUG] No change detected from initial/last save. Save trigger skipped.");
            }
        }
        // -------------------------------------------
    }, [debouncedSaveMetadata, deck]); // Added deck dependency for check


    // --- Card Actions ---
    const handleAddCardOptimistic = useCallback(() => {
         if (!deck) return;
         // Generate a unique temporary ID for the placeholder
         const tempId = `new-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
         const newCardPlaceholder: Partial<DbCard> = {
             id: tempId, // Use unique temp ID
             question: "",
             answer: "",
             question_part_of_speech: null, // Initialize new fields
             question_gender: null,
             answer_part_of_speech: null,
             answer_gender: null,
             deck_id: deck.id,
             user_id: deck.user_id,
             // Default SRS fields
             srs_level: 0,
             easiness_factor: 2.5,
             interval_days: 0,
             stability: 0,
             difficulty: 0,
             last_review_grade: null,
             last_reviewed_at: null,
             next_review_due: null,
             correct_count: 0,
             incorrect_count: 0,
             attempt_count: 0
         };
         // --- Use DeckEditState type --- 
         setDeck((prev: DeckEditState): DeckEditState => {
             if (!prev) return null;
             const updatedCards: Array<Partial<DbCard>> = [...prev.cards, newCardPlaceholder];
             return { ...prev, cards: updatedCards };
         });
         console.log("[useEditDeck] Added optimistic card placeholder:", newCardPlaceholder.id);
    }, [deck]);

    const handleCreateCard = useCallback(async (cardData: CreateCardInput): Promise<string | null> => {
        if (!deck || !deck.id) { toast.error("Cannot create card: Deck missing."); return null; }

        // Find the temporary ID of the card being created (assuming it's the last one)
        // A more robust approach might involve passing the tempId from the component
        const tempCard = deck.cards.find(c => c.id?.startsWith('new-'));
        const tempId = tempCard?.id;

        const toastId = toast.loading("Saving new card...");
        try {
            const result = await createCardAction(deck.id, cardData);
            if (result.error || !result.data) throw result.error || new Error("Failed to create card.");

            const savedCard = result.data;
            toast.success(`New card created!`, { id: toastId });

            // --- Optimistic Update: Replace placeholder with saved card --- 
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const updatedCards = prev.cards.map(c => 
                    c.id === tempId ? savedCard : c // Replace placeholder
                );
                // If placeholder wasn't found (edge case), add the saved card
                if (!tempId || !updatedCards.some(c => c.id === savedCard.id)) {
                   console.warn("[useEditDeck] Placeholder not found for optimistic update, adding saved card directly.");
                   updatedCards.push(savedCard);
                }
                return { ...prev, cards: updatedCards };
            });
            // --------------------------------------------------------------

            // await loadDeckData(deck.id); // Removed: Replaced with optimistic update
            return savedCard.id;

        } catch (error: any) {
            toast.error("Failed to save new card", { id: toastId, description: error.message || "Unknown error." });
            // --- Remove placeholder on error --- 
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                // Filter out the specific placeholder if tempId was found, otherwise filter all placeholders
                const filteredCards: Array<Partial<DbCard>> = tempId 
                    ? prev.cards.filter((c: Partial<DbCard>) => c.id !== tempId)
                    : prev.cards.filter((c: Partial<DbCard>) => !c.id?.startsWith('new-'));
                return { ...prev, cards: filteredCards };
            });
            // -----------------------------------
            return null;
        }
    }, [deck /*, loadDeckData */]); // Removed loadDeckData from dependencies

    // Wrap the core update logic in a ref to keep the useCallback stable
    const updateCardCore = useCallback(async (cardId: string, cardData: UpdateCardInput) => {
        const toastId = toast.loading("Updating card...");
        let originalCards: Array<Partial<DbCard>> | null = null;

        // --- Optimistic UI Update (Apply changes locally first using functional update) ---
        setDeck((prev: DeckEditState): DeckEditState => {
            if (!prev) return null;
            originalCards = prev.cards; // Capture original cards *before* update
            const updatedCards = prev.cards.map(c => 
                c.id === cardId ? { ...c, ...cardData } : c
            );
            return { ...prev, cards: updatedCards };
        });
        // ----------------------------------------------------------------------------

        try {
            const result = await updateCardAction(cardId, cardData);
            if (result.error || !result.data) throw result.error || new Error("Failed to update card.");

            const savedCard = result.data;
            toast.success("Card updated!", { id: toastId });

            // --- Update local state with confirmed data from server --- 
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const confirmedCards = prev.cards.map(c => 
                    c.id === cardId ? savedCard : c
                );
                return { ...prev, cards: confirmedCards };
            });
            // ----------------------------------------------------------

        } catch (error: any) {
            toast.error("Failed to update card", { id: toastId, description: error.message || "Unknown error." });
            // --- Revert to original state on error using functional update ---
            // Capture originalCards *inside* the functional update to ensure prev is not null
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) {
                    // Should not happen if update was attempted, but handle defensively
                    console.error("[useEditDeck] Cannot revert card update: Previous state was null.");
                    return null; 
                }
                // Capture original cards here, *after* confirming prev is not null
                const originalCards = prev.cards; 
                console.log("[useEditDeck] Reverting card update due to error.");
                return { ...prev, cards: originalCards }; 
            });
            // ---------------------------------------------------------------
        }
    }, []); // Keep dependencies empty or only include truly stable functions like updateCardAction if needed

    // The stable callback passed down to components
    const handleUpdateCard = useCallback(async (cardId: string, cardData: UpdateCardInput) => {
        console.log(`[useEditDeck] handleUpdateCard called for ID: ${cardId}`); // Log call initiation
        // Placeholder card check (remains the same)
        if (cardId.startsWith('new-')) {
             const placeholderCard = deck?.cards.find(c => c.id === cardId);
             if (placeholderCard?.question && placeholderCard?.answer) {
                 // Note: handleCreateCard might need similar stabilization if it depends on deck
                 await handleCreateCard({
                     question: placeholderCard.question,
                     answer: placeholderCard.answer,
                     question_part_of_speech: placeholderCard.question_part_of_speech ?? null,
                     question_gender: placeholderCard.question_gender ?? null,
                     answer_part_of_speech: placeholderCard.answer_part_of_speech ?? null,
                     answer_gender: placeholderCard.answer_gender ?? null,
                 });
             }
            return; 
        }
        // Call the core logic
        updateCardCore(cardId, cardData);

    }, [deck, handleCreateCard, updateCardCore]); // Keep `deck` dependency here for the placeholder check

    const handleDeleteCard = useCallback(async (cardId: string) => {
        if (!deck) return;
        // --- Optimistic UI Update (Remove card locally first) ---
        const originalCards = deck.cards;
        setDeck((prev: DeckEditState): DeckEditState => {
            if (!prev) return null;
            const updatedCards = prev.cards.filter(c => c.id !== cardId);
            return { ...prev, cards: updatedCards };
        });
        // -------------------------------------------------------
        const toastId = toast.loading("Deleting card...");
        try {
            const result = await deleteCardAction(cardId);
            if (result.error) throw result.error;
            toast.success("Card deleted!", { id: toastId });
            // No need to update state further, already removed optimistically
            // await loadDeckData(deck.id); // Removed
        } catch (error: any) {
            toast.error("Failed to delete card", { id: toastId, description: error.message || "Unknown error." });
            // --- Revert to original state on error ---
            setDeck((prev: DeckEditState): DeckEditState => {
                 if (!prev) return null;
                 return { ...prev, cards: originalCards }; // Restore original cards array
            });
            // -------------------------------------------
        }
    }, [deck /*, loadDeckData */]); // Removed loadDeckData


    // --- Deck Deletion ---
    const handleDeleteDeckConfirm = useCallback(async (): Promise<void> => {
        if (!deck || !deck.id) { toast.error("Cannot delete deck: data missing."); return; }
        setIsDeletingDeck(true);
        const deckName = deck.name;
        try {
            const result = await deleteDeck(deck.id);
            if (result.error) throw new Error(result.error);
            toast.success(`Deck "${deckName}" deleted successfully!`);
            router.push('/');
        } catch (error: any) {
            toast.error(`Failed to delete deck "${deckName}"`, { description: error.message || "Unknown error." });
            setIsDeletingDeck(false);
        }
    }, [deck, deleteDeck, router]);

    // --- NEW: Deck Tag Handlers ---
    const handleAddTagToDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot add tag: Deck not loaded.");
            return;
        }
        console.log(`[useEditDeck] Adding tag ${tagId} to deck ${deck.id}`);
        const toastId = toast.loading("Adding tag...");
        try {
            const result = await addTagToDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag added to deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            console.error("[useEditDeck] Error adding tag to deck:", error);
            toast.error("Failed to add tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData

    const handleRemoveTagFromDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot remove tag: Deck not loaded.");
            return;
        }
        console.log(`[useEditDeck] Removing tag ${tagId} from deck ${deck.id}`);
        const toastId = toast.loading("Removing tag...");
        try {
            const result = await removeTagFromDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag removed from deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            console.error("[useEditDeck] Error removing tag from deck:", error);
            toast.error("Failed to remove tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData
    // --------------------------------

    // --- Return Values ---
    return {
        deck,
        // Extract tags from deck state, provide empty array if deck is null
        deckTags: deck?.tags ?? [], 
        loading: loading || useDecksLoading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        loadDeckData,
        handleDeckMetadataChange, // Expose the handler that triggers the save
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleAddTagToDeck, // Expose new handler
        handleRemoveTagFromDeck, // Expose new handler
        handleDeleteDeckConfirm,
    };
}
=== edit/[deckId]/page.tsx ===
// app/edit/[deckId]/page.tsx
"use client";

import { useState } from "react";
import { useParams, useRouter } from "next/navigation"; // Keep useRouter if needed for back button etc.
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { ArrowLeft } from "lucide-react";
// Import the new hook and components
import { useEditDeck } from "./useEditDeck";
import { DeckMetadataEditor } from "./DeckMetadataEditor";
import { CardViewTabContent } from "./CardViewTabContent";
import { TableViewTabContent } from "./TableViewTabContent";
import { DeckDangerZone } from "./DeckDangerZone";
import { DeckTagEditor } from '@/components/deck-tag-editor';
import type { Tables } from "@/types/database"; // Keep type import

type DbCard = Tables<'cards'>;

/**
 * Refactored Edit Deck Page Component.
 *
 * Orchestrates the editing process using the `useEditDeck` hook and specialized
 * sub-components for metadata, card view, table view, and deletion.
 */
export default function EditDeckPage() {
    const params = useParams<{ deckId: string }>();
    const deckId = params?.deckId;
    const router = useRouter();

    // Use the custom hook to manage state and actions
    const {
        deck,
        deckTags,
        loading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        // loadDeckData, // Can be called directly if needed (e.g., manual refresh button)
        handleDeckMetadataChange,
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleAddTagToDeck,
        handleRemoveTagFromDeck,
        handleDeleteDeckConfirm,
    } = useEditDeck(deckId);

    const [activeTab, setActiveTab] = useState("cards");

    // --- Loading State ---
    if (loading) {
        return (
            <div className="flex justify-center items-center h-screen">
                <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
            </div>
        );
    }

    // --- Error State ---
    if (error) {
        return (
            <div className="container mx-auto px-4 py-8">
                <div className="flex flex-col items-center justify-center">
                    <h2 className="text-xl font-semibold text-red-500 mb-4">Error Loading Deck</h2>
                    <p className="text-muted-foreground mb-6">{error}</p>
                    <Button onClick={() => router.push("/")}>Return to Home</Button>
                </div>
            </div>
        );
    }

    // --- Deck Not Found State ---
    if (!deck) {
        // This case covers both initial load failure where deck is null
        // and the case where getDeck returns null data (deck truly not found)
        return (
            <div className="container mx-auto px-4 py-8">
                <div className="flex flex-col items-center justify-center">
                    <h2 className="text-xl font-semibold mb-4">Deck Not Found</h2>
                    <p className="text-muted-foreground mb-6">The deck you're looking for doesn't exist or couldn't be loaded.</p>
                    <Button onClick={() => router.push("/")}>Return to Home</Button>
                </div>
            </div>
        );
    }

    // --- Main Render ---
    return (
        <div className="py-4 px-4 md:p-6 max-w-4xl mx-auto">
            {/* Header */}
            <div className="flex items-center justify-between mb-6">
                <h1 className="text-2xl font-bold truncate pr-4" title={deck.name}>Edit Deck: {deck.name}</h1>
                <Button variant="outline" onClick={() => router.back()}>
                    <ArrowLeft className="mr-2 h-4 w-4" />
                    Back
                </Button>
            </div>

            {/* Deck Metadata Editor */}
            <div className="mb-6 space-y-6">
                <DeckMetadataEditor
                    name={deck.name}
                    primaryLanguage={deck.primary_language}
                    secondaryLanguage={deck.secondary_language}
                    isBilingual={deck.is_bilingual}
                    onChange={handleDeckMetadataChange}
                    isSaving={isSavingMetadata}
                />
                <DeckTagEditor 
                    deckId={deck.id}
                    currentTags={deckTags} 
                    onAddTag={handleAddTagToDeck}
                    onRemoveTag={handleRemoveTagFromDeck}
                />
            </div>

            {/* Card Tabs */}
            <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
                <TabsList className="grid w-full grid-cols-2">
                    <TabsTrigger value="cards">Card View</TabsTrigger>
                    <TabsTrigger value="table">Table View</TabsTrigger>
                </TabsList>

                <TabsContent value="cards">
                    <CardViewTabContent
                        cards={deck.cards}
                        onCreateCard={handleCreateCard}
                        onUpdateCard={handleUpdateCard}
                        onDeleteCard={handleDeleteCard}
                        onAddNewCardClick={handleAddCardOptimistic}
                    />
                </TabsContent>

                <TabsContent value="table">
                     <TableViewTabContent
                         // Filter out placeholder cards before passing to table
                         cards={deck.cards.filter(c => c.id && !c.id.startsWith('new-')) as DbCard[]}
                         deckId={deck.id}
                         // Decide how table updates should reflect - refetch or update local state?
                         // Option 1: Assume table handles its own saving and parent just needs to know
                         onCardUpdated={(updatedCard) => {
                              console.log("Card updated via table:", updatedCard.id);
                              // Option: Update local state directly (if needed)
                              // setDeck(prev => ...)
                              // Option: Or trigger a full refetch
                              // loadDeckData(deck.id);
                         }}
                         onAddNewCardClick={handleAddCardOptimistic}
                     />
                 </TabsContent>
            </Tabs>

            {/* Danger Zone */}
            <DeckDangerZone
                deckName={deck.name}
                onDelete={handleDeleteDeckConfirm}
                isDeleting={isDeletingDeck}
            />

        </div>
    );
}
=== profile/page.tsx ===
"use client"

import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { ArrowLeft, LogOut } from "lucide-react"
import Link from "next/link"
import { useAuth } from "@/hooks/use-auth"
import { toast } from "sonner"
import type { AuthError } from "@supabase/supabase-js"

export default function ProfilePage() {
  const { user, signOut, loading: authLoading } = useAuth()
  const router = useRouter()
  const [signOutLoading, setSignOutLoading] = useState(false)

  useEffect(() => {
    if (!authLoading) {
      if (!user) {
        const callbackUrl = encodeURIComponent('/profile');
        console.log("Profile page: User not authenticated, redirecting to login.");
        router.push(`/login?callbackUrl=${callbackUrl}`);
      }
    }
  }, [authLoading, user, router]);

  const handleSignOut = async () => {
    setSignOutLoading(true)
    const { error } = await signOut()

    if (error) {
      console.error("Error signing out:", error)
      if (error instanceof Error) {
        toast.error(error.message || "An unexpected error occurred during sign out.")
      } else {
        const errorMessage = (error as AuthError)?.message || "Sign out failed. Please try again.";
        toast.error(errorMessage)
      }
      setSignOutLoading(false)
    } else {
      toast.success("Signed out successfully.")
    }
  }

  if (authLoading) {
    return (
      <main className="container mx-auto px-4 py-8">
        <div className="flex justify-between items-center mb-6">
           <h1 className="text-2xl font-bold">Profile</h1>
        </div>
        <div className="max-w-2xl mx-auto text-center">
          Loading profile...
        </div>
      </main>
    );
  }

  if (!user) {
    return (
      <main className="container mx-auto px-4 py-8">
        <div className="flex justify-between items-center mb-6">
           <h1 className="text-2xl font-bold">Profile</h1>
        </div>
        <div className="max-w-2xl mx-auto text-center">
          Redirecting to login...
        </div>
      </main>
    );
  }

  return (
    <main className="container mx-auto px-4 py-8">
      <div className="flex justify-between items-center mb-6">
        <div className="flex items-center">
          <Link href="/" className="mr-4">
            <Button variant="ghost" size="icon">
              <ArrowLeft className="h-5 w-5" />
            </Button>
          </Link>
          <h1 className="text-2xl font-bold">Profile</h1>
        </div>
      </div>

      <div className="max-w-2xl mx-auto">
        <Card className="mb-6">
          <CardHeader>
            <CardTitle>User Profile</CardTitle>
            <CardDescription>Your account information</CardDescription>
          </CardHeader>
          <CardContent>
            <div className="space-y-2">
              <p>
                <strong>Email:</strong> {user.email}
              </p>
              <p>
                <strong>User ID:</strong> {user.id}
              </p>
              <p>
                <strong>Last Sign In:</strong>{" "}
                {user.last_sign_in_at ? new Date(user.last_sign_in_at).toLocaleString() : "N/A"}
              </p>
            </div>
          </CardContent>
          <CardFooter>
            <Button variant="destructive" onClick={handleSignOut} disabled={signOutLoading}>
              <LogOut className="mr-2 h-4 w-4" />
              {signOutLoading ? "Signing out..." : "Sign Out"}
            </Button>
          </CardFooter>
        </Card>

        <Card>
          <CardHeader>
            <CardTitle>App Settings</CardTitle>
            <CardDescription>Manage your application preferences</CardDescription>
          </CardHeader>
          <CardContent>
            <p className="text-muted-foreground">
              You can change your language preferences and voice settings in the settings page.
            </p>
          </CardContent>
          <CardFooter>
            <Button onClick={() => router.push("/settings")}>Go to Settings</Button>
          </CardFooter>
        </Card>
      </div>
    </main>
  )
}


=== layout.tsx ===
import { Atkinson_Hyperlegible } from "next/font/google";
import type React from "react";
import type { Metadata } from "next";
import { Inter as FontSans } from "next/font/google";
// --- 1. Import custom font objects and cn utility ---
import { openDyslexicFont, atkinsonFont } from '@/lib/fonts';
import { cn } from '@/lib/utils';
// --- End of imports ---
import "./globals.css";
import { ClientProviders } from "@/components/ClientProviders";
import { ResponsiveLayout } from '@/components/layout/ResponsiveLayout';
import LayoutScript from "./layout-script";
import { SpeedInsights } from "@vercel/speed-insights/next";

export const metadata: Metadata = {
  title: "StudyCards - Interactive Flashcard App",
  description: "Study effectively with interactive question-and-answer cards",
  icons: {
    icon: [
      { url: '/favicon-96x96.png', sizes: '96x96', type: 'image/png' },
      { url: '/favicon.svg', type: 'image/svg+xml' },
      { url: '/favicon.ico' },
    ],
    apple: '/apple-touch-icon.png'
  },
  manifest: '/manifest.json'
};

// --- 2. Configure Inter to use a CSS variable ---
const fontSans = FontSans({
  subsets: ["latin"],
  variable: "--font-sans", // Define the CSS variable name
});
// --- End of font configuration ---

/**
 * Root layout component for the application.
 * 
 * This component sets up the fundamental structure of the application, including:
 * - HTML document structure and metadata
 * - Global styles and fonts
 * - Client-side providers for authentication, theme, and settings
 * 
 * @component
 * @returns {JSX.Element} The root layout with all necessary providers and global styles
 */
export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en" suppressHydrationWarning>
      <head>
        <meta name="theme-color" content="#ffffff" />
        <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
      </head>
      {/* --- 3. Apply all font variables using cn --- */}
      <body
        className={cn(
          "min-h-screen bg-background font-sans antialiased", // Base styles + default font utility
          fontSans.variable,           // Apply --font-sans variable
          openDyslexicFont.variable,   // Apply --font-open-dyslexic variable
          atkinsonFont.variable        // Apply --font-atkinson variable
        )}
      >
      {/* --- End of body className changes --- */}
        <ClientProviders>
          <ResponsiveLayout>
            <div className="relative flex min-h-screen flex-col">
              <div className="flex-1">
                <div className="pb-8">
                  {children}
                </div>
              </div>
            </div>
          </ResponsiveLayout>
        </ClientProviders>
        <LayoutScript />
        <SpeedInsights />
      </body>
    </html>
  )
}
=== api/cards/route.ts ===
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'
import type { Tables } from "@/types/database";
type DbCard = Tables<'cards'>;

export const dynamic = 'force-dynamic'

// Expects card IDs in the request body
export async function POST(request: Request) {
  console.log(`[API /api/cards] POST request received`);

  let cardIds: string[] = [];
  try {
    const body = await request.json();
    if (!Array.isArray(body.cardIds) || body.cardIds.length === 0) {
        throw new Error("cardIds array is required in the request body.");
    }
    cardIds = body.cardIds;
    console.log(`[API /api/cards] Requesting details for ${cardIds.length} cards.`);
  } catch (e) {
    console.error("[API /api/cards] Invalid request body:", e);
    return NextResponse.json({ error: 'Invalid request body. Expecting { "cardIds": [...] }' }, { status: 400 })
  }

  const cookieStore = cookies()
  const supabase = createRouteHandlerClient({ cookies: () => cookieStore })

  const { data: { session }, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !session) {
    console.error('[API /api/cards] Auth error or no session', sessionError);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    console.log(`[API /api/cards] Fetching cards for user: ${session.user.id}`);
    const { data: dbCards, error: fetchError } = await supabase
      .from('cards')
      .select(`*`) // Select all needed card fields
      .in('id', cardIds)
      // RLS policy should handle user access via deck relationship
      
    console.log("[API /api/cards] Supabase fetch result:", { count: dbCards?.length, fetchError });

    if (fetchError) {
      console.error("[API /api/cards] Supabase fetch error:", fetchError);
      throw fetchError;
    }

    if (!dbCards) {
      // This shouldn't happen if fetchError is null, but good practice
      return NextResponse.json({ cards: [] }) 
    }
    
    // Return the raw DbCard data - mapping will happen on client if needed, 
    // or adjust DbCard type to match FlashCard needs exactly
    return NextResponse.json({ cards: dbCards })

  } catch (error) {
     const errorMessage = error instanceof Error ? error.message : String(error);
     console.error('[API /api/cards] Caught error:', errorMessage, error);
     return NextResponse.json({ error: 'Failed to fetch card details', details: errorMessage }, { status: 500 })
  }
} 
=== api/process-ai-step2/route.ts ===
/**
 * API Route Handler for processing the second step of AI generation:
 * - Classifying grammar for translation flashcards.
 * - Regenerating flashcards forcing knowledge mode.
 */
import { NextRequest, NextResponse } from 'next/server';
import { validateConfiguration, GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, GCP_PRIVATE_KEY } from '../extract-pdf/config'; // Reuse config validation
import {
    classifyTranslationFlashcards,
    regenerateAsKnowledgeFlashcards,
    InitialGenerationResult // Needed for the return type of knowledge regen
} from '../extract-pdf/flashcardGeneratorService';
import { GenerationApiError } from '../extract-pdf/types';

// --- Request Body Types --- 
interface ClassifyPayload {
    action: 'classify';
    filename: string;
    basicFlashcards: { question: string; answer: string }[];
}

interface ForceKnowledgePayload {
    action: 'force_knowledge';
    filename: string;
    originalText: string; // Client needs to send the original text back
}

type RequestPayload = ClassifyPayload | ForceKnowledgePayload;

// --- Runtime Configuration (same as extract-pdf) ---
export const config = {
  runtime: 'nodejs',
  regions: ['iad1'], // Adjust if needed
  maxDuration: 90, // Adjust if needed, knowledge regen might take time
};

// --- API Handler --- 

export async function POST(request: NextRequest) {
    const startTime = Date.now();
    console.log(`[API Route Step2 POST] Request received at ${new Date(startTime).toISOString()}`);

    // --- Runtime Credential/Config Check --- 
    if (!GCP_PROJECT_ID || !GCP_SERVICE_ACCOUNT_EMAIL || !GCP_PRIVATE_KEY) {
        console.error('[API Route Step2 POST] CRITICAL: Missing required GCP credentials. Aborting.');
        return NextResponse.json({ success: false, message: 'Server configuration error: Missing necessary credentials.', code: 'MISSING_CREDENTIALS' }, { status: 500 });
    }
    if (!validateConfiguration()) {
        console.error('[API Route Step2 POST] CRITICAL: Core configuration validation failed. Aborting.');
        return NextResponse.json({ success: false, message: 'Server configuration error: Invalid or missing configuration.', code: 'INVALID_CONFIG' }, { status: 500 });
    }

    try {
        // --- Parse and Validate Payload --- 
        let payload: RequestPayload;
        try {
            payload = await request.json();
        } catch (e) {
            return NextResponse.json({ success: false, message: 'Invalid JSON payload.', code: 'INVALID_JSON' }, { status: 400 });
        }

        if (!payload.action || !payload.filename) {
            return NextResponse.json({ success: false, message: 'Missing required fields: action, filename.', code: 'INVALID_PAYLOAD' }, { status: 400 });
        }

        console.log(`[API Route Step2 POST] Processing action: ${payload.action} for file: ${payload.filename}`);

        // --- Execute Action --- 
        if (payload.action === 'classify') {
            if (!Array.isArray(payload.basicFlashcards)) {
                return NextResponse.json({ success: false, message: 'Missing or invalid basicFlashcards for classify action.', code: 'INVALID_PAYLOAD' }, { status: 400 });
            }
            
            console.log(`[API Route Step2 POST] Calling classifyTranslationFlashcards for ${payload.basicFlashcards.length} cards.`);
            const classifications = await classifyTranslationFlashcards(payload.basicFlashcards, payload.filename);
            const duration = Date.now() - startTime;
            console.log(`[API Route Step2 POST] Classification finished for ${payload.filename}. Duration: ${duration}ms. Results: ${classifications.length}`);
            
            return NextResponse.json({
                success: true,
                action: 'classify',
                data: classifications, // Array of classification objects
                processingTimeMs: duration
            });

        } else if (payload.action === 'force_knowledge') {
            if (typeof payload.originalText !== 'string') {
                return NextResponse.json({ success: false, message: 'Missing or invalid originalText for force_knowledge action.', code: 'INVALID_PAYLOAD' }, { status: 400 });
            }

            console.log(`[API Route Step2 POST] Calling regenerateAsKnowledgeFlashcards.`);
            const knowledgeResult = await regenerateAsKnowledgeFlashcards(payload.originalText, payload.filename);
            const duration = Date.now() - startTime;
            console.log(`[API Route Step2 POST] Knowledge regeneration finished for ${payload.filename}. Duration: ${duration}ms. Cards: ${knowledgeResult.basicFlashcards.length}`);

            // Return structure should match client expectation for merging
            return NextResponse.json({
                success: true,
                action: 'force_knowledge',
                data: { // Send back structure similar to InitialGenerationResult but without mode
                    detectedQuestionLanguage: knowledgeResult.detectedQuestionLanguage,
                    detectedAnswerLanguage: knowledgeResult.detectedAnswerLanguage,
                    basicFlashcards: knowledgeResult.basicFlashcards
                },
                processingTimeMs: duration
            });

        } else {
            return NextResponse.json({ success: false, message: `Invalid action specified: ${payload.action}. Must be 'classify' or 'force_knowledge'.`, code: 'INVALID_ACTION' }, { status: 400 });
        }

    } catch (error: any) {
        const endTime = Date.now();
        const duration = endTime - startTime;
        console.error(`[API Route Step2 POST] UNHANDLED ERROR after ${duration}ms:`, error);
        
        let message = 'An unexpected server error occurred during Step 2 processing.';
        let code = 'INTERNAL_SERVER_ERROR';
        if (error instanceof GenerationApiError) {
            message = `AI Generation Error (Step 2): ${error.message}`;
            code = 'GENERATION_ERROR';
        } else if (error.message) {
            message = `Unhandled server error (Step 2): ${error.message}`;
        }

        return NextResponse.json({
            success: false, 
            message: message, 
            code: code, 
            processingTimeMs: duration
        }, { status: 500 });
    }
} 
=== api/decks/route.ts ===
// app/api/decks/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createActionClient } from '@/lib/supabase/server';
import type { ApiFlashcard } from '../extract-pdf/types';
import type { Database, Tables, Json } from '@/types/database';
// --- Import the NEW batch action ---
import { createCardsBatch, type CreateCardInput } from '@/lib/actions/cardActions'; // Adjust path if needed

// Define the expected request body structure (remains the same)
interface CreateDeckRequestBody {
    name: string;
    questionLanguage: string;
    answerLanguage: string;
    isBilingual: boolean;
    flashcards: ApiFlashcard[]; // Expect the full ApiFlashcard structure
}

export async function POST(request: NextRequest) {
    console.log("[API POST /api/decks] Received request to create deck.");
    const supabase = createActionClient(); // Used for deck creation only now

    try {
        // 1. Get User Session (No change)
        const { data: { user }, error: authError } = await supabase.auth.getUser();
        if (authError || !user) {
            console.error("[API POST /api/decks] Authentication error:", authError);
            return NextResponse.json({ success: false, message: 'Authentication required' }, { status: 401 });
        }
        console.log(`[API POST /api/decks] User authenticated: ${user.id}`);

        // 2. Parse Request Body (No change)
        let body: CreateDeckRequestBody;
        try {
             body = await request.json();
        } catch (jsonError: any) {
             console.error("[API POST /api/decks] Error parsing JSON body:", jsonError);
             return NextResponse.json({ success: false, message: `Invalid JSON format in request body: ${jsonError.message}` }, { status: 400 });
        }

        const { name, questionLanguage, answerLanguage, isBilingual, flashcards } = body;

        // 3. Validate Input (No change)
        if (!name || !questionLanguage || !answerLanguage || flashcards === undefined || flashcards === null) {
            return NextResponse.json({ success: false, message: 'Missing required fields: name, questionLanguage, answerLanguage, flashcards (array, can be empty)' }, { status: 400 });
        }
        if (!Array.isArray(flashcards)) {
             return NextResponse.json({ success: false, message: 'Field "flashcards" must be an array.' }, { status: 400 });
        }
        console.log(`[API POST /api/decks] Input validation passed. Creating deck "${name}" with ${flashcards.length} potential cards.`);

        // 4. Insert Deck into Supabase (No change)
        const deckToInsert: Database['public']['Tables']['decks']['Insert'] = {
                user_id: user.id,
                name: name.trim(),
                primary_language: questionLanguage,
                secondary_language: answerLanguage,
                is_bilingual: isBilingual,
        };

        const { data: deckData, error: deckError } = await supabase
            .from('decks')
            .insert(deckToInsert)
            .select()
            .single();

        if (deckError || !deckData) {
            console.error("[API POST /api/decks] Error inserting deck:", deckError);
             if (deckError?.message.includes('duplicate key value violates unique constraint')) {
                 return NextResponse.json({ success: false, message: 'A deck with this name already exists.' }, { status: 409 });
             }
            return NextResponse.json({ success: false, message: `Failed to create deck: ${deckError?.message || 'Unknown DB error'}` }, { status: 500 });
        }

        const newDeckId = deckData.id;
        console.log(`[API POST /api/decks] Deck metadata created successfully with ID: ${newDeckId}`);

        let insertedCardsCount = 0;
        let cardCreationError: string | null = null;

        // 5. Prepare and Insert Cards using Batch Action
        if (flashcards.length > 0) {
            console.log(`[API POST /api/decks] Preparing ${flashcards.length} cards for batch action into deck ${newDeckId}...`);

            // --- Prepare data for the batch action ---
            // Map ApiFlashcard[] to CreateCardInput[] expected by the action
            const cardDataForAction: CreateCardInput[] = flashcards.map(card => ({
                question: card.question,
                answer: card.answer,
                question_part_of_speech: card.questionPartOfSpeech, // Pass through classification fields
                question_gender: card.questionGender,
                answer_part_of_speech: card.answerPartOfSpeech,
                answer_gender: card.answerGender,
            }));

            // --- Call the batch action ---
            const batchResult = await createCardsBatch(newDeckId, cardDataForAction);

            if (batchResult.error || batchResult.data === null) {
                // --- Handle error from batch action ---
                cardCreationError = batchResult.error || 'Unknown error during batch card creation.';
                console.error(`[API POST /api/decks] Error calling createCardsBatch for deck ${newDeckId}:`, cardCreationError);

                // Attempt rollback
                try {
                     await supabase.from('decks').delete().eq('id', newDeckId);
                     console.log(`[API POST /api/decks] Rolled back deck creation (ID: ${newDeckId}) due to card batch error.`);
                } catch (rollbackError: any) {
                    console.error(`[API POST /api/decks] CRITICAL: Failed to rollback deck ${newDeckId} after card batch failure:`, rollbackError);
                    cardCreationError += ' Rollback also failed.'; // Append rollback failure info
                }
                return NextResponse.json({ success: false, message: `Failed to insert cards, deck creation rolled back: ${cardCreationError}` }, { status: 500 });

            } else {
                // --- Success from batch action ---
                insertedCardsCount = batchResult.data.insertedCount;
                console.log(`[API POST /api/decks] createCardsBatch action succeeded. Inserted Count: ${insertedCardsCount}`);
                if (insertedCardsCount < flashcards.length) {
                     console.warn(`[API POST /api/decks] Note: ${flashcards.length - insertedCardsCount} card(s) were skipped during batch validation within the action.`);
                }
            }
        } else {
            console.log(`[API POST /api/decks] No cards provided in request, only created deck metadata for ID: ${newDeckId}.`);
        }


        // 7. Return Success Response
        // Construct message based on outcome
        let message = `Deck "${name}" created successfully`;
        if (flashcards.length > 0) {
            if (insertedCardsCount > 0) {
                message += ` with ${insertedCardsCount} valid card(s)${insertedCardsCount < flashcards.length ? ` (${flashcards.length - insertedCardsCount} skipped)` : ''}.`;
            } else {
                 message += ', but no valid cards were inserted after validation.';
            }
        } else {
            message += '.'; // Just created deck metadata
        }

        return NextResponse.json({
            success: true,
            message: message,
            deckId: newDeckId,
            deck: deckData as Tables<'decks'>
        }, { status: 201 });

    } catch (error: any) {
        console.error("[API POST /api/decks] Unhandled error in POST handler:", error);
        // Keep generic error handlers
        if (error instanceof SyntaxError) {
             return NextResponse.json({ success: false, message: 'Invalid JSON in request body' }, { status: 400 });
        }
        return NextResponse.json({ success: false, message: `Internal server error: ${error.message}` }, { status: 500 });
    }
}
=== api/decks/[deckId]/name/route.ts ===
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { cookies } from 'next/headers'
import { NextResponse } from 'next/server'

export const dynamic = 'force-dynamic' // Ensure dynamic execution

export async function GET(
  request: Request,
  { params }: { params: { deckId: string } }
) {
  const { deckId } = params
  console.log(`[API /api/decks/name] GET request for deckId: ${deckId}`);

  if (!deckId) {
    console.error("[API /api/decks/name] Missing deckId param.");
    return NextResponse.json({ error: 'Missing deckId' }, { status: 400 })
  }

  const cookieStore = cookies()
  const supabase = createRouteHandlerClient({ cookies: () => cookieStore })

  // Check user session
  const { data: { session }, error: sessionError } = await supabase.auth.getSession();
  if (sessionError || !session) {
    console.error('[API /api/decks/name] Auth error or no session', sessionError);
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    console.log(`[API /api/decks/name] Querying decks table for id: ${deckId} and user_id: ${session.user.id}`);
    const { data, error } = await supabase
      .from('decks')
      .select('name') // Select the correct column
      .eq('id', deckId)
      .eq('user_id', session.user.id)
      .single()

    console.log("[API /api/decks/name] Supabase query result:", { data, error });

    if (error) {
      console.error("[API /api/decks/name] Supabase query error:", error);
      // Handle specific errors like not found vs other DB errors
      if (error.code === 'PGRST116') { // PostgREST code for "Relation does not exist" or similar (check actual code if needed)
         return NextResponse.json({ error: 'Deck not found' }, { status: 404 })
      }
      throw error; // Re-throw other errors
    }

    if (!data) {
      return NextResponse.json({ error: 'Deck not found' }, { status: 404 })
    }

    console.log("[API /api/decks/name] Successfully fetched name:", data.name);
    // Return just the name
    return NextResponse.json({ name: data.name })

  } catch (error) {
     const errorMessage = error instanceof Error ? error.message : String(error);
     console.error('[API /api/decks/name] Caught error:', errorMessage, error);
     return NextResponse.json({ error: 'Failed to fetch deck name', details: errorMessage }, { status: 500 })
  }
} 
=== api/tts/route.ts ===
import { NextResponse } from 'next/server';
import { TextToSpeechClient } from '@google-cloud/text-to-speech';
import { google } from '@google-cloud/text-to-speech/build/protos/protos';

// Remove client initialization outside the handler
// const ttsClient = new TextToSpeechClient();

/**
 * API Route Handler for POST requests to generate Text-to-Speech audio.
 * Expects a JSON body with:
 * {
 *   text: string,
 *   languageCode: string,
 *   ssmlGender?: 'SSML_VOICE_GENDER_UNSPECIFIED' | 'MALE' | 'FEMALE' | 'NEUTRAL',
 *   voiceName?: string | null
 * }
 */
export async function POST(request: Request) {
    let text: string;
    let languageCode: string;
    let ssmlGender: google.cloud.texttospeech.v1.SsmlVoiceGender;
    let voiceName: string | null | undefined;

    try {
        const body = await request.json();
        text = body.text;
        languageCode = body.languageCode;
        ssmlGender = body.ssmlGender || google.cloud.texttospeech.v1.SsmlVoiceGender.NEUTRAL;
        voiceName = body.voiceName;

        if (!text || !languageCode) {
            console.warn("[API /tts] Missing text or languageCode in request body.");
            return NextResponse.json({ error: "Missing required parameters: text and languageCode" }, { status: 400 });
        }
        if (body.ssmlGender && !(body.ssmlGender in google.cloud.texttospeech.v1.SsmlVoiceGender)) {
             console.warn(`[API /tts] Invalid ssmlGender provided: ${body.ssmlGender}`);
             return NextResponse.json({ error: `Invalid ssmlGender value. Valid options are: ${Object.keys(google.cloud.texttospeech.v1.SsmlVoiceGender).join(', ')}` }, { status: 400 });
        }
    } catch (error) {
        console.error("[API /tts] Failed to parse request body:", error);
        return NextResponse.json({ error: "Invalid request body. Expected JSON." }, { status: 400 });
    }

    console.log(`[API /tts] Request received (using explicit GCP_... creds): lang=${languageCode}, gender=${ssmlGender}, voice=${voiceName ?? 'default'}, text="${text.substring(0, 50)}..."`);

    // Check for the specific credentials provided by the gcpvercel.com integration
    if (!process.env.GCP_PROJECT_ID || !process.env.GCP_SERVICE_ACCOUNT_EMAIL || !process.env.GCP_PRIVATE_KEY) {
         console.error("[API /tts] Required GCP credentials (GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, GCP_PRIVATE_KEY) are not set in Vercel environment variables.");
         return NextResponse.json({ error: "Server configuration error." }, { status: 500 });
    }
    
    try {
        // Explicitly configure the client with credentials from environment variables
        const credentials = {
            client_email: process.env.GCP_SERVICE_ACCOUNT_EMAIL,
            private_key: process.env.GCP_PRIVATE_KEY.replace(/\\n/g, '\n'), // Ensure newlines are correct
        };
        const projectId = process.env.GCP_PROJECT_ID;

        // Initialize client inside the handler with explicit credentials
        const ttsClient = new TextToSpeechClient({ credentials, projectId });

        const ttsRequest: google.cloud.texttospeech.v1.ISynthesizeSpeechRequest = {
            input: { text: text },
            voice: {
                languageCode: languageCode,
                ssmlGender: ssmlGender,
                ...(voiceName && { name: voiceName })
            },
            audioConfig: { audioEncoding: 'MP3' },
        };

        const [response] = await ttsClient.synthesizeSpeech(ttsRequest);

        if (response.audioContent instanceof Uint8Array) {
            const audioBase64 = Buffer.from(response.audioContent).toString('base64');
            console.log(`[API /tts] Successfully generated TTS audio (using explicit creds) for lang: ${languageCode}`);
            return NextResponse.json({ audioContent: audioBase64 }, { status: 200 });
        } else {
             console.error("[API /tts] TTS response did not contain valid audio content.", response);
            return NextResponse.json({ error: "TTS generation failed: Invalid audio content received." }, { status: 500 });
        }
    } catch (error: any) {
        console.error('[API /tts] Google TTS API Error (using explicit creds):', error);
        const errorMessage = error.details || error.message || 'Unknown API error';
        return NextResponse.json({ error: `TTS generation failed: ${errorMessage}` }, { status: 500 });
    }
} 
=== api/extract-pdf/gcpClients.ts ===
// app/api/extract-pdf/gcpClients.ts
/**
 * Initializes and exports configured GCP service clients.
 */
import { VertexAI } from '@google-cloud/vertexai';
import { ImageAnnotatorClient } from '@google-cloud/vision';
import { DocumentProcessorServiceClient } from '@google-cloud/documentai';

import * as config from './config';

// Ensure configuration is valid before attempting to create clients
if (!config.validateConfiguration()) {
    // Log a critical error, but avoid throwing here to prevent breaking module resolution
    // during potential build phases. The API route handler will perform the runtime check.
    console.error("[GCP Clients] CRITICAL: Cannot initialize clients due to missing configuration.");
}

// Document AI client
const docAIClientOptions = {
    credentials: config.credentials,
    projectId: config.GCP_PROJECT_ID,
    apiEndpoint: config.DOCAI_API_ENDPOINT,
};
// Conditionally create clients only if config is likely valid
export const docAIClient = (config.GCP_PROJECT_ID && config.GCP_SERVICE_ACCOUNT_EMAIL && config.GCP_PRIVATE_KEY && config.DOCAI_PROCESSOR_ID)
    ? new DocumentProcessorServiceClient(docAIClientOptions)
    : null;

// Vision AI client
export const visionClient = (config.GCP_PROJECT_ID && config.GCP_SERVICE_ACCOUNT_EMAIL && config.GCP_PRIVATE_KEY)
    ? new ImageAnnotatorClient({
          credentials: config.credentials,
          projectId: config.GCP_PROJECT_ID
      })
    : null;

// Vertex AI client
export const vertexAI = (config.GCP_PROJECT_ID && config.GCP_SERVICE_ACCOUNT_EMAIL && config.GCP_PRIVATE_KEY)
    ? new VertexAI({
          project: config.GCP_PROJECT_ID!, // Use non-null assertion after validation check
          location: config.VERTEX_LOCATION,
          googleAuthOptions: { credentials: config.credentials }
      })
    : null;

// Log client initialization status
if (!docAIClient || !visionClient || !vertexAI) {
    console.warn("[GCP Clients] One or more GCP clients could not be initialized due to missing configuration. API functionality will be limited.");
} else {
    console.log("[GCP Clients] Document AI, Vision AI, and Vertex AI clients initialized.");
}
=== api/extract-pdf/flashcardGeneratorService.ts ===
// app/api/extract-pdf/flashcardGeneratorService.ts
/**
 * Service responsible for generating flashcards from text using Google Vertex AI (Gemini).
 * Handles structured output configuration and parsing, now in a multi-step process:
 * 1. generateInitialFlashcards: Detects mode/languages, generates basic Q/A.
 * 2. classifyTranslationFlashcards: Classifies grammar for translation flashcards.
 * 3. regenerateAsKnowledgeFlashcards: Re-generates flashcards forcing knowledge mode.
 */
import {
    VertexAI,
    HarmCategory,
    HarmBlockThreshold,
    Schema,
    SchemaType,
    GenerationConfig,
    SafetySetting
} from '@google-cloud/vertexai';
import { vertexAI } from './gcpClients';
import { VERTEX_MODEL_NAME, MAX_TEXT_CHARS_FOR_GEMINI } from './config';
import {
    ApiFlashcard, // Assuming ApiFlashcard type needs update elsewhere
    GenerationApiError
} from './types'; // Ensure types.ts is updated if necessary

// --- Internal Types (remain largely the same, but used differently) ---

// --- Basic Flashcard Structure (Output of Phase 1 & Knowledge Regen) ---
interface GeminiFlashcardInputBasic {
    question: string;
    answer: string;
}

// --- Phase 1 Output --- (Basic Generation + Mode/Lang)
export interface InitialGenerationResult {
    mode: 'translation' | 'knowledge';
    detectedQuestionLanguage: string;
    detectedAnswerLanguage: string;
    basicFlashcards: GeminiFlashcardInputBasic[];
}

// --- Phase 2 Input/Output (Classification) ---
export interface GeminiFlashcardClassification {
    questionPartOfSpeech: string;
    questionGender: string;
    answerPartOfSpeech: string;
    answerGender: string;
}
// Phase 2 function will return GeminiFlashcardClassification[]
interface GeminiStructuredOutputPhase2 {
    classifiedFlashcards: GeminiFlashcardClassification[];
}

// --- Vertex AI Schema Definitions (remain the same) ---

// Schema for Phase 1 and Knowledge Regeneration (Basic Q/A + Mode/Lang)
const flashcardSchemaBasic: Schema = {
    type: SchemaType.OBJECT,
    properties: {
      mode: { type: SchemaType.STRING, enum: ['translation', 'knowledge'], description: "The mode determined: 'translation' for word lists, 'knowledge' for prose." },
      detectedQuestionLanguage: { type: SchemaType.STRING, description: "The primary language detected for questions/source words (e.g., 'English', 'French')." },
      detectedAnswerLanguage: { type: SchemaType.STRING, description: "The secondary/target language detected for answers/translations (e.g., 'Dutch', 'Spanish'). Same as question language for 'knowledge' mode." },
      flashcards: {
        type: SchemaType.ARRAY, description: "An array of generated flashcard objects.",
        items: {
          type: SchemaType.OBJECT,
          properties: {
            question: { type: SchemaType.STRING, description: "The question or source word/phrase." },
            answer: { type: SchemaType.STRING, description: "The answer or target word/phrase/translation." },
          },
          required: ['question', 'answer']
        }
      }
    },
    required: ['mode', 'detectedQuestionLanguage', 'detectedAnswerLanguage', 'flashcards']
};

// Schema for Phase 2 (Classification Only)
const flashcardSchemaClassification: Schema = {
    type: SchemaType.OBJECT,
    description: "Output schema for grammatical classification of flashcards.",
    properties: {
        classifiedFlashcards: {
            type: SchemaType.ARRAY,
            description: "An array of classification objects, corresponding exactly to the input flashcard array.",
            items: {
                type: SchemaType.OBJECT,
                properties: {
                    questionPartOfSpeech: { type: SchemaType.STRING, description: "Part of Speech for the question word (e.g., 'Noun', 'Verb', 'N/A')." },
                    questionGender: { type: SchemaType.STRING, description: "Grammatical gender for the question word (e.g., 'Male', 'Female', 'N/A')." },
                    answerPartOfSpeech: { type: SchemaType.STRING, description: "Part of Speech for the answer word (e.g., 'Noun', 'Verb', 'N/A')." },
                    answerGender: { type: SchemaType.STRING, description: "Grammatical gender for the answer word (e.g., 'Male', 'Female', 'N/A')." }
                },
                required: ['questionPartOfSpeech', 'questionGender', 'answerPartOfSpeech', 'answerGender']
            }
        }
    },
    required: ['classifiedFlashcards']
};


// --- Configs (remain the same) ---
const safetySettings: SafetySetting[] = [
    { category: HarmCategory.HARM_CATEGORY_HARASSMENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_HATE_SPEECH, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_SEXUALLY_EXPLICIT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
    { category: HarmCategory.HARM_CATEGORY_DANGEROUS_CONTENT, threshold: HarmBlockThreshold.BLOCK_MEDIUM_AND_ABOVE },
];

// Generation Configs for different steps
const generationConfigBasic: GenerationConfig = {
    responseMimeType: 'application/json',
    responseSchema: flashcardSchemaBasic, // Use Basic schema
};

const generationConfigClassification: GenerationConfig = {
    responseMimeType: 'application/json',
    responseSchema: flashcardSchemaClassification, // Use Classification schema
};

// --- Mapped Output Type for FINAL result sent to client hook (includes classification) ---
// This type represents the final combined flashcard structure.
export interface MappedFlashcardCore {
    question: string;
    answer: string;
    questionLanguage: string;
    answerLanguage: string;
    isBilingual: boolean;
    questionPartOfSpeech: string;
    questionGender: string;
    answerPartOfSpeech: string;
    answerGender: string;
    // --- Add source and fileType for consistency with ApiFlashcard? Needed downstream? ---
    // source?: string; 
    // fileType?: string;
}

// --- Helper Functions (parseJsonResponse, callVertexAI - modified slightly) ---
function parseJsonResponse(jsonString: string, filename: string, stepName: string): any {
    try {
        return JSON.parse(jsonString);
    } catch (parseError: any) {
        console.error(`[Generator Service] Error parsing JSON string in ${stepName} for ${filename}:`, parseError.message);
        console.error(`[Generator Service] Received text content (${stepName}):`, jsonString);
        throw new GenerationApiError(`Failed to parse ${stepName} JSON response for ${filename}: ${parseError.message}`);
    }
}

// Updated to accept any expected output type based on the config/schema used
async function callVertexAI<T>(
    prompt: string,
    generationConfig: GenerationConfig,
    filename: string,
    stepName: string // e.g., 'Phase 1', 'Classification', 'Knowledge Regen'
): Promise<T> { 
    if (!vertexAI) {
        throw new GenerationApiError("Vertex AI client is not initialized.");
    }

    console.log(`[Generator Service] ${stepName}: Sending prompt for ${filename} to ${VERTEX_MODEL_NAME}. Prompt length: ${prompt.length}`);

    const model = vertexAI.getGenerativeModel({
        model: VERTEX_MODEL_NAME,
        safetySettings: safetySettings,
        generationConfig: generationConfig,
    });

    const requestPayload = {
        contents: [{ role: 'user', parts: [{ text: prompt }] }],
    };

    const result = await model.generateContent(requestPayload);
    const response = result.response;

    if (!response || !response.candidates || response.candidates.length === 0 || !response.candidates[0].content || !response.candidates[0].content.parts || response.candidates[0].content.parts.length === 0) {
        const finishReason = response?.candidates?.[0]?.finishReason;
        const safetyRatings = response?.candidates?.[0]?.safetyRatings;
        console.error(`[Generator Service] ${stepName}: Invalid response structure or safety block for ${filename}. Reason: ${finishReason}`, safetyRatings);
        throw new GenerationApiError(`${stepName}: Invalid or empty response structure from AI for ${filename}. Finish Reason: ${finishReason}`);
    }

    const responsePart = response.candidates[0].content.parts[0];

    if (typeof responsePart === 'object' && responsePart !== null && 'text' in responsePart && typeof responsePart.text === 'string') {
        console.log(`[Generator Service] ${stepName}: Found 'text' property for ${filename}. Parsing.`);
        return parseJsonResponse(responsePart.text, filename, stepName);
    } else {
         console.warn(`[Generator Service] ${stepName}: Response part for ${filename} might be a direct JSON object (lacks 'text' property). Assuming direct object.`);
         if (typeof responsePart === 'object' && responsePart !== null) {
             return responsePart as T; // Assume it matches the expected structure T
         } else {
             console.error(`[Generator Service] ${stepName}: Unexpected response part format for ${filename}. Expected object, got: ${typeof responsePart}. Content:`, String(responsePart));
             throw new GenerationApiError(`${stepName}: Unexpected response format from AI for ${filename}.`);
         }
     }
}


/**
 * STEP 1: Generates initial flashcards, detects mode and languages from text.
 * Does NOT perform grammatical classification.
 * @param text The extracted text content.
 * @param filename The original filename (for context in logging/errors).
 * @returns A promise resolving to the initial generation result.
 */
export async function generateInitialFlashcards(
    text: string,
    filename: string
): Promise<InitialGenerationResult> { // Return specific type for Step 1
    if (!vertexAI) {
        throw new GenerationApiError("Vertex AI client is not initialized. Check configuration.");
    }
    if (!text || text.trim().length < 10) {
        console.warn(`[Generator Service - Step 1] Input text for ${filename} is too short or empty. Skipping generation.`);
        // Return a default structure indicating failure or empty state
        return { mode: 'knowledge', detectedQuestionLanguage: 'N/A', detectedAnswerLanguage: 'N/A', basicFlashcards: [] };
    }

    console.log(`[Generator Service - Step 1] Starting initial generation for: ${filename}`);

    const truncatedText = text.length > MAX_TEXT_CHARS_FOR_GEMINI
        ? text.slice(0, MAX_TEXT_CHARS_FOR_GEMINI) + `\n\n...(text truncated at ${MAX_TEXT_CHARS_FOR_GEMINI} characters for brevity)`
        : text;

    // --- Use Phase 1 Prompt (unchanged logic, just generating basic Q/A) ---
    const promptPhase1 = `
**Goal:** Analyze the provided text, determine the mode ('translation' or 'knowledge'), detect languages, generate basic question/answer flashcards, and prepare the output as structured JSON.

**Instructions:**

1.  **Analyze Content:** Read the text provided below under "Document Text". You are a teacher who is creating flashcards for his students.
2.  **Determine Mode & Languages:**
    *   Identify if the text is primarily a 'translation' list (pairs of words/phrases in different languages) or 'knowledge' text (prose, factual information in a single primary language). Assign 'translation' or 'knowledge' to the \`mode\` field.
    *   Detect the primary language used for the questions or source words. Assign this language name (e.g., 'English', 'German') to the \`detectedQuestionLanguage\` field.
    *   Detect the secondary/target language used for answers or translations. Assign this language name (e.g., 'Spanish', 'French') to the \`detectedAnswerLanguage\` field.
        *   If \`mode\` is 'translation', \`detectedAnswerLanguage\` should typically be different from \`detectedQuestionLanguage\`.
        *   If \`mode\` is 'knowledge', \`detectedAnswerLanguage\` must be the *same* as \`detectedQuestionLanguage\`.
3.  **Generate Basic Flashcards:** Create an array of flashcard objects for the \`flashcards\` field based on the determined mode:
    *   **If Mode is 'translation':**
        *   Create one flashcard object for each distinct word/phrase pair found in the text.
        *   Use the source language word/phrase for the \`question\` field.
        *   Use the target language word/phrase for the \`answer\` field.
    *   **If Mode is 'knowledge':**
        *   Generate multiple high-quality flashcards
        *   Aim for at least 2-3 per main topic or distinct paragraph.
        *   Create as many fashcards as needed in order for the reader to test whether he truly understands the text.
        *   Create a \`question\` that tests understanding or recall of a key concept from the text. Avoid trivial questions.
        *   Provide a concise (ideally under 100 words) and accurate \`answer\` derived directly from the text.
        *   Both \`question\` and \`answer\` must be in the \`detectedQuestionLanguage\`.
4.  **Format Output:** Structure your *entire response* as a single JSON object containing the \`mode\`, \`detectedQuestionLanguage\`, \`detectedAnswerLanguage\`, and \`flashcards\` fields. Each object within the \`flashcards\` array must contain only \`question\` and \`answer\` fields. Adhere strictly to this structure.

**Example \`flashcards\` array content for 'translation' mode:**
\`[ { "question": "la table", "answer": "the table" }, { "question": "le livre", "answer": "the book" }, { "question": "aller", "answer": "to go" } ]\`

**Example \`flashcards\` array content for 'knowledge' mode:**
\`[ { "question": "What is the primary function of the mitochondria?", "answer": "The primary function of mitochondria is to generate most of the cell's supply of adenosine triphosphate (ATP), used as a source of chemical energy." } ]\`

**Important Constraints:**
*   Your final output must be *only* the JSON object. Do not include any introductory text, explanations, or markdown formatting around the JSON.
*   Accurately determine the \`mode\` and languages based *only* on the provided text.
*   Ensure language consistency as described in step 2.
*   Strictly adhere to the output format. The \`flashcards\` array must only contain objects with \`question\` and \`answer\`.

**Document Text:**

"""
${truncatedText}
"""
`;

    // Type alias for clarity
    type Step1OutputType = { mode: 'translation' | 'knowledge', detectedQuestionLanguage: string, detectedAnswerLanguage: string, flashcards: GeminiFlashcardInputBasic[] };

    try {
        const step1Result = await callVertexAI<Step1OutputType>(promptPhase1, generationConfigBasic, filename, 'Step 1 - Initial Generation');

        // --- Validate Step 1 Response --- 
        if (!step1Result || typeof step1Result !== 'object' ||
            !step1Result.mode || typeof step1Result.mode !== 'string' || !['translation', 'knowledge'].includes(step1Result.mode) ||
            !step1Result.detectedQuestionLanguage || typeof step1Result.detectedQuestionLanguage !== 'string' ||
            !step1Result.detectedAnswerLanguage || typeof step1Result.detectedAnswerLanguage !== 'string' ||
            !Array.isArray(step1Result.flashcards))
        {
            console.error(`[Generator Service - Step 1] JSON for ${filename} does NOT match required base schema fields/types. Received:`, JSON.stringify(step1Result, null, 2));
            throw new GenerationApiError(`Step 1 AI response JSON base structure mismatch for ${filename}. Received: ${JSON.stringify(step1Result)}`);
        }

        for (const card of step1Result.flashcards) {
             if (typeof card !== 'object' || card === null ||
                 typeof card.question !== 'string' ||
                 typeof card.answer !== 'string')
             {
                 console.error(`[Generator Service - Step 1] Invalid flashcard structure within the array for ${filename}. Received card:`, JSON.stringify(card, null, 2));
                 throw new GenerationApiError(`Step 1 AI response flashcard structure mismatch for ${filename}.`);
             }
         }

        console.log(`[Generator Service - Step 1] successful for ${filename}. Mode: ${step1Result.mode}, QLang: ${step1Result.detectedQuestionLanguage}, ALang: ${step1Result.detectedAnswerLanguage}, Cards: ${step1Result.flashcards.length}`);

        // Return the structured result
        return {
            mode: step1Result.mode,
            detectedQuestionLanguage: step1Result.detectedQuestionLanguage,
            detectedAnswerLanguage: step1Result.detectedAnswerLanguage,
            basicFlashcards: step1Result.flashcards
        };

    } catch (error: any) {
        console.error(`[Generator Service - Step 1] Error during initial generation for ${filename}:`, error.message);
        if (error.stack) console.error(error.stack);
        if (error instanceof GenerationApiError) throw error;
        throw new GenerationApiError(`Unexpected error during Step 1 generation for ${filename}: ${error.message}`);
    }
}

/**
 * STEP 2 (Optional): Classifies grammatical properties for translation flashcards.
 * @param basicFlashcards Array of Q/A pairs from Step 1.
 * @param filename Original filename for logging.
 * @returns A promise resolving to an array of classification objects.
 */
export async function classifyTranslationFlashcards(
    basicFlashcards: GeminiFlashcardInputBasic[],
    filename: string
): Promise<GeminiFlashcardClassification[]> { 
    if (basicFlashcards.length === 0) {
        console.log(`[Generator Service - Step 2 Classify] No flashcards provided for classification for ${filename}.`);
        return [];
    }

    console.log(`[Generator Service - Step 2 Classify] Starting classification for ${basicFlashcards.length} cards from ${filename}.`);

    // Prepare input for Phase 2 prompt (same as before)
    const inputJsonForPhase2 = JSON.stringify(basicFlashcards, null, 2);
    // Use Phase 2 Prompt (same as before)
    const promptPhase2 = `
**Goal:** Perform grammatical classification (Part of Speech and Gender) for the provided list of translation flashcards.

**Input:** You are given a JSON array of flashcard objects, each containing a "question" (source word/phrase) and an "answer" (target word/phrase).

**Instructions:**

1.  **Analyze Each Flashcard:** For *each* object in the input array below:
    *   **a. Classify Question Word:** Identify the primary vocabulary word in the \`question\` field. Determine its Part of Speech (PoS) and Gender (if applicable).
    *   **b. Classify Answer Word:** Identify the primary vocabulary word in the \`answer\` field. Determine its Part of Speech (PoS) and Gender (if applicable).
2.  **Use Allowed Values:**
    *   **Part of Speech:** Use *only* one of: 'Noun', 'Verb', 'Adjective', 'Adverb', 'Pronoun', 'Preposition', 'Interjection', 'Other', 'N/A'.
    *   **Gender:** Use *only* one of: 'Male', 'Female', 'Neuter', 'N/A'. Use 'N/A' if gender is linguistically irrelevant for the word/language (e.g., English nouns, verbs, adjectives) or cannot be reliably determined.
3.  **Format Output:** Structure your *entire response* as a single JSON object containing exactly one key: \`classifiedFlashcards\`. The value of this key must be an array of classification objects.
    *   This output array must have the *exact same number of elements* as the input flashcard array.
    *   Each object in the \`classifiedFlashcards\` array must correspond positionally to the object in the input array.
    *   Each classification object must contain the fields: \`questionPartOfSpeech\`, \`questionGender\`, \`answerPartOfSpeech\`, and \`answerGender\`, using the allowed values from step 2.

**Example Input Flashcards JSON:**
\`[ { "question": "la table", "answer": "the table" }, { "question": "bon", "answer": "good" }, { "question": "aller", "answer": "to go" } ]\`

**Example Corresponding Output JSON:**
\`{ "classifiedFlashcards": [ { "questionPartOfSpeech": "Noun", "questionGender": "Female", "answerPartOfSpeech": "Noun", "answerGender": "N/A" }, { "questionPartOfSpeech": "Adjective", "questionGender": "Male", "answerPartOfSpeech": "Adjective", "answerGender": "N/A" }, { "questionPartOfSpeech": "Verb", "questionGender": "N/A", "answerPartOfSpeech": "Verb", "answerGender": "N/A" } ] }\`

**Important Constraints:**
*   Your final output must be *only* the JSON object containing the \`classifiedFlashcards\` array. Do not include any introductory text, explanations, or markdown formatting.
*   The output array length *must* match the input array length.
*   Strictly adhere to the classification value lists provided.

**Input Flashcards JSON:**

"""json
${inputJsonForPhase2}
"""
`;

    try {
        // Type alias for clarity
        type Step2OutputType = { classifiedFlashcards: GeminiFlashcardClassification[] };
        const step2Result = await callVertexAI<Step2OutputType>(promptPhase2, generationConfigClassification, filename, 'Step 2 - Classification');

        // --- Log Raw Result --- 
        console.log(`[Generator Service - Step 2 Classify] Raw Result for ${filename}:`, JSON.stringify(step2Result, null, 2));

        // --- Validate Classification Response --- 
        if (!step2Result || typeof step2Result !== 'object' || !Array.isArray(step2Result.classifiedFlashcards)) {
            console.error(`[Generator Service - Step 2 Classify] JSON for ${filename} does NOT match required schema. Expected { classifiedFlashcards: [...] }. Received:`, JSON.stringify(step2Result, null, 2));
            throw new GenerationApiError(`Step 2 Classification AI response JSON structure mismatch for ${filename}.`);
        }

        // Log warning on count mismatch, but still return the data we got
        if (step2Result.classifiedFlashcards.length !== basicFlashcards.length) {
            console.warn(`[Generator Service - Step 2 Classify] Classification count mismatch for ${filename}. Expected ${basicFlashcards.length}, Received ${step2Result.classifiedFlashcards.length}. Proceeding with available data.`);
        }

        // Validate individual classification objects (optional but good practice)
        for (const classification of step2Result.classifiedFlashcards) {
             if (typeof classification !== 'object' || classification === null ||
                 typeof classification.questionPartOfSpeech !== 'string' ||
                 typeof classification.questionGender !== 'string' ||
                 typeof classification.answerPartOfSpeech !== 'string' ||
                 typeof classification.answerGender !== 'string')
             {
                 console.error(`[Generator Service - Step 2 Classify] Invalid classification structure for ${filename}. Received:`, JSON.stringify(classification, null, 2));
                 // Decide whether to throw or just skip/default this specific item
                 throw new GenerationApiError(`Step 2 Classification AI response contains invalid classification object structure for ${filename}.`);
             }
         }

        console.log(`[Generator Service - Step 2 Classify] successful for ${filename}. Classified ${step2Result.classifiedFlashcards.length} cards.`);
        return step2Result.classifiedFlashcards;

    } catch (error: any) {
        console.error(`[Generator Service - Step 2 Classify] Error during classification for ${filename}. Returning empty array. Error:`, error.message);
        if (error.stack) console.error(error.stack);
        // Return empty array on error, let downstream handle merging defaults
        return [];
    }
}

/**
 * STEP 2 (Alternative): Regenerates flashcards forcing knowledge mode.
 * @param text The original extracted text content.
 * @param filename The original filename (for context in logging/errors).
 * @returns A promise resolving to basic Q/A flashcards and detected languages.
 */
export async function regenerateAsKnowledgeFlashcards(
    text: string,
    filename: string
): Promise<{ detectedQuestionLanguage: string; detectedAnswerLanguage: string; basicFlashcards: GeminiFlashcardInputBasic[] }> { // Return similar structure to step 1, but mode is fixed
    if (!vertexAI) {
        throw new GenerationApiError("Vertex AI client is not initialized. Check configuration.");
    }
    if (!text || text.trim().length < 10) {
        console.warn(`[Generator Service - Step 2 Knowledge Regen] Input text for ${filename} is too short or empty. Skipping generation.`);
        return { detectedQuestionLanguage: 'N/A', detectedAnswerLanguage: 'N/A', basicFlashcards: [] };
    }

    console.log(`[Generator Service - Step 2 Knowledge Regen] Starting knowledge regeneration for: ${filename}`);

    const truncatedText = text.length > MAX_TEXT_CHARS_FOR_GEMINI
        ? text.slice(0, MAX_TEXT_CHARS_FOR_GEMINI) + `\n\n...(text truncated at ${MAX_TEXT_CHARS_FOR_GEMINI} characters for brevity)`
        : text;

    // --- Adapt the Phase 1 prompt for KNOWLEDGE mode generation ONLY ---
    // Define the prompt variable
    const promptKnowledge = `\n**Goal:** Analyze the provided text, determine its primary language, generate high-quality knowledge-based question/answer flashcards, and prepare the output as structured JSON in 'knowledge' mode.\n\n**Instructions:**\n\n1.  **Analyze Content:** Read the text provided below under \"Document Text\". You are a teacher creating flashcards for students based *only* on this text.\n2.  **Determine Language:**\n    *   Potentially the document contains multiple languages. Detect the  primary language used in the text content. Assign this language name (e.g., 'English', 'German') to *both* the \`detectedQuestionLanguage\` and \`detectedAnswerLanguage\` fields.\n3.  **Generate Knowledge Flashcards:** Create an array of flashcard objects for the \`flashcards\` field based on the text content:\n    *   Generate multiple high-quality flashcards.\n    *   Aim for at least 3-5 per main topic or distinct paragraph, or more if it is needed to capture the knowledge of a student for this paragraph.\n    *   Create as many flashcards as needed for a reader to test their understanding of the text.\n    *   Create a \`question\` that tests understanding or recall of a key concept, fact, or relationship explicitly described in the Document Text. Avoid trivial questions or questions about the generation process/metadata.\n    *   Provide a concise (ideally under 100 words) and accurate \`answer\` derived **directly and only from the Document Text**.\n    *   Both \`question\` and \`answer\` must be in the \`detectedQuestionLanguage\`.\n4.  **Set Mode:** The \`mode\` field in your output MUST be set to \"knowledge\".\n5.  **Format Output:** Structure your *entire response* as a single JSON object containing the \`mode\` (fixed as \"knowledge\"), \`detectedQuestionLanguage\`, \`detectedAnswerLanguage\` (same as question language), and \`flashcards\` fields. Each object within the \`flashcards\` array must contain only \`question\` and \`answer\` fields. Adhere strictly to this structure.\n\n**Example Output JSON (Knowledge Mode):**\n\`{ \"mode\": \"knowledge\", \"detectedQuestionLanguage\": \"English\", \"detectedAnswerLanguage\": \"English\", \"flashcards\": [ { \"question\": \"What is the primary function of the mitochondria?\", \"answer\": \"The primary function of mitochondria is to generate most of the cell's supply of adenosine triphosphate (ATP), used as a source of chemical energy.\" }, { \"question\": \"Where does the Krebs cycle occur?\", \"answer\": \"The Krebs cycle occurs in the mitochondrial matrix.\" } ] }\`\n\n**Important Constraints:**\n*   Your final output must be *only* the JSON object. Do not include any introductory text, explanations, or markdown formatting around the JSON.\n*   The \`mode\` MUST be \"knowledge\".\n*   \`detectedAnswerLanguage\` MUST be identical to \`detectedQuestionLanguage\`.\n*   Flashcards must test understanding of the **provided Document Text content ONLY**.\n\n**Document Text:**\n\n\"\"\"\n${truncatedText}\n\"\"\"\n`;

    // Type alias for clarity (same structure as Step 1 output)
    // Define the type alias
    type KnowledgeRegenOutputType = { mode: 'knowledge', detectedQuestionLanguage: string, detectedAnswerLanguage: string, flashcards: GeminiFlashcardInputBasic[] };

    try {
        // --- Reduce logging verbosity for Step 2 prompt ---\
        // console.log(`[Generator Service - Step 2 Knowledge Regen] Full prompt for ${filename}:`);\
        // console.log("--- PROMPT START ---");\
        // console.log(promptKnowledge); // <-- Don't log the full prompt
        console.log(`[Generator Service - Step 2 Knowledge Regen] Preparing prompt for ${filename}. Text length being included: ${truncatedText.length}`);
        // ----------------------------------------------------\n\n        // Pass the correct prompt variable to callVertexAI\n        const knowledgeResult = await callVertexAI<KnowledgeRegenOutputType>(promptKnowledge, generationConfigBasic, filename, 'Step 2 - Knowledge Regen');\n\n        // --- Validate Knowledge Regen Response ---
        console.log("--- PROMPT END ---");
        console.log(`[Generator Service - Step 2 Knowledge Regen] Preparing prompt for ${filename}. Text length being included: ${truncatedText.length}`);
        // ----------------------------------------------------\n\n        // Pass the correct prompt variable to callVertexAI\n        const knowledgeResult = await callVertexAI<KnowledgeRegenOutputType>(promptKnowledge, generationConfigBasic, filename, 'Step 2 - Knowledge Regen');\n\n        // --- Validate Knowledge Regen Response ---

        // Add log to inspect the full prompt being sent (Corrected Syntax)
        console.log(`[Generator Service - Step 2 Knowledge Regen] Full prompt for ${filename}:`);
        console.log("--- PROMPT START ---");
        console.log(promptKnowledge);
        console.log("--- PROMPT END ---");
        // Pass the correct prompt variable to callVertexAI
        const knowledgeResult = await callVertexAI<KnowledgeRegenOutputType>(promptKnowledge, generationConfigBasic, filename, 'Step 2 - Knowledge Regen');

        // --- Validate Knowledge Regen Response ---
        if (!knowledgeResult || typeof knowledgeResult !== 'object' ||
            knowledgeResult.mode !== 'knowledge' || // Mode MUST be knowledge
            !knowledgeResult.detectedQuestionLanguage || typeof knowledgeResult.detectedQuestionLanguage !== 'string' ||
            !knowledgeResult.detectedAnswerLanguage || typeof knowledgeResult.detectedAnswerLanguage !== 'string' ||
            knowledgeResult.detectedQuestionLanguage !== knowledgeResult.detectedAnswerLanguage || // Languages MUST match
            !Array.isArray(knowledgeResult.flashcards))
        {
            console.error(`[Generator Service - Step 2 Knowledge Regen] JSON for ${filename} does NOT match required knowledge schema. Received:`, JSON.stringify(knowledgeResult, null, 2));
            throw new GenerationApiError(`Step 2 Knowledge Regen AI response JSON structure/content mismatch for ${filename}. Received: ${JSON.stringify(knowledgeResult)}`);
        }

        // Validate individual flashcards (same as step 1)
        for (const card of knowledgeResult.flashcards) {
             if (typeof card !== 'object' || card === null ||
                 typeof card.question !== 'string' ||
                 typeof card.answer !== 'string')
             {
                 console.error(`[Generator Service - Step 2 Knowledge Regen] Invalid flashcard structure for ${filename}. Received card:`, JSON.stringify(card, null, 2));
                 throw new GenerationApiError(`Step 2 Knowledge Regen AI response flashcard structure mismatch for ${filename}.`);
             }
         }

        console.log(`[Generator Service - Step 2 Knowledge Regen] successful for ${filename}. QLang: ${knowledgeResult.detectedQuestionLanguage}, Cards: ${knowledgeResult.flashcards.length}`);

        // Return the relevant parts
        return {
            detectedQuestionLanguage: knowledgeResult.detectedQuestionLanguage,
            detectedAnswerLanguage: knowledgeResult.detectedAnswerLanguage, // Will be same as QLang
            basicFlashcards: knowledgeResult.flashcards
        };

    } catch (error: any) {
        console.error(`[Generator Service - Step 2 Knowledge Regen] Error during knowledge regeneration for ${filename}:`, error.message);
        if (error.stack) console.error(error.stack);
        if (error instanceof GenerationApiError) throw error;
        throw new GenerationApiError(`Unexpected error during Step 2 Knowledge Regen for ${filename}: ${error.message}`);
    }
}

// Removed the old monolithic generateFlashcards function
=== api/extract-pdf/textExtractorService.ts ===
// app/api/extract-pdf/textExtractorService.ts
/**
 * Service responsible for extracting text from PDF and Image files
 * using appropriate GCP services or libraries.
 */
import { PDFDocument } from 'pdf-lib';
import { docAIClient, visionClient } from './gcpClients';
// --- FIX: Import PAGE_LIMIT and add DOCAI_OCR_PAGE_LIMIT ---
import { PAGE_LIMIT, DOCAI_OCR_PAGE_LIMIT, DOCAI_PROCESSOR_ID, GCP_PROJECT_ID, DOCAI_LOCATION } from './config'; // Assume DOCAI_OCR_PAGE_LIMIT=15 is added
import { SupportedFileType, getMimeTypeFromFilename } from './fileUtils';
import { ExtractionResult, PageLimitExceededError, ExtractionApiError } from './types';

/**
 * Performs a pre-check on a PDF buffer to count pages.
 * Throws PageLimitExceededError if the absolute limit is surpassed.
 * @param fileBuffer The ArrayBuffer of the PDF file.
 * @param filename The name of the file (for error reporting).
 * @returns The page count if within the limit.
 */
async function checkPdfPageCount(fileBuffer: ArrayBuffer, filename: string): Promise<number> {
    console.log(`[Text Extractor] Performing pdf-lib page count check for: ${filename}`);
    try {
        const pdfDoc = await PDFDocument.load(fileBuffer, { ignoreEncryption: true });
        const pageCount = pdfDoc.getPageCount();

        // --- Throw only if > absolute PAGE_LIMIT (e.g., 30) ---
        if (pageCount > PAGE_LIMIT) {
            console.warn(`[Text Extractor] PDF "${filename}" has ${pageCount} pages, exceeding the absolute ${PAGE_LIMIT}-page limit.`);
            throw new PageLimitExceededError(
                `Exceeds absolute ${PAGE_LIMIT}-page limit (${pageCount} pages)`, // Updated message
                filename,
                pageCount,
                PAGE_LIMIT
            );
        }

        console.log(`[Text Extractor] pdf-lib check complete for ${filename}: ${pageCount} pages (within absolute limit).`);
        return pageCount;
    } catch (error: any) {
        if (error instanceof PageLimitExceededError) {
            throw error; // Re-throw specific error
        }
        console.error(`[Text Extractor] pdf-lib processing error for ${filename}:`, error.message);
        if (error.message.includes('Invalid PDF structure') || error.message.includes('not a PDF')) {
            throw new ExtractionApiError(`Invalid or corrupted PDF file (${filename}).`);
        }
        throw new ExtractionApiError(`Failed to process PDF metadata with pdf-lib: ${error.message}`);
    }
}

// extractTextFromImageVisionAI (No changes needed here)
async function extractTextFromImageVisionAI(fileBuffer: ArrayBuffer, filename: string): Promise<ExtractionResult> {
    if (!visionClient) {
        throw new ExtractionApiError("Vision AI client is not initialized. Check configuration.");
    }
    const buffer = Buffer.from(fileBuffer);
    console.log(`[Text Extractor] Starting Vision AI extraction for IMAGE: ${filename}...`);
    try {
        const [result] = await visionClient.documentTextDetection({
            image: { content: buffer.toString('base64') }
        });
        const extractedText = result.fullTextAnnotation?.text || '';
        if (!extractedText && result.error?.message) {
             console.warn(`[Text Extractor] Vision AI returned error for IMAGE ${filename}: ${result.error.message}`);
             throw new ExtractionApiError(`Vision AI error: ${result.error.message}`);
        }
         if (!extractedText) {
            console.warn(`[Text Extractor] Vision AI returned no text detections for IMAGE ${filename}`);
            return {
                 text: "",
                 info: { pages: 0, metadata: { source: 'Vision AI', characters: 0, note: 'No text detected.' } }
             };
        }

        const detectedLanguageCodes = new Set<string>();
        if (result.fullTextAnnotation?.pages) {
            for (const page of result.fullTextAnnotation.pages) {
                if (page.property?.detectedLanguages) {
                    for (const lang of page.property.detectedLanguages) {
                        if (lang.languageCode) detectedLanguageCodes.add(lang.languageCode);
                    }
                }
            }
        }
        if (detectedLanguageCodes.size === 0 && result.textAnnotations && result.textAnnotations.length > 0) {
            for (const annotation of result.textAnnotations) {
                if (annotation.locale) detectedLanguageCodes.add(annotation.locale);
            }
        }

        console.log(`[Text Extractor] Vision AI detected language codes for ${filename}:`, Array.from(detectedLanguageCodes));
        const characterCount = extractedText.length;
        const pageCount = result.fullTextAnnotation?.pages?.length || 1;
        console.log(`[Text Extractor] Vision AI extraction complete for IMAGE ${filename}, extracted ${characterCount} characters from ${pageCount} page(s).`);

        return {
            text: extractedText,
            info: {
                pages: pageCount,
                metadata: {
                    source: 'Vision AI',
                    characters: characterCount,
                    detectedLanguages: Array.from(detectedLanguageCodes)
                }
            }
        };
    } catch (error: any) {
        console.error(`[Text Extractor] Vision AI extraction error for IMAGE ${filename}:`, error.message);
        throw new ExtractionApiError(`Vision AI failed for ${filename}: ${error.message}`);
    }
}


// extractTextFromPdfDocAI (MODIFIED to handle imageless mode)
async function extractTextFromPdfDocAI(fileBuffer: ArrayBuffer, filename: string, initialPageCount: number): Promise<ExtractionResult> {
    if (!docAIClient) {
        throw new ExtractionApiError("Document AI client is not initialized. Check configuration.");
    }
     if (!GCP_PROJECT_ID || !DOCAI_LOCATION || !DOCAI_PROCESSOR_ID) {
         throw new ExtractionApiError("Document AI configuration (Project ID, Location, Processor ID) is incomplete.");
     }
     // --- Use the imported constant --- 
     if (typeof DOCAI_OCR_PAGE_LIMIT === 'undefined') { // Check if it was actually imported
        console.warn('[Text Extractor] DOCAI_OCR_PAGE_LIMIT not defined in config, defaulting to 15.');
     }
     const ocrLimit = DOCAI_OCR_PAGE_LIMIT ?? 15; // Use imported constant or default
     // --------------------------------------

    console.log(`[Text Extractor] Starting Document AI extraction for PDF: ${filename} (${initialPageCount} pages)`);
    const processorName = `projects/${GCP_PROJECT_ID}/locations/${DOCAI_LOCATION}/processors/${DOCAI_PROCESSOR_ID}`;
    const buffer = Buffer.from(fileBuffer);

    // --- Determine Process Options based on page count --- 
    let processOptions = {};
    let mode = 'Standard OCR';
    if (initialPageCount > ocrLimit && initialPageCount <= PAGE_LIMIT) {
        mode = 'Imageless (Native PDF Parsing)';
        processOptions = {
             ocrConfig: { enableNativePdfParsing: true }
        };
        console.log(`[Text Extractor] Using Imageless mode for ${filename} (${initialPageCount} pages > ${ocrLimit})`);
    } else {
        console.log(`[Text Extractor] Using Standard OCR mode for ${filename} (${initialPageCount} pages <= ${ocrLimit})`);
        // No specific options needed for standard, or explicitly set:
        // processOptions = { ocrConfig: { enableNativePdfParsing: false } }; 
    }
    // ----------------------------------------------------

    const request = {
        name: processorName,
        rawDocument: {
            content: buffer.toString('base64'),
            mimeType: 'application/pdf',
        },
        processOptions: processOptions, // Add the determined options
    };

    try {
        console.log(`[Text Extractor] Sending Document AI request (${mode} mode) to processor: ${processorName}`);
        const [result] = await docAIClient.processDocument(request);
        console.log(`[Text Extractor] Document AI request completed successfully (${mode} mode)`);

        const { document } = result;

        if (!document || !document.text) {
            // Handle cases where no text is returned (remains the same)
            console.warn(`[Text Extractor] Document AI returned no text for PDF ${filename} (${mode} mode). Response status: ${result.document?.error?.message || 'N/A'}`);
             return {
                 text: "",
                 info: { pages: initialPageCount, metadata: { source: `Document AI (${mode})`, characters: 0, note: 'No text detected.' } }
             };
        }

        // Language detection (remains the same)
        const detectedLanguageCodes = new Set<string>();
        if (document.pages && document.pages.length > 0) {
            for (const page of document.pages) {
                if (page.detectedLanguages && page.detectedLanguages.length > 0) {
                    for (const lang of page.detectedLanguages) {
                        if (lang.languageCode) detectedLanguageCodes.add(lang.languageCode);
                    }
                }
            }
        }

        console.log(`[Text Extractor] Document AI detected language codes for ${filename}:`, Array.from(detectedLanguageCodes));
        const extractedText = document.text;
        const characterCount = extractedText.length;
        const pageCount = document.pages?.length || initialPageCount;
        console.log(`[Text Extractor] Document AI extraction complete for PDF ${filename} (${mode} mode), extracted ${characterCount} characters from ${pageCount} pages.`);

        return {
            text: extractedText,
            info: {
                pages: pageCount,
                metadata: {
                    source: `Document AI (${mode})`, // Include mode in metadata
                    characters: characterCount,
                    detectedLanguages: Array.from(detectedLanguageCodes)
                }
            }
        };
    } catch (error: any) {
        // Error handling (remains largely the same)
        console.error(`[Text Extractor] Document AI extraction error (${mode} mode) for PDF ${filename}:`, JSON.stringify(error, null, 2));

         // --- ADD Specific Check for Google API Page Limit Error ---
         // Google API uses code 3 (INVALID_ARGUMENT) for various issues,
         // but specifically includes PAGE_LIMIT_EXCEEDED details for this case.
         if (error.code === 3 && (error.details?.includes('limit: 15 got 16') || error.details?.includes('page limit'))) {
             // Attempt to extract the actual page count from the error details if possible
             const match = error.details?.match(/got (\d+)/);
             const reportedPageCount = match ? parseInt(match[1], 10) : initialPageCount;
             console.warn(`[Text Extractor] Detected Document AI page limit error for ${filename}. Reported pages: ${reportedPageCount}, Limit: 15 (for standard OCR)`);
             // Throw OUR custom error type, using the configured OCR limit
             throw new PageLimitExceededError(
                 `Exceeds Document AI OCR page limit (${ocrLimit} pages)`,
                 filename,
                 reportedPageCount,
                 ocrLimit
             );
         }
         // ------------------------------------------------------

         if (error.message.includes('Deadline Exceeded') || error.code === 4) {
             throw new ExtractionApiError(`Document AI request timed out for ${filename} (${mode} mode).`);
         }
         // --- INVALID_ARGUMENT might now indicate a non-digital PDF in imageless mode ---
         if (error.code === 3) { // Keep this generic check AFTER the specific page limit check
            let detail = `Document AI: Invalid argument. Ensure ${filename} is a valid PDF.`;
            if (mode === 'Imageless (Native PDF Parsing)') {
                detail += ` Or, the PDF might not be suitable for imageless mode (e.g., scanned).`;
            }
             throw new ExtractionApiError(detail);
         }
         // ------------------------------------------------------------------------------
         if (error.message.includes('PERMISSION_DENIED') || error.details?.includes('permission')) {
             throw new ExtractionApiError(`Document AI: Permission denied. Check service account roles.`);
         }
         if (error.message.includes('NOT_FOUND')) {
             throw new ExtractionApiError(`Document AI: Processor not found. Verify Processor ID/Location.`);
         }
        throw new ExtractionApiError(`Document AI failed for ${filename} (${mode} mode): ${error.message}`);
    }
}


// extractText (main service function - no changes needed here)
export async function extractText(
    fileBuffer: ArrayBuffer,
    filename: string,
    fileType: SupportedFileType
): Promise<ExtractionResult> {
    if (fileType === 'pdf') {
        const pageCount = await checkPdfPageCount(fileBuffer, filename); // Now only throws if > PAGE_LIMIT
        // Pass pageCount to DocAI function to determine mode
        return await extractTextFromPdfDocAI(fileBuffer, filename, pageCount);
    } else if (fileType === 'image') {
        return await extractTextFromImageVisionAI(fileBuffer, filename);
    } else {
        console.error(`[Text Extractor] Called with unsupported file type for filename: ${filename}`);
        throw new ExtractionApiError(`Unsupported file type provided to extraction service for ${filename}.`);
    }
}
=== api/extract-pdf/types.ts ===
// app/api/extract-pdf/types.ts
/**
 * TypeScript interfaces specific to the data flow within the extract-pdf API feature.
 */

import { SupportedFileType } from './fileUtils';

// SkippedFile interface (no change)
export interface SkippedFile {
  filename: string;
  pages?: number;
  reason: string;
  code?: string;
}

// ExtractionResult interface (no change)
export interface ExtractionResult {
  text: string;
  info: {
    pages: number;
    metadata: {
      source: string;
      characters: number;
      detectedLanguages?: string[];
      note?: string;
    }
  }
}

// --- UPDATED: GeminiFlashcardInput to include classification ---
// This reflects the structure EXPECTED FROM Gemini now
export interface GeminiFlashcardInput {
    question: string;
    answer: string;
    questionPartOfSpeech: string;
    questionGender: string;
    answerPartOfSpeech: string;
    answerGender: string;
}

// --- UPDATED: ApiFlashcard interface to include classification ---
// This reflects the structure RETURNED BY the /api/extract-pdf route
export interface ApiFlashcard {
  question: string;
  answer: string;
  questionLanguage?: string; // Language detected for the whole batch
  answerLanguage?: string;   // Language detected for the whole batch
  isBilingual?: boolean;     // Mode determined for the whole batch
  // --- NEW Classification Fields ---
  questionPartOfSpeech: string; // Classification specific to this card
  questionGender: string;       // Classification specific to this card
  answerPartOfSpeech: string;   // Classification specific to this card
  answerGender: string;         // Classification specific to this card
  // --- End of NEW Fields ---
  source?: string;           // Added by route.ts (filename)
  fileType?: SupportedFileType; // Added by route.ts
}

// --- UPDATED: GeminiStructuredOutput to expect richer flashcards ---
// This reflects the overall JSON structure EXPECTED FROM Gemini now
export interface GeminiStructuredOutput {
    mode: 'translation' | 'knowledge';
    detectedQuestionLanguage: string;
    detectedAnswerLanguage: string;
    flashcards: GeminiFlashcardInput[]; // Should now contain the classification fields
}

// PageLimitExceededError class (no change needed based on previous code)
export class PageLimitExceededError extends Error {
    public filename: string;
    public pageCount: number;
    public limit: number;

    constructor(message: string, filename: string, pageCount: number, limit: number) {
        super(message);
        this.name = 'PageLimitExceededError';
        this.filename = filename;
        this.pageCount = pageCount;
        this.limit = limit;
    }
}

// ExtractionApiError class (no change)
export class ExtractionApiError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'ExtractionApiError';
    }
}

// GenerationApiError class (no change)
export class GenerationApiError extends Error {
    public reason?: string;
    constructor(message: string, reason?: string) {
        super(message);
        this.name = 'GenerationApiError';
        this.reason = reason;
    }
}
=== api/extract-pdf/route.ts ===
// app/api/extract-pdf/route.ts
/**
 * API Route Handler for extracting text from PDF/Image files
 * and generating INITIAL flashcards using AI.
 * Orchestrates calls to text extraction and initial flashcard generation services.
 */
import { NextRequest, NextResponse } from 'next/server';
import { getFileFromStorage } from '@/lib/actions/storageActions';
import { validateConfiguration, GCP_PROJECT_ID, GCP_SERVICE_ACCOUNT_EMAIL, GCP_PRIVATE_KEY, PAGE_LIMIT } from './config';
import { getSupportedFileType, SupportedFileType } from './fileUtils';
import { extractText } from './textExtractorService';
// --- Import INITIAL generator function and its return type --- 
import { generateInitialFlashcards, InitialGenerationResult } from './flashcardGeneratorService'; 
// --- ApiFlashcard is no longer the direct output here --- 
import { /* ApiFlashcard, */ SkippedFile, PageLimitExceededError, ExtractionApiError, GenerationApiError } from './types'; 

// --- Runtime Configuration (Vercel specific) ---
export const config = {
  runtime: 'nodejs',
  regions: ['iad1'],
  maxDuration: 90,
  api: {
    bodyParser: {
      sizeLimit: '26mb'
    }
  }
};

// --- API Handlers ---

// GET Handler (No changes needed)
export async function GET(request: NextRequest) {
  if (!validateConfiguration()) {
    return NextResponse.json({
        message: 'API is potentially misconfigured. Check server logs.',
        status: 'error',
        timestamp: new Date().toISOString()
    }, { status: 500 });
  }
  return NextResponse.json({
    message: 'Flashcard generation API is active. Use POST method to process files.',
    status: 'ok',
    timestamp: new Date().toISOString(),
  });
}

// OPTIONS Handler (No changes needed)
export async function OPTIONS(request: NextRequest) {
  const origin = request.headers.get('origin') || '*';
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Origin': origin,
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400',
    },
  });
}


// POST Handler
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  console.log(`[API Route POST] Request received at ${new Date(startTime).toISOString()}`);

  // Runtime Credential/Config Check (No changes needed)
  if (!GCP_PROJECT_ID || !GCP_SERVICE_ACCOUNT_EMAIL || !GCP_PRIVATE_KEY) {
      console.error('[API Route POST] CRITICAL: Missing required GCP credentials. Aborting.');
      return NextResponse.json({
          success: false, message: 'Server configuration error: Missing necessary credentials.', code: 'MISSING_CREDENTIALS'
      }, { status: 500 });
  }
   if (!validateConfiguration()) {
       console.error('[API Route POST] CRITICAL: Core configuration validation failed. Aborting.');
       return NextResponse.json({
           success: false, message: 'Server configuration error: Invalid or missing configuration.', code: 'INVALID_CONFIG'
      }, { status: 500 });
    }

  // Initialization
  let skippedFiles: SkippedFile[] = [];
  // --- Store initial results per file --- 
  let allInitialResults: InitialGenerationResult[] = [];
  let allResultsInfo: { filename: string; type: SupportedFileType; pages: number; characters: number; initialFlashcardsGenerated: number }[] = [];
  let totalPagesProcessed = 0;
  let combinedTextPreview = "";
  // --- Add array to store full extracted text per file ---
  let allExtractedTexts: { filename: string; extractedText: string }[] = [];

  try {
    const contentType = request.headers.get('content-type') || '';

    // File Processing Logic (No changes needed in setup)
    interface FileSource {
        filename: string;
        getBuffer: () => Promise<ArrayBuffer>;
        fileTypeHint?: string;
    }
    let fileSources: FileSource[] = [];

    // 1. Determine File Sources (No changes needed here)
    if (contentType.includes('application/json')) {
      const jsonData = await request.json();
      const fileReferences = jsonData.files as { filename: string, filePath: string }[];
      if (!fileReferences || !Array.isArray(fileReferences) || fileReferences.length === 0) {
            return NextResponse.json({ success: false, message: 'Invalid or empty file list provided in JSON request', code: 'INVALID_INPUT' }, { status: 400 });
        }
        console.log(`[API Route POST] Processing ${fileReferences.length} files from storage paths via JSON payload.`);
        fileSources = fileReferences.map(ref => ({
            filename: ref.filename,
            getBuffer: async () => {
                console.log(`[API Route POST] Fetching buffer for ${ref.filename} from storage path ${ref.filePath}`);
                const buffer = await getFileFromStorage(ref.filePath);
                if (!buffer || buffer.byteLength === 0) throw new Error(`File not found or empty in storage at path: ${ref.filePath}`);
                return buffer;
            }
        }));
    } else if (contentType.includes('multipart/form-data')) {
        console.log('[API Route POST] Handling multipart/form-data request.');
        const formData = await request.formData();
        const files = formData.getAll('file') as File[];
        if (!files || files.length === 0) {
            return NextResponse.json({ success: false, message: 'No files provided in form-data', code: 'NO_FILES' }, { status: 400 });
        }
        console.log(`[API Route POST] Received ${files.length} file(s) from FormData.`);
        fileSources = files.map((file, i) => ({
            filename: file.name || `Unnamed File ${i+1}`,
            getBuffer: async () => {
                if (!file.name || file.size === 0 || typeof file.arrayBuffer !== 'function') throw new Error('Invalid file data (missing name, zero size, or methods)');
                return file.arrayBuffer();
            },
            fileTypeHint: file.type
        }));
    } else {
        console.warn(`[API Route POST] Received request with unsupported content type: ${contentType}`);
        return NextResponse.json({ success: false, message: `Unsupported content type: ${contentType}. Please use application/json or multipart/form-data.`, code: 'UNSUPPORTED_CONTENT_TYPE'}, { status: 415 });
    }

    // 2. Process Each File Source Sequentially
    for (const source of fileSources) {
        const fileStartTime = Date.now();
        console.log(`[API Route POST] Processing file: ${source.filename}`);
        let fileBuffer: ArrayBuffer | null = null;
        let fileType: SupportedFileType | null = null;

        try {
            // Steps a, b, c, d (No changes needed here)
            fileType = getSupportedFileType(source.filename);
            if (!fileType) throw new Error('Unsupported file type');
            fileBuffer = await source.getBuffer();
            console.log(`[API Route POST] Attempting text extraction for ${source.filename} (Type: ${fileType})`);
            const extractionResult = await extractText(fileBuffer, source.filename, fileType);
            // --- Log the raw extracted text immediately ---\n            console.log(`[API Route POST] Raw server-extracted text for ${source.filename} (first 500 chars):\n`, extractionResult.text.substring(0, 500));\n            // -------------------------------------------\n            console.log(`[API Route POST] Text extraction successful for ${source.filename}. Characters: ${extractionResult.info.metadata.characters}, Pages: ${extractionResult.info.pages}`);
            totalPagesProcessed += extractionResult.info.pages;
            combinedTextPreview += `--- Content from ${source.filename} ---\n${extractionResult.text.slice(0, 200)}...\n\n`;

            // --- Store the FULL extracted text ---
            allExtractedTexts.push({ filename: source.filename, extractedText: extractionResult.text });

            // --- Step e: Initial Flashcard Generation --- 
            let initialResult: InitialGenerationResult | null = null; // Variable to hold result for this file
            if (extractionResult.text && extractionResult.text.trim().length > 0) {
                console.log(`[API Route POST] Attempting initial flashcard generation for ${source.filename}`);

                // --- Call the INITIAL generation service --- 
                initialResult = await generateInitialFlashcards(extractionResult.text, source.filename);
                // -------------------------------------------

                // Add source filename to the result for grouping later if needed (though client might handle this)
                // initialResult.source = source.filename;
                
                allInitialResults.push(initialResult);
                console.log(`[API Route POST] Initial generation complete for ${source.filename}. Mode: ${initialResult.mode}, Cards: ${initialResult.basicFlashcards.length}`);
            } else {
                 console.log(`[API Route POST] Skipping flashcard generation for ${source.filename} due to empty extracted text.`);
            }
            allResultsInfo.push({
                filename: source.filename,
                type: fileType!,
                pages: extractionResult.info.pages,
                characters: extractionResult.info.metadata.characters,
                initialFlashcardsGenerated: initialResult?.basicFlashcards.length || 0, // Count from initial result
            });
            console.log(`[API Route POST] Successfully processed ${source.filename}. Time: ${Date.now() - fileStartTime}ms`);

        } catch (error: any) {
            console.error(`[API Route POST] Error processing file ${source.filename}: ${error.message}`);
            let reason = error.message || 'Unknown processing error';
            let pages: number | undefined = undefined;
            let errorCode: string | undefined = undefined;

            if (error instanceof PageLimitExceededError) {
                reason = error.message;
                pages = error.pageCount;
                errorCode = 'PAGE_LIMIT_EXCEEDED';
            } else if (error instanceof ExtractionApiError || error instanceof GenerationApiError) {
                reason = `${error.name}: ${error.message.substring(0, 200)}${error.message.length > 200 ? '...' : ''}`;
                 if (error instanceof GenerationApiError && error.reason) {
                     reason += ` (Reason: ${error.reason})`;
                 }
            } else if (reason.includes('Invalid file data')) {
                 reason = 'Invalid file data provided';
            } else if (reason === 'Unsupported file type') {
                // Keep reason as is
            } else if (reason.includes('storage')) {
                 reason = `Storage access error: ${reason.substring(0,150)}...`;
            } else {
                 reason = `Processing error: ${reason.substring(0,150)}...`;
            }

            skippedFiles.push({ filename: source.filename, pages: pages, reason: reason, code: errorCode });
            continue;
        }
    }

    // Final Response Aggregation (No changes needed here)
    const endTime = Date.now();
    const duration = endTime - startTime;
    const processedCount = allResultsInfo.length;
    const skippedCount = skippedFiles.length;
    const totalInitialCards = allInitialResults.reduce((sum, res) => sum + res.basicFlashcards.length, 0);
    console.log(`[API Route POST] Initial processing finished. Duration: ${duration}ms. Processed: ${processedCount}, Skipped: ${skippedCount}, Total Initial Flashcards: ${totalInitialCards}`);

    if (processedCount === 0) {
        let message = 'No files could be processed successfully.';
        let status = 400;
        let code = 'PROCESSING_FAILED'; // Default code

        // --- Check if the first skipped file has our specific error code --- 
        if (skippedCount === 1 && skippedFiles[0].code === 'PAGE_LIMIT_EXCEEDED') { 
            // Use the specific reason from the skipped file as the primary message
            message = skippedFiles[0].reason; 
            // Set the specific code for the client to handle
            code = skippedFiles[0].code; // Use the code from the skipped file object
            console.log(`[API Route POST] Setting error code to ${code} for page limit exceeded error`);
        } else if (skippedCount > 0) {
            message = `Processed 0 files successfully. ${skippedCount} file(s) were skipped. See 'skippedFiles' for details.`;
            // Ensure code remains PROCESSING_FAILED if it wasn't a page limit error
            code = 'PROCESSING_FAILED'; 
        }
        // --------------------------------------------------------------------

        // --- Log the final code and message being sent ---
        console.log(`[API Route POST] Returning error response. Code: ${code}, Message: ${message}`);
        console.log(`[API Route POST] skippedFiles: ${JSON.stringify(skippedFiles)}`);
        // --------------------------------------------------

        return NextResponse.json({
            success: false, message, code, skippedFiles,
            // Ensure these fields are present even in error cases for consistent structure
            initialResults: [],
            extractedTexts: [],
            fileInfo: { pages: 0, files: 0, metadata: { sources: [] } },
        }, { status });
    }

    const finalFileInfo = {
        pages: totalPagesProcessed, files: processedCount, metadata: { sources: allResultsInfo }
    };

    // --- Return the INITIAL results --- 
    // The client will now receive mode, languages, and basicFlashcards per source.
    return NextResponse.json({
      success: true,
        message: `Successfully processed ${processedCount} file(s) and generated ${totalInitialCards} initial flashcards. ${skippedCount} file(s) skipped.`,
        extractedTextPreview: combinedTextPreview.length > 1000 ? combinedTextPreview.slice(0, 1000) + "..." : combinedTextPreview,
        fileInfo: finalFileInfo,
        initialResults: allInitialResults, // Array of results, one per processed file
        // --- Include the full extracted texts in the response ---
        extractedTexts: allExtractedTexts,
        skippedFiles: skippedCount > 0 ? skippedFiles : undefined,
        processingTimeMs: duration
    });

  } catch (error: any) {
    // Global Error Handler (No changes needed)
    const endTime = Date.now();
    const duration = endTime - startTime;
    console.error(`[API Route POST] UNHANDLED ERROR after ${duration}ms:`, error);
    let message = 'An unexpected server error occurred.';
    let code = 'INTERNAL_SERVER_ERROR';
    if (error instanceof SyntaxError && error.message.includes('JSON')) {
        message = 'Invalid JSON received in request body.';
        code = 'INVALID_JSON_INPUT';
    } else if (error.message) {
        message = `Unhandled server error: ${error.message}`;
    }
    return NextResponse.json({
        success: false, message: message, code: code, processingTimeMs: duration,
        skippedFiles: skippedFiles.length > 0 ? skippedFiles : undefined,
    }, { status: 500 });
  }
}
=== api/extract-pdf/fileUtils.ts ===
// app/api/extract-pdf/fileUtils.ts
/**
 * Utilities for handling file types related to the extraction API.
 */

export type SupportedFileType = 'pdf' | 'image';

export const SUPPORTED_EXTENSIONS: Record<string, SupportedFileType> = {
  'jpg': 'image',
  'jpeg': 'image',
  'png': 'image',
  'gif': 'image', // Note: Animated GIFs might not extract well
  'bmp': 'image',
  'webp': 'image',
  'pdf': 'pdf',
};

/**
 * Determines the supported file type based on the filename extension.
 * @param filename The full filename (e.g., 'document.pdf', 'photo.jpg').
 * @returns The supported file type ('pdf' or 'image') or null if unsupported.
 */
export function getSupportedFileType(filename: string): SupportedFileType | null {
  if (!filename) {
      return null;
  }
  const extension = filename.split('.').pop()?.toLowerCase() || '';
  return SUPPORTED_EXTENSIONS[extension] || null;
}

/**
 * Maps file extensions to their common MIME types.
 * Used for providing hints to APIs.
 * @param filename The full filename.
 * @returns The common MIME type string or a default if unknown.
 */
export function getMimeTypeFromFilename(filename: string): string {
    const extension = filename.split('.').pop()?.toLowerCase() || '';
    switch (extension) {
        case 'pdf': return 'application/pdf';
        case 'jpg':
        case 'jpeg': return 'image/jpeg';
        case 'png': return 'image/png';
        case 'gif': return 'image/gif';
        case 'bmp': return 'image/bmp';
        case 'webp': return 'image/webp';
        default: return 'application/octet-stream'; // Default binary type
    }
}
=== api/extract-pdf/config.ts ===
// app/api/extract-pdf/config.ts
/**
 * Configuration module for the PDF/Image extraction and flashcard generation API.
 * Reads environment variables and defines constants.
 */

function getEnvVariable(key: string, optional: boolean = false): string | undefined {
    const value = process.env[key];
    if (!value && !optional) {
        console.error(`[Config] Missing required environment variable: ${key}`);
        // In a real app, you might throw an error here or have a stricter startup check
        // For now, we log the error and allow the app to potentially fail later if the value is used.
    }
    return value;
}

// --- GCP Credentials ---
export const GCP_PROJECT_ID = getEnvVariable('GCP_PROJECT_ID');
export const GCP_SERVICE_ACCOUNT_EMAIL = getEnvVariable('GCP_SERVICE_ACCOUNT_EMAIL');
// Ensure newlines are correctly interpreted if present
export const GCP_PRIVATE_KEY = getEnvVariable('GCP_PRIVATE_KEY')?.replace(/\\n/g, '\n');

export const credentials = {
    client_email: GCP_SERVICE_ACCOUNT_EMAIL,
    private_key: GCP_PRIVATE_KEY,
};

// --- Document AI Configuration ---
export const DOCAI_LOCATION = getEnvVariable('DOCAI_LOCATION') || 'eu'; // Default to 'eu' if not set
export const DOCAI_PROCESSOR_ID = getEnvVariable('DOCAI_PROCESSOR_ID');
export const DOCAI_API_ENDPOINT = `${DOCAI_LOCATION}-documentai.googleapis.com`;

// --- Vertex AI Configuration ---
export const VERTEX_LOCATION = getEnvVariable('VERTEX_LOCATION') || 'us-central1'; // Default if not set
export const VERTEX_MODEL_NAME = getEnvVariable('VERTEX_MODEL_NAME') || 'gemini-2.0-flash-lite-001'; // Default model

// --- Processing Limits ---
export const PAGE_LIMIT = 30;
export const DOCAI_OCR_PAGE_LIMIT = 15; // Limit for default OCR mode
export const MAX_TEXT_CHARS_FOR_GEMINI = 50000;

// --- Validation Function ---
export function validateConfiguration(): boolean {
    const requiredVars = [
        GCP_PROJECT_ID,
        GCP_SERVICE_ACCOUNT_EMAIL,
        GCP_PRIVATE_KEY,
        DOCAI_LOCATION,
        DOCAI_PROCESSOR_ID,
        VERTEX_LOCATION,
        VERTEX_MODEL_NAME,
    ];

    const missingVars = requiredVars.filter(v => !v);

    if (missingVars.length > 0) {
        console.error(`[Config Validation] FAILED: Missing required configuration. Check environment variables.`);
        // Logging which specific vars are missing was done by getEnvVariable
        return false;
    }

    console.log(`[Config Validation] SUCCESS: All required configurations seem to be present.`);
    return true;
}

// Log configuration on module load for debugging purposes
console.log(`[Config Loaded] API Configuration:
  - GCP Project ID: ${GCP_PROJECT_ID ? 'Configured' : 'MISSING!'}
  - GCP Service Account: ${GCP_SERVICE_ACCOUNT_EMAIL ? 'Configured' : 'MISSING!'}
  - GCP Private Key: ${GCP_PRIVATE_KEY ? 'Configured' : 'MISSING!'}
  - Doc AI Location: ${DOCAI_LOCATION}
  - Doc AI Processor ID: ${DOCAI_PROCESSOR_ID ? 'Configured' : 'MISSING!'}
  - Doc AI Endpoint: ${DOCAI_API_ENDPOINT}
  - Vertex AI Location: ${VERTEX_LOCATION}
  - Vertex AI Model: ${VERTEX_MODEL_NAME}
  - Page Limit: ${PAGE_LIMIT}
  - Doc AI OCR Page Limit: ${DOCAI_OCR_PAGE_LIMIT}
  - Max Gemini Chars: ${MAX_TEXT_CHARS_FOR_GEMINI}
`);

// Initial validation check during server startup/module load
// Note: This won't stop the server cold in Vercel, but logs the issue early.
// The POST handler should perform a runtime check as well.
validateConfiguration();
=== page.tsx ===
import { DeckListClient } from "@/components/DeckListClient";
import { getDecksWithSrsCounts } from "@/lib/actions/deckActions";
import { redirect } from "next/navigation";
import { createServerClient } from "@/lib/supabase/server";
import { cookies } from "next/headers";

/**
 * Home page component.
 * 
 * This is a Server Component that pre-fetches deck data with all SRS counts
 * server-side before rendering the page. This eliminates client-side requests
 * and provides a faster initial load experience.
 * 
 * The page is protected and requires authentication. If the user is not
 * authenticated, they are redirected to the login page.
 * 
 * @returns {Promise<JSX.Element>} The Home page with pre-fetched data
 */
export default async function Home() {
  // Check authentication server-side
  const cookieStore = cookies();
  const supabase = createServerClient(cookieStore);
  const { data: { session }, error: authError } = await supabase.auth.getSession();
  
  // Redirect to login if not authenticated
  if (!session) {
    redirect("/login");
  }
  
  // Fetch all deck data with SRS counts in a single database call
  const { data: decksWithCounts, error: fetchError } = await getDecksWithSrsCounts();
  
  // Log any fetch errors but still render the page (client will handle empty state)
  if (fetchError) {
    console.error("Error fetching decks with counts:", fetchError);
  }
  
  return (
    <div className="grid gap-4">
      <DeckListClient initialData={decksWithCounts || []} />
    </div>
  );
}


=== globals.css ===
@tailwind base;
@tailwind components;
@tailwind utilities;

/* Import custom fonts */
@font-face {
  font-family: 'OpenDyslexic';
  src: url('/fonts/OpenDyslexic-Regular.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

@font-face {
  font-family: 'Atkinson Hyperlegible';
  src: url('/fonts/AtkinsonHyperlegible-Regular.woff2') format('woff2');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}

/* Font classes */
.font-opendyslexic {
  font-family: 'OpenDyslexic', sans-serif;
}

.font-atkinson {
  font-family: 'Atkinson Hyperlegible', sans-serif;
}

.font-sans {
  font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
}

/* Ensure fonts are loaded before use */
.fonts-loaded .font-opendyslexic,
.fonts-loaded .font-atkinson {
  opacity: 1;
  transition: opacity 0.1s ease-in;
}

.fonts-loading .font-opendyslexic,
.fonts-loading .font-atkinson {
  opacity: 0;
}

/* Debug styles to force font application */
[style*="OpenDyslexic"] {
  font-family: OpenDyslexic, -apple-system, BlinkMacSystemFont, system-ui, sans-serif !important;
}

[style*="Atkinson"] {
  font-family: "Atkinson Hyperlegible", -apple-system, BlinkMacSystemFont, system-ui, sans-serif !important;
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 221.2 83.2% 53.3%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 221.2 83.2% 53.3%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 217.2 91.2% 59.8%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 22%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 224.3 76.3% 48%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

/* CSS class to apply specific border color to flashcards */
.flashcard-border {
  /* Override --border locally for light mode */
  --border: 210 40% 70%;
}

.dark .flashcard-border {
  /* Override --border locally for dark mode */
  --border: 210 30% 35%;
}

.flip-card {
  perspective: 1000px;
}

.flip-card-inner {
  transition: transform 0.6s;
  transform-style: preserve-3d;
}

.flip-card-front,
.flip-card-back {
  backface-visibility: hidden;
}

.flip-card-back {
  transform: rotateY(180deg);
}

.flip-card.flipped .flip-card-inner {
  transform: rotateY(180deg);
}

.card-is-changing .flip-card-content {
  opacity: 0;
  transition: opacity 0.01s;
}

.flip-card-content {
  opacity: 1;
  transition: opacity 0.01s;
}


=== login/page.tsx ===
"use client"

import type React from "react"

import { useState, useEffect, Suspense } from "react"
import { useRouter, useSearchParams } from "next/navigation"
import Link from "next/link"
import { Button } from "@/components/ui/button"
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"
import { useAuth } from "@/hooks/use-auth"
import { toast } from "sonner"
import type { AuthError } from '@supabase/supabase-js'

/**
 * Login Page component.
 *
 * This component serves as the entry point for the login route.
 * It wraps the main `LoginContent` component within a React Suspense
 * boundary to handle client-side rendering dependencies like `useSearchParams`.
 *
 * @returns {JSX.Element} The Login Page UI with a Suspense boundary.
 */
export default function LoginPage() {
  // The main export wraps LoginContent in Suspense
  return (
    <Suspense fallback={<div className="flex items-center justify-center min-h-screen">Loading Page...</div>}>
      <LoginContent />
    </Suspense>
  )
}

/**
 * Renders the actual login form and handles user interactions.
 *
 * This client component manages the state for email and password inputs,
 * handles form submission, interacts with the `useAuth` hook for signing in,
 * displays loading states and error messages using toasts, and handles
 * redirection based on authentication status or feedback query parameters
 * (e.g., from email confirmation links).
 *
 * @returns {JSX.Element} The Login form UI or a loading spinner.
 */
// --- Define the inner component containing the client logic ---
function LoginContent() {
  const [email, setEmail] = useState("")
  const [password, setPassword] = useState("")
  const [isSubmitting, setIsSubmitting] = useState(false)
  const { signIn, user, loading: authLoading } = useAuth()
  const router = useRouter()
  const searchParams = useSearchParams()

  useEffect(() => {
    const message = searchParams.get('message')
    const error = searchParams.get('error')

    if (message === 'email_already_confirmed_or_link_invalid') {
      toast("Your email may already be confirmed, or the link was invalid/expired. Please try logging in.")
    } else if (error === 'confirmation_failed') {
      toast.error("Email Confirmation Failed", {
        description: "Could not confirm your email. Please try the link again or sign up if needed."
      })
    } else if (error === 'missing_confirmation_code') {
      toast.error("Invalid Link", {
        description: "The confirmation link is missing necessary information. Please use the link from your email."
      })
    }

    if (message || error) {
      router.replace('/login', { scroll: false })
    }
  }, [searchParams, router])

  useEffect(() => {
    if (!authLoading && user) {
      const callbackUrl = searchParams.get('callbackUrl');
      // Check if callbackUrl exists and is a non-empty string
      if (callbackUrl && typeof callbackUrl === 'string' && callbackUrl.trim() !== '') {
        console.log(`Login successful, redirecting to callbackUrl: ${callbackUrl}`);
        // Decode the URL in case it contains encoded characters
        router.push(decodeURIComponent(callbackUrl)); 
      } else {
        console.log("Login successful, redirecting to default '/'");
        router.push("/"); // Default redirect to homepage
      }
    }
  }, [user, authLoading, router, searchParams]); // Added searchParams dependency

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsSubmitting(true)

    if (!email || !password) {
      toast.error("Missing Information", {
        description: "Please enter both email and password."
      })
      setIsSubmitting(false)
      return
    }

    try {
      const { error } = await signIn(email, password)

      if (error) {
        console.error("Sign in error:", error)
        if (error && typeof error === 'object' && 'message' in error) {
          toast.error(String(error.message) || "Invalid login credentials.")
        } else {
          toast.error("An unexpected error occurred during sign in.")
        }
      } else {
        toast.success("Sign in successful! Redirecting...")
        // Let the useEffect handle redirection
        // router.push("/") 
      }
    } catch (error) {
      console.error("Login submit error:", error)
      toast.error("Login Failed", {
        description: "An unexpected error occurred. Please try again later."
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  if (authLoading || user) {
    return (
        <div className="flex items-center justify-center min-h-screen bg-background">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-primary"></div>
        </div>
      )
  }

  // The actual JSX for the login form
  return (
    <div className="flex items-center justify-center min-h-screen bg-background">
      <Card className="w-full max-w-md">
        <CardHeader className="space-y-1">
          <CardTitle className="text-2xl text-center">StudyCards</CardTitle>
          <CardDescription className="text-center">Enter your email and password to sign in</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            <div className="space-y-2">
              <Label htmlFor="email">Email</Label>
              <Input
                id="email"
                type="email"
                placeholder="m@example.com"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                required
                disabled={isSubmitting}
              />
            </div>
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label htmlFor="password">Password</Label>
                <Link href="/auth/forgot-password" className="text-sm text-primary hover:underline">
                  Forgot password?
                </Link>
              </div>
              <Input
                id="password"
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                required
                disabled={isSubmitting}
              />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={isSubmitting}>
              {isSubmitting ? "Signing in..." : "Sign in"}
            </Button>
          </CardFooter>
        </form>
        <CardFooter className="flex flex-col items-center justify-center space-y-2">
          <div className="text-sm text-muted-foreground">
            Don't have an account?{" "}
            <Link href="/signup" className="text-primary hover:underline">
              Sign up
            </Link>
          </div>
        </CardFooter>
      </Card>
    </div>
  )
}
// --- End of LoginContent component ---



=== sw.js ===
// This is a service worker file for PWA functionality

// Use a versioned cache name
const CACHE_NAME = "studycards-v1"

// List of assets to cache
const ASSETS_TO_CACHE = ["/", "/index.html", "/manifest.json", "/icon-192x192.png", "/icon-512x512.png"]

// Install event handler
self.addEventListener("install", (event) => {
  // Skip waiting to activate the new service worker immediately
  self.skipWaiting()

  event.waitUntil(
    caches
      .open(CACHE_NAME)
      .then((cache) => {
        console.log("Opened cache")
        return cache.addAll(ASSETS_TO_CACHE)
      })
      .catch((error) => {
        console.error("Failed to cache assets:", error)
      }),
  )
})

// Activate event handler
self.addEventListener("activate", (event) => {
  // Clean up old caches
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            console.log("Deleting old cache:", cacheName)
            return caches.delete(cacheName)
          }
        }),
      )
    }),
  )

  // Ensure the service worker takes control immediately
  return self.clients.claim()
})

// Fetch event handler with improved error handling
self.addEventListener("fetch", (event) => {
  // Only cache GET requests
  if (event.request.method !== "GET") return

  // Skip caching for certain URLs
  if (
    event.request.url.includes("/api/") ||
    event.request.url.includes("chrome-extension://") ||
    event.request.url.includes("extension://")
  ) {
    return
  }

  event.respondWith(
    caches.match(event.request).then((response) => {
      // Return cached response if found
      if (response) {
        return response
      }

      // Otherwise fetch from network
      return fetch(event.request)
        .then((fetchResponse) => {
          // Don't cache non-successful responses
          if (!fetchResponse || fetchResponse.status !== 200 || fetchResponse.type !== "basic") {
            return fetchResponse
          }

          // Cache important assets for offline use
          const responseToCache = fetchResponse.clone()

          caches
            .open(CACHE_NAME)
            .then((cache) => {
              cache.put(event.request, responseToCache)
            })
            .catch((error) => {
              console.error("Failed to cache response:", error)
            })

          return fetchResponse
        })
        .catch((error) => {
          console.error("Fetch failed:", error)

          // Return a fallback for offline experience
          if (event.request.url.includes(".html") || event.request.mode === "navigate") {
            return caches.match("/")
          }

          // For other resources, just let the error happen
          throw error
        })
    }),
  )
})


