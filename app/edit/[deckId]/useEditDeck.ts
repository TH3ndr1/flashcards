// app/edit/[deckId]/useEditDeck.ts
"use client";

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
// Assuming useDecks provides getDeck, updateDeck, deleteDeck and their loading state
import { useDecks } from "@/hooks/use-decks";
// Assuming card actions exist and follow ActionResult pattern
import { createCard as createCardAction, updateCard as updateCardAction, deleteCard as deleteCardAction } from "@/lib/actions/cardActions";
// Import your DB types generated by Supabase
import type { Tables, Json } from "@/types/database";
// Assuming useDecks defines this type for its updateDeck action payload
import type { UpdateDeckParams } from "@/hooks/use-decks";
// For user feedback
import { toast } from "sonner";
// For debouncing saves
import { debounce } from "@/lib/utils";
// --- Import NEW Deck Tag actions --- 
import { addTagToDeck, removeTagFromDeck } from '@/lib/actions/tagActions';
// --- Update state type to include tags --- 
// Use the DeckWithCardsAndTags type which includes the tags array
// Assuming useDecks.getDeck returns this structure now
import type { DeckWithCardsAndTags } from "@/hooks/use-decks"; // Import the combined type

// Type aliases for better readability
type DbDeck = Tables<'decks'>;
type DbCard = Tables<'cards'>;
type DbTag = Tables<'tags'>; // Added Tag type alias

// Define the input type for creating a card (matches server action expectation)
// Add the new classification fields here
type CreateCardInput = Pick<DbCard, 'question' | 'answer' | 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>;

// Define the input type for updating a card (matches server action expectation)
// All fields are optional
type UpdateCardInput = Partial<CreateCardInput>;

// Define the state type managed by this hook
// Base it on the imported type but explicitly allow partial cards in the state
export type DeckEditState = (Omit<DeckWithCardsAndTags, 'cards'> & { cards: Array<Partial<DbCard>> }) | null;

// Debounce time for auto-saving metadata (in milliseconds)
const DECK_UPDATE_DEBOUNCE_MS = 1500;

// Interface for storing previous/initial metadata state for comparison logic
interface MetadataState {
    name?: string | null;
    primary_language?: string | null;
    secondary_language?: string | null;
    is_bilingual?: boolean | null;
}

/**
 * Custom hook to manage the state and logic for editing a deck.
 *
 * @param deckId The ID of the deck to edit (from route params), or undefined if creating/invalid.
 * @returns An object containing the deck state, loading/error status, and action handlers.
 */
export function useEditDeck(deckId: string | undefined) {
    const router = useRouter();
    // Get deck-related actions and loading state from the dedicated useDecks hook
    const { getDeck, updateDeck, deleteDeck, loading: useDecksLoading } = useDecks();

    // --- State Definitions ---
    const [deck, setDeck] = useState<DeckEditState>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isSavingMetadata, setIsSavingMetadata] = useState(false);
    const [isDeletingDeck, setIsDeletingDeck] = useState(false);

    // --- Refs for Internal Logic ---
    const isMountedRef = useRef(false); // Track initial load completion
    // Ref to store the last *successfully saved* or initially loaded metadata state
    const previousSavedMetadataRef = useRef<MetadataState>({});


    // --- Data Fetching Logic ---
    const loadDeckData = useCallback(async (id: string) => {
        console.log(`[useEditDeck] Loading deck data for ID: ${id}`);
        setLoading(true); setError(null);
        isMountedRef.current = false; // Reset load flag
        previousSavedMetadataRef.current = {}; // Reset saved state ref
        try {
            const result = await getDeck(id);
            if (result.error) throw new Error(result.error);
            if (result.data) {
                // Store in the state with cards explicitly as Partial<DbCard>[]
                const fetchedDeckForState: DeckEditState = {
                    ...result.data,
                    cards: (result.data.cards || []) as Array<Partial<DbCard>> // Cast to partial for state
                };
                console.log("[useEditDeck] Fetched Deck Data for State:", fetchedDeckForState);
                setDeck(fetchedDeckForState); 
                // Null check before accessing properties
                if (fetchedDeckForState) { 
                    previousSavedMetadataRef.current = {
                        name: fetchedDeckForState.name,
                        primary_language: fetchedDeckForState.primary_language,
                        secondary_language: fetchedDeckForState.secondary_language,
                        is_bilingual: fetchedDeckForState.is_bilingual,
                    };
                    isMountedRef.current = true;
                    console.log("[useEditDeck] Initial deck loaded. Metadata ref set.", previousSavedMetadataRef.current);
                } else {
                     isMountedRef.current = false;
                     console.warn("[useEditDeck] Fetched deck data was unexpectedly null after check.");
                }
            } else {
                // Deck not found case
                setDeck(null); // Ensure deck state is null
                setError("Deck not found or access denied."); // Set error message
                isMountedRef.current = false; 
                console.log("[useEditDeck] Deck not found or access denied, setting state to null.");
            }
        } catch (err: any) {
             console.error("[useEditDeck] Error loading deck:", err);
              setError(err.message || "Failed to load deck.");
              setDeck(null);
              isMountedRef.current = false;
        } finally {
            setLoading(false);
        }
    }, [getDeck]);

    // Initial load effect
    useEffect(() => {
        isMountedRef.current = false; // Reset on ID change
        previousSavedMetadataRef.current = {};
        if (deckId && !useDecksLoading) {
            loadDeckData(deckId);
        } else if (!deckId) {
            setError("No Deck ID provided."); setLoading(false);
        } else if (useDecksLoading) {
            console.log("[useEditDeck] Waiting for useDecks hook to finish loading...");
            setLoading(true);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [deckId, useDecksLoading]);


    // --- Deck Metadata Updates ---

    // Debounced function responsible for calling the actual update action
    const debouncedSaveMetadata = useCallback(
        debounce(async (deckIdToSave: string, payloadToSave: UpdateDeckParams) => {
            if (!isMountedRef.current) {
                console.warn("[useEditDeck] Debounced save skipped: Initial load not complete.");
                return;
            }

            console.log("[useEditDeck] Debounced Save Metadata EXECUTION for ID:", deckIdToSave, "Payload:", payloadToSave);
            setIsSavingMetadata(true);
            try {
                const result = await updateDeck(deckIdToSave, payloadToSave);

                if (result.error) {
                    toast.error("Deck settings auto-save failed", { description: result.error });
                } else {
                    console.log("[useEditDeck] Deck settings auto-saved successfully to DB.");
                    // Update the ref ONLY after successful save
                    if (result.data) {
                         previousSavedMetadataRef.current = {
                            name: result.data.name,
                            primary_language: result.data.primary_language,
                            secondary_language: result.data.secondary_language,
                            is_bilingual: result.data.is_bilingual,
                         };
                         console.log("[useEditDeck] Updated previousSavedMetadataRef after successful save.");
                    }
                     // *** NO setDeck() call here ***
                }
            } catch (error: any) {
                console.error("[useEditDeck] Error during debouncedSaveMetadata execution:", error);
                toast.error("Deck settings auto-save failed", { description: error.message || "Unknown error" });
            } finally {
                setIsSavingMetadata(false);
            }
        }, DECK_UPDATE_DEBOUNCE_MS),
        [updateDeck] // Stable dependency
    );

    // Handler called by the DeckMetadataEditor component when user input changes
    const handleDeckMetadataChange = useCallback((updates: Partial<DbDeck>) => {
        console.log('[DEBUG] handleDeckMetadataChange called with updates:', updates);
        // --- Use DeckEditState type for callback param and return --- 
        setDeck((prevDeckState: DeckEditState): DeckEditState => {
            if (!prevDeckState) return null;
            // Ensure cards remain Array<Partial<DbCard>>
            return { ...prevDeckState, ...updates }; 
        });
        // --- Trigger debounce after state update --- 
        if (isMountedRef.current && deck?.id && previousSavedMetadataRef.current) {
            const currentMetadataPayload: MetadataState = {
               name: updates.name ?? deck.name,
               primary_language: updates.primary_language ?? deck.primary_language,
               secondary_language: updates.secondary_language ?? deck.secondary_language,
               is_bilingual: updates.is_bilingual ?? deck.is_bilingual,
            };

            let changed = false;
            if (currentMetadataPayload.name !== previousSavedMetadataRef.current.name) changed = true;
            if (currentMetadataPayload.primary_language !== previousSavedMetadataRef.current.primary_language) changed = true;
            if (currentMetadataPayload.secondary_language !== previousSavedMetadataRef.current.secondary_language) changed = true;
            if (currentMetadataPayload.is_bilingual !== previousSavedMetadataRef.current.is_bilingual) changed = true;

            if (changed) {
                console.log("[DEBUG] Change detected from initial/last save. Queuing debounced metadata save.");
                const payloadToSave: UpdateDeckParams = {
                    name: currentMetadataPayload.name ?? undefined,
                    primary_language: currentMetadataPayload.primary_language ?? undefined,
                    secondary_language: currentMetadataPayload.secondary_language ?? undefined,
                    is_bilingual: currentMetadataPayload.is_bilingual ?? undefined,
                };
                debouncedSaveMetadata(deck.id, payloadToSave);
            } else {
                console.log("[DEBUG] No change detected from initial/last save. Save trigger skipped.");
            }
        }
        // -------------------------------------------
    }, [debouncedSaveMetadata, deck]); // Added deck dependency for check


    // --- Card Actions (Remain the same as the last complete version) ---
    const handleAddCardOptimistic = useCallback(() => {
         if (!deck) return;
         const newCardPlaceholder: Partial<DbCard> = {
             id: `new-${Date.now()}`,
             question: "",
             answer: "",
             question_part_of_speech: null, // Initialize new fields
             question_gender: null,
             answer_part_of_speech: null,
             answer_gender: null,
             deck_id: deck.id,
             user_id: deck.user_id,
             // Default SRS fields
             srs_level: 0,
             easiness_factor: 2.5,
             interval_days: 0,
             stability: 0,
             difficulty: 0,
             last_review_grade: null,
             last_reviewed_at: null,
             next_review_due: null,
             correct_count: 0,
             incorrect_count: 0,
             attempt_count: 0
         };
         // --- Use DeckEditState type --- 
         setDeck((prev: DeckEditState): DeckEditState => {
             if (!prev) return null;
             const updatedCards: Array<Partial<DbCard>> = [...prev.cards, newCardPlaceholder];
             return { ...prev, cards: updatedCards };
         });
         console.log("[useEditDeck] Added optimistic card placeholder:", newCardPlaceholder.id);
    }, [deck]);

    const handleCreateCard = useCallback(async (cardData: CreateCardInput): Promise<string | null> => {
        if (!deck || !deck.id) { toast.error("Cannot create card: Deck missing."); return null; }
        const toastId = toast.loading("Saving new card...");
        try {
            const result = await createCardAction(deck.id, cardData);
            if (result.error || !result.data) throw result.error || new Error("Failed to create card.");
            toast.success(`New card created!`, { id: toastId });
            await loadDeckData(deck.id); // Refetch
            return result.data.id;
        } catch (error: any) {
            toast.error("Failed to save new card", { id: toastId, description: error.message || "Unknown error." });
            // --- Use DeckEditState type --- 
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const filteredCards: Array<Partial<DbCard>> = prev.cards.filter((c: Partial<DbCard>) => !c.id?.startsWith('new-'));
                return { ...prev, cards: filteredCards };
            });
            return null;
        }
    }, [deck, loadDeckData]);

    const handleUpdateCard = useCallback(async (cardId: string, cardData: UpdateCardInput): Promise<void> => {
        if (!cardId || cardId.startsWith('new-')) return;
        const toastId = `update-${cardId}`;
        toast.loading("Saving card...", { id: toastId });
        try {
            const updatePayload: UpdateCardInput = { ...cardData };
            const originalCard = deck?.cards.find(c => c.id === cardId);
            if (!originalCard) { toast.dismiss(toastId); return; }

            let changed = false;
            if (originalCard.question !== updatePayload.question) changed = true;
            if (originalCard.answer !== updatePayload.answer) changed = true;
            if (originalCard.question_part_of_speech !== updatePayload.question_part_of_speech) changed = true;
            if (originalCard.question_gender !== updatePayload.question_gender) changed = true;
            if (originalCard.answer_part_of_speech !== updatePayload.answer_part_of_speech) changed = true;
            if (originalCard.answer_gender !== updatePayload.answer_gender) changed = true;

            if (!changed) { toast.dismiss(toastId); console.log(`No changes for card ${cardId}.`); return; }

            const result = await updateCardAction(cardId, updatePayload);
            if (result.error || !result.data) throw result.error || new Error("Failed to update card.");
            toast.success("Card updated!", { id: toastId });
            if(deck?.id) await loadDeckData(deck.id); // Refetch
        } catch (error: any) {
            toast.error("Failed to update card", { id: toastId, description: error.message || "Unknown error." });
            if(deck?.id) await loadDeckData(deck.id); // Refetch on error too
        }
    }, [deck, loadDeckData]);

    const handleDeleteCard = useCallback(async (cardId: string): Promise<void> => {
         if (!cardId) return;
         const isPlaceholder = cardId.startsWith('new-');
         const originalCards = deck?.cards; // Store potentially partial cards

         // --- Optimistic update using DeckEditState --- 
         setDeck((prev: DeckEditState): DeckEditState => {
             if (!prev) return null;
             const filteredCards: Array<Partial<DbCard>> = prev.cards.filter((c: Partial<DbCard>) => c.id !== cardId);
             return { ...prev, cards: filteredCards };
         });

         // If it was just a placeholder, we're done
         if (isPlaceholder) return; 

         // --- Handle existing card deletion on backend --- 
        const toastId = toast.loading("Deleting card...");
        try {
            const result = await deleteCardAction(cardId);
             if (result.error) throw new Error(result.error);
            toast.success("Card deleted!", { id: toastId });
        } catch (error: any) {
            toast.error("Failed to delete card", { id: toastId, description: error.message || "Unknown error." });
            // --- Revert state using original (potentially partial) cards --- 
            if (originalCards) {
                setDeck((prev: DeckEditState): DeckEditState => {
                    if (!prev) return null; 
                    return { ...prev, cards: originalCards }; // Restore original partial array
                });
            } else if (deck?.id) {
                 // Fallback refetch if original state wasn't captured
                loadDeckData(deck.id);
            }
            // ------------------------------------------------------------
        }
    }, [deck, loadDeckData]);


    // --- Deck Deletion ---
    const handleDeleteDeckConfirm = useCallback(async (): Promise<void> => {
        if (!deck || !deck.id) { toast.error("Cannot delete deck: data missing."); return; }
        setIsDeletingDeck(true);
        const deckName = deck.name;
        try {
            const result = await deleteDeck(deck.id);
            if (result.error) throw new Error(result.error);
            toast.success(`Deck "${deckName}" deleted successfully!`);
            router.push('/');
        } catch (error: any) {
            toast.error(`Failed to delete deck "${deckName}"`, { description: error.message || "Unknown error." });
            setIsDeletingDeck(false);
        }
    }, [deck, deleteDeck, router]);

    // --- NEW: Deck Tag Handlers ---
    const handleAddTagToDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot add tag: Deck not loaded.");
            return;
        }
        console.log(`[useEditDeck] Adding tag ${tagId} to deck ${deck.id}`);
        const toastId = toast.loading("Adding tag...");
        try {
            const result = await addTagToDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag added to deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            console.error("[useEditDeck] Error adding tag to deck:", error);
            toast.error("Failed to add tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData

    const handleRemoveTagFromDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot remove tag: Deck not loaded.");
            return;
        }
        console.log(`[useEditDeck] Removing tag ${tagId} from deck ${deck.id}`);
        const toastId = toast.loading("Removing tag...");
        try {
            const result = await removeTagFromDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag removed from deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            console.error("[useEditDeck] Error removing tag from deck:", error);
            toast.error("Failed to remove tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData
    // --------------------------------

    // --- Return Values ---
    return {
        deck,
        // Extract tags from deck state, provide empty array if deck is null
        deckTags: deck?.tags ?? [], 
        loading: loading || useDecksLoading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        loadDeckData,
        handleDeckMetadataChange, // Expose the handler that triggers the save
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleAddTagToDeck, // Expose new handler
        handleRemoveTagFromDeck, // Expose new handler
        handleDeleteDeckConfirm,
    };
}