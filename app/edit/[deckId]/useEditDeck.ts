// app/edit/[deckId]/useEditDeck.ts
"use client";

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
// Assuming useDecks provides getDeck, updateDeck, deleteDeck and their loading state
import { useDecks } from "@/hooks/use-decks";
// Assuming card actions exist and follow ActionResult pattern
import { createCard as createCardAction, updateCard as updateCardAction, deleteCard as deleteCardAction } from "@/lib/actions/cardActions";
// Import your DB types generated by Supabase
import type { Tables, Json } from "@/types/database";
// Assuming useDecks defines this type for its updateDeck action payload
import type { UpdateDeckParams } from "@/hooks/use-decks";
// For user feedback
import { toast } from "sonner";
// For debouncing saves
import { debounce } from "@/lib/utils";
// --- Import NEW Deck Tag actions --- 
import { addTagToDeck, removeTagFromDeck } from '@/lib/actions/tagActions';
// --- Update state type to include tags --- 
// Use the DeckWithCardsAndTags type which includes the tags array
// Assuming useDecks.getDeck returns this structure now
import type { DeckWithCardsAndTags } from "@/hooks/use-decks"; // Import the combined type
import { appLogger, statusLogger } from '@/lib/logger';

// Type aliases for better readability
type DbDeck = Tables<'decks'>;
type DbCard = Tables<'cards'>;
type DbTag = Tables<'tags'>; // Added Tag type alias

// Define the input type for creating a card (matches server action expectation)
// Add the new classification fields here
type CreateCardInput = Pick<DbCard, 'question' | 'answer' | 'question_part_of_speech' | 'question_gender' | 'answer_part_of_speech' | 'answer_gender'>;

// Define the input type for updating a card (matches server action expectation)
// All fields are optional
type UpdateCardInput = Partial<CreateCardInput>;

// Define the state type managed by this hook
// Base it on the imported type but explicitly allow partial cards in the state
export type DeckEditState = (Omit<DeckWithCardsAndTags, 'cards'> & { cards: Array<Partial<DbCard>> }) | null;

// Debounce time for auto-saving metadata (in milliseconds)
const DECK_UPDATE_DEBOUNCE_MS = 1500;

// Interface for storing previous/initial metadata state for comparison logic
interface MetadataState {
    name?: string | null;
    primary_language?: string | null;
    secondary_language?: string | null;
    is_bilingual?: boolean | null;
}

/**
 * Custom hook to manage the state and logic for editing a deck.
 *
 * @param deckId The ID of the deck to edit (from route params), or undefined if creating/invalid.
 * @returns An object containing the deck state, loading/error status, and action handlers.
 */
export function useEditDeck(deckId: string | undefined) {
    const router = useRouter();
    // Get deck-related actions and loading state from the dedicated useDecks hook
    const { getDeck, updateDeck, deleteDeck, loading: useDecksLoading } = useDecks();

    // --- State Definitions ---
    const [deck, setDeck] = useState<DeckEditState>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isSavingMetadata, setIsSavingMetadata] = useState(false);
    const [isDeletingDeck, setIsDeletingDeck] = useState(false);

    // --- Refs for Internal Logic ---
    const isMountedRef = useRef(false); // Track initial load completion
    // Ref to store the last *successfully saved* or initially loaded metadata state
    const previousSavedMetadataRef = useRef<MetadataState>({});


    // --- Data Fetching Logic ---
    const loadDeckData = useCallback(async (id: string) => {
        appLogger.info(`[useEditDeck] Loading deck data for ID: ${id}`);
        setLoading(true); setError(null);
        isMountedRef.current = false; // Reset load flag
        previousSavedMetadataRef.current = {}; // Reset saved state ref
        try {
            const result = await getDeck(id);
            if (result.error) throw new Error(result.error);
            if (result.data) {
                // Store in the state with cards explicitly as Partial<DbCard>[]
                const fetchedDeckForState: DeckEditState = {
                    ...result.data,
                    cards: (result.data.cards || []) as Array<Partial<DbCard>> // Cast to partial for state
                };
                appLogger.info("[useEditDeck] Fetched Deck Data for State:", fetchedDeckForState);
                setDeck(fetchedDeckForState); 
                // Null check before accessing properties
                if (fetchedDeckForState) { 
                    previousSavedMetadataRef.current = {
                        name: fetchedDeckForState.name,
                        primary_language: fetchedDeckForState.primary_language,
                        secondary_language: fetchedDeckForState.secondary_language,
                        is_bilingual: fetchedDeckForState.is_bilingual,
                    };
                    isMountedRef.current = true;
                    appLogger.info("[useEditDeck] Initial deck loaded. Metadata ref set.", previousSavedMetadataRef.current);
                } else {
                     isMountedRef.current = false;
                     appLogger.warn("[useEditDeck] Fetched deck data was unexpectedly null after check.");
                }
            } else {
                // Deck not found case
                setDeck(null); // Ensure deck state is null
                setError("Deck not found or access denied."); // Set error message
                isMountedRef.current = false; 
                appLogger.info("[useEditDeck] Deck not found or access denied, setting state to null.");
            }
        } catch (err: any) {
             appLogger.error("[useEditDeck] Error loading deck:", err);
              setError(err.message || "Failed to load deck.");
              setDeck(null);
              isMountedRef.current = false;
        } finally {
            setLoading(false);
        }
    }, [getDeck]);

    // Initial load effect
    useEffect(() => {
        isMountedRef.current = false; // Reset on ID change
        previousSavedMetadataRef.current = {};
        if (deckId && !useDecksLoading) {
            loadDeckData(deckId);
        } else if (!deckId) {
            setError("No Deck ID provided."); setLoading(false);
        } else if (useDecksLoading) {
            appLogger.info("[useEditDeck] Waiting for useDecks hook to finish loading...");
            setLoading(true);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [deckId, useDecksLoading]);


    // --- Deck Metadata Updates ---

    // Debounced function responsible for calling the actual update action
    const debouncedSaveMetadata = useCallback(
        debounce(async (deckIdToSave: string, payloadToSave: UpdateDeckParams) => {
            if (!isMountedRef.current) {
                appLogger.warn("[useEditDeck] Debounced save skipped: Initial load not complete.");
                return;
            }

            appLogger.info("[useEditDeck] Debounced Save Metadata EXECUTION for ID:", deckIdToSave, "Payload:", payloadToSave);
            setIsSavingMetadata(true);
            try {
                const result = await updateDeck(deckIdToSave, payloadToSave);

                if (result.error) {
                    toast.error("Deck settings auto-save failed", { description: result.error });
                } else {
                    appLogger.info("[useEditDeck] Deck settings auto-saved successfully to DB.");
                    // Update the ref ONLY after successful save
                    if (result.data) {
                         previousSavedMetadataRef.current = {
                            name: result.data.name,
                            primary_language: result.data.primary_language,
                            secondary_language: result.data.secondary_language,
                            is_bilingual: result.data.is_bilingual,
                         };
                         appLogger.info("[useEditDeck] Updated previousSavedMetadataRef after successful save.");
                    }
                     // *** NO setDeck() call here ***
                }
            } catch (error: any) {
                appLogger.error("[useEditDeck] Error during debouncedSaveMetadata execution:", error);
                toast.error("Deck settings auto-save failed", { description: error.message || "Unknown error" });
            } finally {
                setIsSavingMetadata(false);
            }
        }, DECK_UPDATE_DEBOUNCE_MS),
        [updateDeck] // Stable dependency
    );

    // Handler called by the DeckMetadataEditor component when user input changes
    const handleDeckMetadataChange = useCallback((updates: Partial<DbDeck>) => {
        appLogger.info('[DEBUG] handleDeckMetadataChange called with updates:', updates);
        // --- Use DeckEditState type for callback param and return --- 
        setDeck((prevDeckState: DeckEditState): DeckEditState => {
            if (!prevDeckState) return null;
            // Ensure cards remain Array<Partial<DbCard>>
            return { ...prevDeckState, ...updates }; 
        });
        // --- Trigger debounce after state update --- 
        if (isMountedRef.current && deck?.id && previousSavedMetadataRef.current) {
            const currentMetadataPayload: MetadataState = {
               name: updates.name ?? deck.name,
               primary_language: updates.primary_language ?? deck.primary_language,
               secondary_language: updates.secondary_language ?? deck.secondary_language,
               is_bilingual: updates.is_bilingual ?? deck.is_bilingual,
            };

            let changed = false;
            if (currentMetadataPayload.name !== previousSavedMetadataRef.current.name) changed = true;
            if (currentMetadataPayload.primary_language !== previousSavedMetadataRef.current.primary_language) changed = true;
            if (currentMetadataPayload.secondary_language !== previousSavedMetadataRef.current.secondary_language) changed = true;
            if (currentMetadataPayload.is_bilingual !== previousSavedMetadataRef.current.is_bilingual) changed = true;

            if (changed) {
                appLogger.info("[DEBUG] Change detected from initial/last save. Queuing debounced metadata save.");
                const payloadToSave: UpdateDeckParams = {
                    name: currentMetadataPayload.name ?? undefined,
                    primary_language: currentMetadataPayload.primary_language ?? undefined,
                    secondary_language: currentMetadataPayload.secondary_language ?? undefined,
                    is_bilingual: currentMetadataPayload.is_bilingual ?? undefined,
                };
                debouncedSaveMetadata(deck.id, payloadToSave);
            } else {
                appLogger.info("[DEBUG] No change detected from initial/last save. Save trigger skipped.");
            }
        }
        // -------------------------------------------
    }, [debouncedSaveMetadata, deck]); // Added deck dependency for check


    // --- Card Actions ---
    const handleAddCardOptimistic = useCallback(() => {
         if (!deck) return;
         // Generate a unique temporary ID for the placeholder
         const tempId = `new-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
         const newCardPlaceholder: Partial<DbCard> = {
             id: tempId, // Use unique temp ID
             question: "",
             answer: "",
             question_part_of_speech: null, // Initialize new fields
             question_gender: null,
             answer_part_of_speech: null,
             answer_gender: null,
             deck_id: deck.id,
             user_id: deck.user_id,
             // Default SRS fields
             srs_level: 0,
             easiness_factor: 2.5,
             interval_days: 0,
             stability: 0,
             difficulty: 0,
             last_review_grade: null,
             last_reviewed_at: null,
             next_review_due: null,
             correct_count: 0,
             incorrect_count: 0,
             attempt_count: 0
         };
         // --- Use DeckEditState type --- 
         setDeck((prev: DeckEditState): DeckEditState => {
             if (!prev) return null;
             const updatedCards: Array<Partial<DbCard>> = [...prev.cards, newCardPlaceholder];
             return { ...prev, cards: updatedCards };
         });
         appLogger.info("[useEditDeck] Added optimistic card placeholder:", newCardPlaceholder.id);
    }, [deck]);

    const handleCreateCard = useCallback(async (cardData: CreateCardInput): Promise<string | null> => {
        // deckId is stable from the hook's parameter
        if (!deckId) { 
            toast.error("Cannot create card: Deck ID missing."); 
            appLogger.error("[useEditDeck] handleCreateCard: deckId is undefined.");
            return null; 
        }

        // Find the temporary ID for optimistic update.
        // This part still needs access to the current cards list.
        // We can get it from the functional update form of setDeck.
        let tempId: string | undefined;

        setDeck((prevDeckState) => {
            if (prevDeckState) {
                const tempCard = prevDeckState.cards.find(c => c.id?.startsWith('new-'));
                tempId = tempCard?.id;
            }
            return prevDeckState; // No change here, just reading
        });

        const toastId = toast.loading("Saving new card...");
        try {
            const result = await createCardAction(deckId, cardData); // Use stable deckId from hook params
            if (result.error || !result.data) throw result.error || new Error("Failed to create card.");

            const savedCard = result.data;
            toast.success(`New card created!`, { id: toastId });

            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const updatedCards = prev.cards.map(c => 
                    (tempId && c.id === tempId) ? savedCard : c // Replace placeholder if tempId was found
                );
                // If placeholder wasn't found or wasn't replaced, add the saved card
                // This can happen if tempId was not identified correctly or if the create was triggered independently
                if (!updatedCards.some(c => c.id === savedCard.id)) {
                   appLogger.warn("[useEditDeck] Optimistic placeholder not replaced or found, adding saved card directly to list:", savedCard.id);
                   updatedCards.push(savedCard);
                }
                return { ...prev, cards: updatedCards.filter(c => !(tempId && c.id === tempId && c.id !== savedCard.id)) }; // Ensure only one instance
            });
            return savedCard.id;

        } catch (error: any) {
            toast.error("Failed to save new card", { id: toastId, description: error.message || "Unknown error." });
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const filteredCards: Array<Partial<DbCard>> = tempId 
                    ? prev.cards.filter((c: Partial<DbCard>) => c.id !== tempId)
                    : prev.cards.filter((c: Partial<DbCard>) => !c.id?.startsWith('new-')); // Fallback: remove all placeholders
                return { ...prev, cards: filteredCards };
            });
            return null;
        }
    }, [deckId, createCardAction]); // Dependencies: stable deckId and server action

    // updateCardCore should already be stable if its dependencies are just server actions
    const updateCardCore = useCallback(async (cardId: string, cardData: UpdateCardInput) => {
        const toastId = toast.loading("Updating card...");
        
        // For optimistic revert, we need the state of the specific card *before* this update.
        // It's complex to manage perfectly without a snapshot if setDeck is called multiple times.
        // The current optimistic update applies locally first.
        let originalCardState: Partial<DbCard> | undefined;

        setDeck((prev: DeckEditState): DeckEditState => {
            if (!prev) return null;
            originalCardState = prev.cards.find(c => c.id === cardId);
            const updatedCards = prev.cards.map(c => 
                c.id === cardId ? { ...c, ...cardData } : c
            );
            return { ...prev, cards: updatedCards };
        });

        try {
            const result = await updateCardAction(cardId, cardData);
            if (result.error || !result.data) throw result.error || new Error("Failed to update card.");

            const savedCard = result.data;
            toast.success("Card updated!", { id: toastId });

            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                const confirmedCards = prev.cards.map(c => 
                    c.id === cardId ? savedCard : c
                );
                return { ...prev, cards: confirmedCards };
            });

        } catch (error: any) {
            toast.error("Failed to update card", { id: toastId, description: error.message || "Unknown error." });
            setDeck((prev: DeckEditState): DeckEditState => {
                if (!prev) return null;
                // Revert to the specific card's original state if captured, else full originalCards might be too broad
                const revertedCards = prev.cards.map(c => 
                    (c.id === cardId && originalCardState) ? originalCardState : c
                );
                // If originalCardState wasn't captured or something went wrong, this might not fully revert.
                // A more robust revert might involve storing the full 'originalCards' array before any optimistic change for this action.
                appLogger.info("[useEditDeck] Attempting to revert card update due to error. Card ID:", cardId);
                return { ...prev, cards: revertedCards }; 
            });
        }
    }, [updateCardAction]); // Dependency: stable server action

    // This is the stable callback passed down to CardEditor for existing card updates
    const handleUpdateCard = useCallback((cardId: string, cardData: UpdateCardInput) => {
        if (cardId.startsWith('new-')) {
            appLogger.warn(`[useEditDeck] handleUpdateCard called for placeholder ID: ${cardId}. This should be handled by CardEditor's onCreate.`);
            // It's possible the CardEditor's internal save logic for new cards might call onUpdate if not careful.
            // If cardData contains enough info, we could redirect to handleCreateCard.
            // For now, let's assume CardEditor correctly distinguishes create vs update.
            return;
        }
        appLogger.info(`[useEditDeck] Stable handleUpdateCard forwarding to updateCardCore for ID: ${cardId}`);
        updateCardCore(cardId, cardData);
    }, [updateCardCore]); // Now only depends on the stable updateCardCore

    const handleDeleteCard = useCallback(async (cardId: string) => {
        // deckId is stable from hook params
        if (!deckId) {
             appLogger.error("[useEditDeck] handleDeleteCard: deckId is undefined, cannot proceed.");
             return; // Should not happen if deck is loaded
        }
        
        let originalCards: Array<Partial<DbCard>> = [];
        setDeck((prev: DeckEditState): DeckEditState => {
            if (!prev) return null;
            originalCards = [...prev.cards]; // Shallow copy for potential revert
            const updatedCards = prev.cards.filter(c => c.id !== cardId);
            return { ...prev, cards: updatedCards };
        });

        const toastId = toast.loading("Deleting card...");
        try {
            // For non-placeholder cards, call the server action
            if (!cardId.startsWith('new-')) {
                const result = await deleteCardAction(cardId);
                if (result.error) throw result.error;
            }
            // If it was a placeholder (starts with 'new-'), it's already removed from local state.
            toast.success("Card deleted!", { id: toastId });
            // State already updated optimistically.
        } catch (error: any) {
            toast.error("Failed to delete card", { id: toastId, description: error.message || "Unknown error." });
            setDeck((prev: DeckEditState): DeckEditState => {
                 if (!prev) return null;
                 // Revert to the copied originalCards array
                 return { ...prev, cards: originalCards }; 
            });
        }
    }, [deckId, deleteCardAction]); // Dependencies: stable deckId and server action


    // --- Deck Deletion ---
    const handleDeleteDeckConfirm = useCallback(async (): Promise<void> => {
        if (!deck || !deck.id) { toast.error("Cannot delete deck: data missing."); return; }
        setIsDeletingDeck(true);
        const deckName = deck.name;
        try {
            const result = await deleteDeck(deck.id);
            if (result.error) throw new Error(result.error);
            toast.success(`Deck "${deckName}" deleted successfully!`);
            router.push('/');
        } catch (error: any) {
            toast.error(`Failed to delete deck "${deckName}"`, { description: error.message || "Unknown error." });
            setIsDeletingDeck(false);
        }
    }, [deck, deleteDeck, router]);

    // --- NEW: Deck Tag Handlers ---
    const handleAddTagToDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot add tag: Deck not loaded.");
            return;
        }
        appLogger.info(`[useEditDeck] Adding tag ${tagId} to deck ${deck.id}`);
        const toastId = toast.loading("Adding tag...");
        try {
            const result = await addTagToDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag added to deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            appLogger.error("[useEditDeck] Error adding tag to deck:", error);
            toast.error("Failed to add tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData

    const handleRemoveTagFromDeck = useCallback(async (tagId: string) => {
        if (!deck || !deck.id) {
            toast.error("Cannot remove tag: Deck not loaded.");
            return;
        }
        appLogger.info(`[useEditDeck] Removing tag ${tagId} from deck ${deck.id}`);
        const toastId = toast.loading("Removing tag...");
        try {
            const result = await removeTagFromDeck(deck.id, tagId);
            if (result.error) {
                throw new Error(result.error);
            }
            toast.success("Tag removed from deck", { id: toastId });
            // Refetch deck data to get the updated tag list
            await loadDeckData(deck.id);
        } catch (error: any) {
            appLogger.error("[useEditDeck] Error removing tag from deck:", error);
            toast.error("Failed to remove tag", { id: toastId, description: error.message });
        }
    }, [deck, loadDeckData]); // Depend on deck and loadDeckData
    // --------------------------------

    // --- Return Values ---
    return {
        deck,
        // Extract tags from deck state, provide empty array if deck is null
        deckTags: deck?.tags ?? [], 
        loading: loading || useDecksLoading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        loadDeckData,
        handleDeckMetadataChange, // Expose the handler that triggers the save
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleAddTagToDeck, // Expose new handler
        handleRemoveTagFromDeck, // Expose new handler
        handleDeleteDeckConfirm,
    };
}