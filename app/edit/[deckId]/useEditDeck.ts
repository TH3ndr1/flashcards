// app/edit/[deckId]/useEditDeck.ts
"use client";

import { useState, useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';
// Assuming useDecks provides getDeck, updateDeck, deleteDeck and their loading state
import { useDecks } from "@/hooks/use-decks";
// Assuming card actions exist and follow ActionResult pattern
import { createCard as createCardAction, updateCard as updateCardAction, deleteCard as deleteCardAction } from "@/lib/actions/cardActions";
// Import your DB types generated by Supabase
import type { Tables, Json } from "@/types/database";
// Assuming useDecks defines this type for its updateDeck action payload
import type { UpdateDeckParams } from "@/hooks/use-decks";
// For user feedback
import { toast } from "sonner";
// For debouncing saves
import { debounce } from "@/lib/utils";

// Type aliases for better readability
type DbDeck = Tables<'decks'>;
type DbCard = Tables<'cards'>;

// Define the state type managed by this hook
// Includes the full deck and potentially partial cards (e.g., new placeholders)
export type DeckEditState = (DbDeck & { cards: Array<Partial<DbCard>> }) | null;

// Debounce time for auto-saving metadata (in milliseconds)
const DECK_UPDATE_DEBOUNCE_MS = 1500;

// Interface for storing previous/initial metadata state for comparison logic
interface MetadataState {
    name?: string | null;
    primary_language?: string | null;
    secondary_language?: string | null;
    is_bilingual?: boolean | null;
}

/**
 * Custom hook to manage the state and logic for editing a deck.
 *
 * @param deckId The ID of the deck to edit (from route params), or undefined if creating/invalid.
 * @returns An object containing the deck state, loading/error status, and action handlers.
 */
export function useEditDeck(deckId: string | undefined) {
    const router = useRouter();
    // Get deck-related actions and loading state from the dedicated useDecks hook
    const { getDeck, updateDeck, deleteDeck, loading: useDecksLoading } = useDecks();

    // --- State Definitions ---
    const [deck, setDeck] = useState<DeckEditState>(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isSavingMetadata, setIsSavingMetadata] = useState(false);
    const [isDeletingDeck, setIsDeletingDeck] = useState(false);

    // --- Refs for Internal Logic ---
    const isMountedRef = useRef(false); // Track initial load completion
    // Ref to store the last *successfully saved* or initially loaded metadata state
    const previousSavedMetadataRef = useRef<MetadataState>({});


    // --- Data Fetching Logic ---
    const loadDeckData = useCallback(async (id: string) => {
        console.log(`[useEditDeck] Loading deck data for ID: ${id}`);
        setLoading(true); setError(null);
        isMountedRef.current = false; // Reset load flag
        previousSavedMetadataRef.current = {}; // Reset saved state ref
        try {
            const result = await getDeck(id);
            if (result.error) throw new Error(result.error);
            if (result.data) {
                const fetchedDeck = {
                    ...result.data,
                    cards: (result.data.cards || []) as Array<Partial<DbCard>>
                };
                setDeck(fetchedDeck);
                // Initialize the ref holding the baseline state *after* successful load
                previousSavedMetadataRef.current = {
                    name: fetchedDeck.name,
                    primary_language: fetchedDeck.primary_language,
                    secondary_language: fetchedDeck.secondary_language,
                    is_bilingual: fetchedDeck.is_bilingual,
                };
                isMountedRef.current = true; // Mark initial load as complete
                console.log("[useEditDeck] Initial deck loaded. Baseline metadata ref set:", previousSavedMetadataRef.current);
            } else {
                throw new Error("Deck not found");
            }
        } catch (err: any) {
            console.error("[useEditDeck] Error loading deck:", err);
            setError(err.message || "Failed to load deck.");
            setDeck(null);
            isMountedRef.current = false;
        } finally {
            setLoading(false);
        }
    }, [getDeck]); // Stable dependency

    // Initial load effect
    useEffect(() => {
        isMountedRef.current = false; // Reset on ID change
        previousSavedMetadataRef.current = {};
        if (deckId && !useDecksLoading) {
            loadDeckData(deckId);
        } else if (!deckId) {
            setError("No Deck ID provided."); setLoading(false);
        } else if (useDecksLoading) {
            console.log("[useEditDeck] Waiting for useDecks hook to finish loading...");
            setLoading(true);
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
    }, [deckId, useDecksLoading]);


    // --- Deck Metadata Updates ---

    // Debounced function responsible for calling the actual update action
    const debouncedSaveMetadata = useCallback(
        debounce(async (deckIdToSave: string, payloadToSave: UpdateDeckParams) => {
            if (!isMountedRef.current) {
                console.warn("[useEditDeck] Debounced save skipped: Initial load not complete.");
                return;
            }

            console.log("[useEditDeck] Debounced Save Metadata EXECUTION for ID:", deckIdToSave, "Payload:", payloadToSave);
            setIsSavingMetadata(true);
            try {
                const result = await updateDeck(deckIdToSave, payloadToSave);

                if (result.error) {
                    toast.error("Deck settings auto-save failed", { description: result.error });
                } else {
                    console.log("[useEditDeck] Deck settings auto-saved successfully to DB.");
                    // Update the ref ONLY after successful save
                    if (result.data) {
                         previousSavedMetadataRef.current = {
                            name: result.data.name,
                            primary_language: result.data.primary_language,
                            secondary_language: result.data.secondary_language,
                            is_bilingual: result.data.is_bilingual,
                         };
                         console.log("[useEditDeck] Updated previousSavedMetadataRef after successful save.");
                    }
                     // *** NO setDeck() call here ***
                }
            } catch (error: any) {
                console.error("[useEditDeck] Error during debouncedSaveMetadata execution:", error);
                toast.error("Deck settings auto-save failed", { description: error.message || "Unknown error" });
            } finally {
                setIsSavingMetadata(false);
            }
        }, DECK_UPDATE_DEBOUNCE_MS),
        [updateDeck] // Stable dependency
    );

    // Handler called by the DeckMetadataEditor component when user input changes
    const handleDeckMetadataChange = useCallback((updates: Partial<DbDeck>) => {
        console.log('[DEBUG] handleDeckMetadataChange called with updates:', updates);
        setDeck(prevDeckState => {
            if (!prevDeckState) return null;

            const newState = { ...prevDeckState, ...updates };

            const metadataForLog = { id: newState.id, name: newState.name, primary_language: newState.primary_language, secondary_language: newState.secondary_language, is_bilingual: newState.is_bilingual };
            console.log('[DEBUG] newState metadata inside setDeck:', JSON.stringify(metadataForLog, null, 2));

            if (isMountedRef.current && newState.id && previousSavedMetadataRef.current) {
                 const currentMetadataPayload: MetadataState = {
                    name: newState.name,
                    primary_language: newState.primary_language,
                    secondary_language: newState.secondary_language,
                    is_bilingual: newState.is_bilingual,
                 };

                 let changed = false;
                 if (currentMetadataPayload.name !== previousSavedMetadataRef.current.name) changed = true;
                 if (currentMetadataPayload.primary_language !== previousSavedMetadataRef.current.primary_language) changed = true;
                 if (currentMetadataPayload.secondary_language !== previousSavedMetadataRef.current.secondary_language) changed = true;
                 if (currentMetadataPayload.is_bilingual !== previousSavedMetadataRef.current.is_bilingual) changed = true;

                 if (changed) {
                     console.log("[DEBUG] Change detected from initial/last save. Queuing debounced metadata save.");
                     // --- FIX: Convert null to undefined for payload ---
                     const payloadToSave: UpdateDeckParams = {
                         name: currentMetadataPayload.name ?? undefined,
                         primary_language: currentMetadataPayload.primary_language ?? undefined,
                         secondary_language: currentMetadataPayload.secondary_language ?? undefined,
                         is_bilingual: currentMetadataPayload.is_bilingual ?? undefined, // Handle potential null for boolean too
                     };
                     // -------------------------------------------------
                     debouncedSaveMetadata(newState.id, payloadToSave);
                 } else {
                     console.log("[DEBUG] No change detected from initial/last save. Save trigger skipped.");
                 }
            } else {
                 console.warn("[DEBUG] Save trigger condition not met. isMounted:", isMountedRef.current, "newState.id:", newState.id, "initialRef:", previousSavedMetadataRef.current);
            }
            return newState;
        });
    }, [debouncedSaveMetadata]); // Stable dependency


    // --- Card Actions (Remain the same as the last complete version) ---
    const handleAddCardOptimistic = useCallback(() => {
         if (!deck) return;
         const newCardPlaceholder: Partial<DbCard> = { id: `new-${Date.now()}`, question: "", answer: "", deck_id: deck.id, user_id: deck.user_id, srs_level: 0, easiness_factor: 2.5, interval_days: 0, stability: 0, difficulty: 0, last_review_grade: null, last_reviewed_at: null, next_review_due: null, correct_count: 0, incorrect_count: 0, attempt_count: 0 };
         setDeck(prev => prev ? { ...prev, cards: [...prev.cards, newCardPlaceholder] } : null);
         console.log("[useEditDeck] Added optimistic card placeholder:", newCardPlaceholder.id);
    }, [deck]);

    const handleCreateCard = useCallback(async (question: string, answer: string): Promise<string | null> => {
        if (!deck || !deck.id) { toast.error("Cannot create card: Deck missing."); return null; }
        const toastId = toast.loading("Saving new card...");
        try {
            const result = await createCardAction(deck.id, { question, answer });
            if (result.error || !result.data) throw result.error || new Error("Failed to create card.");
            toast.success(`New card created!`, { id: toastId });
            await loadDeckData(deck.id); // Refetch
            return result.data.id;
        } catch (error: any) {
            toast.error("Failed to save new card", { id: toastId, description: error.message || "Unknown error." });
             setDeck(prev => prev ? { ...prev, cards: prev.cards.filter(c => !c.id?.startsWith('new-')) } : null);
            return null;
        }
    }, [deck, loadDeckData]);

    const handleUpdateCard = useCallback(async (cardId: string, question: string, answer: string): Promise<void> => {
        if (!cardId || cardId.startsWith('new-')) return;
        const toastId = `update-${cardId}`;
        toast.loading("Saving card...", { id: toastId });
        try {
            const updatePayload: { question?: string, answer?: string } = {};
            const originalCard = deck?.cards.find(c => c.id === cardId);
            if (!originalCard) { toast.dismiss(toastId); return; }
            let changed = false;
            if (originalCard.question !== question) { updatePayload.question = question; changed = true; }
            if (originalCard.answer !== answer) { updatePayload.answer = answer; changed = true; }
            if (!changed) { toast.dismiss(toastId); console.log(`No changes for card ${cardId}.`); return; }
            const result = await updateCardAction(cardId, updatePayload);
            if (result.error || !result.data) throw result.error || new Error("Failed to update card.");
            toast.success("Card updated!", { id: toastId });
            if(deck?.id) await loadDeckData(deck.id); // Refetch
        } catch (error: any) {
            toast.error("Failed to update card", { id: toastId, description: error.message || "Unknown error." });
            if(deck?.id) await loadDeckData(deck.id); // Refetch on error too
        }
    }, [deck, loadDeckData]);

    const handleDeleteCard = useCallback(async (cardId: string): Promise<void> => {
         if (!cardId) return;
         if (cardId.startsWith('new-')) { setDeck(prev => prev ? { ...prev, cards: prev.cards.filter(c => c.id !== cardId) } : null); return; }
        const originalCards = deck?.cards;
        setDeck(prev => prev ? { ...prev, cards: prev.cards.filter(c => c.id !== cardId) } : null); // Optimistic
        const toastId = toast.loading("Deleting card...");
        try {
            const result = await deleteCardAction(cardId);
            if (result.error) throw new Error(result.error || "Action error.");
            toast.success("Card deleted!", { id: toastId });
        } catch (error: any) {
            toast.error("Failed to delete card", { id: toastId, description: error.message || "Unknown error." });
            if (originalCards) setDeck(prev => prev ? { ...prev, cards: originalCards } : null); // Revert
             else if (deck?.id) loadDeckData(deck.id);
        }
    }, [deck, loadDeckData]);


    // --- Deck Deletion ---
    const handleDeleteDeckConfirm = useCallback(async (): Promise<void> => {
        if (!deck || !deck.id) { toast.error("Cannot delete deck: data missing."); return; }
        setIsDeletingDeck(true);
        const deckName = deck.name;
        try {
            const result = await deleteDeck(deck.id);
            if (result.error) throw new Error(result.error);
            toast.success(`Deck "${deckName}" deleted successfully!`);
            router.push('/');
        } catch (error: any) {
            toast.error(`Failed to delete deck "${deckName}"`, { description: error.message || "Unknown error." });
            setIsDeletingDeck(false);
        }
    }, [deck, deleteDeck, router]);


    // --- Return Values ---
    return {
        deck,
        loading: loading || useDecksLoading,
        error,
        isSavingMetadata,
        isDeletingDeck,
        loadDeckData,
        handleDeckMetadataChange, // Expose the handler that triggers the save
        handleAddCardOptimistic,
        handleCreateCard,
        handleUpdateCard,
        handleDeleteCard,
        handleDeleteDeckConfirm,
    };
}