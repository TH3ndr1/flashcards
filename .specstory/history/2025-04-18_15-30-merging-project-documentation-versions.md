<!-- Generated by SpecStory -->

# Merging Project Documentation Versions (2025-04-18 17:30:01)

_**User**_

@project-documentation.md@docv2 docv2 is a new version of the project documentation - can you merge it with the original file? please make sure you add all new aspects in @project-documentation.md 

---

_**Assistant**_



---

Okay, I can help with that. I need to read the current content of `docs/project-documentation.md` to perform the merge accurately, ensuring that the newer information from `docs/docv2` is integrated while preserving valuable context from the original.



---

Read file: docs/project-documentation.md

---

Got it. I have the content of both files now. I will proceed to merge `docs/docv2` into `docs/project-documentation.md`, updating the version and incorporating the new sections and details as planned.

Here's the proposed merged content for `docs/project-documentation.md`:


---

```diff
- # Project Documentation
- 
- **Version:** 2.2 (Consolidated Documentation)
- **Date:** 2024-04-05
+ # Project Documentation: StudyCards App
+ 
+ **Version:** 3.0 (Consolidated Architecture & AI Generation Plan)
+ **Date:** 2025-04-09 (Placeholder based on docv2)
+ 
+ **(Consolidated based on user requirements and iterative AI discussions)**
+ 
+ ---
+ 
+ ## Table of Contents
+ 
+ 1.  [Executive Summary](#1-executive-summary)
+ 2.  [Conceptual Overview: Prepare vs. Practice](#2-conceptual-overview-prepare-vs-practice)
+ 3.  [Business Context](#3-business-context)
+     *   [3.1 Problem Statement](#31-problem-statement)
+     *   [3.2 Key Stakeholders](#32-key-stakeholders)
+     *   [3.3 User Personas](#33-user-personas)
+     *   [3.4 Business Workflows](#34-business-workflows)
+ 4.  [Functional Requirements](#4-functional-requirements)
+     *   [4.1 Core Features](#41-core-features)
+     *   [4.2 Prepare Mode Features](#42-prepare-mode-features)
+     *   [4.3 Practice Mode Features](#43-practice-mode-features)
+     *   [4.4 Accessibility & Inclusivity](#44-accessibility--inclusivity)
+     *   [4.5 Key User Interactions](#45-key-user-interactions)
+ 5.  [Technical Architecture](#5-technical-architecture)
+     *   [5.1 Technology Stack](#51-technology-stack)
+     *   [5.2 Frontend Architecture](#52-frontend-architecture)
+     *   [5.3 Backend Architecture](#53-backend-architecture)
+     *   [5.4 Database Schema](#54-database-schema)
+     *   [5.5 Navigation Structure](#55-navigation-structure)
+     *   [5.6 Code Structure and Organization](#56-code-structure-and-organization)
+         *   [5.6.1 Component Architecture](#561-component-architecture)
+         *   [5.6.2 Directory Structure](#562-directory-structure)
+         *   [5.6.3 Key Components and Their Functions](#563-key-components-and-their-functions)
+         *   [5.6.4 State Management](#564-state-management)
+         *   [5.6.5 Data Flow](#565-data-flow)
+         *   [5.6.6 Performance Considerations](#566-performance-considerations)
+     *   [5.7 Authentication Flow](#57-authentication-flow)
+     *   [5.8 Codebase Structure and File Interactions](#58-codebase-structure-and-file-interactions)
+         *   [5.8.1 File Structure Overview](#581-file-structure-overview)
+         *   [5.8.2 Core File Interactions (Diagram)](#582-core-file-interactions-diagram)
+         *   [5.8.3 File Descriptions](#583-file-descriptions)
+         *   [5.8.4 Data Flow Patterns (Diagram)](#584-data-flow-patterns-diagram)
+ 6.  [Core Feature Implementation Details](#6-core-feature-implementation-details)
+     *   [6.1 Study Session Initiation & Execution Flow](#61-study-session-initiation--execution-flow)
+     *   [6.2 SRS Algorithm: SM-2 Implementation](#62-srs-algorithm-sm-2-implementation)
+     *   [6.3 AI Q&A Generation Workflow (Google Cloud)](#63-ai-qa-generation-workflow-google-cloud)
+ 7.  [Component Breakdown (Key Components)](#7-component-breakdown-key-components)
+ 8.  [Security Considerations](#8-security-considerations)
+ 9.  [Development & Deployment Workflow](#9-development--deployment-workflow)
+ 10. [Known Issues / Future Roadmap](#10-known-issues--future-roadmap)
+ 11. [References](#11-references)
+ 12. [Changelog](#12-changelog)
+ 13. [Implementation Action Plan & Status](#13-implementation-action-plan--status)
+ 
+ ---
  
  ## 1. Executive Summary
  
  ### Purpose and Objectives
- The Flashcards App is a modern, multilingual learning platform designed to help users create and study flashcards efficiently and effectively. The project aims to enhance the learning experience through:
- - Interactive flashcard creation and management.
- - Flexible, query-based study sessions using tags, deck affiliation, and other criteria.
- - Implementation of proven Spaced Repetition System (SRS) algorithms (initially SM-2, expandable to FSRS) for optimized long-term retention.
- - Multi-modal learning via integrated Text-to-Speech (TTS) audio support.
- - Progress tracking and user-configurable settings.
- 
- ### Target Users and Main Use Cases
- - Language learners improving vocabulary (using audio, tags like 'verb', 'noun').
- - Students studying any subject matter (organizing by chapter tags, studying due cards).
- - Teachers creating and organizing study materials (using decks and tags).
- - Self-learners requiring an organized and efficient study system (using query-based study sets like "difficult items" or "review all due").
- - Users with specific learning needs (Dyslexia, ADHD) benefiting from structured SRS, audio, and clear UI (addressed via separate accessibility features).
- 
- ### Business Value and Expected Outcomes
- - **Improved Learning Efficiency:** Through optimized SRS scheduling and focused query-based study.
- - **Enhanced Retention:** Through active recall, spaced repetition, and multi-modal learning (text + audio).
- - **Increased User Engagement:** Through progress tracking, flexible study options, and customizable settings (like SRS algorithm choice).
- - **Flexible Learning Environment:** Supporting multiple languages, diverse content, and personalized study workflows.
- 
- ## 2. Business Context
- 
- ### Problem Statement
+ StudyCards is a modern, multilingual learning platform designed for maximum learning efficiency and inclusivity. It aims to enhance the study experience through:
+ *   **Effective Spaced Repetition:** Implementing proven SRS algorithms (starting with SM-2) integrated into flexible study modes.
+ *   **Flexible Content Management:** Allowing users to organize content via decks and tags, and create custom study sessions using "Smart Playlists" (Study Sets).
+ *   **AI-Powered Content Creation:** Enabling users to automatically generate flashcards from uploaded PDF documents or images.
+ *   **Accessibility:** Providing features specifically designed to support learners with dyslexia, ADHD, and other challenges (font choices, colors, TTS, simple UI).
+ *   **Multi-modal Learning:** Supporting text and audio (TTS).
+ 
+ ### Target Users
+ Students of all ages, language learners, self-learners, teachers, particularly benefiting those seeking efficient study methods and users with learning differences.
+ 
+ ### Key Differentiators
+ *   Robust and flexible SRS implementation.
+ *   Seamless AI-powered card generation from user documents/images.
+ *   Strong focus on accessibility and inclusivity features.
+ *   Clean, intuitive, distraction-free user interface optimized for learning.
+ *   Flexible, query-based study sessions using tags, deck affiliation, and other criteria ("Smart Playlists").
+ 
+ ---
+ 
+ ## 2. Conceptual Overview: Prepare vs. Practice
+ 
+ The application's functionality is divided into two main modes:
+ 
+ *   **Prepare Mode:** Encompasses all aspects of content creation, organization, and setup. This includes managing decks, creating/editing individual cards, managing tags, creating/editing Study Sets ("Smart Playlists"), and using the AI Flashcard Generator.
+ *   **Practice Mode:** Focuses entirely on the active learning and review process using the prepared content. This includes initiating study sessions (via decks, tags, playlists, or global review), interacting with flashcards (flipping, grading), and leveraging the SRS scheduling.
+ 
+ This conceptual separation guides the UI navigation and feature organization.
+ 
+ ---
+ 
+ ## 3. Business Context
+ 
+ ### 3.1 Problem Statement
  Traditional flashcard methods and simpler apps often lack the flexibility, efficiency, and features needed for modern, optimized learning:
  - Limited accessibility across devices.
  - Difficulty studying related concepts across different decks or focusing on specific card types (e.g., only difficult cards, only due cards).
  
- ### Key Stakeholders
+ ### 3.2 Key Stakeholders
  - End Users (students, language learners, self-learners)
  - Content Creators (teachers, education professionals)
  - Platform Administrators
  - Development Team
  
- ### User Personas
+ ### 3.3 User Personas
  1. Language Learner
     - Primary need: Vocabulary acquisition with pronunciation and context.
     - Key features: Deck management, multi-language support, tagging for structure.
  
- ### Business Workflows
+ ### 3.4 Business Workflows
  1. User Registration and Authentication
  2. Deck Creation and Management
  8. Progress Tracking and Analytics (Overall stats, card-level SRS state)
  9. User Settings Management (Including SRS algorithm preference)
- 10. Content Sharing and Collaboration (Future)
- 
- ## 3. Functional Overview
- 
- ### Main Features and Modules
- 1. Authentication System
-    - Sign up/Login, Profile management, OAuth integration.
- 2. Deck Management
-    - Create/Edit/Delete decks, Import/Export, Categorization.
- 3. Tag Management
-     - Create/Edit/Delete user-specific tags.
-     - Assign/Remove tags from cards.
- 4. Study Set Management ("Smart Playlists")
-     - Create/Edit/Delete named study sets based on query criteria.
-     - Query criteria include tags (include/exclude), decks (include/exclude), date added/modified, language, etc.
- 5. Study System
-    - Interactive study sessions based on flexible **Card Selections** (Deck, All Cards, Tags, Study Sets) and distinct **Study Modes**.
-    - **Study Modes:**
-         - **Learn Mode:** Comprehensive review of selected cards with session-based completion criteria.
-         - **Review Mode:** SRS-prioritized review focusing only on cards due according to their `next_review_due` date.
-    - **Spaced Repetition System (SRS):**
-         - User-selectable algorithm (via Settings), starting with SM-2.
-         - Automatic calculation of next review date based on user performance (grade) and chosen algorithm.
-         - Card-level storage of SRS state (`next_review_due`, `srs_level`, `easiness_factor`, etc.).
-         - **SRS state updated consistently regardless of Study Mode.**
-    - Progress tracking (overall and per card).
-    - Flippable card interface.
- 6. Audio Support
-    - Text-to-speech integration (Google Cloud TTS).
-    - Multiple language support & voice customization.
- 7. User Settings
-     - General preferences (e.g., session completion threshold `X` for Learn Mode).
-     - SRS Algorithm selection ('sm2', 'fsrs' - future).
-     - TTS preferences.
- 
- ### Key User Interactions
+ 10. AI Flashcard Generation (Upload -> Process -> Review -> Import)
+ 11. Content Sharing and Collaboration (Future)
+ 
+ ---
+ 
+ ## 4. Functional Requirements
+ 
+ ### 4.1 Core Features
+ *   User Authentication (Supabase Auth).
+ *   Multi-language support (UI and potentially content).
+ *   Responsive design (Mobile, Tablet, Desktop).
+ *   User Settings management.
+ 
+ ### 4.2 Prepare Mode Features
+ *   **Deck Management:** Create, view, edit, delete decks.
+ *   **Card Management:** Create, view, edit, delete individual cards within decks.
+     *   Support for front text, back text (fields `front_content`, `back_content`).
+ *   **Tag Management:**
+     *   Create, view, delete user-specific tags (`/tags` page via `<TagManager />`).
+     *   Assign/remove tags to/from specific cards (via `<CardTagEditor />` in card editing view).
+ *   **Study Set ("Smart Playlist") Management:**
+     *   Create/Save complex filter criteria as named Study Sets (`/study/sets/new` via `<StudySetBuilder />`).
+     *   View/List saved Study Sets (`/study/sets` page).
+     *   Edit existing Study Sets (`/study/sets/[id]/edit` via `<StudySetBuilder />`).
+     *   Delete saved Study Sets (`/study/sets` page).
+     *   **Filter Criteria:** Support filtering by Deck(s), Included Tags (Any/All), Excluded Tags, Date ranges (Created, Updated, Last Reviewed, Next Due - including 'never', 'isDue'), SRS Level (equals, <, >).
+ *   **AI Flashcard Generator:**
+     *   Upload PDF or Image files.
+     *   Extract text content (PDF parsing / OCR via Google Vision AI).
+     *   Generate Q&A pairs using AI (Google Gemini).
+     *   Allow user review, editing, and selection of generated pairs.
+     *   Import selected pairs as new cards into a chosen deck.
+ 
+ ### 4.3 Practice Mode Features
+ *   **Study Session Initiation:** Start sessions based on:
+     *   A specific Deck.
+     *   All user cards.
+     *   A specific Tag (Future UI).
+     *   A saved Study Set ("Smart Playlist").
+     *   A dynamic query (e.g., "All Due Cards" - implicitly via Study Set Selector).
+ *   **Study Mode Selection:** Choose between:
+     *   **Learn Mode:** Reviews *all* selected cards, repeating cards answered incorrectly within the session until a configurable consecutive correct answer threshold (`mastery_threshold` / `learn_mode_success_threshold` in settings) is met *for that session*.
+     *   **Review Mode (SRS):** Reviews *only* cards from the selection that are due (`next_review_due <= now()` or `next_review_due IS NULL`), prioritized by due date.
+ *   **Study Interface:**
+     *   Display current card (`<StudyFlashcardView />`).
+     *   Allow flipping between front and back.
+     *   Provide grading buttons (e.g., Again, Hard, Good, Easy - mapped to grades 1-4).
+     *   Display session progress (e.g., Card X / Y).
+     *   Display session completion feedback.
+ *   **SRS Engine:**
+     *   Utilize SM-2 algorithm initially (`calculateSm2State`). Expandable to FSRS.
+     *   Calculate and update card SRS state (`srs_level`, `easiness_factor`, `interval_days`, `next_review_due`, `last_reviewed_at`, `last_review_grade`) after *every* card review, regardless of study mode.
+     *   Persist SRS state updates to the database (`progressActions.updateCardProgress`).
+ *   **Text-to-Speech (TTS):**
+     *   Read card front/back content aloud using Google Cloud TTS.
+     *   Determine language based on card's deck (`primary_language`, `secondary_language`) or potential future card-level overrides.
+     *   Allow user to enable/disable TTS in settings.
+ 
+ ### 4.4 Accessibility & Inclusivity
+ *   **Dyslexia Support:**
+     *   User-selectable dyslexia-friendly fonts (e.g., OpenDyslexic, Atkinson Hyperlegible) via Settings.
+     *   Adjustable font size, line spacing via Settings.
+     *   Multiple low-contrast color themes / adjustable background/text colors via Settings.
+     *   High-quality TTS.
+ *   **ADHD Support:**
+     *   Clean, minimalist, distraction-free UI during study.
+     *   Optional session timers (e.g., Pomodoro).
+     *   Clear progress indicators & goal setting options.
+     *   Concise card content encouraged.
+     *   Chunking of study material via Decks/Tags/Study Sets.
+ *   **Dysorthographia/General:**
+     *   TTS bypasses reading difficulties.
+     *   Image support (future) provides visual cues.
+     *   Focus on recall over perfect input (if typed answers are added).
+ 
+ ### 4.5 Key User Interactions
  1. Card Creation/Editing Flow
     - Enter content, select languages, assign/remove tags, generate audio.
  3. Study Set Creation Flow ("Smart Playlist")
      - Name the set (e.g., "Hard Verbs Chapter 1").
-     - Define query criteria using UI (e.g., Tags: include 'verb', Deck: 'Chapter 1', Added Date: newer than 14 days).
+     - Define query criteria using UI (e.g., Tags: include 'verb', Deck: 'Chapter 1', SRS Level: < 3).
      - Save the Study Set.
  4. Study Session Initiation Flow
-    - **Step 1: Select Cards:** Choose a Deck, "All Cards", a Tag, or a saved Study Set/Smart Playlist.
+    - **Step 1: Select Cards:** Choose a Deck, "All Cards", a Tag, or a saved Study Set/Smart Playlist via (`/study/select`).
     - **Step 2: Select Study Mode:** Choose "Learn Mode" or "Review Mode".
     - Click "Start Studying".
     - **If Review Mode:** Filters fetched cards for `isDue`, sorts by due date, presents only due cards.
     - **In both modes:** User reviews, flips, listens, self-assesses (e.g., Again, Hard, Good, Easy). System calculates *next* SRS state via `calculateSm2State`, schedules debounced save via `progressActions.updateCardProgress`. System presents next card based on mode logic.
- 6. Settings Flow
-     - Navigate to settings page.
-     - Select preferred SRS Algorithm. Adjust Learn Mode threshold `X`.
-     - Adjust other preferences (TTS, etc.).
+ 6. AI Generation Flow
+    - User uploads PDF/Image.
+    - System extracts text, generates Q&A pairs.
+    - User reviews/edits pairs.
+    - User selects pairs and imports them into a deck.
+ 7. Settings Flow
+     - Navigate to settings page (`/settings`).
+     - Select preferred SRS Algorithm, adjust Learn Mode threshold `X`.
+     - Adjust other preferences (TTS, fonts, colors, etc.).
      - Save settings.
  
- ## 4. Technical Architecture
- 
- ### Technology Stack
- - Frontend: Next.js 15.1.0 (or latest stable) with React 19 (or latest stable) - Using App Router
- - Backend: Serverless via Next.js API routes and **Server Actions** (preferred for mutations/queries)
- - Database: Supabase (PostgreSQL)
- - **(New Recommendation)** Database Functions: Consider `pl/pgsql` functions for complex queries like `resolveStudyQuery`.
- - Authentication: Supabase Auth integrated via `@supabase/ssr` library (client and server)
- - Storage: Supabase Storage (For user-uploaded media if added later, TTS is currently generated on-the-fly)
- - Text-to-Speech: Google Cloud TTS API (via `/api/tts` route)
- - UI Framework: Tailwind CSS with shadcn/ui (using Radix UI primitives)
- - Form Management: React Hook Form
- - Validation: Zod
- - State Management: React Context (`AuthProvider`, `SettingsProvider`), Custom Hooks (`useAuth`, `useDecks`, `useStudySession`, `useTags`, `useStudySets`, `useSettings`, etc.)
- - Utility Libraries: `sonner` (toasts), `lucide-react` (icons), `date-fns`
- 
- ### Frontend Architecture
- - Next.js App Router structure (`app/`).
- - Mix of Server and Client Components.
- - Styling via Tailwind CSS / shadcn/ui.
- - Reusable UI components (`components/ui/`).
- - Application-specific components (`components/`) including:
-     - `StudySetBuilder`, `StudySetSelector`, `TagManager`, `CardTagEditor`, `SrsSelector`.
-     - `study-flashcard-view`, `table-editor`, `card-editor`.
- - State Management Strategy:
-     - Global State (Auth, Settings): Managed via React Context (`AuthProvider`, `SettingsProvider`) and hooks (`useAuth`, `useSettings`).
-     - Domain-Specific State: Managed by custom hooks:
-         - `useDecks` (CRUD for decks)
-         - `useTags` (CRUD for tags, linking to cards)
-         - `useStudySets` (CRUD for study sets)
-         - `useStudySession` (Orchestrates active study, refactored for queries & SRS & Modes)
-     - Local Component State: `useState`, `useReducer`.
- - Custom Hooks (`hooks/`) are central:
-     - `useSupabase`, `useAuth`, `useSettings`.
-     - `useDecks`, `useTags`, `useStudySets`.
-     - `useStudySession` (Refactored: takes query/setID, resolves card IDs via action, fetches cards via action, calculates SRS state via utils, persists progress via `progressActions`, manages Learn/Review modes).
-     - `useTTS`, `useStudyTTS` (Bridge study session state to TTS).
-     - `useMobile`.
- 
- ### Backend Architecture
- - Primarily serverless logic within Next.js.
- - **API Routes (`app/api/*`)**: Specific endpoints like `/api/tts`.
- - **Server Actions (`*.actions.ts`)**: Preferred for data fetching and mutations. Encapsulate business logic and database interaction.
-     - `tagActions.ts` (CRUD for tags and card_tags)
-     - `studySetActions.ts` (CRUD for study_sets)
-     - `studyQueryActions.ts` (`resolveStudyQuery` - takes criteria, executes DB query/function, returns card IDs)
-     - `cardActions.ts` (`getCardsByIds`, `getCardById`)
-     - `progressActions.ts` (`updateCardProgress` - saves calculated SRS state for a single card)
-     - `settingsActions.ts` (Get/Update user settings)
-     - `deckActions.ts` (CRUD for decks)
- - **Service Layer (`lib/*Service.ts`)**: Potentially reduced role.
- - **SRS Logic Utilities (`lib/srs.ts`)**:
-     - `calculateNextSrsState(card, grade, algorithm)`: Selects algorithm.
-     - `calculateSm2State(currentSm2State, grade)`: SM-2 logic.
-     - `calculateFsrsState(...)`: Placeholder.
- - **Database Interaction**: Supabase client (`@supabase/ssr`), RLS enforced. **DB Function (`resolve_study_query`) highly recommended.** **Indexes crucial** (esp. `cards(user_id, next_review_due)`).
- - **External Services**: Google Cloud TTS.
- - **Middleware (`middleware.ts`)**: Manages session cookies via `@supabase/ssr`.
- 
- ### Data Models (Supabase PostgreSQL Schema)
- 
+ ---
+ 
+ ## 5. Technical Architecture
+ 
+ ### 5.1 Technology Stack
+ *   Frontend: Next.js 15+ (App Router), React 19+, TypeScript
+ *   Backend: Serverless via Next.js Server Actions (preferred) and API Routes
+ *   Database: Supabase (PostgreSQL)
+ *   Database Functions: `resolve_study_query` (pl/pgsql) for complex card selection.
+ *   Authentication: Supabase Auth via `@supabase/ssr`
+ *   State Management: Zustand (`studySessionStore`), React Context (`SettingsProvider`, `AuthProvider`)
+ *   UI: Tailwind CSS, `shadcn/ui` (using Radix UI primitives)
+ *   Forms: `react-hook-form`, `zod`
+ *   Audio: Google Cloud TTS API (`@google-cloud/text-to-speech`) via `/api/tts` route or dedicated action.
+ *   AI (Q&A Gen): Google Cloud Vision AI (`@google-cloud/vision`) for OCR, Google AI Gemini (`@google/generative-ai`) for generation.
+ *   File Parsing: `pdf-parse` (server-side)
+ *   File Storage: Supabase Storage (temporary uploads for AI Gen)
+ *   Utilities: `date-fns`, `lucide-react`, `sonner` (toasts)
+ 
+ ### 5.2 Frontend Architecture
+ *   **Structure:** Next.js App Router (`app/`). Mix of Server (`'use server'`) and Client Components (`'use client'`).
+ *   **Styling:** Tailwind CSS / `shadcn/ui`.
+ *   **Components:** Reusable UI elements (`components/ui/`), feature-specific components (`components/study/`, `components/tags/`, etc.), layout components (`components/layout/`).
+ *   **State Management:**
+     *   Global Auth: `AuthProvider` context / `useAuth` hook.
+     *   Global Settings: `SettingsProvider` context / `useSettingsContext` hook.
+     *   Study Session Params/State: `useStudySessionStore` (Zustand) for passing `input`/`mode` between selection and session pages, and managing active session state.
+     *   Data Fetching/Caching: Custom hooks (`useDecks`, `useTags`, etc.) calling Server Actions. Consider SWR/TanStack Query for more advanced caching/refetching later.
+     *   Study Session Logic: `useStudySession` hook encapsulates fetching cards for session, managing queue based on mode, triggering SRS calcs, handling answers.
+     *   Local UI State: `useState` within components (e.g., `isFlipped`, `isSaving`, popover open states).
+ *   **Custom Hooks (`hooks/`):** Central for state and logic:
+     *   `useSupabase`, `useAuth`, `useSettingsContext`.
+     *   `useDecks`, `useTags`, `useStudySets`, `useCardTags`.
+     *   `useStudySession` (Orchestrates active study, manages Learn/Review modes).
+     *   `useTTS`, `useStudyTTS` (Bridge study session state to TTS).
+     *   `useMobileSidebar` (Zustand store for mobile navigation state).
+ 
+ ### 5.3 Backend Architecture
+ *   **Primary Mechanism:** Next.js Server Actions (`lib/actions/`) for data mutations and queries. Use `'use server'` directive.
+ *   **Supabase Client:** Use dedicated client creation functions for actions (`createActionClient` from `lib/supabase/server.ts`) leveraging `@supabase/ssr`. Ensure authentication is checked within actions.
+ *   **Key Actions:**
+     *   `cardActions`: `createCard`, `updateCard`, `deleteCard`, `getCardsByIds` (includes nested deck languages), `createMultipleCards` (for AI Gen).
+     *   `deckActions`: `createDeck`, `updateDeck`, `deleteDeck`, `getDecks`, `getDeckWithCards`.
+     *   `tagActions`: `createTag`, `getTags`, `deleteTag`, `addTagToCard`, `removeTagFromCard`, `getCardTags`.
+     *   `studySetActions`: `createStudySet`, `getUserStudySets`, `getStudySet`, `updateStudySet`, `deleteStudySet`.
+     *   `progressActions`: `updateCardProgress` (saves SRS state).
+     *   `studyQueryActions`: `resolveStudyQuery` (calls DB function).
+     *   `settingsActions`: Get/Update user settings.
+     *   `ttsActions`: Generate TTS audio.
+     *   *(New)* AI Generation Actions (e.g., `uploadFileAction`, `extractTextAction`, `generateQnaAction`).
+ *   **Database Function (`resolve_study_query`):** (Defined in migration, called via RPC) Handles complex filtering logic for card selection based on `queryCriteria` JSONB (decks, tags, dates, SRS level, etc.) and `user_id`. Returns `TABLE(card_id uuid)`. **Indexes crucial** (esp. `cards(user_id, next_review_due)`).
+ *   **API Routes:** Used sparingly for specific needs (e.g., `/api/tts/route.ts`, potentially AI processing steps if long-running: `/api/process-upload`, `/api/extract-text`, `/api/generate-qna`).
+ *   **SRS Logic Utilities (`lib/srs.ts`):**
+     *   `calculateSm2State(currentSm2State, grade)`: SM-2 logic (pure function).
+     *   *(Placeholder)* `calculateFsrsState(...)`
+ *   **AI Utilities (`lib/ai-utils.ts` - New):** Will contain `chunkText` and potentially helper functions for interacting with Vision/Gemini APIs.
+ *   **General Utilities (`lib/utils.ts`):** General helpers (e.g., `debounce`).
+ *   **Middleware (`middleware.ts`):** Manages session cookies via `@supabase/ssr`.
+ *   **Error Handling:** Actions return `{ data, error }` structure. Use `try...catch`, handle specific DB errors (e.g., unique constraints), log errors server-side.
+ 
+ ### 5.4 Database Schema
  1.  **`users`** (Managed by Supabase Auth)
  2.  **`settings`** (User preferences)
      *   `created_at`: `timestamptz` (default: `now()`)
      *   `updated_at`: `timestamptz` (default: `now()`)
-     *   *... other setting fields (TTS preferences, etc.) ...*
      *   *RLS: User can only manage/view their own settings.*
  3.  **`decks`**
      *   *RLS: User can only manage/view their own study sets.*
  
- ### 4.1 Code Structure and Organization
- 
- #### Component Architecture
+ ### 5.5 Navigation Structure
+ *   **Sidebar (Primary Navigation):**
+     *   Practice: "Start Session" (`/study/select`), "Smart Playlists" (`/study/sets`).
+     *   Prepare: "Decks" (`/`), "Manage Tags" (`/tags`), "AI Generate" (`/prepare/ai-generate` - New).
+     *   Other: "Settings" (`/settings`), Auth links.
+ *   **Header:** App Title/Logo (links to `/`), global icons (Settings, Profile/Auth), mobile Hamburger menu.
+ *   **Contextual Navigation:**
+     *   Deck List (`/`): Links to Edit Deck (`/edit/[deckId]`), Learn/Review buttons navigate to `/study/session` via store. "+ Create Deck" button.
+     *   Study Set List (`/study/sets`): Links to Edit Set (`/study/sets/[id]/edit`), Learn/Review buttons navigate to `/study/session` via store. Delete buttons. "+ Create Playlist" button links to `/study/sets/new`.
+ 
+ ### 5.6 Code Structure and Organization
+ #### 5.6.1 Component Architecture
  
  The application follows Next.js App Router best practices with a clear separation between Server and Client Components:
  2. **Client Components (`'use client'`)**
     - Used for interactivity, React Hooks, browser APIs, and Context providers
-    - Examples: `components/ClientProviders.tsx`, `components/header.tsx`, `components/study-flashcard-view.tsx`
+    - Examples: `components/layout/ClientProviders.tsx` (if used), `components/layout/site-header.tsx`, `components/study/study-flashcard-view.tsx`
  
  3. **Provider Pattern**
-    - Client-side providers are grouped in `components/ClientProviders.tsx`
-    - Includes `ThemeProvider`, `AuthProvider`, `SettingsProvider`, and `SonnerToaster`
-    - Root layout (`app/layout.tsx`) remains a Server Component, wrapping content with `ClientProviders`
- 
- #### Directory Structure
+    - Client-side providers might be grouped (e.g., `components/layout/ClientProviders.tsx`) or applied individually in `app/layout.tsx`.
+    - Includes `ThemeProvider`, `AuthProvider`, `SettingsProvider`, and `SonnerToaster`.
+    - Root layout (`app/layout.tsx`) remains a Server Component, wrapping content with necessary Client Providers.
+ 
+ #### 5.6.2 Directory Structure
  
  ```plaintext
  │   ├── edit/              # Deck editing pages
  │   ├── study/             # Study session pages
+ │   │   ├── select/        # Session selection page
+ │   │   ├── session/       # Active session page
+ │   │   └── sets/          # Study Set CRUD pages
  │   ├── tags/              # Tag management pages
  │   ├── settings/          # User settings pages
  │   ├── auth/              # Authentication pages
- │   └── api/               # API routes
+ │   ├── prepare/           # Prepare mode specific pages (e.g., ai-generate)
+ │   └── api/               # API routes (e.g., tts)
  ├── components/            # Reusable components
  │   ├── ui/               # shadcn/ui components
- │   ├── study/            # Study-related components
- │   ├── tags/             # Tag-related components
- │   └── [component].tsx   # Individual components
- ├── hooks/                # Custom React hooks
- ├── lib/                  # Utility functions and services
- │   ├── actions/          # Server actions
- │   ├── schema/           # Database schema types
- │   └── supabase/         # Supabase client setup
- ├── providers/            # Context providers
- └── types/                # TypeScript type definitions
- ```
- 
- #### Key Components and Their Functions
+ │   ├── layout/           # Site layout components (Header, Sidebar)
+ │   ├── study/            # Study-related components (FlashcardView, SetBuilder)
+ │   ├── tags/             # Tag-related components (TagManager, CardTagEditor)
+ │   └── [feature]/        # Other feature-specific components
+ ├── hooks/                # Custom React hooks (useAuth, useSettings, useStudySession, etc.)
+ ├── lib/                  # Core logic, utilities, actions
+ │   ├── actions/          # Server actions (*.actions.ts)
+ │   ├── supabase/         # Supabase client setup (server, client)
+ │   ├── schema/           # Zod schemas, potentially DB types
+ │   ├── utils.ts          # General utilities
+ │   ├── srs.ts            # SRS calculation logic
+ │   └── ai-utils.ts       # AI related utilities
+ ├── providers/            # React Context providers (AuthProvider, SettingsProvider) - if not directly in layout
+ ├── store/                # Zustand stores (studySessionStore, mobileSidebarStore)
+ ├── styles/               # Global styles
+ └── types/                # Global TypeScript type definitions (e.g., database types)
+ ```
+ *Note: Removed `services/` directory. Grouped providers conceptually, might live elsewhere.*
+ 
+ #### 5.6.3 Key Components and Their Functions
  
  1. **Root Layout (`app/layout.tsx`)**
     - Server Component
-    - Sets up fonts, metadata, and global styles
-    - Wraps content with `ClientProviders` for client-side context
- 
- 2. **Client Providers (`components/ClientProviders.tsx`)**
-    - Client Component
-    - Groups all client-side context providers
-    - Manages theme, auth, settings, and toast notifications
- 
- 3. **Study Components**
-    - `StudyFlashcardView`: Interactive card display with TTS
-    - `StudySetSelector`: Card selection interface
-    - `StudySession`: Core study loop management
- 
- 4. **Editing Components**
-    - `CardEditor`: Individual card editing
-    - `TableEditor`: Bulk card editing
-    - `TagManager`: Tag management interface
- 
- #### State Management
+    - Sets up fonts, metadata, global styles, Toaster.
+    - Wraps content with necessary `ClientProviders` (Auth, Settings, Theme).
+ 
+ 2. **Layout Components (`components/layout/`)**
+     - `SiteHeader`: Top navigation, user menu, mobile toggle.
+     - `SiteSidebar`: Main navigation menu (responsive).
+     - `ClientProviders` (Optional grouping component).
+ 
+ 3. **Study Components (`components/study/`)**
+    - `StudyFlashcardView`: Interactive card display with TTS, grading.
+    - `StudySetSelector`: Card/Set/Mode selection interface for starting sessions.
+    - `StudySetBuilder`: Form for creating/editing "Smart Playlists".
+    - `DifficultyIndicator`: UI element for grading buttons.
+ 
+ 4. **Editing/Management Components**
+    - `CardEditor`: Individual card editing form.
+    - `DeckList` / `EditableCardTable`: Displaying and managing decks/cards.
+    - `TagManager` (`components/tags/TagManager.tsx`): Tag CRUD interface.
+    - `CardTagEditor` (`components/tags/CardTagEditor.tsx`): Assigning tags to cards.
+ 
+ 5. **AI Generation Components (`components/ai/` - New)**
+    - `FileUpload`: Component for uploading PDF/Image.
+    - `QnaReview`: Interface for reviewing/editing/selecting generated Q&A pairs.
+ 
+ #### 5.6.4 State Management
  
  1. **Global State**
-    - Auth: `AuthProvider` with `useAuth` hook
-    - Settings: `SettingsProvider` with `useSettings` hook
-    - Theme: `ThemeProvider` with `useTheme` hook
+    - Auth: `AuthProvider` with `useAuth` hook.
+    - Settings: `SettingsProvider` with `useSettingsContext` hook.
+    - Theme: `ThemeProvider` with `useTheme` hook.
+    - Mobile Sidebar: `useMobileSidebar` Zustand store.
  
  2. **Study Session State**
-    - Managed by `useStudySession` hook
-    - Handles card queue, progress, and SRS logic
-    - Integrates with TTS and settings
- 
- 3. **Data Fetching**
-    - Server Components: Direct data fetching
-    - Client Components: Custom hooks (`useDecks`, `useTags`, etc.)
-    - Server Actions for mutations
- 
- #### Data Flow
+    - Managed by `useStudySessionStore` (Zustand) for params and `useStudySession` hook for active logic.
+    - Handles card queue, progress, SRS calculations, interaction with TTS.
+ 
+ 3. **Data Fetching & Caching**
+    - Server Components: Direct data fetching (preferred).
+    - Client Components: Custom hooks (`useDecks`, `useTags`, etc.) calling Server Actions.
+    - Mutations: Server Actions.
+    - Real-time: Consider Supabase Realtime for updates if needed.
+ 
+ #### 5.6.5 Data Flow
  
  1. **Server to Client**
-    - Initial data loaded in Server Components
-    - Hydrated on client with `ClientProviders`
-    - Subsequent updates via Server Actions
+    - Initial data loaded in Server Components or fetched via Server Actions called from Client Components/Hooks.
+    - Hydrated on client via Providers/Hooks.
  
  2. **Client to Server**
-    - Mutations via Server Actions
-    - Real-time updates via Supabase subscriptions
-    - Optimistic updates for better UX
- 
- #### Performance Considerations
- 
- 1. **Code Splitting**
-    - Server Components for static content
-    - Client Components for interactivity
-    - Dynamic imports for heavy components
- 
- 2. **Data Loading**
-    - Streaming for large datasets
-    - Suspense boundaries for loading states
-    - Optimistic updates for mutations
- 
- 3. **Caching**
-    - React Query for client-side caching
-    - Server-side caching via Next.js
-    - Supabase real-time subscriptions
- 
- ### 4.2 Authentication Flow
- 
- The application utilizes Supabase Auth integrated with Next.js using the `@supabase/ssr` package. This ensures seamless authentication handling across all contexts, including Server Components, Client Components, API/Route Handlers, Server Actions, and importantly, dynamic routes like `/study/[deckId]`.
- 
- Key aspects include:
- 
- - **Middleware (`middleware.ts`):** Handles session cookie management and refresh for incoming requests using the Supabase server client from `@supabase/ssr`. The middleware intercepts requests, refreshes expired sessions, and ensures that authentication state is consistently available across the application.
- 
- - **Server Clients (`lib/supabase/server.ts`):** Provides utility functions to create Supabase server clients with proper async cookie handling:
-   - `createServerClient()`: For Server Components, with full async cookie handling for both regular and dynamic routes
-   - `createActionClient()`: For Server Actions, with the same robust cookie handling
-   - `createDynamicRouteClient()`: For backward compatibility, now using the standard pattern
-   - `createAnonymousClient()`: For unauthenticated requests
- 
-   Each client implementation properly awaits the `cookies()` function to avoid warnings in dynamic routes and ensures secure authentication handling.
- 
- - **Client Client (`useSupabase` hook):** A hook that provides the browser client instance using `createBrowserClient` from `@supabase/ssr`. The browser client automatically reads and manages cookies set by the server.
- 
- - **Auth Provider (`AuthProvider`):** A context provider that leverages the browser client to manage auth state and provide auth-related functions to the application.
- 
- This implementation allows seamless authentication across all parts of the application, including dynamic routes which have special cookie handling requirements in Next.js. By properly handling async cookie access and using the standard `@supabase/ssr` package, the application maintains a secure and consistent authentication state without custom workarounds.
- 
- ## 5. Study Session Architecture & Flow (v2.1 Target)
- 
- This section provides the definitive architecture for how study sessions are initiated and executed, incorporating flexible card selection and distinct study modes.
- 
- **Overall Process:** The user first defines *which cards* they want to potentially study (**Card Selection**), and then chooses *how* they want to study that set (**Study Mode**).
- 
- ### 5.1 Phase 1: Card Selection
- 
- **Goal:** Determine the initial pool of card IDs the user is interested in, based on their chosen criteria, before considering study mode or SRS due status.
- 
- 1.  **User Initiation & Criteria Definition:**
-     *   User interacts with UI (`StudySetSelector` or query builder). Options:
-         *   **A) Single Deck:** User selects a deck.
-             *   *Resulting `queryCriteria`:* `{ deckId: "uuid" }`
-         *   **B) All User Cards:** User selects "All Cards".
-             *   *Resulting `queryCriteria`:* `{ allCards: true }` (or `{}`)
-         *   **C) Tag(s):** User selects one or more tags.
-             *   *Resulting `queryCriteria`:* `{ includeTags: ["uuid1", "uuid2"], tagLogic: "ANY" | "ALL" }` (UI determines logic)
-         *   **D) "Smart Playlist" / Study Set:** User selects a saved `Study Set` or builds a dynamic query using criteria like:
-             *   Deck Title (contains)
-             *   Date Added/Modified (relative/absolute)
-             *   Language
-             *   Tags (Include/Exclude, Any/All)
-             *   *(Future)* Specific SRS properties (e.g., low level, high difficulty)
-             *   **Logic:** UI allows AND/OR/NOT combinations.
-             *   *Resulting `queryCriteria`:* Complex JSON object (e.g., `{"logic": "AND", "filters": [...] }`) saved in `study_sets` or generated dynamically.
+    - User interactions trigger event handlers.
+    - Handlers call custom hooks or directly invoke Server Actions for mutations/queries.
+    - Server Actions interact with Database/External Services.
+    - UI updates based on Action results or optimistic updates.
+ 
+ #### 5.6.6 Performance Considerations
+ 
+ 1. **Code Splitting:** Leverage Next.js automatic code splitting per route. Use dynamic imports (`next/dynamic`) for large, non-critical client components.
+ 2. **Data Loading:** Use Server Components for initial data where possible. Use React Suspense for loading states. Implement pagination/infinite scrolling for large lists.
+ 3. **Caching:** Rely on Next.js Data Cache for fetches in Server Components/Route Handlers. Consider client-side caching libraries (SWR, TanStack Query) if complex client-side state synchronization is needed beyond custom hooks.
+ 4. **Bundle Size:** Monitor bundle size, minimize heavy client-side dependencies.
+ 5. **Database:** Ensure proper indexing (especially for `resolve_study_query` filters and RLS lookups). Optimize queries.
+ 
+ ### 5.7 Authentication Flow
+ The application utilizes Supabase Auth integrated with Next.js using the `@supabase/ssr` package. This ensures seamless authentication handling across Server Components, Client Components, API/Route Handlers, and Server Actions.
+ 
+ Key aspects include:
+ 
+ - **Middleware (`middleware.ts`):** Handles session cookie management and refresh for incoming requests using `createMiddlewareClient` from `@supabase/ssr`. It intercepts requests, refreshes expired sessions if necessary, and ensures authentication state is available server-side.
+ - **Server Clients (`lib/supabase/server.ts`):** Provides utility functions to create Supabase server clients using cookies:
+   - `createServerClient()`: For Server Components/Route Handlers.
+   - `createActionClient()`: For Server Actions.
+ These functions properly read cookies available in the server context.
+ - **Client Client (`lib/supabase/client.ts` or hook):** Creates the browser client instance using `createBrowserClient` from `@supabase/ssr`. This client automatically manages auth state via browser storage (cookies/localStorage). Usually accessed via a hook like `useSupabase`.
+ - **Auth Provider (`providers/AuthProvider.tsx`):** A client-side context provider that uses the browser client to:
+     - Manage the session state (`useState`).
+     - Listen to `onAuthStateChange`.
+     - Provide the session object and auth helper functions (login, logout, etc.) to the application via the `useAuth` hook.
+ 
+ This setup ensures secure and consistent authentication across the Next.js App Router architecture.
+ 
+ ### 5.8 Codebase Structure and File Interactions
+ #### 5.8.1 File Structure Overview
+ 
+ *(See Section 5.6.2 for the directory structure)*
+ 
+ #### 5.8.2 Core File Interactions (Diagram)
+ 
+ ```mermaid
+ graph TD
+     subgraph "Root Layout & Providers"
+         A[app/layout.tsx] --> B[ClientProviders/Individual Providers]
+         B --> C[providers/ThemeProvider]
+         B --> D[providers/AuthProvider]
+         B --> E[providers/SettingsProvider]
+     end
+ 
+     subgraph "Study Session Flow"
+         F[hooks/useStudySession.ts] --> G[lib/actions/studyQueryActions.ts]
+         F --> H[lib/actions/cardActions.ts]
+         F --> I[lib/actions/progressActions.ts]
+         F --> J[lib/srs.ts]
+         F --> K[store/studySessionStore.ts]
+         L[components/study/study-flashcard-view.tsx] --> F
+         L --> M[hooks/useStudyTTS.ts]
+         M --> N[lib/actions/ttsActions.ts or /api/tts]
+         O[app/study/session/page.tsx] --> F
+         O --> L
+         P[app/study/select/page.tsx] --> K
+         P --> Q[components/study/StudySetSelector.tsx]
+     end
+ 
+     subgraph "Deck Management"
+         R[lib/actions/deckActions.ts] --> S[lib/supabase/server.ts]
+         T[hooks/useDecks.ts] --> R
+         U[components/deck-list.tsx] --> T
+         V[components/create-deck-dialog.tsx] --> R
+     end
+ 
+     subgraph "Tag Management"
+         W[hooks/useTags.ts] --> X[lib/actions/tagActions.ts]
+         Y[hooks/useCardTags.ts] --> X
+         Z[components/tags/CardTagEditor.tsx] --> Y
+         AA[components/tags/TagManager.tsx] --> W
+         AB[app/tags/page.tsx] --> AA
+     end
+ 
+     subgraph "Study Set Management"
+        AC[hooks/useStudySets.ts] --> AD[lib/actions/studySetActions.ts]
+        AE[components/study/StudySetBuilder.tsx] --> AD
+        AF[app/study/sets/page.tsx] --> AC
+        AG[app/study/sets/new/page.tsx] --> AE
+        AH[app/study/sets/[id]/edit/page.tsx] --> AE
+        AH --> AC
+     end
+ 
+     subgraph "Authentication"
+         AI[hooks/useAuth.tsx] --> AJ[providers/AuthProvider.tsx]
+         AK[lib/supabase/client.ts] --> AJ
+         AL[middleware.ts] -.-> AM[lib/supabase/server.ts] # conceptually
+         AN[Server Actions/Components] --> AM[lib/supabase/server.ts]
+         AO[app/auth/*] --> AI
+     end
+ 
+     subgraph "AI Generation Flow"
+         AP[app/prepare/ai-generate/page.tsx] --> AQ[components/ai/FileUpload.tsx]
+         AP --> AR[components/ai/QnaReview.tsx]
+         AQ --> AS[lib/actions/aiUploadAction.ts] # Example name
+         AR --> AT[lib/actions/cardActions.ts # createMultipleCards]
+         AS --> AU[lib/ai-utils.ts # extractText]
+         AU --> AV[lib/actions/aiGenerateAction.ts] # Example name
+         AV --> AR
+     end
+ 
+ ```
+ 
+ #### 5.8.3 File Descriptions
+ 
+ *(Descriptions mostly align with the original Section 14.3, adapted for the new structure)*
+ 
+ 1.  **Core Hooks (`hooks/`)**: Manage state and logic for features like Study Sessions (`useStudySession`), TTS (`useStudyTTS`), Data Fetching (`useDecks`, `useTags`, `useStudySets`, `useCardTags`), Auth (`useAuth`), Settings (`useSettingsContext`), UI (`useMobileSidebar`).
+ 2.  **Server Actions (`lib/actions/`)**: Handle backend logic triggered from the frontend (CRUD operations, study query resolution, progress updates, AI processing steps, TTS generation).
+ 3.  **Zustand Stores (`store/`)**: Manage cross-component state not suitable for Context (e.g., `studySessionStore` for passing parameters, `mobileSidebarStore` for UI state).
+ 4.  **Utility Libraries (`lib/`)**: Contain helper functions like SRS calculations (`srs.ts`), AI utilities (`ai-utils.ts`), general helpers (`utils.ts`), and Supabase client setup (`supabase/`).
+ 5.  **Components (`components/`)**: Reusable UI parts, organized by feature (study, tags, layout, ai) or shared (`ui`).
+ 6.  **Providers (`providers/` or `components/layout/`)**: React Context providers for global state like Auth, Settings, Theme.
+ 7.  **App Router Pages (`app/`)**: Define routes and structure, coordinating hooks, components, and actions.
+ 
+ #### 5.8.4 Data Flow Patterns (Diagram)
+ 
+ ```mermaid
+ graph TD
+     subgraph "Study Session Flow"
+         A[useStudySession Hook] --> B(studyQueryActions);
+         A --> C(cardActions - get);
+         A --> D(progressActions - update);
+         E[useStudyTTS] --> F[ttsActions];
+         G[StudyFlashcardView] --> A;
+         G --> E;
+     end
+ 
+     subgraph "Deck Management"
+         H[useDecks Hook] --> I(deckActions);
+         K[DeckList Comp] --> H;
+         L[CreateDeckDialog Comp] --> I;
+     end
+ 
+     subgraph "Tag Management"
+         M[useTags Hook] --> N(tagActions);
+         O[useCardTags Hook] --> N;
+         P[CardTagEditor Comp] --> O;
+         Q[TagManager Comp] --> M;
+     end
+ 
+     subgraph "Study Set Management"
+         R[useStudySets Hook] --> S(studySetActions);
+         T[StudySetBuilder Comp] --> S;
+         U[StudySetList Page] --> R;
+         V[StudySet Edit Page] --> R;
+         V --> T;
+     end
+ 
+     subgraph "Settings Management"
+         W[useSettings Hook] --> X(settingsActions);
+         Y[SettingsForm Comp] --> W;
+     end
+ 
+     subgraph "Authentication"
+         Z[useAuth Hook] --> AA[AuthProvider Context];
+         BB[Login/Signup Forms] --> Z;
+         CC[Server Action/Component] --> DD(Supabase Server Client);
+         EE[Middleware] -.-> DD;
+     end
+ 
+     subgraph "AI Generation"
+         FF[AI Page] --> GG[Upload Comp];
+         FF --> HH[Review Comp];
+         GG --> II(Upload Action);
+         II --> JJ(Extract Action);
+         JJ --> KK(Generate Action);
+         KK --> HH;
+         HH --> LL(cardActions - createMultiple);
+     end
+ 
+ ```
+ 
+ ---
+ 
+ ## 6. Core Feature Implementation Details
+ 
+ ### 6.1 Study Session Initiation & Execution Flow
+ **Overall Process:** The user first defines *which cards* they want to potentially study (**Card Selection**), and then chooses *how* they want to study that set (**Study Mode**).
+ 
+ **Phase 1: Card Selection**
+ 
+ 1.  **User Initiation & Criteria Definition:** (via `/study/select`, using `<StudySetSelector />`)
+     *   User selects source: Deck, "All Cards", Tag(s), or saved/dynamic Study Set.
+     *   If Study Set, criteria like Deck(s), Tags (Include/Exclude, Any/All), Date ranges, SRS Level are used.
+     *   *Resulting `queryCriteria`:* JSON object representing the selection.
  
  2.  **Backend: Resolve Initial Card IDs (`studyQueryActions.resolveStudyQuery`):**
-     *   Frontend (`useStudySession` init) calls `resolveStudyQuery` Server Action with the `queryCriteria` (or `studySetId`).
-     *   Action/RPC translates criteria into a SQL query:
-         *   **Always** filters by `user_id`.
-         *   Applies filters for decks, tags (JOIN `card_tags`), dates, etc. based on criteria.
+     *   Frontend (`useStudySessionStore` triggers `useStudySession` hook init) calls `resolveStudyQuery` Server Action with the `queryCriteria` (or `studySetId`).
+     *   Action calls `resolve_study_query` DB function/RPC.
+     *   DB function translates criteria into SQL:
+         *   Filters by `user_id`.
+         *   Applies filters based on `queryCriteria`.
          *   **Does NOT filter by `next_review_due` at this stage.**
-     *   **Returns:** Array of all `cardIds` matching the selection criteria.
- 
- ### 5.2 Phase 2: Study Mode Execution
- 
- **Goal:** Take the initial list of card IDs, fetch their data, and then execute the study session according to the user's chosen mode.
- 
- 1.  **User Mode Selection:** User chooses **Mode 1 (Learn)** or **Mode 2 (Review)** in the UI, typically alongside Card Selection.
- 
- 2.  **Backend: Fetch Full Card Data (`cardActions.getCardsByIds`):**
-     *   `useStudySession` calls `getCardsByIds` with the `cardIds` array from Phase 1.
-     *   **Returns:** Array of fully populated `FlashCard` objects (content, current SRS state, etc.).
- 
- 3.  **Frontend: Session Preparation & Loop (`useStudySession` Hook Logic):**
-     *   Receives the `FlashCard[]` array.
+     *   **Returns:** Array of `card_id`s matching the criteria.
+ 
+ **Phase 2: Study Mode Execution**
+ 
+ 1.  **User Mode Selection:** User chooses **Mode 1 (Learn)** or **Mode 2 (Review)** in the UI (usually `/study/select`).
+ 
+ 2.  **Frontend/Backend Handoff:**
+     *   Card IDs and selected Mode are stored (e.g., in `studySessionStore`).
+     *   User navigates to `/study/session`.
+ 
+ 3.  **Frontend: Session Initialization (`useStudySession` Hook):**
+     *   Reads Card IDs and Mode from the store.
+     *   Calls `cardActions.getCardsByIds` with the `cardIds` array.
+     *   **Returns:** Array of fully populated `Card` objects (content, current SRS state, deck languages, etc.).
+ 
+ 4.  **Frontend: Session Preparation & Loop (`useStudySession` Hook Logic):**
+     *   Receives the `Card[]` array.
      *   Prepares the study queue and manages the loop based on the **selected Study Mode**:
  
      *   **If Mode 1: Learn Mode (Comprehensive Review):**
          *   **Queue Init:** Includes **all** fetched cards.
-         *   **Ordering:** Apply shuffling or smart prioritization (e.g., recently failed cards). Define strategy.
-         *   **Goal:** Review each card until session success threshold `X` (from `settings.learn_mode_success_threshold`) is met *for this session*.
+         *   **Ordering:** Apply shuffling or smart prioritization (TBD).
+         *   **Goal:** Review each card until session success threshold (`learn_mode_success_threshold` from settings) is met *for this session*.
          *   **Progression:**
              *   Track consecutive correct answers *per card* within session state.
              *   Increment on correct, reset to 0 on incorrect.
-             *   Remove card from active queue when count reaches `X`.
-             *   Ensure incorrect cards are repeated.
-         *   **SRS Update:** **Crucially, after every answer, calculate the *next* SRS state using `calculateSm2State` (mapping answer to grade 1-4) and schedule a debounced save via `progressActions.updateCardProgress`**.
-         *   **End:** Session ends when active queue is empty.
+             *   Remove card from active queue when count reaches threshold.
+             *   Ensure incorrect cards are repeated (pushed to end or similar).
+         *   **SRS Update:** **After every answer (map correct/incorrect to grade), calculate the *next* SRS state using `calculateSm2State` and schedule a debounced save via `progressActions.updateCardProgress`**.
+         *   **End:** Session ends when active queue is empty. Display summary.
  
      *   **If Mode 2: Review Mode (SRS-Prioritized):**
-         *   **Filtering:** Filter the fetched `FlashCard[]` array *locally in the hook* to keep only cards where `card.next_review_due <= now()`.
+         *   **Filtering:** Filter the fetched `Card[]` array *locally in the hook* to keep only cards where `card.next_review_due <= now()` or `card.next_review_due IS NULL`.
          *   **Empty Queue Handling:** Notify user if no cards are due from the initial selection.
          *   **Ordering:** Sort the filtered (due) cards by `next_review_due ASC`.
          *   **Progression:** Present cards sequentially from the sorted due queue.
          *   **SRS Update:** After every answer (grade 1-4), calculate the *next* SRS state using `calculateSm2State` and schedule a debounced save via `progressActions.updateCardProgress`.
-         *   **End:** Session ends when the due queue is exhausted.
- 
- ### 5.3 Key Considerations & Implementation Notes
- 
- *   **UI Clarity:** Clearly separate Card Selection and Study Mode choices. Explain mode differences.
- *   **Backend Query (`resolveStudyQuery`):** Handling complex "Smart Playlist" criteria requires careful SQL/RPC implementation and indexing. Performance is key.
- *   **Frontend Hook (`useStudySession`):** Needs robust state management for both modes, including session-specific tracking for Learn Mode.
- *   **Tagging Integration:** Requires implementing `tagActions`, tag-related UI, and adding tag filtering logic to `resolve_study_query`.
- *   **Consistency:** Ensure SRS state is always calculated and saved correctly in both modes based on user input/grades (map Learn Mode right/wrong to grades 1 & 3 for SRS calc).
- 
- ## 6. Component Breakdown
- - `StudySetBuilder`
- - `StudySetSelector`
- - `TagManager`
- - `CardTagEditor`
- - `SrsSelector`
- - `StudyFlashcardView`
- - `DeckList`, `DeckForm`, `CardForm`, `TableEditor`
- - Standard UI elements from `shadcn/ui`.
- - Layout components (`Header`, `Sidebar`, `Footer`).
- - Authentication forms (`LoginForm`, `SignupForm`).
- 
- ## 7. Data Models and Relationships
- *(Schema defined in Section 4 - Data Models remains the source of truth)*
- 
- ## 8. Security Considerations
- - Supabase Auth, JWT/Cookies (@supabase/ssr)
- - RLS on all tables (`decks`, `cards`, `settings`, `tags`, `card_tags`, `study_sets`)
- - Server Action validation (Session, Input via Zod)
- - API route protection
- - Environment variable security
- - Query parameterization (via Supabase client or DB function)
- 
- ## 9. Development and Deployment Workflow
- - Git workflow
- - Supabase local dev + migrations (`supabase/migrations`)
- - Linting/Formatting/Typing
- - Testing (Unit for SRS utils, Integration for Actions/Hooks)
- - Vercel deployment
- 
- ## 10. Known Issues and Future Roadmap
- *   Need to implement UI for `StudySetSelector`, `StudySetBuilder`, `TagManager`, `CardTagEditor`.
- *   Need to implement backend logic for `tagActions`, `studySetActions`.
- *   Need to implement complex filtering (tags, dates, languages etc.) in `resolve_study_query` DB function/RPC.
- *   Need to implement the specific card ordering/shuffling strategy for Learn Mode in `useStudySession`.
- *   Need to finalize UI changes for `StudyFlashcardView` (4-grade input) and `StudyPage`.
- *   Need to address TTS language determination in `useStudyTTS` (fetch languages with card data?).
- *   Backfilling SRS/user_id data for existing cards is required (migration script needed).
- *   Performance testing of `resolve_study_query` with large datasets.
- *   **Future Roadmap:**
-     - Implement FSRS algorithm + optimization.
-     - Sharing Decks/Study Sets.
-     - Advanced Query Operators/UI.
-     - System-generated Study Sets ("Hardest", "Recent Lapses").
-     - Enhanced Analytics.
-     - Import/Export improvements.
-     - Rich text editing.
-     - Mobile App / PWA.
- 
- ## 11. References and Resources
- - Next.js, Supabase (@supabase/ssr, RLS, Functions), React, Tailwind/shadcn/ui Docs
- - SM-2 Algorithm Specification
- - FSRS Algorithm Resources
- - Google Cloud TTS Docs
- - `date-fns` Docs
- 
- ## 12. Changelog
- *   **v2.3 (2024-04-05):** 
-     - Removed deprecated `language` column from `decks` table, keeping only `primary_language` and `secondary_language` as nullable fields.
-     - Deprecated and removed `lib/deckService.ts` and its tests in favor of Server Actions pattern (`lib/actions/deckActions.ts`).
-     - Consolidated documentation from `architecture-study-sets.md` and `project-documentation.md`. 
-     - Added comprehensive authentication flow details. 
-     - Updated version to reflect latest architecture.
- *   **v2.2 (2024-04-05):** Consolidated documentation from `architecture-study-sets.md` and `project-documentation.md`. Added comprehensive authentication flow details. Updated version to reflect latest architecture.
- *   **v2.1 (2024-07-27):** Refactored study session architecture into Section 5. Clarified Card Selection vs. Study Mode execution. Consolidated SRS details. Updated functional overview and workflows. Added `learn_mode_success_threshold` to settings.
- *   **v2.0 (2024-07-26):** Integrated architecture for Tagging, Query-Based Study Sets, and Spaced Repetition System (SRS) with initial SM-2 support. Updated data models, hooks, server actions, and documentation throughout.
- *   **v1.0 (Previous Date):** Initial project documentation covering basic deck/card management, authentication, and TTS.
- 
- ## 13. Implementation Plan & Status (v2.1 Refactor)
- *   **Phase 1: Data Model & Core Backend Setup:** (Completed - Migration `YYYYMMDDHHMMSS_add_srs_study_sets.sql` includes schema, `calculateSm2State` done, core Actions `settings/progress/card` done, Action placeholders created, **Supabase Types Integrated**, **Removed deprecated `language` column from `decks` table**).
- *   **Phase 2: Study Session Hook Refactoring:** (**Completed** - `useStudySession` refactored for store-based initialization, mode handling, data fetching, and SRS logic).
- *   **Phase 3: UI Adaptation & New Features:** (**Largely Completed for Core Study Loop & Study Set Definition**)
-     *   Implement `StudySetSelector` (Card Selection + Mode Selection UI). **(Largely Completed - Added Study Set Selection)**
-     *   Implement `StudySetBuilder` (Smart Playlist UI): **(Completed)**
-         *   Structure Implemented with Hooks. **(Completed)**
-         *   Implement Full `onSubmit` Criteria Mapping. **(Completed)**
-         *   Implement Multi-Select Combobox UI for Tag selection. **(Completed)**
-         *   Implement Date Picker UI (onDate, betweenDates) for Date filters. **(Completed)**
-         *   Implement SRS Level filter UI. **(Completed)**
-         *   Implement other required filter UIs (updatedDate, lastReviewed, etc.). **(Completed)**
-         *   Update `studySetBuilderSchema` to include fields for all implemented filters. **(Completed)**
-     *   Implement `TagManager`, `CardTagEditor`. **(Completed)**
-     *   Implement `useTags`, `useCardTags`, `useDecks`, `useStudySets` hooks. **(Completed)**
-     *   Update `StudyFlashcardView` for 4-grade input. (**Pending**)
-     *   Implement `app/study/session/page.tsx` Study Page: **(Completed - Core Functionality)**
-         *   Use Settings Context. **(Completed)**
-         *   Implement Flip State Management & `isTransitioning`. **(Completed)**
-         *   Integrate `useStudySession` and `StudyFlashcardView`. **(Completed)**
-         *   Handle Loading/Error/Completion States. **(Completed)**
-     *   Implement `app/study/sets/new/page.tsx` (Create Study Set Page). **(Completed)**
-     *   Implement `app/study/sets/page.tsx` (List/Manage Study Sets Page). **(Completed)**
-     *   Implement `app/study/sets/[setId]/edit/page.tsx` (Edit Study Set Page). **(Completed)**
- *   **Phase 4: Backend Implementation:** (**Largely Completed, StudySet Actions Implemented**)
-     *   Implement complex filtering (tags, dates, etc.) in `resolve_study_query` DB function/RPC. **(Completed)** 
-     *   Implement Server Action `studyQueryActions.resolveStudyQuery` to call the DB function and handle criteria/studySetId input. **(Completed)**
-     *   Implement `tagActions`. **(Completed)**
-     *   Implement `studySetActions`. (**Completed**)
-     *   **Removed deprecated `deckService.ts` and its tests in favor of Server Actions pattern (`deckActions.ts`)**. **(Completed)**
- 
- ## 14. Codebase Structure and File Interactions
- 
- ### 14.1 File Structure Overview
- 
- ```plaintext
- /
- ├── app/                    # Next.js App Router pages
- │   ├── layout.tsx         # Root layout (Server Component)
- │   ├── page.tsx           # Home page (Server Component)
- │   ├── edit/              # Deck editing pages
- │   ├── study/             # Study session pages
- │   ├── tags/              # Tag management pages
- │   ├── settings/          # User settings pages
- │   ├── auth/              # Authentication pages
- │   └── api/               # API routes
- ├── components/            # Reusable components
- │   ├── ui/               # shadcn/ui components
- │   ├── study/            # Study-related components
- │   ├── tags/             # Tag-related components
- │   └── [component].tsx   # Individual components
- ├── hooks/                # Custom React hooks
- ├── lib/                  # Utility functions and services
- │   ├── actions/          # Server actions
- │   ├── schema/           # Database schema types
- │   └── supabase/         # Supabase client setup
- ├── providers/            # Context providers
- └── types/                # TypeScript type definitions
- ```
- 
- *Note: Removed `services/` directory as we've migrated to Server Actions pattern.*
- 
- ### 14.2 Core File Interactions
- 
- ```mermaid
- graph TD
-     subgraph "Root Layout & Providers"
-         A[app/layout.tsx] --> B[components/ClientProviders.tsx]
-         B --> C[providers/ThemeProvider]
-         B --> D[providers/AuthProvider]
-         B --> E[providers/SettingsProvider]
-     end
- 
-     subgraph "Study Session Flow"
-         F[hooks/useStudySession.ts] --> G[lib/actions/studyQueryActions.ts]
-         F --> H[lib/actions/cardActions.ts]
-         F --> I[lib/actions/progressActions.ts]
-         F --> J[lib/srs.ts]
-         K[components/study-flashcard-view.tsx] --> F
-         K --> L[hooks/useStudyTTS.ts]
-         L --> M[lib/actions/ttsActions.ts]
-     end
- 
-     subgraph "Deck Management"
-         N[lib/actions/deckActions.ts] --> O[lib/supabase/client.ts]
-         N --> P[lib/supabase/server.ts]
-         Q[components/deck-list.tsx] --> N
-         R[components/create-deck-dialog.tsx] --> N
-     end
- 
-     subgraph "Tag Management"
-         S[hooks/useTags.ts] --> T[lib/actions/tagActions.ts]
-         U[components/CardTagEditor.tsx] --> S
-         V[components/tags-button.tsx] --> S
-     end
- 
-     subgraph "Authentication"
-         W[hooks/useAuth.tsx] --> X[lib/supabase/client.ts]
-         Y[app/auth/*] --> W
-     end
- ```
- 
- ### 14.3 File Descriptions
- 
- #### 14.3.1 Core Hooks
- 
- 1. **Study Session Hooks**
-    - `hooks/useStudySession.ts`: Core hook managing study session state and logic, including card progression, SRS calculations, and session completion.
-    - `hooks/useStudyTTS.ts`: Manages text-to-speech functionality during study sessions, including language-specific voice selection and playback control.
- 
- 2. **Deck Management Hooks**
-    - `hooks/useDecks.ts`: Manages deck operations (CRUD) and state, including loading, error handling, and refresh functionality.
- 
- 3. **Tag Management Hooks**
-    - `hooks/useTags.ts`: Manages tag operations and state, including creation, updating, and deletion of tags.
-    - `hooks/useCardTags.ts`: Manages card-tag relationships, including assignment and removal of tags from cards.
- 
- 4. **Study Set Hooks**
-    - `hooks/useStudySets.ts`: Manages study set operations and state, including creation, updating, and deletion of smart playlists.
- 
- 5. **Authentication Hooks**
-    - `hooks/useAuth.tsx`: Manages authentication state and operations, including login, logout, and session management.
-    - `hooks/useSupabase.tsx`: Provides access to the Supabase client instance with proper cookie handling.
- 
- 6. **UI Utility Hooks**
-    - `hooks/useMobile.tsx`: Detects mobile device state and manages responsive UI behavior.
- 
- #### 14.3.2 Server Actions
- 
- 1. **Study Session Actions**
-    - `lib/actions/studyQueryActions.ts`: Handles study query resolution and card ID fetching based on query criteria.
-    - `lib/actions/cardActions.ts`: Manages card operations including creation, updating, deletion, and batch operations.
-    - `lib/actions/progressActions.ts`: Handles study progress tracking and SRS state updates.
- 
- 2. **Deck Management Actions**
-    - `lib/actions/deckActions.ts`: Manages deck operations including creation, updating, deletion, and metadata management.
- 
- 3. **Tag Management Actions**
-    - `lib/actions/tagActions.ts`: Handles tag operations and card-tag relationship management.
- 
- 4. **Study Set Actions**
-    - `lib/actions/studySetActions.ts`: Manages study set operations including creation, updating, deletion, and query criteria management.
- 
- 5. **Settings Actions**
-    - `lib/actions/settingsActions.ts`: Handles user settings management including SRS configuration and study preferences.
- 
- 6. **TTS Actions**
-    - `lib/actions/ttsActions.ts`: Manages text-to-speech functionality including audio generation and caching.
- 
- ### 14.4 Data Flow Patterns
- 
- ```mermaid
- graph TD
-     subgraph "Study Session Flow"
-         A[useStudySession] --> B[studyQueryActions]
-         A --> C[cardActions]
-         A --> D[progressActions]
-         E[useStudyTTS] --> F[ttsActions]
-         G[StudyFlashcardView] --> A
-         G --> E
-     end
- 
-     subgraph "Deck Management"
-         H[useDecks] --> I[deckActions]
-         K[DeckList] --> H
-         L[CreateDeckDialog] --> H
-     end
- 
-     subgraph "Tag Management"
-         M[useTags] --> N[tagActions]
-         O[useCardTags] --> N
-         P[CardTagEditor] --> O
-         Q[TagsButton] --> M
-     end
- 
-     subgraph "Study Set Management"
-         R[useStudySets] --> S[studySetActions]
-         T[StudySetSelector] --> R
-         U[StudySetBuilder] --> R
-     end
- 
-     subgraph "Settings Management"
-         V[useSettings] --> W[settingsActions]
-         X[SettingsForm] --> V
-     end
- 
-     subgraph "Authentication"
-         Y[useAuth] --> Z[AuthProvider]
-         AA[useSupabase] --> Z
-     end
- ``` 
+         *   **End:** Session ends when the due queue is exhausted. Display summary.
+ 
+ ### 6.2 SRS Algorithm: SM-2 Implementation
+ The core SM-2 logic resides in the `calculateSm2State` function within `lib/srs.ts`.
+ 
+ **Input:**
+ *   `currentSm2State`: Object containing `{ interval_days, easiness_factor, srs_level }` for the card *before* the review.
+ *   `grade`: User's assessment of recall difficulty (integer 1-4, where 1='Again', 2='Hard', 3='Good', 4='Easy').
+ 
+ **Output:**
+ *   `newSm2State`: Object containing `{ interval_days, easiness_factor, srs_level, next_review_due, last_reviewed_at, last_review_grade }` for the card *after* the review.
+ 
+ **Simplified Logic:**
+ 
+ 1.  **Handle Failing Grades (Grade < 3):**
+     *   Reset `srs_level` to 0 (or 1 depending on interpretation).
+     *   Reset `interval_days` to 0 (or 1, meaning review tomorrow).
+     *   Adjust `easiness_factor` slightly (usually no change or small decrease for grade < 3).
+ 2.  **Handle Passing Grades (Grade >= 3):**
+     *   Increment `srs_level`.
+     *   Calculate the new `easiness_factor` based on the old EF and the grade:
+         *   `EF' = EF + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02))`
+         *   Ensure EF does not drop below 1.3.
+     *   Calculate the new `interval_days`:
+         *   If `srs_level` is 1, interval is 1 day.
+         *   If `srs_level` is 2, interval is 6 days.
+         *   If `srs_level` > 2, interval is `previous_interval * EF'`.
+     *   Round the interval to the nearest integer.
+ 3.  **Calculate `next_review_due`:** Add the calculated `interval_days` to the current date (`last_reviewed_at`).
+ 4.  **Set `last_reviewed_at`:** Record the timestamp of the review.
+ 5.  **Set `last_review_grade`:** Store the user's input grade.
+ 
+ *(Actual implementation in `lib/srs.ts` provides the precise calculations)*
+ 
+ ### 6.3 AI Q&A Generation Workflow (Google Cloud)
+ This workflow enables users to automatically generate flashcards from uploaded documents.
+ 
+ 1.  **Upload (Client -> Server Action/API):**
+     *   User selects a PDF or Image file via `<FileUpload />` component on `/prepare/ai-generate`.
+     *   File is sent to a Server Action or API Route (`uploadFileAction` or similar).
+     *   Action temporarily stores the file (e.g., Supabase Storage).
+ 
+ 2.  **Pre-process & Text Extraction (Server-Side):**
+     *   Triggered after upload (e.g., background job or subsequent action call `extractTextAction`).
+     *   **If PDF:** Use `pdf-parse` library to extract raw text content.
+     *   **If Image:** Use Google Cloud Vision AI (`@google-cloud/vision`) OCR API to extract text.
+     *   Handle potential errors during extraction.
+ 
+ 3.  **Chunk Text (Server-Side):**
+     *   Use a utility function (`lib/ai-utils.ts -> chunkText`) to split the extracted text into meaningful chunks (e.g., by paragraph, section, or fixed size) suitable for AI processing. This prevents hitting token limits and provides context.
+ 
+ 4.  **Generate Q&A Pairs (Server-Side -> Google Gemini):**
+     *   For each text chunk, call the Google AI Gemini API (`@google/generative-ai`) via a Server Action (`generateQnaAction`).
+     *   **Prompt Engineering:** Craft a prompt instructing Gemini to generate relevant Question/Answer pairs based on the provided text chunk. Specify desired format (e.g., JSON array of `{ question: "...", answer: "..." }`).
+     *   Handle API calls, potentially in batches or parallel. Manage rate limits and errors.
+ 
+ 5.  **Parse & Validate (Server-Side):**
+     *   Receive responses from Gemini.
+     *   Parse the generated Q&A pairs (e.g., from JSON).
+     *   Validate the structure and content (ensure question/answer fields exist, basic quality checks).
+ 
+ 6.  **User Review & Selection (Client):**
+     *   Send the validated, generated Q&A pairs back to the client.
+     *   Display pairs in the `<QnaReview />` component on `/prepare/ai-generate`.
+     *   Allow the user to:
+         *   Review each pair.
+         *   Edit the question or answer content.
+         *   Select/deselect pairs for import.
+         *   Choose a target deck for importing.
+ 
+ 7.  **Save Selected Cards (Client -> Server Action):**
+     *   User clicks "Import Selected".
+     *   Client sends the final list of selected (and potentially edited) Q&A pairs along with the target `deck_id` to a Server Action (`cardActions.createMultipleCards`).
+     *   Action performs a batch insert into the `cards` table, setting `front_content` and `back_content` accordingly, associating them with the correct `user_id` and `deck_id`.
+     *   Provide feedback to the user (success/failure).
+ 
+ 8.  **Cleanup (Server-Side):**
+     *   Delete the temporary file from storage after processing.
+ 
+ ---
+ 
+ ## 7. Component Breakdown (Key Components)
+ 
+ *   **Layout:** `RootLayout`, `SiteHeader`, `SiteSidebar`.
+ *   **Providers:** `AuthProvider`, `SettingsProvider`, `ThemeProvider`.
+ *   **Core Study:** `StudySessionPage` (`app/study/session/page.tsx`), `StudyFlashcardView`, `DifficultyIndicator`.
+ *   **Study Setup:** `StudySetSelector`, `StudySetBuilder`, Study Setup Page (`app/study/select/page.tsx`).
+ *   **Deck/Card Management:** `DeckList`, `CardEditor`, `EditableCardTable` (or integrated into Edit Deck Page).
+ *   **Tag Management:** `TagManager`, `CardTagEditor`, Tag Management Page (`app/tags/page.tsx`).
+ *   **Study Set Management:** List page (`app/study/sets/page.tsx`), New page (`.../new`), Edit page (`.../[id]/edit`).
+ *   **AI Generation (New):** `FileUpload`, `QnaReview`, Orchestrator page (`app/prepare/ai-generate/page.tsx`).
+ *   **Settings:** Settings Page (`app/settings/page.tsx`), various settings controls.
+ *   **Authentication:** Login/Signup Forms (`app/auth/...`).
+ *   **Hooks:** `useAuth`, `useSettingsContext`, `useMobileSidebar`, `useStudySessionStore`, `useDecks`, `useTags`, `useCardTags`, `useStudySets`, `useTTS`.
+ 
+ ---
+ 
+ ## 8. Security Considerations
+ 
+ *   **Authentication:** Secure user authentication managed by Supabase Auth (JWT/Cookies managed via `@supabase/ssr`).
+ *   **Authorization (RLS):** Row Level Security policies strictly enforced on all user-specific tables (`settings`, `decks`, `cards`, `tags`, `card_tags`, `study_sets`) ensuring users can only access/modify their own data. Policies must cover SELECT, INSERT, UPDATE, DELETE. Denormalized `user_id` fields aid RLS implementation.
+ *   **Server Action Validation:**
+     *   Verify user session/authentication within each action.
+     *   Validate all input data using Zod schemas before processing or database interaction.
+ *   **API Route Protection:** Secure API routes (e.g., `/api/tts`) by verifying user authentication if they handle sensitive data or actions.
+ *   **Environment Variables:** Store sensitive keys (Supabase URL/anon key, Google Cloud credentials, JWT secret) securely in environment variables (`.env.local`, Vercel environment variables). Do not commit sensitive keys to Git.
+ *   **Database Security:** Use parameterized queries (handled by Supabase client libraries) or properly sanitize inputs in DB functions (`resolve_study_query`) to prevent SQL injection. Limit database user permissions if not using Supabase defaults.
+ *   **HTTPS:** Ensure all communication is over HTTPS (handled by Vercel/Supabase).
+ *   **Dependencies:** Regularly audit and update dependencies to patch security vulnerabilities.
+ *   **Rate Limiting:** Consider rate limiting on sensitive API routes or actions (e.g., AI generation, TTS) to prevent abuse.
+ 
+ ---
+ 
+ ## 9. Development & Deployment Workflow
+ 
+ *   **Version Control:** Git (GitHub/GitLab/Bitbucket).
+     *   Feature branches (`feat/`, `fix/`, `chore/`).
+     *   Pull Requests with code review.
+     *   Clear, descriptive commit messages.
+ *   **Local Development:**
+     *   Supabase CLI for local development environment (`supabase start`).
+     *   Manage database schema changes via migrations (`supabase/migrations/`). Apply locally (`supabase db reset`), link project (`supabase link`), push changes (`supabase db push`), generate types (`supabase gen types typescript`).
+ *   **Code Quality & Consistency:**
+     *   TypeScript for static typing.
+     *   Linting (`ESLint`) and Formatting (`Prettier`) enforced via pre-commit hooks (`husky`, `lint-staged`).
+     *   Adherence to coding standards defined in custom instructions.
+ *   **Testing:**
+     *   Unit Tests (Jest/Vitest) for utility functions (e.g., `lib/srs.ts`, `lib/utils.ts`).
+     *   Integration Tests for Server Actions, custom hooks, potentially database functions.
+     *   End-to-End Tests (Cypress/Playwright) for critical user flows (Auth, Card CRUD, Study Session, Review Mode Session, AI Gen flow, Settings update).
+     *   Aim for reasonable test coverage.
+ *   **Continuous Integration (CI):** GitHub Actions (or similar).
+     *   Run linters, formatters, type checks, tests on each push/PR.
+     *   Build the application.
+ *   **Deployment:**
+     *   Vercel for hosting the Next.js application.
+     *   Connect Vercel to Git repository for automatic deployments from `main` branch.
+     *   Preview deployments for Pull Requests.
+     *   Manage environment variables securely in Vercel.
+     *   Apply Supabase migrations to staging/production environments (`supabase migration up`).
+ 
+ ---
+ 
+ ## 10. Known Issues / Future Roadmap
+ 
+ *   **Known Issues:**
+     *   TTS Language determination relies on joined deck data in `getCardsByIds`; need robust handling if deck data is missing or for card-level overrides (future).
+     *   `StudyFlashcardView` needs final prop/state implementation (e.g., `isTransitioning` refinement).
+     *   Learn mode card ordering/repetition logic is basic (needs defined strategy: random shuffle, push-to-end, smarter prioritization?).
+     *   Need comprehensive testing coverage (Unit, Integration, E2E).
+     *   Database backfilling script required for existing users' cards (`user_id`, SRS defaults, potentially tag links).
+     *   Performance testing of `resolve_study_query` with large datasets and complex criteria is needed.
+     *   UI for Settings page (`app/settings/page.tsx`) needs full implementation connecting controls to the Settings context/service.
+     *   Study session completion/summary UI needs refinement (clear "No Cards Found" state, child-friendly summary).
+     *   Potential UI/UX inconsistencies across different modules.
+ *   **Future Roadmap:**
+     *   Implement FSRS algorithm & parameter optimization UI/logic.
+     *   Implement remaining `StudySetBuilder` filters (text search within cards, other SRS props like stability/difficulty).
+     *   Sharing Decks/Study Sets between users.
+     *   System-generated Study Sets (e.g., "Hardest Cards", "Recently Lapsed", "Due Today").
+     *   Enhanced Analytics/Stats page (progress charts, review heatmap, retention rates).
+     *   Refine UI/UX, add subtle animations, improve layout consistency.
+     *   Import/Export features (CSV, Anki format?).
+     *   Image support on card fronts/backs.
+     *   Alternative answer input methods (typing, potentially speech-to-text).
+     *   Offline support (Progressive Web App - PWA capabilities).
+     *   Rich text editing for card content.
+     *   Mobile App (React Native or native).
+     *   Advanced query operators/UI in `StudySetBuilder`.
+ 
+ ---
+ 
+ ## 11. References
+ 
+ *   Next.js Documentation ([https://nextjs.org/docs](https://nextjs.org/docs))
+ *   React Documentation ([https://react.dev/](https://react.dev/))
+ *   Supabase Documentation ([https://supabase.com/docs](https://supabase.com/docs))
+     *   `@supabase/ssr` Guide ([https://supabase.com/docs/guides/auth/server-side/nextjs](https://supabase.com/docs/guides/auth/server-side/nextjs))
+     *   RLS Policies ([https://supabase.com/docs/guides/auth/row-level-security](https://supabase.com/docs/guides/auth/row-level-security))
+     *   Database Functions ([https://supabase.com/docs/guides/database/functions](https://supabase.com/docs/guides/database/functions))
+ *   Tailwind CSS Documentation ([https://tailwindcss.com/docs](https://tailwindcss.com/docs))
+ *   shadcn/ui Documentation ([https://ui.shadcn.com/docs](https://ui.shadcn.com/docs))
+ *   Zustand Documentation ([https://github.com/pmndrs/zustand](https://github.com/pmndrs/zustand))
+ *   React Hook Form Documentation ([https://react-hook-form.com/](https://react-hook-form.com/))
+ *   Zod Documentation ([https://zod.dev/](https://zod.dev/))
+ *   Google Cloud TTS API Documentation ([https://cloud.google.com/text-to-speech/docs](https://cloud.google.com/text-to-speech/docs))
+ *   Google Cloud Vision AI API Documentation ([https://cloud.google.com/vision/docs](https://cloud.google.com/vision/docs))
+ *   Google AI Gemini API Documentation ([https://ai.google.dev/docs](https://ai.google.dev/docs))
+ *   SM-2 Algorithm Specification (e.g., [https://www.supermemo.com/en/archives1990-2015/english/ol/sm2](https://www.supermemo.com/en/archives1990-2015/english/ol/sm2))
+ *   FSRS Algorithm Resources (e.g., [https://github.com/open-spaced-repetition/fsrs4anki](https://github.com/open-spaced-repetition/fsrs4anki))
+ *   `date-fns` Documentation ([https://date-fns.org/docs/Getting-Started](https://date-fns.org/docs/Getting-Started))
+ *   `pdf-parse` Documentation ([https://www.npmjs.com/package/pdf-parse](https://www.npmjs.com/package/pdf-parse))
+ 
+ ---
+ 
+ ## 12. Changelog
+ 
+ *   **v3.0 (YYYY-MM-DD - Placeholder):** Consolidated architecture from v2.x docs, added AI Generation plan & workflow, refined component breakdown and action plan. Merged business context and detailed code structure/auth flow from previous documentation. Updated technical architecture details.
+ *   **v2.3 (2024-04-05 - Based on original):**
+     *   Removed deprecated `language` column from `decks` table, keeping `primary_language` and `secondary_language`.
+     *   Deprecated and removed `lib/deckService.ts` in favor of Server Actions (`lib/actions/deckActions.ts`).
+     *   Added comprehensive authentication flow details (Section 4.2 in original).
+     *   Added Codebase Structure and File Interactions section (Section 14 in original).
+ *   **v2.2 (2024-04-05 - Based on original):** Consolidated documentation from prior `architecture-study-sets.md`. Updated version number.
+ *   **v2.1 (2025-04-09 - Based on docv2 / 2024-07-27 - Based on original):** Refactored study session flow (Card Selection vs. Study Mode), added Study Modes (Learn/Review), completed Study Set CRUD & UI structure, implemented Tagging system, finalized core SRS integration (SM-2), added `learn_mode_success_threshold` setting.
+ *   **v2.0 (2025-04-07 - Based on docv2 / 2024-07-26 - Based on original):** Initial integration plan/architecture for SRS, Tags, Study Sets. Updated data models, hooks, actions.
+ *   **v1.0 (Previous Date):** Basic deck/card management, auth, TTS, initial project documentation.
+ 
+ ---
+ 
+ ## 13. Implementation Action Plan & Status
+ 
+ **(Status Key: `[x]`=Done, `[/]`=In Progress, `[ ]`=Pending)**
+ 
+ **Phase 0: Foundational Setup (Assumed Mostly Done)**
+ *   [x] Next.js project setup with App Router.
+ *   [x] Supabase project setup.
+ *   [x] Supabase Auth integration (`@supabase/ssr`, Middleware, AuthProvider).
+ *   [x] `shadcn/ui` and Tailwind setup.
+ *   [x] Basic layout components (Header, Footer - pre-refactor).
+ *   [x] Initial Deck/Card CRUD (pre-refactor).
+ *   [x] TTS Integration (`useTTS`, `/api/tts` or action).
+ *   [x] Settings Provider/Service initial setup.
+ *   [x] Supabase Type Generation initial setup.
+ 
+ **Phase 1: DB Schema & Core Backend Refactor (Completed)**
+ *   [x] Add SRS fields & `user_id` to `cards` table schema.
+ *   [x] Create `tags`, `card_tags`, `study_sets`, `settings` table schemas.
+ *   [x] Implement Supabase migrations for all schema changes. (`..._add_srs_study_sets.sql`, `..._add_card_id_default.sql`, `..._enhance_resolve_study_query.sql`, etc.)
+ *   [x] Finalize Supabase type definitions (`types/database.ts` or equivalent) and integrate imports.
+ *   [x] Implement core SM-2 calculation logic (`lib/srs.ts`).
+ *   [x] Implement `progressActions.updateCardProgress`.
+ *   [x] Implement `settingsActions` (`fetchSettings`, `updateSettings` including `srs_algorithm`).
+ *   [x] Implement `cardActions.getCardsByIds` including nested deck languages.
+ *   [x] Implement `deckActions.getDecks`.
+ *   [x] Implement `resolve_study_query` DB function (handling Deck, Tags, Dates, SRS Level).
+ *   [x] Implement `studyQueryActions.resolveStudyQuery` Server Action (handling criteria and studySetId).
+ *   [x] Implement `tagActions.ts` (CRUD, link/unlink).
+ *   [x] Implement `studySetActions.ts` (CRUD).
+ *   [x] **Removed deprecated `deckService.ts` and its tests in favor of Server Actions pattern (`deckActions.ts`)**.
+ 
+ **Phase 2: Core Study Flow Refactoring (Completed)**
+ *   [x] Implement Zustand store (`store/studySessionStore.ts`).
+ *   [x] Refactor `useStudySession` hook (initialize via store, handle Learn/Review modes, fetch data via actions, trigger SRS calcs, save progress).
+ *   [x] Refactor `app/study/session/page.tsx` (use store, use refactored hook, render view, handle loading/error/complete/redirect/cleanup).
+ *   [x] Refactor `components/study/study-flashcard-view.tsx` (accept `DbCard`, use `front/back_content`, handle nested languages for TTS, use `onAnswer` mapped to grades).
+ 
+ **Phase 3: UI Implementation & Integration (Mostly Complete)**
+ *   [x] Implement Responsive Navigation (`SiteHeader`, `SiteSidebar`, `useMobileSidebar` hook, update `RootLayout`).
+ *   [x] Implement `TagManager` component (`components/tags/TagManager.tsx`).
+ *   [x] Create `app/tags/page.tsx` to host `TagManager`.
+ *   [x] Implement `CardTagEditor` component (`components/tags/CardTagEditor.tsx`).
+ *   [x] Implement `useTags` and `useCardTags` hooks.
+ *   [x] Integrate `CardTagEditor` into `CardEditor` component / Edit Deck Page.
+ *   [x] Refactor `CardEditor` to handle new cards correctly (no client ID, explicit save).
+ *   [x] Implement `StudySetBuilder` component (`components/study/StudySetBuilder.tsx`):
+     *   [x] Basic structure, form setup, name/description fields.
+     *   [x] `useDecks` integration & Deck selector UI.
+     *   [x] `useTags` integration & Multi-Select Combobox UI for Tags.
+     *   [x] Zod schema updated for all implemented filters.
+     *   [x] Date Picker UI (createdDate, updatedDate, lastReviewed, nextReviewDue) implemented.
+     *   [x] SRS Level filter UI implemented.
+     *   [x] `onSubmit` mapping logic fully implemented for all current UI filters.
+ *   [x] Implement `useStudySets` hook.
+ *   [x] Create "New Study Set" Page (`app/study/sets/new/page.tsx`) using `StudySetBuilder` and `createStudySet` action.
+ *   [x] Create "List Study Sets" Page (`app/study/sets/page.tsx`) using `useStudySets`, linking to edit/new, implementing Delete, and initiating study sessions via store.
+ *   [x] Create "Edit Study Set" Page (`app/study/sets/[studySetId]/edit/page.tsx`) fetching data, using `StudySetBuilder` with `initialData`, and calling `updateStudySet` action.
+ *   [x] Implement `StudySetSelector` component handling All/Deck/Study Set choices + Mode choice.
+ *   [x] Create Study Setup Page (`app/study/select/page.tsx`) using `StudySetSelector` and Zustand store.
+ *   [x] Update Deck List component UI to use new study initiation flow (set store, navigate).
+ *   [/] Implement Settings Page UI (`app/settings/page.tsx`) - **Partially Done**
+     *   [ ] Add controls for `srs_algorithm`.
+     *   [ ] Add control for `learn_mode_success_threshold`.
+     *   [ ] Add controls for Accessibility settings (font, theme, TTS toggle).
+     *   [ ] Connect UI to Settings Context/Service for saving.
+ *   [/] Finalize Study Session Page UI (`app/study/session/page.tsx`) - **Partially Done**
+     *   [x] Core rendering, hook usage, flip state, settings prop passing.
+     *   [ ] Implement clear "Session Complete" / "No Cards Found" UI distinctions.
+     *   [ ] Implement child-friendly end-of-session summary (requires adding tracking to `useStudySession`).
+     *   [ ] Implement `isTransitioning` state fully (optional refinement for smoother flips).
+ *   [x] Add main navigation links for new sections (Tags, Study Sets, Study Select).
+ 
+ **Phase 4: AI Flashcard Generator (Pending)**
+ *   [ ] Task 1.1: AI Key Setup (Google Cloud Credentials, Env Vars for API Keys).
+ *   [ ] Task 1.2: Install AI Dependencies (`pdf-parse`, `@google-cloud/vision`, `@google/generative-ai`).
+ *   [ ] Task 1.3: Implement Upload Action/Route & Temporary Storage (`uploadFileAction`, Supabase Storage).
+ *   [ ] Task 1.4: Implement Text Extraction Action/Route (`extractTextAction` using `pdf-parse`/Vision API).
+ *   [ ] Task 2.1: Implement Text Chunking Utility (`lib/ai-utils.ts -> chunkText`).
+ *   [ ] Task 2.2: Implement Q&A Generation Action/Route (`generateQnaAction` using Gemini API).
+ *   [ ] Task 3.1: Implement Upload Component UI (`components/ai/FileUpload.tsx`).
+ *   [ ] Task 3.2: Implement Orchestrator Page UI (`app/prepare/ai-generate/page.tsx`).
+ *   [ ] Task 3.3: Implement Q&A Review Component UI (`components/ai/QnaReview.tsx`).
+ *   [ ] Task 4.1: Implement `cardActions.createMultipleCards` Action.
+ *   [ ] Task 4.2: Connect Review UI to Save Action (`createMultipleCards`).
+ *   [ ] Task 4.3: Add AI Gen Entry Point in Main UI (Sidebar Link).
+ *   [ ] Task 5.1: Implement temporary file cleanup logic.
+ 
+ **Phase 5: Testing & Polish (Pending)**
+ *   [ ] Database Backfilling script creation & testing (Staging).
+ *   [ ] Unit testing (SRS utils, helpers, AI utils).
+ *   [ ] Integration testing (Server Actions, Hooks, DB function calls).
+ *   [ ] E2E testing (Core user flows: Auth, Deck/Card CRUD, Tagging, Study Set CRUD, Learn Mode Session, Review Mode Session, AI Gen flow, Settings update).
+ *   [ ] Manual cross-browser/device testing.
+ *   [ ] UI/UX polish (animations, layout consistency, wording, accessibility checks).
+ *   [ ] Performance review & optimization (DB queries, indexes, bundle size).
+ 
+ --- 
```

---

I have updated the `docs/project-documentation.md` file by merging the content from `docs/docv2`.

The updated document now reflects:
*   Version 3.0 and the consolidated title.
*   The "Conceptual Overview: Prepare vs. Practice" section.
*   The "Business Context" section from the original document.
*   Updated "Functional Requirements" including AI Generation and detailed Accessibility.
*   Updated "Technical Architecture" incorporating details from both versions, including the AI stack components, navigation structure, code structure, authentication flow, and file interaction diagrams.
*   Updated "Core Feature Implementation Details" including the AI Generation workflow.
*   Updated "Component Breakdown", "Security Considerations", "Development & Deployment Workflow", "Known Issues / Future Roadmap", "References", and "Changelog".
*   The detailed "Implementation Action Plan & Status" from `docv2`.

Please review the changes in `docs/project-documentation.md`.

---

_**User**_

[{
	"resource": "/Users/tom/dev/flashcards/app/globals.css",
	"owner": "_generated_diagnostic_collection_name_#3",
	"code": "unknownAtRules",
	"severity": 4,
	"message": "Unknown at rule @tailwind",
	"source": "css",
	"startLineNumber": 1,
	"startColumn": 1,
	"endLineNumber": 1,
	"endColumn": 10,
	"modelVersionId": 65
},{
	"resource": "/Users/tom/dev/flashcards/app/globals.css",
	"owner": "_generated_diagnostic_collection_name_#3",
	"code": "unknownAtRules",
	"severity": 4,
	"message": "Unknown at rule @tailwind",
	"source": "css",
	"startLineNumber": 2,
	"startColumn": 1,
	"endLineNumber": 2,
	"endColumn": 10,
	"modelVersionId": 65
},{
	"resource": "/Users/tom/dev/flashcards/app/globals.css",
	"owner": "_generated_diagnostic_collection_name_#3",
	"code": "unknownAtRules",
	"severity": 4,
	"message": "Unknown at rule @tailwind",
	"source": "css",
	"startLineNumber": 3,
	"startColumn": 1,
	"endLineNumber": 3,
	"endColumn": 10,
	"modelVersionId": 65
},{
	"resource": "/Users/tom/dev/flashcards/app/globals.css",
	"owner": "_generated_diagnostic_collection_name_#3",
	"code": "unknownAtRules",
	"severity": 4,
	"message": "Unknown at rule @apply",
	"source": "css",
	"startLineNumber": 105,
	"startColumn": 5,
	"endLineNumber": 105,
	"endColumn": 11,
	"modelVersionId": 65
},{
	"resource": "/Users/tom/dev/flashcards/app/globals.css",
	"owner": "_generated_diagnostic_collection_name_#3",
	"code": "unknownAtRules",
	"severity": 4,
	"message": "Unknown at rule @apply",
	"source": "css",
	"startLineNumber": 108,
	"startColumn": 5,
	"endLineNumber": 108,
	"endColumn": 11,
	"modelVersionId": 65
}]

---

_**Assistant**_



---

It looks like you're seeing some linting errors in your `app/globals.css` file related to `@tailwind` and `@apply` directives.

These directives are standard parts of Tailwind CSS. The `@tailwind` directive is used to inject Tailwind's base, components, and utilities styles, while `@apply` is used to inline utility classes into custom CSS.

The "Unknown at rule" errors usually indicate that the CSS language server or linter running in your editor doesn't recognize these specific Tailwind directives. This is often an editor configuration issue rather than a problem with the code itself, especially if your project builds and runs correctly otherwise.

Here are a few things you can check in your IDE (Cursor) to resolve this:

1.  **Tailwind CSS IntelliSense:** Make sure you have the official Tailwind CSS IntelliSense extension installed and enabled. This extension provides autocompletion, linting, and syntax highlighting for Tailwind features.
2.  **IDE/Editor Settings:** Sometimes, you might need to configure the CSS language server settings. Check if there are specific settings related to Tailwind CSS validation or if you need to point the editor to your `tailwind.config.js` file.
3.  **Restart:** Try restarting Cursor or reloading the window (`Developer: Reload Window` command) to ensure the Tailwind extension and language server initialize correctly.

The CSS code using `@tailwind` and `@apply` is likely correct and necessary for your project's styling, so you shouldn't need to change the code itself to fix these specific linting messages. They are generally safe to ignore if the extension is working correctly or if the project compiles successfully.

---

_**User**_

none of the 3 options worked

---

_**Assistant**_



---

Okay, let's try a few more specific things to troubleshoot why the Tailwind directives (`@tailwind`, `@apply`) are still being flagged as unknown in `app/globals.css`.

1.  **Check VS Code/Cursor Settings (`settings.json`):**
    *   Open your settings file (Command Palette: `Preferences: Open Settings (JSON)`).
    *   Look for settings related to CSS validation or file associations. Specifically:
        *   `"css.validate"`: Ensure this is set to `true` or not set to `false`.
        *   `"files.associations"`: Check if `.css` files are being explicitly associated with a different language mode. If so, try removing that association or ensuring it's set correctly for Tailwind. You could try adding:
            ```json
            "files.associations": {
              "*.css": "tailwindcss"
            }
            ```
        *   `"tailwindCSS.includeLanguages"`: Check if this setting exists and includes `css`. It might look like:
            ```json
            "tailwindCSS.includeLanguages": {
              "css": "css",
              "plaintext": "html" // Or similar other associations
            }
            ```
        *   Look for any settings from other CSS linting extensions (like stylelint) that might be overriding the validation.

2.  **Verify `postcss.config.js`:**
    *   Make sure you have a `postcss.config.js` (or `.postcssrc.js`, etc.) file in your project root.
    *   Ensure it correctly includes `tailwindcss` and `autoprefixer` as plugins. A typical Next.js setup looks like this:
        ```javascript
        // postcss.config.js
        module.exports = {
          plugins: {
            tailwindcss: {},
            autoprefixer: {},
          },
        }
        ```
    *   While this primarily affects the build, the Tailwind IntelliSense extension often relies on this configuration being present and correct.

3.  **Check for Conflicting Extensions:**
    *   Temporarily disable other CSS-related extensions (like Stylelint, CSS Peek, linters other than Tailwind IntelliSense) one by one to see if one of them is causing the conflict. Restart Cursor after disabling each one.

4.  **Tailwind Extension Activation:**
    *   Open the Output panel in Cursor (View -> Output).
    *   In the dropdown menu in the Output panel, select "Tailwind CSS IntelliSense".
    *   Check if there are any error messages or logs indicating why it might not be activating correctly for your `globals.css` file. It should typically show messages about finding the config file and initializing.

Sometimes these linting issues can be persistent due to caching or minor configuration conflicts within the editor's language servers. Trying these steps should help narrow down the cause.

---



---

