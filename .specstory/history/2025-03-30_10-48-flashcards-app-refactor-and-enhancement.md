<!-- Generated by SpecStory -->

# Flashcards App Refactor and Enhancement (2025-03-30 12:48:04)

_**User**_


Hello! You are an expert AI software engineer specializing in full-stack TypeScript development with Next.js, React, Supabase, and PostgreSQL. Your task is to help me refactor and enhance my existing Flashcards App codebase to align with a new, significantly updated architecture.

**Project Context:**

*   **Application:** A multilingual Flashcards learning app.
*   **Tech Stack:** Next.js 15+ (App Router), React 19+, TypeScript, Supabase (PostgreSQL DB, Auth via @supabase/ssr, Storage), Tailwind CSS, shadcn/ui, Server Actions (preferred for mutations/queries), React Hook Form, Zod.
*   **Source of Truth:** The **consolidated `project-documentation.md` file** (Version 2.0) provided in our chat history is the definitive guide for the target architecture. Please refer to it meticulously for data models, component interactions, hook responsibilities, action definitions, SRS logic, etc.

**Current State (Where We Come From):**

The app currently allows users to create decks and study cards *within a single deck*. Study session logic (`useStudySession` hook) is tightly coupled to loading an entire deck (`useDeckLoader`). Progress tracking is basic, stored directly on cards (`correct_count`, etc.), and lacks a formal Spaced Repetition System (SRS). Authentication and basic TTS are implemented.

**Target State (Where We Are Going - Key Architectural Changes):**

We are implementing a major upgrade to introduce:

1.  **Tagging System:** Users can create tags and assign them to cards (`tags`, `card_tags` tables).
2.  **Query-Based Study Sets:** Users can create saved "Study Sets" defined by query criteria (tags, decks, SRS status, etc. stored in `study_sets` table) or study based on dynamic queries (e.g., "all due cards").
3.  **Spaced Repetition System (SRS) Integration:**
    *   Implementing SRS logic, starting with **SM-2**. FSRS support is planned later.
    *   User-selectable SRS algorithm via `settings` table.
    *   Storing detailed SRS state per card directly on the `cards` table (`next_review_due`, `srs_level`, `easiness_factor`, `interval_days`, etc.).
    *   Refactoring study flow to calculate and save SRS state after each review.
4.  **Refactored Study Flow:** The `useStudySession` hook will be fundamentally changed. It will no longer load based on `deckId`. Instead, it will:
    *   Accept query criteria or a study set ID.
    *   Call a new `studyQueryActions.resolveStudyQuery` Server Action to get a list of `cardIds`.
    *   Call a new `cardActions.getCardsByIds` Server Action to fetch full card data (including SRS state).
    *   Call utility functions (`lib/srs.ts`) to calculate the next SRS state based on user grade and selected algorithm.
    *   Call a new `progressActions.updateCardProgress` Server Action (debounced) to save the updated SRS state for the *individual card* just reviewed.
5.  **New Server Actions:** Introduction of actions for managing tags (`tagActions`), study sets (`studySetActions`), resolving study queries (`studyQueryActions`), fetching specific card data (`cardActions`), updating individual card progress (`progressActions`), and managing settings (`settingsActions`).
6.  **Data Model Changes:** Significant updates to the `cards` table to include SRS fields and `user_id`. New tables: `tags`, `card_tags`, `study_sets`, `settings`. RLS policies are crucial. Ensure necessary database indexes (e.g., `cards(user_id, next_review_due)`) are considered.

**Your Task:**

Assist me in incrementally refactoring the existing codebase and implementing these new features. We will work together, likely focusing on specific files or modules at a time. Please:

1.  **Adhere strictly to the architecture defined in `project-documentation.md` (Version 2.0).** Ask clarifying questions if anything is ambiguous, but the document is the primary reference.
2.  **Prioritize the implementation plan** outlined in the documentation (Tags -> SRS Data Model -> Settings -> SM-2 Logic -> Progress Action -> Query Action -> `useStudySession` refactor -> UI). Let's start with the core backend changes first.
3.  **Write clean, maintainable, well-typed TypeScript code.** Follow existing project patterns where sensible. Leverage Server Actions effectively.
4.  **Focus on correctness and robustness.** Ensure proper error handling (e.g., Supabase `{ data, error }` patterns), validation (Zod where appropriate), and security (respecting RLS implicitly via Supabase client usage in authenticated actions).
5.  **Provide code changes clearly.** Use Markdown code blocks. Explain *why* changes are being made, referencing the documentation. If possible, provide diffs or clearly indicate added/modified/removed lines.
6.  **Help create necessary database migration SQL** for the schema changes, compatible with Supabase migrations.
7.  **Implement the `calculateSm2State` function** within `lib/srs.ts` exactly as specified in the documentation.

**Let's start with the first phase:**

**Phase 1: Data Model Changes & Core Backend Setup**

Please help me:

1.  **Generate the SQL migration code** (for Supabase CLI) to:
    *   Create the new tables: `settings`, `tags`, `card_tags`, `study_sets`.
    *   Modify the existing `cards` table: add the `user_id` foreign key and all the new SRS fields (`last_reviewed_at`, `next_review_due`, `srs_level`, etc.) as defined in the documentation (Section 4, Data Models). Ensure correct types, defaults, nullability, and unique constraints. Define the index on `cards(user_id, next_review_due)`.
    *   Ensure RLS policies are mentioned conceptually (we can refine the exact policies later, but the structure should support user-specific data).
2.  **Define the TypeScript types/interfaces** corresponding to these new/updated database tables (e.g., `Settings`, `Tag`, `CardTag`, `StudySet`, and the updated `FlashCard` type including SRS fields). Place these in appropriate shared type definition files (e.g., `types/database.ts` or similar).
3.  **Set up the initial Server Action files** (`settingsActions.ts`, `tagActions.ts`, `studySetActions.ts`, `progressActions.ts`, `cardActions.ts`, `studyQueryActions.ts`) with basic boilerplate, ready for implementation. Include necessary imports for Supabase server client creation (`@supabase/ssr`).

Provide the SQL migration script and the TypeScript type definitions first. We can then move on to implementing the actions one by one.
@use-study-session.ts @useDeckLoader.ts @page.tsx @use-decks.tsx @deckService.ts @use-supabase.tsx @use-auth.tsx @server.ts @middleware.ts 

---

_**Assistant**_

Okay, sounds like an exciting and well-thought-out upgrade! I've thoroughly reviewed the `docs/architecture-study-sets.md` document and understand the target architecture. It's a solid plan to decouple the study session logic from specific decks and introduce the flexibility of tags, query-based sets, and a proper SRS.

Let's start with Phase 1 as you outlined.

### 1. SQL Migration Code (Supabase)

Here is the SQL script designed for Supabase migrations. It creates the new tables (`settings`, `tags`, `card_tags`, `study_sets`) and modifies the existing `cards` table according to the documentation. I've included comments explaining each section and mentioning RLS enablement.

```sql
-- Migration Script: Add Tags, Study Sets, SRS, and Settings

-- ========= Enable UUID generation if not already enabled =========
-- Often enabled by default in Supabase, but good to ensure.
-- create extension if not exists "uuid-ossp";

-- ========= Create 'settings' table =========
CREATE TABLE public.settings (
    user_id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    srs_algorithm text NOT NULL DEFAULT 'sm2'::text,
    fsrs_parameters jsonb NULL, -- For future FSRS tuning
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
    -- Add other user-specific settings fields here as needed (e.g., tts preferences)
);

-- RLS Policy for settings (Conceptual)
-- Users should only be able to view/manage their own settings row.
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their settings"
    ON public.settings
    FOR ALL
    USING (auth.uid() = user_id);

COMMENT ON TABLE public.settings IS 'Stores user-specific application settings, including preferred SRS algorithm.';
COMMENT ON COLUMN public.settings.srs_algorithm IS 'Identifier for the selected SRS algorithm (e.g., ''sm2'', ''fsrs'').';
COMMENT ON COLUMN public.settings.fsrs_parameters IS 'JSON object containing user-specific FSRS parameters (if using FSRS).';


-- ========= Create 'tags' table =========
CREATE TABLE public.tags (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT tags_user_id_name_key UNIQUE (user_id, name) -- Enforce unique tag names per user
);

-- RLS Policy for tags (Conceptual)
-- Users should only be able to manage/view their own tags.
ALTER TABLE public.tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their tags"
    ON public.tags
    FOR ALL
    USING (auth.uid() = user_id);

COMMENT ON TABLE public.tags IS 'Stores user-defined tags for organizing flashcards.';
COMMENT ON COLUMN public.tags.name IS 'The user-defined name of the tag.';


-- ========= Alter existing 'cards' table =========

-- Add user_id (denormalized for easier RLS and querying)
ALTER TABLE public.cards
    ADD COLUMN user_id uuid NULL; -- Initially allow NULL to backfill existing rows

-- Constraint to link cards.user_id to decks.user_id (optional but good for integrity)
-- Requires a function to look up deck owner or assumes user_id is reliably set.
-- UPDATE public.cards c SET user_id = (SELECT d.user_id FROM public.decks d WHERE d.id = c.deck_id) WHERE c.user_id IS NULL; -- Backfill user_id
-- ALTER TABLE public.cards ALTER COLUMN user_id SET NOT NULL; -- Make it non-nullable after backfill
-- ALTER TABLE public.cards ADD CONSTRAINT cards_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE; -- Add FK constraint

-- Add SRS fields
ALTER TABLE public.cards
    ADD COLUMN last_reviewed_at timestamptz NULL,
    ADD COLUMN next_review_due timestamptz NULL,
    ADD COLUMN srs_level integer NOT NULL DEFAULT 0,
    ADD COLUMN easiness_factor real NULL DEFAULT 2.5, -- 'real' maps to float4 in Postgres
    ADD COLUMN interval_days integer NULL DEFAULT 0,
    ADD COLUMN stability real NULL, -- FSRS 'S'
    ADD COLUMN difficulty real NULL, -- FSRS 'D'
    ADD COLUMN last_review_grade integer NULL; -- User rating (1-4)

-- (Optional but recommended) Remove potentially redundant/old progress fields if replaced by SRS
-- ALTER TABLE public.cards DROP COLUMN IF EXISTS correct_count; -- If replacing with SRS logic
-- ALTER TABLE public.cards DROP COLUMN IF EXISTS incorrect_count; -- If replacing with SRS logic
-- ALTER TABLE public.cards DROP COLUMN IF EXISTS attempt_count; -- If replacing with SRS logic
-- ALTER TABLE public.cards DROP COLUMN IF EXISTS difficulty_score; -- If replacing with SRS logic
-- ALTER TABLE public.cards DROP COLUMN IF EXISTS last_studied; -- Replaced by last_reviewed_at

-- Add INDEX for efficient querying of due cards per user
CREATE INDEX idx_cards_user_id_next_review_due ON public.cards (user_id, next_review_due);

-- Update RLS for cards (Conceptual - Ensure policy uses user_id)
-- Existing RLS policy likely uses deck_id join. Update it to use the direct user_id column.
ALTER TABLE public.cards ENABLE ROW LEVEL SECURITY; -- Ensure RLS is on
-- Example: DROP POLICY IF EXISTS "Allow individual user access" ON public.cards; -- Drop old one if necessary
-- CREATE POLICY "Allow individual user access to their cards"
--     ON public.cards
--     FOR ALL
--     USING (auth.uid() = user_id);

COMMENT ON COLUMN public.cards.user_id IS 'Denormalized user ID for easier RLS and querying.';
COMMENT ON COLUMN public.cards.last_reviewed_at IS 'Timestamp of the last time the card was reviewed.';
COMMENT ON COLUMN public.cards.next_review_due IS 'Timestamp when the card is next due for review based on SRS calculation.';
COMMENT ON COLUMN public.cards.srs_level IS 'The current SRS level or repetition count (e.g., SM-2 ''n'').';
COMMENT ON COLUMN public.cards.easiness_factor IS 'The easiness factor (e.g., SM-2 EF).';
COMMENT ON COLUMN public.cards.interval_days IS 'The last calculated interval in days (e.g., SM-2 I(n)).';
COMMENT ON COLUMN public.cards.stability IS 'FSRS Stability parameter (S).';
COMMENT ON COLUMN public.cards.difficulty IS 'FSRS Difficulty parameter (D).';
COMMENT ON COLUMN public.cards.last_review_grade IS 'The self-assessed grade (e.g., 1-4) given during the last review.';


-- ========= Create 'card_tags' join table =========
CREATE TABLE public.card_tags (
    card_id uuid NOT NULL REFERENCES public.cards(id) ON DELETE CASCADE,
    tag_id uuid NOT NULL REFERENCES public.tags(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, -- Denormalized for RLS
    PRIMARY KEY (card_id, tag_id)
);

-- RLS Policy for card_tags (Conceptual)
-- Users should only be able to manage/view links related to their own cards/tags.
ALTER TABLE public.card_tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their card_tags"
    ON public.card_tags
    FOR ALL
    USING (auth.uid() = user_id);

COMMENT ON TABLE public.card_tags IS 'Join table linking flashcards to tags.';


-- ========= Create 'study_sets' table =========
CREATE TABLE public.study_sets (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text NULL,
    query_criteria jsonb NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- RLS Policy for study_sets (Conceptual)
-- Users should only be able to manage/view their own study sets.
ALTER TABLE public.study_sets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their study_sets"
    ON public.study_sets
    FOR ALL
    USING (auth.uid() = user_id);

COMMENT ON TABLE public.study_sets IS 'Stores user-defined study sets based on query criteria.';
COMMENT ON COLUMN public.study_sets.name IS 'User-defined name for the study set.';
COMMENT ON COLUMN public.study_sets.query_criteria IS 'JSON object storing the rules for selecting cards (e.g., tags, deck IDs, SRS status).';

-- ========= Add trigger for updated_at timestamps (Optional but recommended) =========
-- Create the function if it doesn't exist
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Apply the trigger to tables that have an updated_at column
CREATE TRIGGER on_settings_update BEFORE UPDATE ON public.settings FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_decks_update BEFORE UPDATE ON public.decks FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at(); -- Assuming decks has updated_at
CREATE TRIGGER on_cards_update BEFORE UPDATE ON public.cards FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_study_sets_update BEFORE UPDATE ON public.study_sets FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

```

**Important Considerations for Migration:**

*   **Run in Supabase:** Execute this script using the Supabase CLI (`supabase db push` after placing it in `supabase/migrations/`) or directly in the Supabase SQL editor.
*   **Backfilling `cards.user_id`:** The script includes commented-out lines for backfilling the `user_id` on existing cards. You'll need to run the `UPDATE` statement *before* making the column `NOT NULL` and adding the final FK constraint. Test this carefully on a staging environment first.
*   **RLS Policies:** The provided RLS policies are basic examples. Review and refine them based on your exact security requirements. Ensure existing RLS policies (especially on `cards`) are updated to use the new `user_id` column if necessary.
*   **Removing Old Fields:** Decide if you want to drop the old progress columns (`correct_count`, `incorrect_count`, `attempt_count`, `difficulty_score`, `last_studied`) from the `cards` table now or later. The script comments them out. If you keep them, ensure your application logic uses the new SRS fields consistently.

### 2. TypeScript Type Definitions

Let's define the corresponding TypeScript types. You can place these in a central file like `types/database.ts` or structure them as needed.

```typescript
// types/database.ts (or similar shared location)

/**
 * Represents the structure of the 'settings' table.
 */
export interface Settings {
  user_id: string; // UUID -> string
  srs_algorithm: 'sm2' | 'fsrs'; // Assuming these are the only valid values initially
  fsrs_parameters: Record<string, any> | null; // JSONB -> object or null
  created_at: string; // timestamptz -> string (ISO 8601)
  updated_at: string; // timestamptz -> string
  // Add other settings fields matching the DB schema
}

/**
 * Represents the structure of the 'tags' table.
 */
export interface Tag {
  id: string; // UUID -> string
  user_id: string; // UUID -> string
  name: string;
  created_at: string; // timestamptz -> string
}

/**
 * Represents the structure of the 'card_tags' join table.
 */
export interface CardTag {
  card_id: string; // UUID -> string
  tag_id: string; // UUID -> string
  user_id: string; // UUID -> string
}

/**
 * Represents the structure of the 'study_sets' table.
 */
export interface StudySet {
  id: string; // UUID -> string
  user_id: string; // UUID -> string
  name: string;
  description: string | null;
  query_criteria: StudySetQueryCriteria; // JSONB -> specific object type
  created_at: string; // timestamptz -> string
  updated_at: string; // timestamptz -> string
}

/**
 * Defines the expected structure for the 'query_criteria' JSONB field
 * in the 'study_sets' table. Adapt this based on your actual query needs.
 */
export interface StudySetQueryCriteria {
  includeTags?: string[]; // Array of tag IDs to include
  excludeTags?: string[]; // Array of tag IDs to exclude
  includeDecks?: string[]; // Array of deck IDs to include
  excludeDecks?: string[]; // Array of deck IDs to exclude
  isDue?: boolean; // Include cards where next_review_due <= now()
  isNew?: boolean; // Include cards never reviewed (srs_level = 0 or last_reviewed_at IS NULL)
  difficultyRange?: [number, number]; // Min/Max FSRS difficulty (e.g., [0.7, 1.0])
  srsLevelRange?: [number, number]; // Min/Max SRS level
  limit?: number; // Max number of cards to return
  // Add other potential filter fields: e.g., content search term?
}

/**
 * Represents the structure of the 'cards' table, including SRS fields.
 * Updates the existing FlashCard type or creates a new one.
 */
export interface FlashCard {
  id: string; // UUID -> string
  deck_id: string; // UUID -> string
  user_id: string; // UUID -> string (Newly added)
  front_content: string; // Assuming existing field name
  back_content: string; // Assuming existing field name
  created_at: string; // timestamptz -> string
  updated_at: string; // timestamptz -> string

  // SRS Fields (Newly added)
  last_reviewed_at: string | null; // timestamptz -> string | null
  next_review_due: string | null; // timestamptz -> string | null
  srs_level: number; // integer -> number
  easiness_factor: number | null; // real -> number | null
  interval_days: number | null; // integer -> number | null
  stability: number | null; // real -> number | null (for FSRS)
  difficulty: number | null; // real -> number | null (for FSRS)
  last_review_grade: 1 | 2 | 3 | 4 | null; // integer -> specific number union | null

  // Optional General Stats (May be redundant if fully relying on SRS)
  // Consider if these are still needed or calculated differently
  correct_count?: number; // integer -> number
  incorrect_count?: number; // integer -> number

  // You might have other existing fields like question/answer, handle appropriately
  // Example (if different from front/back_content):
  // question: string;
  // answer: string;
}

// You might also want a type for the Deck, potentially linking to FlashCard[]
export interface Deck {
    id: string;
    user_id: string;
    title: string; // Assuming 'title' instead of 'name' based on docs
    description: string | null;
    primary_language: string | null;
    secondary_language: string | null;
    created_at: string;
    updated_at: string;
    cards: FlashCard[]; // Embed cards or fetch separately
    // Add any other deck-specific fields like progress if still relevant
}

```

*   **Adapt Field Names:** Ensure the `FlashCard` interface matches your *actual* existing field names (e.g., `question`/`answer` vs `front_content`/`back_content`). I used the names from the documentation's data model section.
*   **Query Criteria:** The `StudySetQueryCriteria` interface is a starting point. Refine it based on the exact filtering capabilities you want to offer.
*   **Dates:** Dates (`timestamptz`) are represented as strings (ISO 8601 format) when fetched as JSON. You'll parse them into `Date` objects when needed in the application logic (e.g., using `new Date(timestampString)`).

### 3. Server Action File Boilerplate

Create the following files within your project structure (e.g., under `lib/actions/` or wherever your Server Actions reside) with this basic content:

**`lib/actions/settingsActions.ts`**
```typescript
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server"; // Adjust path if needed
import type { Settings } from "@/types/database"; // Adjust path if needed
import { revalidatePath } from "next/cache"; // Useful for cache invalidation

// --- Get User Settings ---
export async function getUserSettings(): Promise<{ data: Settings | null, error: Error | null }> {
    const supabase = createSupabaseServerClient();
    const { data: { user } } = await supabase.auth.getUser();

    if (!user) {
        return { data: null, error: new Error("User not authenticated.") };
    }

    try {
        const { data, error } = await supabase
            .from("settings")
            .select("*")
            .eq("user_id", user.id)
            .maybeSingle(); // Use maybeSingle to handle case where settings don't exist yet

        if (error) throw error;

        // TODO: Consider creating default settings if data is null

        return { data, error: null };
    } catch (error) {
        console.error("Error fetching user settings:", error);
        return { data: null, error: error instanceof Error ? error : new Error("Failed to fetch settings.") };
    }
}

// --- Update User Settings ---
// Using Partial<Settings> allows updating only specific fields
export async function updateUserSettings(updates: Partial<Omit<Settings, 'user_id' | 'created_at' | 'updated_at'>>): Promise<{ data: Settings | null, error: Error | null }> {
     const supabase = createSupabaseServerClient();
     const { data: { user } } = await supabase.auth.getUser();

     if (!user) {
         return { data: null, error: new Error("User not authenticated.") };
     }

     try {
        // Upsert ensures settings row is created if it doesn't exist
         const { data, error } = await supabase
             .from("settings")
             .upsert({ ...updates, user_id: user.id }) // Spread updates and ensure user_id is set
             .select()
             .single(); // Expect one row back after upsert

         if (error) throw error;

         revalidatePath('/settings'); // Example path invalidation

         return { data, error: null };
     } catch (error) {
         console.error("Error updating user settings:", error);
         return { data: null, error: error instanceof Error ? error : new Error("Failed to update settings.") };
     }
}
```

**`lib/actions/tagActions.ts`**
```typescript
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { Tag } from "@/types/database";
import { revalidatePath } from "next/cache";

// --- Get User Tags ---
export async function getUserTags(): Promise<{ data: Tag[] | null, error: Error | null }> {
    // ... Implementation pending ...
     return { data: [], error: null }; // Placeholder
}

// --- Create Tag ---
export async function createTag(name: string): Promise<{ data: Tag | null, error: Error | null }> {
    // ... Implementation pending ...
     return { data: null, error: new Error("Not implemented") }; // Placeholder
}

// --- Delete Tag ---
export async function deleteTag(tagId: string): Promise<{ error: Error | null }> {
    // ... Implementation pending ...
    return { error: new Error("Not implemented") }; // Placeholder
}

// --- Add Tag to Card ---
export async function addTagToCard(cardId: string, tagId: string): Promise<{ error: Error | null }> {
    // ... Implementation pending ...
    return { error: new Error("Not implemented") }; // Placeholder
}

// --- Remove Tag from Card ---
export async function removeTagFromCard(cardId: string, tagId: string): Promise<{ error: Error | null }> {
     // ... Implementation pending ...
     return { error: new Error("Not implemented") }; // Placeholder
}
```

**`lib/actions/studySetActions.ts`**
```typescript
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { StudySet, StudySetQueryCriteria } from "@/types/database";
import { revalidatePath } from "next/cache";

// --- Get User Study Sets ---
export async function getStudySets(): Promise<{ data: StudySet[] | null, error: Error | null }> {
    // ... Implementation pending ...
    return { data: [], error: null }; // Placeholder
}

// --- Create Study Set ---
export async function createStudySet(name: string, description: string | null, queryCriteria: StudySetQueryCriteria): Promise<{ data: StudySet | null, error: Error | null }> {
    // ... Implementation pending ...
    return { data: null, error: new Error("Not implemented") }; // Placeholder
}

// --- Update Study Set ---
export async function updateStudySet(setId: string, updates: Partial<Pick<StudySet, 'name' | 'description' | 'query_criteria'>>): Promise<{ data: StudySet | null, error: Error | null }> {
    // ... Implementation pending ...
    return { data: null, error: new Error("Not implemented") }; // Placeholder
}

// --- Delete Study Set ---
export async function deleteStudySet(setId: string): Promise<{ error: Error | null }> {
    // ... Implementation pending ...
    return { error: new Error("Not implemented") }; // Placeholder
}
```

**`lib/actions/progressActions.ts`**
```typescript
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { FlashCard } from "@/types/database"; // Assuming FlashCard includes SRS fields

// Define the payload structure expected by updateCardProgress
// This should match the output of the calculateSm2State (or general SRS calculation)
export interface SrsUpdatePayload {
  srsLevel: number;
  easinessFactor: number;
  intervalDays: number;
  nextReviewDue: Date; // Use Date object here, convert to string before DB
  lastReviewGrade: 1 | 2 | 3 | 4;
  // Include any other fields to update (e.g., stability, difficulty for FSRS)
}


// --- Update Card Progress (SRS State) ---
export async function updateCardProgress(cardId: string, payload: SrsUpdatePayload): Promise<{ data: FlashCard | null, error: Error | null }> {
     const supabase = createSupabaseServerClient();
     const { data: { user } } = await supabase.auth.getUser();

     if (!user) {
         return { data: null, error: new Error("User not authenticated.") };
     }

     const now = new Date();

     try {
        const { data: updatedCard, error } = await supabase
            .from('cards')
            .update({
                srs_level: payload.srsLevel,
                easiness_factor: payload.easinessFactor,
                interval_days: payload.intervalDays,
                next_review_due: payload.nextReviewDue.toISOString(),
                last_review_grade: payload.lastReviewGrade,
                last_reviewed_at: now.toISOString(), // Update last review timestamp
                // Add stability/difficulty updates if implementing FSRS later
            })
            .eq('id', cardId)
            .eq('user_id', user.id) // Ensure user owns the card
            .select() // Select the updated card data
            .single();

        if (error) throw error;

        // Note: Revalidation might not be strictly necessary here if study session
        // state is managed locally, but consider if other parts of the UI need updates.
        // revalidatePath(`/study/...`); // Example

        return { data: updatedCard, error: null };
     } catch (error) {
        console.error(`Error updating card progress for card ${cardId}:`, error);
        return { data: null, error: error instanceof Error ? error : new Error("Failed to update card progress.") };
     }
}
```

**`lib/actions/cardActions.ts`**
```typescript
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { FlashCard } from "@/types/database";

// --- Get Cards by IDs ---
export async function getCardsByIds(cardIds: string[]): Promise<{ data: FlashCard[] | null, error: Error | null }> {
    const supabase = createSupabaseServerClient();
     const { data: { user } } = await supabase.auth.getUser();

     if (!user) {
         return { data: null, error: new Error("User not authenticated.") };
     }
    if (!cardIds || cardIds.length === 0) {
        return { data: [], error: null }; // Return empty array if no IDs provided
    }

    try {
        const { data, error } = await supabase
            .from('cards')
            .select('*') // Select all fields for the FlashCard type
            .in('id', cardIds)
            .eq('user_id', user.id); // Ensure user owns the cards

        if (error) throw error;

        return { data, error: null };
    } catch (error) {
        console.error(`Error fetching cards by IDs:`, error);
        return { data: null, error: error instanceof Error ? error : new Error("Failed to fetch cards.") };
    }
}

// --- Add other card CRUD actions if needed (Create, Update, Delete) ---
// Example:
// export async function createCard(...) ...
// export async function updateCard(...) ...
// export async function deleteCard(...) ...
```

**`lib/actions/studyQueryActions.ts`**
```typescript
"use server";

import { createSupabaseServerClient } from "@/lib/supabase/server";
import type { StudySetQueryCriteria } from "@/types/database";

// --- Resolve Study Query to Card IDs ---
export async function resolveStudyQuery(criteria: StudySetQueryCriteria | { studySetId: string }): Promise<{ data: string[] | null, error: Error | null }> {
    const supabase = createSupabaseServerClient();
     const { data: { user } } = await supabase.auth.getUser();

     if (!user) {
         return { data: null, error: new Error("User not authenticated.") };
     }

    try {
        let finalCriteria: StudySetQueryCriteria;

        // If studySetId is provided, fetch the criteria from the database
        if ('studySetId' in criteria) {
             const { data: studySet, error: fetchError } = await supabase
                .from('study_sets')
                .select('query_criteria')
                .eq('id', criteria.studySetId)
                .eq('user_id', user.id)
                .single();

             if (fetchError || !studySet) {
                 throw fetchError || new Error(`Study set not found: ${criteria.studySetId}`);
             }
             // TODO: Validate the fetched criteria structure
             finalCriteria = studySet.query_criteria as StudySetQueryCriteria;
        } else {
            finalCriteria = criteria;
        }

        // --- Build the Query ---
        // This is the complex part. Use Supabase query builder or call a DB function.
        // Example using query builder (simplified):

        let query = supabase
            .from('cards')
            .select('id', { count: 'exact', head: false }) // Select only IDs, get count if needed
            .eq('user_id', user.id);

        // Apply criteria filters
        if (finalCriteria.isDue) {
            query = query.lte('next_review_due', new Date().toISOString());
        }
        if (finalCriteria.isNew) {
            query = query.or('srs_level.eq.0,last_reviewed_at.is.null');
        }
        // Add filters for include/exclude tags (requires joins or subqueries)
        if (finalCriteria.includeTags && finalCriteria.includeTags.length > 0) {
             // Example using exists subquery (check performance)
            query = query.exists('card_tags', { card_id: 'cards.id', tag_id: `in.(${finalCriteria.includeTags.join(',')})` });
            // Alternative: Use RPC function for more complex tag logic
        }
        // Add filters for include/exclude decks
        if (finalCriteria.includeDecks && finalCriteria.includeDecks.length > 0) {
            query = query.in('deck_id', finalCriteria.includeDecks);
        }
        if (finalCriteria.excludeDecks && finalCriteria.excludeDecks.length > 0) {
            query = query.not('deck_id', 'in', `(${finalCriteria.excludeDecks.join(',')})`);
        }
        // Add filters for difficulty/srsLevel ranges...

        // Add limit
        if (finalCriteria.limit && finalCriteria.limit > 0) {
            query = query.limit(finalCriteria.limit);
        }

        // Add ordering (e.g., by due date, random?)
        query = query.order('next_review_due', { ascending: true, nullsFirst: true });


        // --- Execute Query ---
        const { data: cardIdsData, error: queryError } = await query;

        if (queryError) throw queryError;

        const cardIds = cardIdsData?.map(item => item.id) ?? [];

        return { data: cardIds, error: null };

    } catch (error) {
        console.error(`Error resolving study query:`, error);
        return { data: null, error: error instanceof Error ? error : new Error("Failed to resolve study query.") };
    }
}
```

*   **Error Handling:** The boilerplate includes basic try-catch blocks and returns a `{ data, error }` object, which is a good practice for Server Actions.
*   **Authentication:** Each action checks for an authenticated user using `supabase.auth.getUser()`.
*   **Placeholders:** Most actions have placeholder implementations (`// ... Implementation pending ...`). We will fill these in subsequent steps.
*   **`resolveStudyQuery` Complexity:** This action is the most complex. The provided example uses the Supabase query builder, but for sophisticated tag logic (especially handling `includeTags` AND `excludeTags` simultaneously) or better performance, creating a PostgreSQL function (`pl/pgsql`) and calling it via `supabase.rpc()` is highly recommended, as noted in your documentation.
*   **Revalidation:** `revalidatePath` is included where appropriate to invalidate Next.js cache after mutations. Adjust paths as needed.

This completes Phase 1. We have the database schema changes defined in SQL, the corresponding TypeScript types, and the basic structure for our new Server Actions.

What would you like to tackle next? Implementing the `calculateSm2State` function in `lib/srs.ts`, or starting to fill in one of the Server Actions (like `tagActions` or `progressActions`)?

---

_**User**_

thank you, while your input seems reasonable, you are an agent, so please execute these tass yourself or make edits yoursefl

---

_**Assistant**_

You are absolutely right! My role is to assist you actively, including making code changes directly when possible. My apologies for providing instructions instead of executing.

Let's get Phase 1 implemented in your codebase.

**1. SQL Migration**

As an AI assistant within the IDE, I cannot directly execute SQL commands against your database or manage your migration files. You will need to run the following SQL script using your Supabase CLI (`supabase db push` after adding it to `supabase/migrations/`) or the Supabase SQL Editor.

Here is the script again for easy copying:

```sql
-- Migration Script: Add Tags, Study Sets, SRS, and Settings

-- ========= Enable UUID generation if not already enabled =========
-- create extension if not exists "uuid-ossp";

-- ========= Create 'settings' table =========
CREATE TABLE public.settings (
    user_id uuid NOT NULL PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
    srs_algorithm text NOT NULL DEFAULT 'sm2'::text,
    fsrs_parameters jsonb NULL, -- For future FSRS tuning
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
    -- Add other user-specific settings fields here as needed (e.g., tts preferences)
);

-- RLS Policy for settings
ALTER TABLE public.settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their settings"
    ON public.settings FOR ALL USING (auth.uid() = user_id);

COMMENT ON TABLE public.settings IS 'Stores user-specific application settings, including preferred SRS algorithm.';
COMMENT ON COLUMN public.settings.srs_algorithm IS 'Identifier for the selected SRS algorithm (e.g., ''sm2'', ''fsrs'').';
COMMENT ON COLUMN public.settings.fsrs_parameters IS 'JSON object containing user-specific FSRS parameters (if using FSRS).';

-- ========= Create 'tags' table =========
CREATE TABLE public.tags (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    CONSTRAINT tags_user_id_name_key UNIQUE (user_id, name) -- Enforce unique tag names per user
);

-- RLS Policy for tags
ALTER TABLE public.tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their tags"
    ON public.tags FOR ALL USING (auth.uid() = user_id);

COMMENT ON TABLE public.tags IS 'Stores user-defined tags for organizing flashcards.';
COMMENT ON COLUMN public.tags.name IS 'The user-defined name of the tag.';

-- ========= Alter existing 'cards' table =========
ALTER TABLE public.cards ADD COLUMN user_id uuid NULL; -- Add user_id, allow NULL initially

-- Backfill user_id (RUN THIS MANUALLY after checking)
-- UPDATE public.cards c SET user_id = (SELECT d.user_id FROM public.decks d WHERE d.id = c.deck_id) WHERE c.user_id IS NULL;

-- After backfilling, make user_id NOT NULL and add FK constraint (RUN MANUALLY)
-- ALTER TABLE public.cards ALTER COLUMN user_id SET NOT NULL;
-- ALTER TABLE public.cards ADD CONSTRAINT cards_user_id_fkey FOREIGN KEY (user_id) REFERENCES auth.users(id) ON DELETE CASCADE;

-- Add SRS fields
ALTER TABLE public.cards
    ADD COLUMN last_reviewed_at timestamptz NULL,
    ADD COLUMN next_review_due timestamptz NULL,
    ADD COLUMN srs_level integer NOT NULL DEFAULT 0,
    ADD COLUMN easiness_factor real NULL DEFAULT 2.5, -- 'real' maps to float4 in Postgres
    ADD COLUMN interval_days integer NULL DEFAULT 0,
    ADD COLUMN stability real NULL, -- FSRS 'S'
    ADD COLUMN difficulty real NULL, -- FSRS 'D'
    ADD COLUMN last_review_grade integer NULL; -- User rating (1-4)

-- Add INDEX for efficient querying of due cards per user
CREATE INDEX idx_cards_user_id_next_review_due ON public.cards (user_id, next_review_due);

-- Update RLS for cards (Ensure policy uses user_id)
ALTER TABLE public.cards ENABLE ROW LEVEL SECURITY; -- Ensure RLS is on
-- Example: DROP POLICY IF EXISTS "Allow individual user access" ON public.cards; -- Drop old one if necessary
CREATE POLICY "Allow individual user access to their cards"
    ON public.cards FOR ALL USING (auth.uid() = user_id); -- Use the direct user_id column

COMMENT ON COLUMN public.cards.user_id IS 'Denormalized user ID for easier RLS and querying.';
COMMENT ON COLUMN public.cards.last_reviewed_at IS 'Timestamp of the last time the card was reviewed.';
COMMENT ON COLUMN public.cards.next_review_due IS 'Timestamp when the card is next due for review based on SRS calculation.';
COMMENT ON COLUMN public.cards.srs_level IS 'The current SRS level or repetition count (e.g., SM-2 ''n'').';
COMMENT ON COLUMN public.cards.easiness_factor IS 'The easiness factor (e.g., SM-2 EF).';
COMMENT ON COLUMN public.cards.interval_days IS 'The last calculated interval in days (e.g., SM-2 I(n)).';
COMMENT ON COLUMN public.cards.stability IS 'FSRS Stability parameter (S).';
COMMENT ON COLUMN public.cards.difficulty IS 'FSRS Difficulty parameter (D).';
COMMENT ON COLUMN public.cards.last_review_grade IS 'The self-assessed grade (e.g., 1-4) given during the last review.';

-- ========= Create 'card_tags' join table =========
CREATE TABLE public.card_tags (
    card_id uuid NOT NULL REFERENCES public.cards(id) ON DELETE CASCADE,
    tag_id uuid NOT NULL REFERENCES public.tags(id) ON DELETE CASCADE,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE, -- Denormalized for RLS
    PRIMARY KEY (card_id, tag_id)
);

-- RLS Policy for card_tags
ALTER TABLE public.card_tags ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their card_tags"
    ON public.card_tags FOR ALL USING (auth.uid() = user_id);

COMMENT ON TABLE public.card_tags IS 'Join table linking flashcards to tags.';

-- ========= Create 'study_sets' table =========
CREATE TABLE public.study_sets (
    id uuid NOT NULL DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
    name text NOT NULL,
    description text NULL,
    query_criteria jsonb NOT NULL,
    created_at timestamptz NOT NULL DEFAULT now(),
    updated_at timestamptz NOT NULL DEFAULT now()
);

-- RLS Policy for study_sets
ALTER TABLE public.study_sets ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow individual user access to their study_sets"
    ON public.study_sets FOR ALL USING (auth.uid() = user_id);

COMMENT ON TABLE public.study_sets IS 'Stores user-defined study sets based on query criteria.';
COMMENT ON COLUMN public.study_sets.name IS 'User-defined name for the study set.';
COMMENT ON COLUMN public.study_sets.query_criteria IS 'JSON object storing the rules for selecting cards (e.g., tags, deck IDs, SRS status).';

-- ========= Add trigger for updated_at timestamps (Optional but recommended) =========
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_settings_update BEFORE UPDATE ON public.settings FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_decks_update BEFORE UPDATE ON public.decks FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_cards_update BEFORE UPDATE ON public.cards FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
CREATE TRIGGER on_study_sets_update BEFORE UPDATE ON public.study_sets FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

```
**Remember to handle the backfilling of `cards.user_id` carefully.**

**2. TypeScript Type Definitions**

I will now create/update the `types/database.ts` file with the necessary type definitions. Please ensure the path `types/database.ts` is correct for your project structure.

---

```diff
- 
+ /**
+  * Represents the structure of the 'settings' table.
+  */
+ export interface Settings {
+   user_id: string; // UUID -> string
+   srs_algorithm: 'sm2' | 'fsrs'; // Assuming these are the only valid values initially
+   fsrs_parameters: Record<string, any> | null; // JSONB -> object or null
+   created_at: string; // timestamptz -> string (ISO 8601)
+   updated_at: string; // timestamptz -> string
+   // Add other settings fields matching the DB schema
+ }
+ 
+ /**
+  * Represents the structure of the 'tags' table.
+  */
+ export interface Tag {
+   id: string; // UUID -> string
+   user_id: string; // UUID -> string
+   name: string;
+   created_at: string; // timestamptz -> string
+ }
+ 
+ /**
+  * Represents the structure of the 'card_tags' join table.
+  */
+ export interface CardTag {
+   card_id: string; // UUID -> string
+   tag_id: string; // UUID -> string
+   user_id: string; // UUID -> string
+ }
+ 
+ /**
+  * Represents the structure of the 'study_sets' table.
+  */
+ export interface StudySet {
+   id: string; // UUID -> string
+   user_id: string; // UUID -> string
+   name: string;
+   description: string | null;
+   query_criteria: StudySetQueryCriteria; // JSONB -> specific object type
+   created_at: string; // timestamptz -> string
+   updated_at: string; // timestamptz -> string
+ }
+ 
+ /**
+  * Defines the expected structure for the 'query_criteria' JSONB field
+  * in the 'study_sets' table. Adapt this based on your actual query needs.
+  */
+ export interface StudySetQueryCriteria {
+   includeTags?: string[]; // Array of tag IDs to include
+   excludeTags?: string[]; // Array of tag IDs to exclude
+   includeDecks?: string[]; // Array of deck IDs to include
+   excludeDecks?: string[]; // Array of deck IDs to exclude
+   isDue?: boolean; // Include cards where next_review_due <= now()
+   isNew?: boolean; // Include cards never reviewed (srs_level = 0 or last_reviewed_at IS NULL)
+   difficultyRange?: [number, number]; // Min/Max FSRS difficulty (e.g., [0.7, 1.0])
+   srsLevelRange?: [number, number]; // Min/Max SRS level
+   limit?: number; // Max number of cards to return
+   // Add other potential filter fields: e.g., content search term?
+ }
+ 
+ /**
+  * Represents the structure of the 'cards' table, including SRS fields.
+  * Updates the existing FlashCard type or creates a new one.
+  * Make sure field names match your actual table columns.
+  */
+ export interface FlashCard {
+   id: string; // UUID -> string
+   deck_id: string; // UUID -> string
+   user_id: string; // UUID -> string (Newly added)
+   front_content: string; // Example field name
+   back_content: string; // Example field name
+   created_at: string; // timestamptz -> string
+   updated_at: string; // timestamptz -> string
+ 
+   // SRS Fields (Newly added)
+   last_reviewed_at: string | null; // timestamptz -> string | null
+   next_review_due: string | null; // timestamptz -> string | null
+   srs_level: number; // integer -> number
+   easiness_factor: number | null; // real -> number | null
+   interval_days: number | null; // integer -> number | null
+   stability: number | null; // real -> number | null (for FSRS)
+   difficulty: number | null; // real -> number | null (for FSRS)
+   last_review_grade: 1 | 2 | 3 | 4 | null; // integer -> specific number union | null
+ 
+   // Optional General Stats (Consider if still needed)
+   correct_count?: number; // integer -> number
+   incorrect_count?: number; // integer -> number
+ }
+ 
+ /**
+  * Represents the structure of the 'decks' table.
+  * Ensure this matches your schema and includes FKs/relationships as needed.
+  */
+ export interface Deck {
+     id: string;
+     user_id: string;
+     title: string; // Assuming 'title' based on docs
+     description: string | null;
+     primary_language: string | null;
+     secondary_language: string | null;
+     created_at: string;
+     updated_at: string;
+     cards: FlashCard[]; // Embed cards or fetch separately
+     // Add any other deck-specific fields
+ } 
```

---

I have created/updated `types/database.ts` with the new and modified interfaces. Please verify that the field names in `FlashCard` and `Deck` match your existing schema precisely.

**3. Server Action File Boilerplate**

I will now create the Server Action files with the boilerplate code. I'll place them in `lib/actions/` based on common project structures. If this path is incorrect, please let me know the correct directory.

---

```diff
- 
+ "use server";
+ 
+ import { createSupabaseServerClient } from "@/lib/supabase/server";
+ import type { StudySetQueryCriteria } from "@/types/database";
+ 
+ // --- Resolve Study Query to Card IDs ---
+ export async function resolveStudyQuery(criteria: StudySetQueryCriteria | { studySetId: string }): Promise<{ data: string[] | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+      const { data: { user } } = await supabase.auth.getUser();
+ 
+      if (!user) {
+          return { data: null, error: new Error("User not authenticated.") };
+      }
+ 
+     try {
+         let finalCriteria: StudySetQueryCriteria;
+ 
+         // If studySetId is provided, fetch the criteria from the database
+         if ('studySetId' in criteria) {
+              const { data: studySet, error: fetchError } = await supabase
+                 .from('study_sets')
+                 .select('query_criteria')
+                 .eq('id', criteria.studySetId)
+                 .eq('user_id', user.id)
+                 .single();
+ 
+              if (fetchError || !studySet) {
+                  throw fetchError || new Error(`Study set not found: ${criteria.studySetId}`);
+              }
+              // TODO: Validate the fetched criteria structure
+              finalCriteria = studySet.query_criteria as StudySetQueryCriteria;
+         } else {
+             finalCriteria = criteria;
+         }
+ 
+         // --- Build the Query ---
+         // This is the complex part. Use Supabase query builder or call a DB function.
+         // Example using query builder (simplified):
+ 
+         let query = supabase
+             .from('cards')
+             .select('id', { count: 'exact', head: false }) // Select only IDs, get count if needed
+             .eq('user_id', user.id);
+ 
+         // Apply criteria filters
+         if (finalCriteria.isDue) {
+             query = query.lte('next_review_due', new Date().toISOString());
+         }
+         if (finalCriteria.isNew) {
+             query = query.or('srs_level.eq.0,last_reviewed_at.is.null');
+         }
+         // Add filters for include/exclude tags (requires joins or subqueries)
+         if (finalCriteria.includeTags && finalCriteria.includeTags.length > 0) {
+              // Example using exists subquery (check performance)
+              // Note: Syntax for exists might vary, check Supabase docs/examples
+              // query = query.exists('card_tags', { card_id: 'cards.id', tag_id: `in.(${finalCriteria.includeTags.join(',')})` });
+              // Placeholder: Complex tag filtering might need RPC
+              console.warn("Complex includeTags filtering not fully implemented in query builder, consider RPC.");
+         }
+          if (finalCriteria.excludeTags && finalCriteria.excludeTags.length > 0) {
+              console.warn("excludeTags filtering not implemented in query builder, consider RPC.");
+          }
+         // Add filters for include/exclude decks
+         if (finalCriteria.includeDecks && finalCriteria.includeDecks.length > 0) {
+             query = query.in('deck_id', finalCriteria.includeDecks);
+         }
+         if (finalCriteria.excludeDecks && finalCriteria.excludeDecks.length > 0) {
+             query = query.not('deck_id', 'in', `(${finalCriteria.excludeDecks.join(',')})`);
+         }
+         // Add filters for difficulty/srsLevel ranges...
+          if (finalCriteria.srsLevelRange) {
+              query = query.gte('srs_level', finalCriteria.srsLevelRange[0])
+                           .lte('srs_level', finalCriteria.srsLevelRange[1]);
+          }
+          // Add difficulty range filter if needed (for FSRS)
+ 
+         // Add limit
+         if (finalCriteria.limit && finalCriteria.limit > 0) {
+             query = query.limit(finalCriteria.limit);
+         }
+ 
+         // Add ordering (e.g., by due date, random?)
+         query = query.order('next_review_due', { ascending: true, nullsFirst: true });
+ 
+ 
+         // --- Execute Query ---
+         // Adjust select based on whether you used `head: false` earlier
+         const { data: cardIdsData, error: queryError } = await query;
+ 
+         if (queryError) throw queryError;
+ 
+         const cardIds = cardIdsData?.map(item => item.id) ?? [];
+ 
+         return { data: cardIds, error: null };
+ 
+     } catch (error) {
+         console.error(`Error resolving study query:`, error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to resolve study query.") };
+     }
+ } 
```

---

```diff
- 
+ "use server";
+ 
+ import { createSupabaseServerClient } from "@/lib/supabase/server";
+ import type { Settings } from "@/types/database";
+ import { revalidatePath } from "next/cache";
+ 
+ // --- Get User Settings ---
+ export async function getUserSettings(): Promise<{ data: Settings | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         const { data, error } = await supabase
+             .from("settings")
+             .select("*")
+             .eq("user_id", user.id)
+             .maybeSingle(); // Use maybeSingle to handle case where settings don't exist yet
+ 
+         if (error) throw error;
+ 
+         // Optionally create default settings if data is null and user exists
+         if (!data) {
+             console.log(`No settings found for user ${user.id}, creating defaults.`);
+             const { data: defaultSettings, error: createError } = await supabase
+                 .from('settings')
+                 .insert({ user_id: user.id, srs_algorithm: 'sm2' }) // Default to sm2
+                 .select()
+                 .single();
+             if (createError) throw createError;
+             return { data: defaultSettings, error: null };
+         }
+ 
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error fetching user settings:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to fetch settings.") };
+     }
+ }
+ 
+ // --- Update User Settings ---
+ // Using Partial<Settings> allows updating only specific fields
+ export async function updateUserSettings(updates: Partial<Omit<Settings, 'user_id' | 'created_at' | 'updated_at'>>): Promise<{ data: Settings | null, error: Error | null }> {
+      const supabase = createSupabaseServerClient();
+      const { data: { user } } = await supabase.auth.getUser();
+ 
+      if (!user) {
+          return { data: null, error: new Error("User not authenticated.") };
+      }
+ 
+      try {
+         // Upsert ensures settings row is created if it doesn't exist
+          const { data, error } = await supabase
+              .from("settings")
+              .upsert({ ...updates, user_id: user.id }) // Spread updates and ensure user_id is set
+              .select()
+              .single(); // Expect one row back after upsert
+ 
+          if (error) throw error;
+ 
+          revalidatePath('/settings'); // Invalidate settings page cache
+ 
+          return { data, error: null };
+      } catch (error) {
+          console.error("Error updating user settings:", error);
+          return { data: null, error: error instanceof Error ? error : new Error("Failed to update settings.") };
+      }
+ } 
```

---

```diff
- 
+ "use server";
+ 
+ import { createSupabaseServerClient } from "@/lib/supabase/server";
+ import type { Tag } from "@/types/database";
+ import { revalidatePath } from "next/cache";
+ 
+ // --- Get User Tags ---
+ export async function getUserTags(): Promise<{ data: Tag[] | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         const { data, error } = await supabase
+             .from('tags')
+             .select('*')
+             .eq('user_id', user.id)
+             .order('name', { ascending: true });
+ 
+         if (error) throw error;
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error fetching tags:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to fetch tags.") };
+     }
+ }
+ 
+ // --- Create Tag ---
+ export async function createTag(name: string): Promise<{ data: Tag | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+     if (!name || name.trim() === '') {
+         return { data: null, error: new Error("Tag name cannot be empty.") };
+     }
+ 
+     try {
+         const { data, error } = await supabase
+             .from('tags')
+             .insert({ name: name.trim(), user_id: user.id })
+             .select()
+             .single();
+ 
+         if (error) {
+              // Handle unique constraint violation (PostgreSQL code 23505)
+              if (error.code === '23505') {
+                  return { data: null, error: new Error(`Tag "${name.trim()}" already exists.`) };
+              }
+             throw error;
+         }
+ 
+         // Revalidate paths where tags might be displayed or used
+         revalidatePath('/tags'); // Example
+         revalidatePath('/edit'); // Example: deck/card editing pages
+ 
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error creating tag:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to create tag.") };
+     }
+ }
+ 
+ // --- Delete Tag --- // TODO: Consider what happens to cards tagged with this tag.
+ export async function deleteTag(tagId: string): Promise<{ error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         // First, remove associations in card_tags (optional, depends on desired behavior)
+         // If you want tags removed from cards when the tag is deleted:
+         const { error: deleteLinksError } = await supabase
+             .from('card_tags')
+             .delete()
+             .eq('tag_id', tagId)
+             .eq('user_id', user.id);
+ 
+          if (deleteLinksError) {
+              console.error("Error removing tag links from cards:", deleteLinksError);
+              // Decide whether to proceed with tag deletion or return error
+              // return { error: new Error("Failed to remove tag from cards before deleting.") };
+          }
+ 
+         // Then, delete the tag itself
+         const { error } = await supabase
+             .from('tags')
+             .delete()
+             .eq('id', tagId)
+             .eq('user_id', user.id); // Ensure ownership
+ 
+         if (error) throw error;
+ 
+         revalidatePath('/tags');
+         revalidatePath('/edit');
+ 
+         return { error: null };
+     } catch (error) {
+         console.error("Error deleting tag:", error);
+         return { error: error instanceof Error ? error : new Error("Failed to delete tag.") };
+     }
+ }
+ 
+ // --- Add Tag to Card ---
+ export async function addTagToCard(cardId: string, tagId: string): Promise<{ error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         // Optional: Verify both card and tag belong to the user before linking
+         // (RLS on insert should handle this if user_id is correct)
+ 
+         const { error } = await supabase
+             .from('card_tags')
+             .insert({ card_id: cardId, tag_id: tagId, user_id: user.id })
+             // No .select() needed unless you need the created record
+ 
+          if (error) {
+              // Handle potential FK violations or unique constraint violations (if user tries to add same tag twice)
+              if (error.code === '23505') { // Primary key violation (already linked)
+                 console.warn(`Tag ${tagId} already linked to card ${cardId}.`);
+                 return { error: null }; // Not necessarily an error
+              }
+              if (error.code === '23503') { // Foreign key violation
+                 return { error: new Error("Card or Tag not found.") };
+              }
+              throw error;
+          }
+ 
+         // Revalidate paths where card details/tags are shown
+         // e.g., revalidatePath(`/edit/[deckId]/[cardId]`);
+ 
+         return { error: null };
+     } catch (error) {
+         console.error("Error adding tag to card:", error);
+         return { error: error instanceof Error ? error : new Error("Failed to add tag to card.") };
+     }
+ }
+ 
+ // --- Remove Tag from Card ---
+ export async function removeTagFromCard(cardId: string, tagId: string): Promise<{ error: Error | null }> {
+      const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         const { error } = await supabase
+             .from('card_tags')
+             .delete()
+             .eq('card_id', cardId)
+             .eq('tag_id', tagId)
+             .eq('user_id', user.id); // Ensure user owns the link
+ 
+         if (error) throw error;
+ 
+          // Revalidate relevant paths
+         // e.g., revalidatePath(`/edit/[deckId]/[cardId]`);
+ 
+         return { error: null };
+     } catch (error) {
+         console.error("Error removing tag from card:", error);
+         return { error: error instanceof Error ? error : new Error("Failed to remove tag from card.") };
+     }
+ } 
```

---

```diff
- 
+ "use server";
+ 
+ import { createSupabaseServerClient } from "@/lib/supabase/server";
+ import type { StudySet, StudySetQueryCriteria } from "@/types/database";
+ import { revalidatePath } from "next/cache";
+ 
+ // --- Get User Study Sets ---
+ export async function getStudySets(): Promise<{ data: StudySet[] | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         const { data, error } = await supabase
+             .from('study_sets')
+             .select('*')
+             .eq('user_id', user.id)
+             .order('name', { ascending: true });
+ 
+         if (error) throw error;
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error fetching study sets:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to fetch study sets.") };
+     }
+ }
+ 
+ // --- Create Study Set ---
+ export async function createStudySet(name: string, description: string | null, queryCriteria: StudySetQueryCriteria): Promise<{ data: StudySet | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+      if (!name || name.trim() === '') {
+          return { data: null, error: new Error("Study set name cannot be empty.") };
+      }
+      // TODO: Add validation for queryCriteria using Zod?
+ 
+     try {
+         const { data, error } = await supabase
+             .from('study_sets')
+             .insert({
+                 name: name.trim(),
+                 description,
+                 query_criteria: queryCriteria,
+                 user_id: user.id
+             })
+             .select()
+             .single();
+ 
+         if (error) throw error;
+ 
+         revalidatePath('/study-sets'); // Example path
+ 
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error creating study set:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to create study set.") };
+     }
+ }
+ 
+ // --- Update Study Set ---
+ export async function updateStudySet(setId: string, updates: Partial<Pick<StudySet, 'name' | 'description' | 'query_criteria'>>): Promise<{ data: StudySet | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+     // TODO: Add validation for updates?
+ 
+     try {
+         const { data, error } = await supabase
+             .from('study_sets')
+             .update(updates)
+             .eq('id', setId)
+             .eq('user_id', user.id)
+             .select()
+             .single();
+ 
+         if (error) throw error;
+ 
+         revalidatePath('/study-sets');
+         // Consider revalidating study pages if criteria changed?
+ 
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error updating study set:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to update study set.") };
+     }
+ }
+ 
+ // --- Delete Study Set ---
+ export async function deleteStudySet(setId: string): Promise<{ error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { error: new Error("User not authenticated.") };
+     }
+ 
+     try {
+         const { error } = await supabase
+             .from('study_sets')
+             .delete()
+             .eq('id', setId)
+             .eq('user_id', user.id);
+ 
+         if (error) throw error;
+ 
+         revalidatePath('/study-sets');
+ 
+         return { error: null };
+     } catch (error) {
+         console.error("Error deleting study set:", error);
+         return { error: error instanceof Error ? error : new Error("Failed to delete study set.") };
+     }
+ } 
```

---

```diff
- 
+ "use server";
+ 
+ import { createSupabaseServerClient } from "@/lib/supabase/server";
+ import type { FlashCard } from "@/types/database"; // Assuming FlashCard includes SRS fields
+ 
+ // Define the payload structure expected by updateCardProgress
+ // This should match the output of the calculateSm2State (or general SRS calculation)
+ export interface SrsUpdatePayload {
+   srsLevel: number;
+   easinessFactor: number | null; // Allow null for EF
+   intervalDays: number | null; // Allow null for interval
+   nextReviewDue: Date; // Use Date object here, convert to string before DB
+   lastReviewGrade: 1 | 2 | 3 | 4;
+   // Include any other fields to update (e.g., stability, difficulty for FSRS)
+ }
+ 
+ 
+ // --- Update Card Progress (SRS State) ---
+ export async function updateCardProgress(cardId: string, payload: SrsUpdatePayload): Promise<{ data: FlashCard | null, error: Error | null }> {
+      const supabase = createSupabaseServerClient();
+      const { data: { user } } = await supabase.auth.getUser();
+ 
+      if (!user) {
+          return { data: null, error: new Error("User not authenticated.") };
+      }
+ 
+      const now = new Date();
+ 
+      try {
+         const { data: updatedCard, error } = await supabase
+             .from('cards')
+             .update({
+                 srs_level: payload.srsLevel,
+                 easiness_factor: payload.easinessFactor,
+                 interval_days: payload.intervalDays,
+                 next_review_due: payload.nextReviewDue.toISOString(),
+                 last_review_grade: payload.lastReviewGrade,
+                 last_reviewed_at: now.toISOString(), // Update last review timestamp
+                 // Add stability/difficulty updates if implementing FSRS later
+             })
+             .eq('id', cardId)
+             .eq('user_id', user.id) // Ensure user owns the card
+             .select("*") // Select all fields to return the full FlashCard type
+             .single();
+ 
+         if (error) throw error;
+ 
+         // Note: Revalidation might not be strictly necessary here if study session
+         // state is managed locally, but consider if other parts of the UI need updates.
+         // revalidatePath(`/study/...`); // Example
+ 
+         return { data: updatedCard, error: null };
+      } catch (error) {
+         console.error(`Error updating card progress for card ${cardId}:`, error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to update card progress.") };
+      }
+ } 
```

---

```diff
- 
+ "use server";
+ 
+ import { createSupabaseServerClient } from "@/lib/supabase/server";
+ import type { FlashCard } from "@/types/database";
+ 
+ // --- Get Cards by IDs ---
+ export async function getCardsByIds(cardIds: string[]): Promise<{ data: FlashCard[] | null, error: Error | null }> {
+     const supabase = createSupabaseServerClient();
+      const { data: { user } } = await supabase.auth.getUser();
+ 
+      if (!user) {
+          return { data: null, error: new Error("User not authenticated.") };
+      }
+     if (!cardIds || cardIds.length === 0) {
+         return { data: [], error: null }; // Return empty array if no IDs provided
+     }
+ 
+     try {
+         const { data, error } = await supabase
+             .from('cards')
+             .select('*') // Select all fields for the FlashCard type
+             .in('id', cardIds)
+             .eq('user_id', user.id); // Ensure user owns the cards
+ 
+         if (error) throw error;
+ 
+         return { data, error: null };
+     } catch (error) {
+         console.error(`Error fetching cards by IDs:`, error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to fetch cards.") };
+     }
+ }
+ 
+ // --- Add other card CRUD actions if needed (Create, Update, Delete) ---
+ // Placeholder for potential future actions like creating/updating/deleting single cards
+ // outside the deckService context, although deckService might still be suitable.
+ 
+ // Example: Create a single card (maybe useful for quick add?)
+ /*
+ export async function createCard(deckId: string, cardData: Omit<FlashCard, 'id' | 'user_id' | 'deck_id' | 'created_at' | 'updated_at' | 'srs_level' | 'easiness_factor' | 'interval_days' | 'last_reviewed_at' | 'next_review_due' | 'last_review_grade'>):
+     Promise<{ data: FlashCard | null, error: Error | null }> {
+ 
+     const supabase = createSupabaseServerClient();
+     const { data: { user } } = await supabase.auth.getUser();
+ 
+     if (!user) {
+         return { data: null, error: new Error("User not authenticated.") };
+     }
+ 
+     // Optional: Check if user owns the deckId first
+ 
+     try {
+         const { data, error } = await supabase
+             .from('cards')
+             .insert({
+                 ...cardData,
+                 deck_id: deckId,
+                 user_id: user.id,
+                 // Default SRS values are set by DB
+             })
+             .select("*")
+             .single();
+ 
+         if (error) throw error;
+         return { data, error: null };
+     } catch (error) {
+         console.error("Error creating card:", error);
+         return { data: null, error: error instanceof Error ? error : new Error("Failed to create card.") };
+     }
+ }
+ */ 
```

---

Phase 1 is now complete!

-   The SQL migration script is ready for you to apply via Supabase.
-   The TypeScript types in `types/database.ts` are updated.
-   The initial Server Action files (`settingsActions.ts`, `tagActions.ts`, `studySetActions.ts`, `progressActions.ts`, `cardActions.ts`, `studyQueryActions.ts`) have been created in `lib/actions/` with basic implementations or placeholders.

We have the foundational backend structure in place based on the new architecture.

Next steps according to the plan would be:

1.  **Implement the `calculateSm2State` function** in `lib/srs.ts`.
2.  **Fully implement the Server Actions** (we can go one by one, e.g., finish `tagActions`, `progressActions`, etc.).
3.  **Refactor `useStudySession`** to use the new actions and SRS logic.
4.  **Update/Create UI components** (`StudySetBuilder`, `StudySetSelector`, `TagManager`, etc.).

I recommend we tackle **implementing the `calculateSm2State` function** next, as it's a core piece of the SRS logic and self-contained. Shall I proceed with creating/editing `lib/srs.ts` according to the specification in the documentation?

---

_**User**_

can you at leaste save the sql in the migrations folder?

---

_**Assistant**_

You're right, while I can't *run* the migration, I can certainly create the migration file for you in the correct directory.

I will create the file `supabase/migrations/0001_add_tags_srs_settings.sql` with the SQL content.

*Self-correction: Supabase typically uses timestamp-based migration filenames (e.g., `YYYYMMDDHHMMSS_description.sql`). While I can create `0001_...`, it's better practice to use a timestamp. Since I can't generate a precise timestamp easily, I'll use `YYYYMMDDHHMMSS_...` as a placeholder and remind you to rename it.*

Okay, creating the file `supabase/migrations/YYYYMMDDHHMMSS_add_tags_srs_settings.sql`. Please remember to **rename this file** with the current timestamp (e.g., `20240727103000_add_tags_srs_settings.sql`) for the Supabase CLI to process it correctly, or use `supabase migration new add_tags_srs_settings` and paste the content into the generated file.

---



---

