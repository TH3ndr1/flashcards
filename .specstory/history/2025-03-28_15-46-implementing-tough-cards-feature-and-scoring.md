<!-- Generated by SpecStory -->

# Implementing Tough Cards Feature and Scoring (2025-03-28 16:46:36)

_**User**_

I want to add a new feature.

Generate a "Tough Cards" feature .

On the main screen for a specific deck, include a clearly labeled button like “Tough Cards”. When tapped, this button initiates a focused study session using only the cards the backend identifies as most difficult (backend logic is handled separately). For each flashcard, the backend must persistently store:
* incorrect_count: Integer (number of times marked "Incorrect").
* attempt_count: Integer (total number of times reviewed). -> not yet in DB
* last_studied: DateTime (timestamp of the last review).
Difficulty Scoring Algorithm:
* Implement a function CalculateDifficultyScore(card_data) that takes a card's persisted data as input.
* The score should be calculated based on:
    * Incorrectness Ratio: card_data.incorrect_count / card_data.attempt_count (handle division by zero for cards with 0 attempts). Weighted heavily.
    * Attempt Factor: A normalized value based on card_data.attempt_count (e.g., attempts / (attempts + C), where C is a constant like 5) to give some weight to exposure, with diminishing returns. Weighted moderately.
    * Forgetfulness Factor: Based on the time elapsed since card_data.last_studied (e.g., linearly increasing score capped after a certain period like 5 days). Weighted moderately. Give a default score if never reviewed.
* Use configurable weights for each factor (Incorrect Ratio, Attempts, Forgetfulness).

Example:

FUNCTION CalculateDifficultyScore(card):
  // --- Constants (tune these based on testing) ---
  WEIGHT_INCORRECT_RATIO = 0.6  // Heaviest weight on failure rate
  WEIGHT_ATTEMPTS = 0.2         // Some weight for exposure/effort
  WEIGHT_FORGETFULNESS = 0.2    // Weight for time decay
  DAYS_FOR_MAX_FORGETFULNESS = 5 // Time window for forgetting

  score = 0.0

  // --- Factor 1: Incorrectness Ratio ---
  IF card.attempt_count > 0 THEN
    incorrect_ratio = card.incorrect_count / card.attempt_count
    score = score + WEIGHT_INCORRECT_RATIO * incorrect_ratio
  ENDIF
  // Cards never attempted have 0 score from this factor

  // --- Factor 2: Number of Attempts (Normalized) ---
  // More attempts suggest more exposure needed, even if eventually correct.
  // Normalization prevents score from growing indefinitely and gives diminishing returns.
  attempts_factor = card.attempt_count / (card.attempt_count + 5.0) // Adding ~5 smooths the curve for low attempt counts
  score = score + WEIGHT_ATTEMPTS * attempts_factor

  // --- Factor 3: Forgetfulness (Time Since Last Review) ---
  IF card.last_reviewed_timestamp IS NOT NULL THEN
    time_since_review = NOW() - card.last_studied
    days_since_review = CONVERT_TO_DAYS(time_since_review)
    // Score increases linearly up to DAYS_FOR_MAX_FORGETFULNESS, then caps out
    forgetfulness_factor = MIN(1.0, days_since_review / DAYS_FOR_MAX_FORGETFULNESS)
    score = score + WEIGHT_FORGETFULNESS * forgetfulness_factor
  ELSE
    // Card never reviewed - give it a moderate forgetfulness boost to prioritize it initially
    score = score + WEIGHT_FORGETFULNESS * 0.5
  ENDIF

  RETURN score
ENDFUNCTION

Is the assignment clear? Please keep the business logic serpate from the presentation.

---

_**Assistant**_

I understand you want to add a "Tough Cards" feature with a sophisticated difficulty scoring system. Let's break this down into clear steps and implement it following clean architecture principles.

First, let's analyze what we need:

1. Data Model Changes:
- Add `attempt_count` to the FlashCard type
- We already have `incorrect_count` and `last_studied`

2. Business Logic:
- Create a separate utility for the difficulty scoring algorithm
- Keep it independent of UI/presentation concerns

3. UI Changes:
- Add a "Tough Cards" button
- Modify the study session to handle tough cards mode

Let me start by searching for relevant files:

---

<details>
            <summary>Searched codebase "type FlashCard interface or type definition" • **25** results</summary>
        
| File | Lines |
|------|-------|
| `types/deck.ts` | L1-8 |
| `types/deck.ts` | L8-22 |
| `components/card-editor.tsx` | L1-16 |
| `components/table-editor.tsx` | L1-13 |
| `app/study/[deckId]/page.tsx` | L1-43 |
| `lib/deckService.ts` | L1-55 |
| `app/study/[deckId]/page.tsx` | L43-63 |
| `lib/localStorageUtils.ts` | L1-20 |
| `.specstory/history/2025-03-28_13-05-card-flip-animation-issue.md` | L248-295 |
| `lib/deckService.ts` | L119-172 |
| `app/study/[deckId]/page.tsx` | L562-582 |
| `lib/deckService.ts` | L55-119 |
| `lib/deckService.ts` | L226-250 |
| `app/study/[deckId]/page.tsx` | L253-312 |
| `docs/project-documentation.md` | L137-213 |
| `app/study/[deckId]/page.tsx` | L207-253 |
| `lib/deckService.ts` | L172-226 |
| `app/study/[deckId]/page.tsx` | L582-625 |
| `lib/localStorageUtils.ts` | L20-28 |
| `components/ui/carousel.tsx` | L15-22 |
| `hooks/use-decks.tsx` | L1-24 |
| `app/edit/[deckId]/page.tsx` | L74-151 |
| `app/study/[deckId]/page.tsx` | L178-207 |
| `.specstory/history/2025-03-25_17-06-integrating-google-cloud-tts-into-app.md` | L4597-4656 |
| `.specstory/history/2025-03-28_13-05-card-flip-animation-issue.md` | L54-119 |

</details>

---

Based on the search results, I'll implement this feature following clean architecture principles. Let's break it down into steps:

1. First, let's update the FlashCard type to include `attempt_count`:

---

```diff
    incorrectCount: number
    lastStudied: string | null
+   attemptCount: number
  }
  
```

---

2. Now, let's create a utility file for the difficulty scoring algorithm:

---

```diff
- 
+ import type { FlashCard } from "@/types/deck"
+ 
+ // Constants for difficulty calculation
+ const WEIGHT_INCORRECT_RATIO = 0.6 // Heaviest weight on failure rate
+ const WEIGHT_ATTEMPTS = 0.2 // Some weight for exposure/effort
+ const WEIGHT_FORGETFULNESS = 0.2 // Weight for time decay
+ const DAYS_FOR_MAX_FORGETFULNESS = 5 // Time window for forgetting
+ const ATTEMPT_NORMALIZATION_FACTOR = 5 // Constant C for attempt normalization
+ 
+ /**
+  * Calculates a difficulty score for a flashcard based on various factors.
+  * @param card The flashcard to calculate difficulty for
+  * @returns A score between 0 and 1, where higher values indicate greater difficulty
+  */
+ export function calculateDifficultyScore(card: FlashCard): number {
+   let score = 0.0
+ 
+   // Factor 1: Incorrectness Ratio (60% weight)
+   if (card.attemptCount > 0) {
+     const incorrectRatio = card.incorrectCount / card.attemptCount
+     score += WEIGHT_INCORRECT_RATIO * incorrectRatio
+   }
+ 
+   // Factor 2: Number of Attempts (20% weight)
+   // Normalize attempts to prevent indefinite growth and give diminishing returns
+   const attemptsFactor = card.attemptCount / (card.attemptCount + ATTEMPT_NORMALIZATION_FACTOR)
+   score += WEIGHT_ATTEMPTS * attemptsFactor
+ 
+   // Factor 3: Forgetfulness (20% weight)
+   if (card.lastStudied) {
+     const daysSinceReview = getDaysSinceDate(new Date(card.lastStudied))
+     // Score increases linearly up to DAYS_FOR_MAX_FORGETFULNESS, then caps
+     const forgetfulnessFactor = Math.min(1.0, daysSinceReview / DAYS_FOR_MAX_FORGETFULNESS)
+     score += WEIGHT_FORGETFULNESS * forgetfulnessFactor
+   } else {
+     // Card never reviewed - give it a moderate forgetfulness boost
+     score += WEIGHT_FORGETFULNESS * 0.5
+   }
+ 
+   return Math.min(1.0, score) // Ensure score doesn't exceed 1.0
+ }
+ 
+ /**
+  * Helper function to calculate days between now and a given date
+  */
+ function getDaysSinceDate(date: Date): number {
+   const now = new Date()
+   const diffTime = Math.abs(now.getTime() - date.getTime())
+   return Math.ceil(diffTime / (1000 * 60 * 60 * 24))
+ }
+ 
+ /**
+  * Returns an array of cards sorted by difficulty (most difficult first)
+  * @param cards Array of flashcards to sort
+  * @param limit Optional limit on number of cards to return
+  * @returns Sorted array of cards
+  */
+ export function getToughCards(cards: FlashCard[], limit?: number): FlashCard[] {
+   const scoredCards = cards.map(card => ({
+     card,
+     score: calculateDifficultyScore(card)
+   }))
+ 
+   // Sort by difficulty score (descending)
+   scoredCards.sort((a, b) => b.score - a.score)
+ 
+   // Return cards up to the limit (or all if no limit specified)
+   const selectedCards = scoredCards.slice(0, limit).map(sc => sc.card)
+   return selectedCards
+ } 
```

---

3. Now, let's update the study page to include the "Tough Cards" feature:

---

Cancelled

---

Cancelled

---



Let me modify the study page to add the "Tough Cards" feature. I'll need to:
1. Import the difficulty utils
2. Add state for tough cards mode
3. Add the button and logic to switch modes

---

Cancelled

---



I apologize for the tool errors. Let me try again with a more specific edit:

---

Cancelled

---



I apologize for the continued errors. Let me try one more time with a more focused edit:

---

Cancelled

---



---



---

